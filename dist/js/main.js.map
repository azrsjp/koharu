{"version":3,"sources":["webpack:///webpack/bootstrap 17e930ed7e67b3782151","webpack:///./src/Core/State/CustomState.ts","webpack:///(webpack)/buildin/global.js","webpack:///./src/Core/Coord.ts","webpack:///./src/main.ts","webpack:///./src/CustomizedDeps/pixi-custom.js-exposed","webpack:///./src/CustomizedDeps/pixi-custom.js","webpack:///./src/CustomizedDeps/phaser-custom.js-exposed","webpack:///./src/CustomizedDeps/phaser-custom.js","webpack:///./node_modules/process/browser.js","webpack:///./src/CustomizedDeps/box2d-plugin-full.js","webpack:///./src/Extension/Image.ts","webpack:///./src/Extension/Sprite.ts","webpack:///./src/Constants/UISettings.ts","webpack:///./src/State/BootState.ts","webpack:///./src/State/PreloadState.ts","webpack:///./src/State/HomeState.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;AC7DA,8BAA8B;;;;;;;;;;;;AAE9B,qCAAiC;AAEjC;IAAiC,+BAAY;IAA7C;;IAeA,CAAC;IAbG,0BAAI,GAAJ;QACI,aAAK,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC9C,CAAC;IAED,4BAAM,GAAN;QACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;YAC3B,MAAM,CAAC;QACX,CAAC;QACD,IAAI,CAAC,MAAM,EAAE,CAAC;IAClB,CAAC;IAED,4BAAM,GAAN;IACA,CAAC;IACL,kBAAC;AAAD,CAAC,CAfgC,MAAM,CAAC,KAAK,GAe5C;AAfY,kCAAW;;;;;;;ACJxB;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;ACpBA,2CAAgD;AAEhD,cAAc;AACd,kEAAkE;AAClE,kFAAkF;AAClF,8BAA8B;AAE9B;IAAA;IAsLA,CAAC;IArLG,SAAS;IAET,qDAAqD;IAC9C,8BAAwB,GAA/B,UAAgC,IAAiB;QAC7C,IAAI,CAAC,cAAc,EAAE,CAAC;QAEtB,6DAA6D;QAC7D,uBAAuB;QACvB,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC;QACtD,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,GAAG,MAAM,CAAC,gBAAgB,EAAE,CAAC,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,sBAAsB;QAEzG,iBAAiB;QACjB,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;QAE5D,uCAAuC;QACvC,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC;QAEpF,4BAA4B;QAC5B,IAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC;QAClD,EAAE,CAAC,CAAC,YAAY,YAAY,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;YACvC,YAAY,CAAC,MAAM,EAAE,CAAC;QAC1B,CAAC;IACL,CAAC;IAGD,sBAAW,sBAAa;QADxB,QAAQ;aACR;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,cAAc,EAAE,CAAC;YAC1B,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAC1D,CAAC;;;OAAA;IAGD,sBAAW,mBAAU;QADrB,kBAAkB;aAClB;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,cAAc,EAAE,CAAC;YAC1B,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC;QACjC,CAAC;;;OAAA;IAGD,sBAAW,oBAAW;QADtB,kBAAkB;aAClB;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,cAAc,EAAE,CAAC;YAC1B,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC;QAClC,CAAC;;;OAAA;IAGD,sBAAW,qBAAY;QADvB,oBAAoB;aACpB;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,cAAc,EAAE,CAAC;YAC1B,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,gBAAgB,GAAG,GAAG,CAAC;QACvC,CAAC;;;OAAA;IAGD,sBAAW,qBAAY;QADvB,oBAAoB;aACpB;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,cAAc,EAAE,CAAC;YAC1B,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,iBAAiB,GAAG,GAAG,CAAC;QACxC,CAAC;;;OAAA;IAGD,sBAAW,oBAAW;QADtB,sBAAsB;aACtB;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,cAAc,EAAE,CAAC;YAC1B,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC;QAClC,CAAC;;;OAAA;IAGD,sBAAW,qBAAY;QADvB,sBAAsB;aACtB;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;gBACtB,IAAI,CAAC,cAAc,EAAE,CAAC;YAC1B,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC;QACnC,CAAC;;;OAAA;IAED,sBAAW,0BAAiB;aAA5B;YACI,MAAM,CAAC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC;QAC9C,CAAC;;;OAAA;IAED,sBAAsB;IACf,gBAAU,GAAjB,UAAkB,KAAmB;QACjC,MAAM,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5E,CAAC;IAED,sBAAsB;IACf,cAAQ,GAAf,UAAgB,OAAe;QAC3B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACtB,IAAI,CAAC,cAAc,EAAE,CAAC;QAC1B,CAAC;QACD,MAAM,CAAC,CAAC,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC;IACtE,CAAC;IAED,sBAAsB;IACf,cAAQ,GAAf,UAAgB,OAAe;QAC3B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACtB,IAAI,CAAC,cAAc,EAAE,CAAC;QAC1B,CAAC;QACD,MAAM,CAAC,CAAC,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC,iBAAiB,CAAC;IACxE,CAAC;IAED,sBAAsB;IACf,iBAAW,GAAlB,UAAmB,KAAmB;QAClC,MAAM,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9E,CAAC;IAEH,sBAAsB;IACb,eAAS,GAAhB,UAAiB,MAAc;QAC3B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACtB,IAAI,CAAC,cAAc,EAAE,CAAC;QAC1B,CAAC;QACD,MAAM,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC,iBAAiB,CAAC;IACrE,CAAC;IAED,sBAAsB;IACf,eAAS,GAAhB,UAAiB,MAAc;QAC3B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACtB,IAAI,CAAC,cAAc,EAAE,CAAC;QAC1B,CAAC;QACD,MAAM,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC;IACvE,CAAC;IAUD,+CAA+C;IAC/C,4DAA4D;IAC7C,oBAAc,GAA7B;QACI,IAAI,CAAC,eAAe,EAAE,CAAC;QACvB,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACxB,IAAI,CAAC,cAAc,EAAE,CAAC;QACtB,IAAI,CAAC,eAAe,EAAE,CAAC;QACvB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;IAC9B,CAAC;IAED,kBAAkB;IACH,oBAAc,GAA7B;QACI,IAAI,CAAC,gBAAgB,GAAG,uBAAU,CAAC,aAAa,CAAC;IACrD,CAAC;IAED,kBAAkB;IACH,qBAAe,GAA9B;QACI,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,gBAAgB,GAAG,CAAC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAC;IACnH,CAAC;IAED,8BAA8B;IACf,qBAAe,GAA9B;QACI,EAAE,CAAC,CAAC,IAAI,CAAC,kBAAkB,EAAE,GAAG,uBAAU,CAAC,cAAc,CAAC,CAAC,CAAC;YACxD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW,GAAG,uBAAU,CAAC,cAAc,CAAC,CAAC;QACxF,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,iBAAiB,GAAG,MAAM,CAAC,UAAU,CAAC;QAC/C,CAAC;QAED,gBAAgB;QAChB,IAAI,CAAC,iBAAiB,IAAI,MAAM,CAAC,gBAAgB,CAAC;IACtD,CAAC;IAED,8BAA8B;IACf,sBAAgB,GAA/B;QACI,EAAE,CAAC,CAAC,IAAI,CAAC,kBAAkB,EAAE,GAAG,uBAAU,CAAC,cAAc,CAAC,CAAC,CAAC;YACxD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,UAAU,GAAG,uBAAU,CAAC,cAAc,CAAC,CAAC;QACxF,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,kBAAkB,GAAG,MAAM,CAAC,WAAW,CAAC;QACjD,CAAC;QAED,gBAAgB;QAChB,IAAI,CAAC,kBAAkB,IAAI,MAAM,CAAC,gBAAgB,CAAC;IACvD,CAAC;IAEc,wBAAkB,GAAjC;QACI,MAAM,CAAC,MAAM,CAAC,WAAW,GAAG,MAAM,CAAC,UAAU,CAAC;IAClD,CAAC;IAtDD,UAAU;IAEK,mBAAa,GAAG,KAAK,CAAC;IAqDzC,YAAC;CAAA;AAtLY,sBAAK;;;;;;;;;ACPlB,qEAAqE;;AAErE,UAAU;AACV,uBAAc;AACd,uBAAgB;AAChB,uBAAe;AAEf,WAAW;AACX,wBAAyB;AACzB,wBAA0B;AAE1B,qCAAmC;AACnC,0CAA4C;AAC5C,6CAAkD;AAClD,0CAA4C;AAE5C,UAAU;AACV,IAAM,IAAI,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,aAAK,CAAC,WAAW,EAAE,aAAK,CAAC,YAAY,EAAE,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;AAErF,2CAA2C;AAC3C,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,mBAAmB,GAAG;IAC3C,aAAK,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;AACzC,CAAC,CAAC;AAEF,wBAAwB;AACxB,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAAE,eAAK;IACzC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAC3B,KAAK,CAAC,cAAc,EAAE,CAAC;IAC3B,CAAC;AACL,CAAC,EAAE,IAAI,CAAC,CAAC;AAET,wBAAwB;AACxB,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,WAAW,EAAE,qBAAS,CAAC,CAAC;AACvC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,cAAc,EAAE,2BAAY,CAAC,CAAC;AAC7C,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,WAAW,EAAE,qBAAS,CAAC,CAAC;AAEvC,mBAAmB;AACnB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;;;;;;;ACrC9B,uG;;;;;;;ACAA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,8BAA8B,YAAY,MAAM,+BAA+B,YAAY;AAChG;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C,eAAe,mBAAmB;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO,6CAA6C,uCAAuC,iBAAiB,YAAY;AACtI,cAAc,uCAAuC;AACrD,eAAe,mBAAmB;AAClC;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB,eAAe,WAAW;AAC1B;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB,cAAc,mBAAmB;AACjC,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,kBAAkB;AACjD;AACA;;AAEA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B,YAAY,cAAc;AAC1B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B,iBAAiB,OAAO;AACxB,YAAY,cAAc;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B,YAAY,OAAO;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C;AAC1C,0CAA0C;;AAE1C;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,YAAY,cAAc;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B,YAAY,cAAc;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,YAAY,cAAc;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,mBAAmB,OAAO;AAC1B;AACA;;AAEA,mCAAmC,gBAAgB;AACnD,iCAAiC,iCAAiC;;AAElE;;AAEA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,YAAY,UAAU;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,K;AACA;AACA;AACA;AACA,K;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,2CAA2C;AAC9D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,eAAe,0BAA0B;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,2CAA2C;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,c;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,c;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,0BAA0B;AACzC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,c;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,c;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,sEAAsE;AACtE;AACA;AACA,kBAAkB;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB,YAAY,Q;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB,oBAAoB,OAAO;AAC3B,qBAAqB,OAAO;AAC5B,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,oBAAoB;AACpB,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,oBAAoB;AACpB,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,oBAAoB;AACpB,qBAAqB;AACrB,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,oBAAoB;AACpB,sBAAsB;AACtB,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,6BAA6B;AAC7B,oCAAoC;AACpC,0BAA0B;AAC1B,wEAAwE;AACxE,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,kCAAkC;AAClC,2BAA2B;;AAE3B,mCAAmC;AACnC,+BAA+B;;AAE/B,gCAAgC;AAChC,yBAAyB;;AAEzB,yCAAyC;;AAEzC,sBAAsB;AACtB,uGAAuG;AACvG,sCAAsC;AACtC,uDAAuD;AACvD,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,8BAA8B;AAC9B,oCAAoC;AACpC,0BAA0B;AAC1B,wEAAwE;AACxE,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,uCAAuC;AACvC,+BAA+B;AAC/B,mCAAmC;AACnC,sCAAsC;AACtC,gCAAgC;;AAEhC,uCAAuC;AACvC,mCAAmC;AACnC,8BAA8B;;AAE9B,oCAAoC;AACpC,8BAA8B;;AAE9B,6CAA6C;;AAE7C,0BAA0B;AAC1B,mBAAmB;AACnB,+CAA+C;AAC/C,oEAAoE;AACpE,oEAAoE;AACpE,iEAAiE;AACjE,6EAA6E;AAC7E,0CAA0C;AAC1C,gGAAgG;AAChG,4BAA4B;AAC5B,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,oCAAoC;AACpC,gCAAgC;AAChC,6BAA6B;AAC7B,oCAAoC;;AAEpC,0BAA0B;AAC1B,+FAA+F;AAC/F,sDAAsD,yBAAyB;AAC/E,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,sCAAsC;AACtC,wCAAwC;AACxC,uCAAuC;AACvC,mCAAmC;AACnC,+BAA+B;AAC/B,6BAA6B;AAC7B,oCAAoC;AACpC,+BAA+B;;AAE/B,0BAA0B;AAC1B,qEAAqE;AACrE,kCAAkC;AAClC,2GAA2G;AAC3G,0CAA0C;AAC1C,0DAA0D;AAC1D,UAAU;AACV;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;;AAE7B,0BAA0B;AAC1B,kCAAkC;AAClC,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,+BAA+B;AAC/B,wCAAwC;AACxC,uCAAuC;AACvC,mCAAmC;AACnC,6BAA6B;AAC7B,6BAA6B;AAC7B,2BAA2B;AAC3B,6BAA6B;;AAE7B,0BAA0B;AAC1B,qEAAqE;AACrE,kCAAkC;AAClC,uHAAuH;AACvH,wDAAwD;AACxD,UAAU;AACV;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC,6BAA6B;;AAE7B,0BAA0B;AAC1B,kCAAkC;AAClC,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,iCAAiC;AACjC,wCAAwC;AACxC,uCAAuC;AACvC,mCAAmC;;AAEnC,2BAA2B;AAC3B,6BAA6B;AAC7B,4BAA4B;AAC5B,6BAA6B;AAC7B,6BAA6B;;AAE7B,0BAA0B;AAC1B,qEAAqE;AACrE,kCAAkC;AAClC,uHAAuH;AACvH,uDAAuD,kCAAkC;AACzF,UAAU;AACV;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC,sBAAsB,MAAM;AAC5B,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;;AAEA,eAAe,iCAAiC;AAChD;AACA;AACA;;AAEA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,6BAA6B;AAC7B,oCAAoC;AACpC,0BAA0B;AAC1B,wEAAwE;AACxE,UAAU;AACV;AACA;;AAEA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB,UAAU,OAAO;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,OAAO;;AAErD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD;;AAElD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB,eAAe;AACf,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,KAAK;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,c;AACxB,iBAAiB,Y;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,6CAA6C,kCAAkC;;AAE/E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,uCAAuC;AAC9D;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC,qBAAqB,QAAQ;AAC7B,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,yDAAyD;AACzD,0DAA0D;AAC1D;AACA,kEAAkE;AAClE;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mBAAmB,6BAA6B;AAChD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB,oBAAoB,OAAO,OAAO,uCAAuC,iBAAiB,YAAY;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,yBAAyB,OAAO;AAChC;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,iBAAiB,OAAO;AACxB,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,iBAAiB,OAAO;AACxB,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,iBAAiB,OAAO;AACxB,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;;AAEA,mCAAmC,mBAAmB;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC,mBAAmB,yBAAyB;AAC5C,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC,qBAAqB,OAAO,OAAO,uCAAuC,iBAAiB,YAAY;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,qBAAqB,OAAO,OAAO,uCAAuC,iBAAiB,YAAY;AACvG,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,iBAAiB,UAAU;AAC3B,kBAAkB,UAAU;AAC5B,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,qBAAqB,OAAO,OAAO,uCAAuC,iBAAiB,YAAY;AACvG,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB,oBAAoB,6BAA6B;AACjD,qBAAqB,OAAO,OAAO,uCAAuC,iBAAiB,YAAY;AACvG,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC,oBAAoB,OAAO;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC,oBAAoB,OAAO;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oCAAoC,yBAAyB,EAAE;AAC/D,KAAK;AACL;AACA;;AAEA;AACA,CAAC,a;;;;;;AChvPD,yG;;;;;;;ACAA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;AAC9B,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,EAAE;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;AACA,mCAAmC,aAAa;AAChD;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA,gCAAgC,aAAa;AAC7C,gCAAgC,eAAe;AAC/C,gCAAgC,aAAa;;AAE7C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA,oCAAoC,iBAAiB;;AAErD;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA,gCAAgC,0BAA0B;;AAE1D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,cAAc;AAC5B,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,MAAM;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,kBAAkB,4GAA4G;AAC9H;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA,+IAA+I;AAC/I;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,cAAc;AACxB,WAAW,QAAQ,sHAAsH;AACzI;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,cAAc;AACxB,WAAW,QAAQ,4EAA4E;AAC/F;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,kCAAkC,mBAAmB;AACrD,4BAA4B,0BAA0B;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,iBAAiB;AAC3B,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,eAAe;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,eAAe;AAC9B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,eAAe;AAC7B,eAAe,eAAe;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA,gCAAgC,0BAA0B;;AAE1D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,kBAAkB,uGAAuG;AACzH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA,oJAAoJ;AACpJ;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,YAAY;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB,eAAe,YAAY;AAC3B;AACA;;AAEA,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,YAAY;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,YAAY;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,YAAY;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA,gCAAgC,0BAA0B;;AAE1D;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,YAAY;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA,gCAAgC,0BAA0B;;AAE1D;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,eAAe,MAAM;AACrB;AACA;;AAEA,qCAAqC,cAAc;AACnD,oCAAoC,cAAc;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,YAAY;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,QAAQ;AAClB,UAAU,oBAAoB;AAC9B,WAAW,aAAa;AACxB;AACA;;AAEA,kCAAkC,kBAAkB;AACpD,+BAA+B,6BAA6B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,YAAY;AACtB,UAAU,QAAQ;AAClB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,wBAAwB;AAClC,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,YAAY;AACtB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA,wCAAwC,OAAO;AAC/C,wCAAwC,OAAO;AAC/C,wCAAwC,OAAO;AAC/C,wCAAwC,OAAO;AAC/C,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;;AAElD;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,gBAAgB,cAAc;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,kBAAkB;AAChC,eAAe,kBAAkB;AACjC;AACA;;AAEA,kCAAkC,kCAAkC;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA,mCAAmC,6BAA6B;;AAEhE;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA,mCAAmC,6BAA6B;;AAEhE;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,kBAAkB,0CAA0C;;AAE5D;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,OAAO;AACjB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,OAAO,2JAA2J;AAC5K,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB,WAAW,aAAa;AACxB;AACA;;AAEA,oBAAoB,qCAAqC;;AAEzD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA,4BAA4B,0BAA0B;;AAEtD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,aAAa;AACxB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kDAAkD;AAC5D;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,MAAM;AACtB;AACA;;AAEA,mCAAmC,aAAa;;AAEhD,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,gBAAgB,eAAe;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,yDAAyD,gCAAgC;AACzF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD,2BAA2B;AACpF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAkD;AACjE,gBAAgB,eAAe;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD,SAAS;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO,iCAAiC;AACxC;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,eAAe;AACf;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ,sEAAsE;AAC7F;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,eAAe,QAAQ,sEAAsE;AAC7F;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,eAAe,QAAQ,8GAA8G;AACrI;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,cAAc,iBAAiB;AAC/B,eAAe,iBAAiB,4IAA4I;AAC5K;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,eAAe,QAAQ,+EAA+E;AACtG;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ,uEAAuE;AAC9F;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,cAAc,iBAAiB;AAC/B,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA,gCAAgC,0BAA0B;;AAE1D;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA,gCAAgC,0BAA0B;;AAE1D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,kBAAkB,2HAA2H;;AAE7I;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;;AAEA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,iBAAiB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,aAAa;AACvB,WAAW,iBAAiB;AAC5B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,aAAa;AACvB,WAAW,aAAa;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,QAAQ,sEAAsE;AACzF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,QAAQ,sEAAsE;AACzF;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,aAAa;AACvB,WAAW,QAAQ,sEAAsE;AACzF;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,WAAW,QAAQ,sEAAsE;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,WAAW,QAAQ,8GAA8G;AACjI;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,WAAW,iBAAiB,4IAA4I;AACxK;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,WAAW,QAAQ,+EAA+E;AAClG;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,QAAQ,uEAAuE;AAC1F;AACA;;AAEA,kCAAkC,eAAe;;AAEjD;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,WAAW,iBAAiB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB,UAAU,iBAAiB;AAC3B,WAAW,iBAAiB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,0BAA0B,OAAO;AACjC,8BAA8B,WAAW;AACzC,+BAA+B,YAAY;AAC3C,+BAA+B,aAAa;;AAE5C;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ,uFAAuF;AAC9G;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA,oBAAoB;;AAEpB;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uCAAuC;AACrD,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB;AACA;;AAEA,kCAAkC,qCAAqC;AACvE,kCAAkC,WAAW;AAC7C,kCAAkC,WAAW;;AAE7C;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA,sCAAsC,kBAAkB;AACxD,qCAAqC,gBAAgB;AACrD,kCAAkC,cAAc;AAChD,sCAAsC,sCAAsC;AAC5E,wCAAwC,oBAAoB;;AAE5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA,kCAAkC,kBAAkB;AACpD,qCAAqC,gBAAgB;AACrD,kCAAkC,eAAe;;AAEjD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA,kCAAkC,kBAAkB;AACpD,qCAAqC,gBAAgB;AACrD,kCAAkC,eAAe;;AAEjD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,6CAA6C,uBAAuB;AACpE,6CAA6C,uBAAuB;;AAEpE;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;;AAGD;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,6BAA6B;AAC3C,cAAc,QAAQ;AACtB;AACA;;AAEA,sCAAsC,mBAAmB;;AAEzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,KAAK;AACnB;AACA;;AAEA,uCAAuC,mBAAmB;AAC1D,uCAAuC,oBAAoB;;AAE3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,KAAK;AACnB;AACA;;AAEA,uCAAuC,mBAAmB;AAC1D,uCAAuC,oBAAoB;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM,EAAE;AAC7C;AACA;AACA;AACA,wCAAwC;AACxC,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;;AAEA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,uGAAuG,WAAW,KAAK,eAAe;AACtI,WAAW,cAAc;AACzB;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,2IAA2I,YAAY;AACvJ;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA,6EAA6E,GAAG,wCAAwC,GAAG;AAC3H;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,qBAAqB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,gBAAgB;;AAEpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,qBAAqB;AACpC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,sBAAsB,uCAAuC;AAC7D;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,qBAAqB;AACpC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,eAAe,SAAS;AACxB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA,oCAAoC,gBAAgB;;AAEpD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,iEAAiE,qBAAqB;AACtF;AACA;AACA,cAAc,IAAI;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,SAAS;AACnB,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,eAAe,IAAI;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,aAAa;AACvB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA,qBAAqB,qBAAqB,kBAAkB;AAC5D,eAAe,uBAAuB;AACtC,gBAAgB,qBAAqB,iBAAiB,EAAE;AACxD,eAAe,qIAAqI;AACpJ,qBAAqB,6BAA6B;AAClD,oBAAoB,+CAA+C,eAAe,EAAE;AACpF,oBAAoB,+CAA+C,eAAe,EAAE;AACpF,oBAAoB,+CAA+C,eAAe,EAAE;AACpF,oBAAoB,+CAA+C,eAAe;;AAElF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA,oCAAoC,aAAa;AACjD,oCAAoC,aAAa;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,IAAI;AACd;AACA;;AAEA,+BAA+B,eAAe;;AAE9C;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,IAAI;AACrB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC,cAAc,KAAK;AACnB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB;AACA;;AAEA,oCAAoC,gBAAgB;;AAEpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF,SAAS;;AAET;AACA,iEAAiE,iBAAiB;AAClF,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,MAAM;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;;AAEA,gCAAgC,QAAQ;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,8BAA8B,oCAAoC,YAAY,4BAA4B,MAAM,0BAA0B;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,mBAAmB,qDAAqD,oBAAoB;AACtG,+DAA+D,oCAAoC;AACnG,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ,wDAAwD,cAAc,KAAK,sBAAsB,sEAAsE,uBAAuB;AAChN,UAAU,QAAQ,sGAAsG,uBAAuB;AAC/I;AACA;;AAEA,mCAAmC,oBAAoB;AACvD,mCAAmC,oBAAoB;AACvD,wCAAwC,yCAAyC;;AAEjF;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,2DAA2D,cAAc,KAAK,sBAAsB;AACpG;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA,4EAA4E,YAAY,MAAM,gBAAgB;AAC9G,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,UAAU,kBAAkB;AAC5B;AACA,4BAA4B,4BAA4B,GAAG,0BAA0B,GAAG,2BAA2B;AACnH,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,yBAAyB,qBAAqB;AAC9C;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,uCAAuC,eAAe;AACtD;AACA,SAAS;AACT;AACA;;AAEA;AACA,uCAAuC,eAAe;AACtD;AACA,SAAS;AACT;AACA;;AAEA;AACA,uCAAuC,eAAe;AACtD;AACA,SAAS;AACT;AACA;;AAEA;AACA,uCAAuC,eAAe;AACtD;AACA,SAAS;AACT;AACA;;AAEA;AACA,0CAA0C,YAAY;AACtD;AACA,SAAS;AACT;AACA;;AAEA;AACA,0CAA0C,YAAY;AACtD;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa,yCAAyC,cAAc;AAC3E;AACA;AACA,UAAU,cAAc;AACxB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,cAAc;AACzB;AACA;;AAEA,+BAA+B,gBAAgB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,cAAc;AACzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,6BAA6B;AACvC,UAAU,QAAQ;AAClB,WAAW,6BAA6B;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,WAAW,sBAAsB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO,iBAAiB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,wEAAwE;AAClF,UAAU,cAAc;AACxB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,cAAc,wCAAwC,oBAAoB,SAAS,iBAAiB;AAC/G;AACA;;AAEA,+BAA+B,eAAe;;AAE9C;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,iBAAiB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,aAAa;AACvB,UAAU,qBAAqB;AAC/B,UAAU,QAAQ;AAClB,WAAW,MAAM;AACjB;AACA;;AAEA,8BAA8B,WAAW;AACzC,+BAA+B,gBAAgB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,2BAA2B,cAAc;AACzC;AACA;AACA;;AAEA,SAAS;;AAET,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA,iCAAiC,4BAA4B;AAC7D,+BAA+B,YAAY;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,WAAW,IAAI;AACf;AACA;;AAEA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,UAAU,IAAI;AACd;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,WAAW,IAAI;AACf;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,UAAU,IAAI;AACd,WAAW,IAAI;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,UAAU,SAAS;AACnB,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,UAAU,MAAM;AAChB,UAAU,IAAI;AACd,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA,8BAA8B,eAAe;;AAE7C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B,uBAAuB;AACrD,mCAAmC,wBAAwB;AAC3D,mCAAmC,wBAAwB;AAC3D,mCAAmC,wBAAwB;AAC3D,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA,8BAA8B,+BAA+B;AAC7D,mCAAmC,gCAAgC;AACnE,mCAAmC,gCAAgC;AACnE,mCAAmC,gCAAgC;AACnE,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA,8BAA8B,uCAAuC;AACrE,mCAAmC,wCAAwC;AAC3E,mCAAmC,wCAAwC;AAC3E,mCAAmC,wCAAwC;AAC3E,mCAAmC,wCAAwC;AAC3E;AACA;AACA;AACA,8BAA8B,+CAA+C;AAC7E,mCAAmC,gDAAgD;AACnF,mCAAmC,gDAAgD;AACnF,mCAAmC,gDAAgD;AACnF,mCAAmC,gDAAgD;AACnF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,UAAU,MAAM;AAChB,UAAU,IAAI;AACd,UAAU,QAAQ;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA,8BAA8B,eAAe;;AAE7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,OAAO;AACjB,UAAU,IAAI;AACd,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA,8BAA8B,eAAe;;AAE7C;;AAEA,mCAAmC,oBAAoB;AACvD,qCAAqC,sBAAsB;;AAE3D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,IAAI;AACd,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA,mCAAmC,oBAAoB;AACvD,qCAAqC,sBAAsB;AAC3D,8BAA8B,eAAe;;AAE7C;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,IAAI;AACd,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA,mCAAmC,oBAAoB;AACvD,qCAAqC,sBAAsB;AAC3D,8BAA8B,eAAe;;AAE7C;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,IAAI;AACd,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA,mCAAmC,oBAAoB;AACvD,qCAAqC,sBAAsB;AAC3D,8BAA8B,eAAe;;AAE7C,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,MAAM;AAChB,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB,UAAU,QAAQ,8DAA8D;AAChF,WAAW,gBAAgB;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB;AACA;;AAEA,oCAAoC,qBAAqB;;AAEzD;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO,mCAAmC;AAC1C;AACA;AACA,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO,mCAAmC;AAC1C;AACA;AACA,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO,mCAAmC;AAC1C;AACA;AACA,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,QAAQ,yDAAyD,iDAAiD,kBAAkB,mDAAmD;AACjM;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,WAAW;AACvC,8BAA8B,qCAAqC;;AAEnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,6CAA6C;AAClD;AACA,KAAK,2CAA2C;AAChD;AACA,KAAK,6CAA6C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,IAAI;AACd,UAAU,QAAQ;AAClB,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,UAAU,MAAM,2DAA2D;AAC3E,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ,wDAAwD;AAC1E,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,wEAAwE;AAClF,UAAU,cAAc;AACxB,WAAW,cAAc;AACzB;AACA;;AAEA,qCAAqC,sBAAsB;;AAE3D;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,wEAAwE;AAClF,UAAU,cAAc;AACxB,WAAW,cAAc;AACzB;AACA;;AAEA,qCAAqC,sBAAsB;;AAE3D;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,wEAAwE;AAClF,UAAU,cAAc;AACxB,WAAW,cAAc;AACzB;AACA;;AAEA,qCAAqC,sBAAsB;;AAE3D;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,wEAAwE;AAClF,UAAU,cAAc;AACxB,WAAW,cAAc,sCAAsC,oBAAoB;AACnF;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,UAAU;AACpC,0BAA0B,UAAU;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,WAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,IAAI;AACf;AACA;;AAEA,mCAAmC,gBAAgB;AACnD,+BAA+B,+BAA+B;;AAE9D;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,IAAI;AACf;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,IAAI;AACd,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,IAAI;AACf;AACA;;AAEA,mCAAmC,gBAAgB;AACnD,iCAAiC,iCAAiC;;AAElE;;AAEA,4BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA,gCAAgC,iBAAiB;AACjD,+BAA+B,gBAAgB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,QAAQ;AAClB,WAAW,aAAa;AACxB;AACA;;AAEA,+BAA+B,gBAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA,gCAAgC,iBAAiB;AACjD,+BAA+B,gBAAgB;AAC/C,uCAAuC,wBAAwB;;AAE/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA,iCAAiC,qCAAqC;AACtE,gCAAgC,iBAAiB;AACjD,+BAA+B,gBAAgB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA,mDAAmD,QAAQ;;AAE3D,wCAAwC,wBAAwB;AAChE,6BAA6B,cAAc;;AAE3C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0HAA0H;AACpI,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,aAAa;AACxB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0HAA0H;AACpI,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,aAAa;AACxB;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC,GAAG,oBAAoB,GAAG,oBAAoB,GAAG;AACjD,cAAc,yBAAyB;AACvC;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,yDAAyD;AACnE,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA,gCAAgC,aAAa;AAC7C,kCAAkC,mBAAmB;AACrD,mCAAmC,mBAAmB;AACtD,iCAAiC,iBAAiB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,cAAc;AACxB,UAAU,OAAO;AACjB,UAAU,mBAAmB;AAC7B,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,sCAAsC;AACzF;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,sCAAsC;AACzF;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,uCAAuC;AACxD;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,WAAW;AAC5B;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,qBAAqB;AACtC;AACA;;AAEA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,+BAA+B;AAC9F,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B,wBAAwB,uBAAuB;AACnG;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;;AAEA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO,sHAAsH;AAC9I;AACA;AACA;;AAEA;AACA;AACA;AACA,2FAA2F;AAC3F,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa,0GAA0G;AACxI;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,aAAa,iEAAiE;AAC/F;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA,iCAAiC,uCAAuC;;AAExE,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB,yCAAyC;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iDAAiD,sCAAsC;AACvF;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC,cAAc;;AAE/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,eAAe;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,eAAe,qCAAqC;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,eAAe;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,eAAe,QAAQ;AACvB;AACA;;AAEA,kCAAkC,8BAA8B;;AAEhE;;AAEA,uBAAuB,uCAAuC;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,eAAe;AAC9B;AACA;;AAEA,qCAAqC,kBAAkB;;AAEvD,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,eAAe;AAC9B;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,eAAe;AAC9B;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,eAAe;AAC7B,eAAe,aAAa;AAC5B;AACA;;AAEA,mCAAmC,6BAA6B;;AAEhE;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,eAAe;AAC7B,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAuC;AAClE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,uCAAuC,wCAAwC;AAC/E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,IAAI,8DAA8D;AACnF;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa,iBAAiB;AAC9B,kBAAkB,mBAAmB,wBAAwB,EAAE,EAAE;AACjE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,eAAe;AACf,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB;AACA;;AAEA;AACA,iBAAiB,gCAAgC;AACjD;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,mBAAmB;AAC7B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD,cAAc,QAAQ;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,QAAQ;AACtB;AACA;;AAEA,mCAAmC,gBAAgB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,cAAc,OAAO,mCAAmC;AACxD,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA;AACA;;AAEA;AACA,wFAAwF;AACxF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA,kCAAkC,eAAe;;AAEjD,sCAAsC,qDAAqD;;AAE3F,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,iCAAiC;AACxD;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA,0CAA0C,uBAAuB;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA,gDAAgD,4BAA4B;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe;AACf;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe;AACf;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe;AACf;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe;AACf;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,eAAe;AAC7B,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB,eAAe;AACf;AACA;;AAEA,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B,cAAc,cAAc;AAC5B;AACA;;AAEA,uCAAuC,oBAAoB;AAC3D,uCAAuC,oBAAoB;AAC3D,yCAAyC,sBAAsB;AAC/D,2CAA2C,sBAAsB;AACjE,uCAAuC,mBAAmB;AAC1D,yCAAyC,qBAAqB;;AAE9D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA,4CAA4C,wBAAwB;AACpE,0CAA0C,sBAAsB;;AAEhE;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,mCAAmC,eAAe;AAClD,sCAAsC,mBAAmB;AACzD,wCAAwC,iBAAiB;AACzD,wCAAwC,iBAAiB;;AAEzD;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0HAA0H;AACxI,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA,oCAAoC,aAAa;AACjD,oCAAoC,aAAa;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0HAA0H;AACxI,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA,oCAAoC,aAAa;AACjD,oCAAoC,aAAa;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,YAAY;;AAEZ;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAwE;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,cAAc,QAAQ;AACtB;AACA;;AAEA,iCAAiC,cAAc;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA,sDAAsD,QAAQ;;AAE9D,4CAA4C,wBAAwB;AACpE,2CAA2C,wBAAwB;;AAEnE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,oBAAoB;AACxG;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,2BAA2B;AACnE,wCAAwC,gCAAgC;AACxE,wCAAwC,oCAAoC;AAC5E,wCAAwC,oCAAoC;AAC5E,wCAAwC,0BAA0B;AAClE,wCAAwC,2BAA2B;AACnE,wCAAwC,+BAA+B;AACvE,wCAAwC,+BAA+B;;AAEvE,wCAAwC,6BAA6B;AACrE,wCAAwC,4BAA4B;AACpE,wCAAwC,6BAA6B;AACrE,wCAAwC,2BAA2B;AACnE,wCAAwC,6BAA6B;AACrE,wCAAwC,8BAA8B;AACtE,wCAAwC,4BAA4B;;AAEpE,wCAAwC,kCAAkC;AAC1E,wCAAwC,qCAAqC;AAC7E,wCAAwC,iCAAiC;;AAEzE,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,aAAa;AACpB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,aAAa;AACpB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,eAAe;AACtB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,eAAe;AACtB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,eAAe;AACtB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,eAAe;AACtB,OAAO,QAAQ;AACf,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,eAAe;AACtB,OAAO,OAAO;AACd,OAAO,OAAO;AACd,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,eAAe;AACtB,OAAO,OAAO;AACd,OAAO,OAAO;AACd,OAAO,aAAa;AACpB,OAAO,QAAQ;AACf,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,eAAe;AACtB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,iBAAiB;AACxB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,iBAAiB;AACxB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,OAAO,iBAAiB;AACxB,iBAAiB,cAAc;AAC/B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,SAAS;;AAET,2EAA2E;AAC3E;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,mBAAmB;AAClC;AACA;;AAEA,mCAAmC,cAAc;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wEAAwE;AACtF,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8EAA8E;AAC5F,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iFAAiF;AAClG;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,mBAAmB;AAC9B;AACA;;AAEA,+BAA+B,YAAY;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,SAAS,qCAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,IAAI;AACnB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,wEAAwE;AACtF,cAAc,cAAc;AAC5B,cAAc,aAAa;AAC3B,gBAAgB,cAAc;AAC9B;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,wEAAwE;AACtF,cAAc,cAAc;AAC5B,cAAc,aAAa;AAC3B,gBAAgB,aAAa;AAC7B;AACA;;AAEA,kCAAkC,oBAAoB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,wEAAwE;AACtF,cAAc,cAAc;AAC5B,cAAc,aAAa;AAC3B,gBAAgB,cAAc;AAC9B;AACA;;AAEA,kCAAkC,oBAAoB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,cAAc,aAAa;AAC3B,gBAAgB,gBAAgB;AAChC;AACA;;AAEA,kCAAkC,oBAAoB;;AAEtD;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,IAAI;AAClB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,mBAAmB;AAClC;AACA;;AAEA,mCAAmC,eAAe;AAClD,iCAAiC,gBAAgB;AACjD,uCAAuC,oBAAoB;;AAE3D;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,mBAAmB;AACnC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,sCAAsC;AACpD,cAAc,cAAc;AAC5B,cAAc,aAAa;AAC3B,eAAe,kBAAkB;AACjC;AACA;;AAEA,kCAAkC,oBAAoB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,wEAAwE;AACtF,cAAc,cAAc;AAC5B,cAAc,MAAM,uBAAuB,aAAa;AACxD,cAAc,aAAa;AAC3B,eAAe,YAAY;AAC3B;AACA;;AAEA,kCAAkC,oBAAoB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,aAAa;AAC3B,eAAe,YAAY;AAC3B;AACA;;AAEA,kCAAkC,oBAAoB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,aAAa;AAC3B,eAAe,cAAc;AAC7B;AACA;;AAEA,kCAAkC,oBAAoB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,aAAa;AAC3B,eAAe,gBAAgB;AAC/B;AACA;;AAEA,kCAAkC,oBAAoB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gCAAgC;AAC/C;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,aAAa;AAC3B,eAAe,kBAAkB;AACjC;AACA;;AAEA,kCAAkC,oBAAoB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,eAAe;AAC9B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,qBAAqB;AACpC;AACA;;AAEA,8CAA8C,4BAA4B;AAC1E,uCAAuC,oBAAoB;;AAE3D;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA,uCAAuC,oBAAoB;AAC3D,8CAA8C,4BAA4B;;AAE1E;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,IAAI;AAClB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC,cAAc,KAAK;AACnB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,2CAA2C,uCAAuC;AAClF;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,yCAAyC;AACvD,cAAc,cAAc;AAC5B,gBAAgB,aAAa;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,yCAAyC;AACvD,cAAc,cAAc;AAC5B,gBAAgB,cAAc;AAC9B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,mBAAmB;AAClC;AACA;;AAEA,iCAAiC,gBAAgB;AACjD,uCAAuC,oBAAoB;;AAE3D;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,mBAAmB;AACnC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,sCAAsC;AACpD,cAAc,cAAc;AAC5B,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,2DAA2D;AACzE,cAAc,cAAc;AAC5B,eAAe,YAAY;AAC3B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,YAAY;AAC3B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,eAAe;AAC9B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,qBAAqB;AACpC;AACA;;AAEA,8CAA8C,4BAA4B;AAC1E,uCAAuC,oBAAoB;;AAE3D;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA,uCAAuC,oBAAoB;AAC3D,8CAA8C,4BAA4B;;AAE1E;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,IAAI;AAClB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,2DAA2D;AACrE,UAAU,cAAc;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,2DAA2D;AACrE,UAAU,cAAc;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,uFAAuF,+CAA+C;AACtI;AACA,mDAAmD;AACnD;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,+CAA+C;AAC7E;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,cAAc;AACxB,UAAU,QAAQ;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,eAAe;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,eAAe;AACzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,eAAe;AACzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,UAAU,eAAe;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,gCAAgC;AAC1C,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA;;AAEA,kDAAkD,qBAAqB;;AAEvE;;AAEA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA;;AAEA,6CAA6C,aAAa;AAC1D,+CAA+C,cAAc;AAC7D,iCAAiC,kBAAkB;;AAEnD;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA,iDAAiD,cAAc;;AAE/D;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,mBAAmB;;AAEnB;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA,iCAAiC,aAAa;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA,iCAAiC,aAAa;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,0DAA0D;AACxE,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wFAAwF;AACtG,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,kCAAkC,oBAAoB;AACtD,mCAAmC,sBAAsB;;AAEzD;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA,8BAA8B,OAAO;;AAErC;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,kCAAkC,iCAAiC;AACnE,mCAAmC,mCAAmC;;AAEtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA,oEAAoE,0EAA0E;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,kCAAkC,oBAAoB;AACtD,mCAAmC,sBAAsB;;AAEzD;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,QAAQ;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,kCAAkC,oBAAoB;AACtD,mCAAmC,sBAAsB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,iBAAiB;AAC/B,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,iBAAiB;AAC/B,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,8BAA8B,mBAAmB;AACjD;AACA,kCAAkC,kBAAkB;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,iBAAiB;AAC/B,eAAe,kBAAkB;AACjC;AACA;;AAEA,4CAA4C,WAAW;AACvD,4CAA4C,WAAW;AACvD,4CAA4C,WAAW;;AAEvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,8BAA8B,mBAAmB;AACjD;AACA,kCAAkC,kBAAkB;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA,sCAAsC,kBAAkB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,eAAe,UAAU;AACzB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,sCAAsC,eAAe;;AAErD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,eAAe,iBAAiB;AAChC;AACA;;AAEA,iCAAiC,+BAA+B;;AAEhE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6GAA6G;AAC5H,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,gBAAgB,kBAAkB;AAClC;AACA;;AAEA,sDAAsD,eAAe;;AAErE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,eAAe;AACjE,kDAAkD,eAAe;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,OAAO;AACnD,4CAA4C,OAAO;;AAEnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD,8CAA8C,QAAQ;AACtD,0DAA0D,yBAAyB;AACnF,4DAA4D,0BAA0B;;AAEtF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,kBAAkB;AACxD,oCAAoC,iBAAiB;;AAErD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2EAA2E;AACzF,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA,sCAAsC,kBAAkB;AACxD,oCAAoC,iBAAiB;;AAErD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,2FAA2F;AACzG,cAAc,iBAAiB;AAC/B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAA4D;AAC1E,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,6CAA6C;AAC3D,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mFAAmF;AACjG,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wFAAwF;AACtG,cAAc,wFAAwF;AACtG,cAAc,iBAAiB;AAC/B,cAAc,iBAAiB;AAC/B,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB,kBAAkB;AAClC;AACA;;AAEA,8BAA8B,SAAS;AACvC,mCAAmC,gBAAgB;AACnD,+BAA+B,QAAQ;AACvC,+BAA+B,QAAQ;AACvC,+BAA+B,QAAQ;;AAEvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,iCAAiC,uBAAuB;AACxD,kCAAkC,4BAA4B;AAC9D,mCAAmC,eAAe;;AAElD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA,kCAAkC,gBAAgB;AAClD,kCAAkC,WAAW;;AAE7C;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA,mCAAmC,qBAAqB;;AAExD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA,yCAAyC,gBAAgB;AACzD,yCAAyC,gBAAgB;AACzD,qCAAqC,YAAY;AACjD,qCAAqC,YAAY;AACjD,oCAAoC,WAAW;AAC/C,oCAAoC,WAAW;;AAE/C,YAAY;;AAEZ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,kBAAkB,OAAO;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,kBAAkB,OAAO;AACzB,sBAAsB,OAAO;AAC7B,oBAAoB,OAAO;AAC3B,yBAAyB,QAAQ;AACjC,oBAAoB,OAAO;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,uBAAuB;AAC7D,iCAAiC,eAAe;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,eAAe;AAClC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,oBAAoB,OAAO;AAC3B,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,yBAAyB,OAAO;AAChC,uBAAuB,OAAO;AAC9B,YAAY,QAAQ;AACpB;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,kCAAkC,qCAAqC;AACvE,gCAAgC,aAAa;;AAE7C;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,c;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,c;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;;AAEA;;AAEA,eAAe,0BAA0B;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,QAAQ;AAC7B,qBAAqB,sCAAsC;AAC3D;;AAEA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA,gBAAgB,sCAAsC;AACtD;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0EAA0E;AAC1E;AACA;AACA;;AAEA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,SAAS;AAChC,KAAK;AACL,2BAA2B,YAAY;AACvC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD;;AAErD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD;;AAErD,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,sCAAsC,+BAA+B;;AAErE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA,4DAA4D;AAC5D;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,eAAe,gBAAgB;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kCAAkC;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,kCAAkC;AACrD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA,0BAA0B,OAAO;AACjC,0BAA0B,OAAO;;AAEjC;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,kBAAkB,eAAe,kBAAkB,aAAa;AAChE;AACA;AACA,UAAU,oBAAoB;AAC9B,UAAU,QAAQ;AAClB;AACA;;AAEA,6BAA6B,cAAc;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,eAAe;AACxB;AACA;AACA,UAAU,kCAAkC;AAC5C,UAAU,cAAc,EAAE,aAAa;AACvC,UAAU,QAAQ;AAClB;AACA;;AAEA,6BAA6B,cAAc;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA,4BAA4B,UAAU;AACtC,kCAAkC,uCAAuC;AACzE,mCAAmC,gBAAgB;;AAEnD;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sEAAsE;AAChF,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sEAAsE;AAChF,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sEAAsE;AAChF,UAAU,cAAc;AACxB,UAAU,QAAQ;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,iEAAiE;AACxE;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,cAAc;AACxB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;;AAElC;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA,iBAAiB,MAAM,wDAAwD,oCAAoC;AACnH;AACA;;AAEA;AACA,iBAAiB,MAAM,qEAAqE,gDAAgD;AAC5I;AACA;;AAEA;AACA,iBAAiB,MAAM,kEAAkE,4CAA4C;AACrI;AACA;;AAEA;AACA,iBAAiB,MAAM,oEAAoE,8CAA8C;AACzI;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,YAAY;AACvB;AACA;;AAEA,0BAA0B,OAAO;AACjC,0BAA0B,OAAO;AACjC,8BAA8B,4BAA4B;AAC1D,6BAA6B,UAAU;AACvC,qCAAqC,qBAAqB;AAC1D,mCAAmC,mBAAmB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,cAAc;AACxB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,aAAa;AACvB,UAAU,QAAQ;AAClB,WAAW,YAAY;AACvB;AACA;;AAEA,+BAA+B,gBAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,eAAe,gBAAgB;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,YAAY;AACvB;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,YAAY;AACvB;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,YAAY;AACvB;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,YAAY;AACvB;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,uSAAuS,IAAI;;AAE3S;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B,eAAe;;AAE7C;AACA,8BAA8B,eAAe;;AAE7C;AACA,8BAA8B,eAAe;;AAE7C;AACA,8BAA8B,eAAe;;AAE7C;AACA,YAAY,eAAe;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,WAAW,YAAY;AACvB;AACA;;AAEA,kCAAkC,mBAAmB;;AAErD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,YAAY;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,YAAY;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mBAAmB,cAAc;AACjC;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wBAAwB,cAAc;AACtC;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB,WAAW,iBAAiB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,0DAA0D,oCAAoC;AAC9F;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG,qFAAqF;AACxF;AACA,wCAAwC,kCAAkC;AAC1E;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA,gDAAgD,uFAAuF;AACvI;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,0FAA0F,wCAAwC;AAClI;AACA;AACA;AACA;AACA;AACA,0DAA0D,kBAAkB;AAC5E,4CAA4C,gDAAgD;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO,sGAAsG;AAC9H;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA,kBAAkB,wCAAwC;AAC1D;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gDAAgD;AACzF;AACA;AACA,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,GAAG,uBAAuB,OAAO;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA,sCAAsC,MAAM,iDAAiD,6DAA6D,yHAAyH,EAAE,aAAa,cAAc,EAAE,EAAE;AACpT;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA;AACA;;AAEA,oEAAoE;AACpE;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA,wDAAwD,6EAA6E;AACrI;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA,0DAA0D,0CAA0C;AACpG;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,mBAAmB;AACjC,cAAc,QAAQ;AACtB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,2CAA2C,uBAAuB;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,yBAAyB;AACxC;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC,cAAc,QAAQ;AACtB,eAAe,yBAAyB;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC,eAAe,YAAY;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,gBAAgB,QAAQ;AACxB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,eAAe,kBAAkB;AACjC;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,QAAQ;AAClB;AACA;;AAEA,wCAAwC,yBAAyB;;AAEjE;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qDAAqD;AACxE;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA,oCAAoC,kBAAkB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA,oCAAoC,kBAAkB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA,oCAAoC,kBAAkB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,oCAAoC,kBAAkB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,oCAAoC,kBAAkB;;AAEtD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,kCAAkC,WAAW;;AAE7C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,kCAAkC,WAAW;;AAE7C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,kCAAkC,WAAW;;AAE7C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,kCAAkC,WAAW;AAC7C,iCAAiC,WAAW;;AAE5C;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,kCAAkC,WAAW;AAC7C,iCAAiC,WAAW;;AAE5C;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,kCAAkC,WAAW;AAC7C,iCAAiC,WAAW;;AAE5C;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,iCAAiC,aAAa;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,gFAAgF,uBAAuB;AACvG;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA,iDAAiD;AACjD;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,OAAO,qBAAqB;AAC3C;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB,4BAA4B;AAC5C;AACA;;AAEA,yCAAyC,oBAAoB;AAC7D,yCAAyC,oBAAoB;AAC7D,sCAAsC,iBAAiB;;AAEvD;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,YAAY;;AAEnC;AACA;;AAEA;AACA;;AAEA;;AAEA,gBAAgB;;AAEhB,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,gCAAgC,SAAS;;AAEzC;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB,YAAY;AACZ;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe;AACf;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,eAAe,MAAM;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,eAAe,MAAM;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ,gBAAgB;AACvC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,iCAAiC,UAAU;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,aAAa,8EAA8E,OAAO;AAC5G;AACA;;AAEA,8BAA8B,YAAY;;AAE1C;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA,oEAAoE;;AAEpE;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wCAAwC;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA,kDAAkD;;AAElD,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,kDAAkD;;AAElD,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,qGAAqG;;AAErG,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA,wBAAwB,UAAU;AAClC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,eAAe,IAAI;AACnB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,eAAe,IAAI;AACnB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,kCAAkC;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C,eAAe,MAAM;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C,cAAc,QAAQ;AACtB;AACA;;AAEA,qCAAqC,iBAAiB;;AAEtD;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,gBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,aAAa;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA;AACA,SAAS;;AAET,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,YAAY;AACtB,UAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wHAAwH,SAAS;AACjI;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA,sDAAsD,iBAAiB;AACvE,kDAAkD,8BAA8B;AAChF,sCAAsC,mBAAmB;AACzD,kCAAkC,WAAW;AAC7C,mCAAmC,YAAY;AAC/C,iCAAiC,cAAc;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA,qKAAqK,SAAS;AAC9K;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA,qCAAqC,iBAAiB;AACtD,kDAAkD,8BAA8B;AAChF,sCAAsC,mBAAmB;AACzD,kCAAkC,WAAW;AAC7C,mCAAmC,YAAY;AAC/C,iCAAiC,cAAc;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA,kCAAkC,WAAW;;AAE7C;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA,qCAAqC,kBAAkB;;AAEvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA,yCAAyC,aAAa;;AAEtD,kCAAkC,WAAW;;AAE7C;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA,wCAAwC,iBAAiB;;AAEzD;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA,sCAAsC,eAAe;;AAErD;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA,oCAAoC,uBAAuB;;AAE3D;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA,kCAAkC,WAAW;;AAE7C;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA,kCAAkC,cAAc;;AAEhD;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,eAAe,MAAM;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,gBAAgB;AACtD,iCAAiC,WAAW;;AAE5C;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;;AAEA;;AAEA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA,wHAAwH,SAAS;AACjI;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA,qKAAqK,SAAS;AAC9K;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,MAAM;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,OAAO,WAAW;AAClD;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,OAAO,WAAW;AAClD;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,OAAO,WAAW;AAClD;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA;;AAEA,aAAa;;AAEb;;AAEA,aAAa;;AAEb;;AAEA,aAAa;;AAEb;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB,qBAAqB,gCAAgC;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA,uDAAuD,0BAA0B;AACjF;AACA,KAAK,0EAA0E;AAC/E;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2CAA2C;AACtD;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2CAA2C;AACtD;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,SAAS,mBAAmB;AAC5B,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA,wCAAwC,oBAAoB;;AAE5D;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA,0FAA0F,gCAAgC;AAC1H;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,uCAAuC,MAAM,0BAA0B;AAC5F;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,yCAAyC,qCAAqC;AAC9E;AACA;AACA,uEAAuE;AACvE;AACA;AACA,+CAA+C,4BAA4B;AAC3E;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,QAAQ;AAClB;AACA;;AAEA,oCAAoC,oBAAoB;;AAExD;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,+BAA+B,OAAO,iCAAiC;AAC/G,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,uBAAuB,GAAG,0BAA0B,MAAM,wBAAwB;AAC7F;AACA;AACA;AACA,cAAc,QAAQ,yCAAyC,4BAA4B;AAC3F,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA,cAAc,QAAQ,yCAAyC,4BAA4B;AAC3F,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,KAAK;AACnB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA,cAAc,QAAQ,yCAAyC,4BAA4B;AAC3F,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,KAAK;AACnB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA,cAAc,QAAQ,yCAAyC,4BAA4B;AAC3F,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,KAAK;AACnB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,QAAQ,6CAA6C,4BAA4B;AAC/F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;;AAEA,wCAAwC,oBAAoB;;AAE5D;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,uBAAuB,GAAG,0BAA0B,MAAM,wBAAwB;AACzF;AACA;AACA;AACA,UAAU,aAAa;AACvB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB,UAAU,MAAM;AAChB;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,cAAc,cAAc;AAC5B,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,cAAc,cAAc;AAC5B,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;;AAEA,iCAAiC,cAAc;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA,4CAA4C,wBAAwB;;AAEpE,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA,uCAAuC,oBAAoB;;AAE3D;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,cAAc;AACxB,UAAU,OAAO;AACjB,UAAU,iBAAiB;AAC3B,UAAU,kBAAkB;AAC5B,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA;;AAEA,6BAA6B,cAAc;;AAE3C;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA,uCAAuC,oBAAoB;AAC3D,6CAA6C,0BAA0B;;AAEvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA,qCAAqC,kBAAkB;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA,qCAAqC,cAAc;;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA,qCAAqC,cAAc;;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,WAAW,SAAS;AACpB;AACA;;AAEA,+BAA+B,aAAa;;AAE5C;AACA;;AAEA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;;AAEA;;AAEA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,eAAe,MAAM;AACrB;AACA;;AAEA,mCAAmC,aAAa;;AAEhD,2BAA2B,UAAU;AACrC;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,MAAM;AACpB,eAAe,MAAM;AACrB;AACA;;AAEA,4CAA4C,wBAAwB;AACpE,mCAAmC,aAAa;;AAEhD;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,MAAM;AACpB,eAAe,MAAM;AACrB;AACA;;AAEA,4CAA4C,wBAAwB;AACpE,mCAAmC,aAAa;;AAEhD;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB,mBAAmB;AACnB,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB;AAChB,gBAAgB;AAChB,eAAe;AACf,mBAAmB;AACnB,mBAAmB;AACnB,kBAAkB;AAClB,sBAAsB;AACtB,sBAAsB;AACtB,kBAAkB;AAClB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC,cAAc,yBAAyB;AACvC;AACA;;AAEA,oCAAoC,mCAAmC;;AAEvE,mCAAmC;;AAEnC,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC;;AAElC;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC;;AAElC;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA,qCAAqC,iBAAiB,kBAAkB;AACxE,qCAAqC,kBAAkB,iBAAiB;;AAExE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,iCAAiC;;AAEjC;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,oCAAoC;;AAEpC;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,oCAAoC;;AAEpC;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC,cAAc,sBAAsB;AACpC,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;;AAEvC;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,cAAc;AACnD,qCAAqC,cAAc;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,iCAAiC;;AAEjC;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,gCAAgC;;AAEhC;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA,kCAAkC;;AAElC;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,mCAAmC;;AAEnC;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,qBAAqB;AACnC;AACA;;AAEA,0CAA0C;;AAE1C,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,qCAAqC,eAAe;AACpD,mCAAmC,YAAY;AAC/C,oCAAoC,aAAa;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,MAAM;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC,cAAc;;AAE/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA,kCAAkC,4BAA4B;;AAE9D;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA,kCAAkC,4BAA4B;;AAE9D;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA,kCAAkC,4BAA4B;;AAE9D;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA,kCAAkC,4BAA4B;;AAE9D;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA,kCAAkC,4BAA4B;;AAE9D;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,eAAe,MAAM;AACrB;AACA;;AAEA,kCAAkC,4BAA4B;;AAE9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA,+CAA+C,2BAA2B;;AAE1E;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C,sGAAsG,qBAAqB;AAC3H;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,sDAAsD,sDAAsD;AAC5G;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,IAAI,sEAAsE;AACzF;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA,wCAAwC,qBAAqB;;AAE7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA,gCAAgC,YAAY;AAC5C,iCAAiC,aAAa;AAC9C,4CAA4C,wBAAwB;;AAEpE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA,qCAAqC,kBAAkB;;AAEvD,kEAAkE,wBAAwB;;AAE1F,uDAAuD,wEAAwE;;AAE/H,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA,qCAAqC,kBAAkB;;AAEvD;AACA,kEAAkE,4BAA4B;;AAE9F,uDAAuD,uDAAuD;;AAE9G,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA,qCAAqC,eAAe;AACpD,mCAAmC,YAAY;AAC/C,oCAAoC,aAAa;;AAEjD,4DAA4D,yGAAyG;;AAErK,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,yBAAyB,iEAAiE,kBAAkB;AAC1H;AACA,kFAAkF,0CAA0C;AAC5H,wGAAwG;AACxG,cAAc,QAAQ;AACtB;AACA,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,mBAAmB;;AAE1D;AACA;AACA;AACA;;AAEA,uDAAuD,uCAAuC;;AAE9F,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB;AACA,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,gBAAgB;AACpD,qCAAqC,iBAAiB;AACtD,uCAAuC,mBAAmB;;AAE1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,QAAQ;AACtB;AACA,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,yBAAyB,iEAAiE,kBAAkB;AAC1H;AACA,mFAAmF,0CAA0C;AAC7H,wGAAwG;AACxG,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,gBAAgB;;AAEnD;AACA;AACA;AACA;;AAEA,uDAAuD,qDAAqD;;AAE5G,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA,gCAAgC,YAAY;AAC5C,iCAAiC,aAAa;AAC9C,mCAAmC,6BAA6B;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,iBAAiB;AACtE;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA,gCAAgC,YAAY;AAC5C,iCAAiC,aAAa;AAC9C,mCAAmC,0CAA0C;;AAE7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,iBAAiB;AACtE;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,iBAAiB;AACtD,sCAAsC,kBAAkB;;AAExD;AACA;AACA;AACA;;AAEA,qCAAqC,cAAc;AACnD,qCAAqC,cAAc;;AAEnD;AACA;AACA;AACA,+DAA+D,6DAA6D;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mEAAmE;AACnE,kGAAkG;AAClG;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA,qCAAqC,iBAAiB;AACtD,sCAAsC,kBAAkB;;AAExD;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,iBAAiB;AACtD,sCAAsC,kBAAkB;AACxD,mCAAmC,iDAAiD;;AAEpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE,qCAAqC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iEAAiE,uDAAuD;;AAExH;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,cAAc;AAC7B,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,8BAA8B;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,0CAA0C,2BAA2B;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,yCAAyC,mBAAmB;;AAE5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB,aAAa,aAAa;AAC1D,eAAe,OAAO,0BAA0B;AAChD;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;;AAEA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB,aAAa,aAAa;AAC1D,eAAe,OAAO,0BAA0B;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;;AAEA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,eAAe;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,eAAe;AAC7B;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,eAAe;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA,mEAAmE,kCAAkC;AACrG;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,iBAAiB;AAC/B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,iBAAiB;AAC/B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,iBAAiB;AAC/B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;;AAEA,mCAAmC,YAAY;;AAE/C;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA;;AAEA,+BAA+B,YAAY;AAC3C,6BAA6B,cAAc;AAC3C,gCAAgC,sCAAsC;;AAEtE;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA,0DAA0D,cAAc;AACxE,sDAAsD,YAAY;AAClE,iCAAiC,cAAc;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA,0EAA0E,aAAa;AACvF,yCAAyC,qBAAqB;;AAE9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,uBAAuB;AAC9D,qCAAqC,kBAAkB;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,cAAc;;AAE/C;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO,oDAAoD;AACzE;AACA;;AAEA,iCAAiC,cAAc;AAC/C,mCAAmC,6BAA6B;;AAEhE;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,iBAAiB;;AAEtD;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,iBAAiB;;AAEzE;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA,mCAAmC,eAAe;;AAElD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA,mCAAmC,YAAY;AAC/C,iCAAiC,cAAc;AAC/C,oCAAoC,gCAAgC;;AAEpE;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,mBAAmB;AACnC;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB;AACjE,mCAAmC,sBAAsB,sDAAsD,0DAA0D;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,cAAc;AACxB,UAAU,cAAc;AACxB;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,sBAAsB,KAAK,qBAAqB;AAC/D;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,WAAW,6BAA6B;AACxC,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,WAAW,2BAA2B;AACtC,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uEAAuE,8DAA8D;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,wBAAwB;AAClF;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA,iGAAiG,wBAAwB;AACzH;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA,iGAAiG,wBAAwB;AACzH;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA,4CAA4C,8BAA8B;AAC1E,0BAA0B,wBAAwB;AAClD,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kGAAkG,0BAA0B;AAC5H;AACA,kCAAkC,wBAAwB;AAC1D,wDAAwD,8BAA8B;AACtF;AACA;AACA;AACA,uDAAuD,wBAAwB;AAC/E;AACA;AACA;AACA;AACA,mEAAmE,4DAA4D;AAC/H;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA;AACA,WAAW,sCAAsC;AACjD;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA,6DAA6D;AAC7D;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,eAAe;AACxB;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,QAAQ,qCAAqC,sCAAsC;AACpG;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,cAAc;AAC/B;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,qDAAqD,wCAAwC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA,iDAAiD,8BAA8B;AAC/E;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,gCAAgC,gBAAgB;AAChD,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,gEAAgE,mBAAmB;AACnF,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,+DAA+D;AAC/D,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,yEAAyE,8CAA8C;AACvH;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,gDAAgD,8CAA8C;AAC9F;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,+EAA+E,8CAA8C;AAC7H;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,0DAA0D,8CAA8C;AACxG;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,wDAAwD,8CAA8C;AACtG;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAA4D;AAClG;AACA;AACA,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,6CAA6C,oBAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO,mEAAmE;AACxF,cAAc,OAAO,qEAAqE;AAC1F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA,0CAA0C,uBAAuB;;AAEjE;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,wDAAwD;AACxD,qEAAqE;AACrE,gEAAgE;AAChE,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,oDAAoD,sBAAsB;AAC1E;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB,oDAAoD;AACnF,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,qCAAqC,8BAA8B;AACnE,sCAAsC,gCAAgC;;AAEtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,cAAc,gBAAgB,MAAM,iBAAiB;AACrD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,gEAAgE,wBAAwB;AACxF;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,qDAAqD,yEAAyE;AAC9H;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM,+CAA+C;AACnE;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,2BAA2B;AAC1C;AACA;;AAEA,kCAAkC,oBAAoB;AACtD,mCAAmC,sBAAsB;AACzD,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB,sBAAsB,+CAA+C,wBAAwB;AAC/G;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,SAAS,mCAAmC;AAC5C;AACA;AACA;AACA;AACA,SAAS,oCAAoC;AAC7C;AACA;AACA;AACA;AACA,SAAS,mCAAmC;AAC5C;AACA;AACA;AACA,SAAS,iCAAiC;AAC1C;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA,SAAS,qCAAqC;AAC9C;AACA,iFAAiF,oDAAoD;AACrI;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,OAAO,8CAA8C;AACrD;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,OAAO,8CAA8C;AACrD;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA,8FAA8F,gDAAgD;AAC9I;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA,4FAA4F,gDAAgD;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iFAAiF;AAC5I;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,oCAAoC,OAAO;AAC3C,oCAAoC,OAAO;AAC3C;AACA,wCAAwC,iBAAiB;;AAEzD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,kBAAkB;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wDAAwD;AACtE,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB;AACA;;AAEA,mCAAmC,eAAe;AAClD,sCAAsC,eAAe;;AAErD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA,mCAAmC,eAAe;;AAElD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA,0CAA0C,iCAAiC;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4CAA4C;AACjF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,eAAe,eAAe;AAC9B;AACA;;AAEA,oCAAoC,aAAa;;AAEjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,2DAA2D,yDAAyD;AACzI,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,sBAAsB;;AAEtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO,kFAAkF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,qBAAqB,2BAA2B,EAAE;AAClD,qBAAqB,4CAA4C;;AAEjE;AACA,qBAAqB,2BAA2B,EAAE;AAClD,qBAAqB,2CAA2C;;AAEhE;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA,qCAAqC;AACrC;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA,qCAAqC;AACrC;;AAEA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL,CAAC;;AAED;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,MAAM;AAChB;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,IAAI;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,IAAI;AAClB,eAAe,IAAI;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,eAAe,IAAI;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,cAAc,IAAI;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,KAAK;AACnB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA,oCAAoC,iBAAiB;;AAErD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA,+BAA+B,aAAa;AAC5C,uCAAuC,gBAAgB;AACvD,mCAAmC,yBAAyB;;AAE5D;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA,8BAA8B;AAC9B;AACA;;AAEA,uCAAuC,gBAAgB;AACvD,mCAAmC,yBAAyB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,eAAe,MAAM;AACrB;AACA;;AAEA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;;AAEA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,iCAAiC,6CAA6C;AAC9E;AACA;AACA,cAAc,aAAa,8BAA8B;AACzD,cAAc,cAAc;AAC5B,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,eAAe,IAAI;AACnB;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,eAAe,IAAI;AACnB;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,eAAe,IAAI;AACnB;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,SAAS;AACxB;AACA;;AAEA;;AAEA,2BAA2B,UAAU;AACrC;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,WAAW;;AAE/D;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,UAAU;;AAE3C;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA,SAAS,2NAA2N;AACpO,SAAS,8NAA8N;AACvO,SAAS,2NAA2N;AACpO,SAAS,2NAA2N;AACpO,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yCAAyC;AACzC;AACA;AACA,yFAAyF;AACzF;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,aAAa;AAC7B;AACA;;AAEA,uCAAuC,gBAAgB;AACvD,wCAAwC,0BAA0B;AAClE,oCAAoC,aAAa;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uBAAuB,YAAY;AACnC;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,OAAO;AACtB;AACA;;AAEA,gDAAgD,kCAAkC;AAClF,gDAAgD,aAAa;AAC7D,gDAAgD,aAAa;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,gCAAgC,wDAAwD;;AAExF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,mBAAmB;;AAEnB;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA,8BAA8B,SAAS;AACvC,mCAAmC,cAAc;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET,yCAAyC,EAAE,UAAU,EAAE,UAAU,EAAE;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,MAAM;AACrB;AACA;;AAEA,8BAA8B,SAAS;AACvC,8BAA8B,SAAS;;AAEvC;;AAEA,uBAAuB,UAAU;AACjC;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,MAAM;AACrB;AACA;;AAEA,8BAA8B,SAAS;AACvC,8BAA8B,SAAS;;AAEvC;;AAEA,uBAAuB,UAAU;AACjC;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;;AAEA,kCAAkC,aAAa;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;;AAEA,gCAAgC,SAAS;AACzC,gCAAgC,WAAW;AAC3C,kCAAkC,aAAa;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,+F;AACA;AACA;AACA;AACA,+G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,iG;AACA;AACA;AACA,iG;AACA;AACA;AACA,+G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB;AACA;;AAEA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA,iBAAiB,qBAAqB;AACtC;AACA;;AAEA;AACA,iBAAiB,qBAAqB;AACtC;AACA;;AAEA;AACA,iBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;;AAEA,mCAAmC,gCAAgC;AACnE,kCAAkC,eAAe;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,eAAe,eAAe;AAC9B;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,YAAY;AACtB,UAAU,YAAY;AACtB;AACA;;AAEA,4BAA4B,YAAY;AACxC,4BAA4B,YAAY;;AAExC;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,YAAY;AAC3B,gBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,aAAa;AAC7B;AACA;;AAEA,yCAAyC,sBAAsB;AAC/D,kCAAkC,cAAc;AAChD,mCAAmC,eAAe;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB,uCAAuC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,gBAAgB,aAAa;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oEAAoE,4BAA4B,EAAE;AAClG;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,gBAAgB,aAAa;AAC7B;AACA;;AAEA,qCAAqC,kBAAkB;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA,oDAAoD,+BAA+B,eAAe;AAClG,sDAAsD,iCAAiC;;AAEvF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;;AAEA,iCAAiC,cAAc;AAC/C,yCAAyC,kBAAkB;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,0DAA0D;AACxE,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,gBAAgB,aAAa;AAC7B;AACA;;AAEA,qCAAqC,iBAAiB;;AAEtD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,kBAAkB;AAClC;AACA;;AAEA,kCAAkC,eAAe;AACjD,kCAAkC,WAAW;AAC7C,sCAAsC,kBAAkB;;AAExD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,sCAAsC,6BAA6B,EAAE;AACrE,KAAK;AACL;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;ACz7yDA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;ACvLtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD,6CAA6C,iCAAiC;AAC9E,IAAI,kBAAkB;AACtB;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ,oDAAoD;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAiE,GAAG;AACpE;AACA;AACA;;AAEA;AACA,gBAAgB,wCAAwC;AACxD;AACA,yCAAyC;AACzC;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;;AAGjC;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ,yCAAyC;AAC5D;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,YAAY,KAAK;AACjB;AACA;;;AAGA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,KAAK;AAChB,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,MAAM;AAClB;AACA;AACA;AACA;;;AAGA;AACA,WAAW,kBAAkB;AAC7B;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA,WAAW;AACX;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB,gBAAgB;AAChB;AACA,eAAe;AACf,eAAe;AACf;;;AAGA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,GAAG;AACH;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,iBAAiB;AAC5B;AACA,WAAW,KAAK;AAChB;AACA,YAAY,UAAU;AACtB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;;;AAGA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,iBAAiB;AAC5B;AACA,WAAW,KAAK;AAChB;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA,gCAAgC;AAChC;AACA,WAAW,uBAAuB;AAClC,WAAW,EAAE;AACb;AACA,WAAW,KAAK;AAChB;AACA,YAAY,UAAU;AACtB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,KAAK;AAChB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa,IAAI,uBAAuB;AAC9E;AACA;AACA,WAAW,OAAO,sDAAsD,KAAK;AAC7E,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA,yBAAyB,MAAM,IAAI;AACnC;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,QAAQ,oDAAoD;AACvE;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA,aAAa,KAAK;AAClB;AACA,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,WAAW,KAAK;AAChB,YAAY,EAAE;AACd,cAAc,UAAU;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B,QAAQ;AACR;AACA;;;AAGA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sDAAsD;AACvE;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,O;AACV;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,UAAU,O;AACV;AACA,wBAAwB;AACxB;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,E;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,O;AACV;AACA,oCAAoC;AACpC;AACA;AACA,UAAU,O;AACV;AACA,oCAAoC;AACpC;AACA;AACA,UAAU,O;AACV;AACA,uCAAuC;;AAEvC;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,gB;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,U;AACZ,WAAW,QAAQ;AACnB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,e;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA,gDAAgD,UAAU,EAAE;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA,aAAa,a;AACb;AACA;AACA;AACA,6DAA6D,kBAAkB,EAAE;AACjF,6DAA6D,kBAAkB,EAAE;AACjF,8DAA8D,eAAe,EAAE;AAC/E,8DAA8D,eAAe,EAAE;;AAE/E;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;;AAEA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA,gDAAgD,2BAA2B,EAAE;AAC7E;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,sCAAsC,mBAAmB,mBAAmB,YAAY;;AAExF;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,sCAAsC,mBAAmB,mBAAmB,YAAY;;AAExF;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,sCAAsC,iBAAiB,iBAAiB,YAAY;;AAEpF;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,6CAA6C,yBAAyB,yBAAyB,YAAY;AAC3G;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,6CAA6C,yBAAyB,yBAAyB,YAAY;;AAE3G;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,sCAAsC,2BAA2B,2BAA2B,YAAY;;AAExG;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,sCAAsC,2BAA2B,2BAA2B,YAAY;;AAExG;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,kCAAkC,cAAc,cAAc,YAAY;;AAE1E;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA,aAAa,a;AACb;AACA;AACA;AACA,6DAA6D,kBAAkB,EAAE;AACjF,6DAA6D,kBAAkB,EAAE;AACjF,6DAA6D,kBAAkB,EAAE;AACjF,8DAA8D,eAAe,EAAE;AAC/E,8DAA8D,eAAe,EAAE;AAC/E,8DAA8D,eAAe,EAAE;;AAE/E;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;;AAEA;AACA;AACA,UAAU,c;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4DAA4D,+CAA+C;;AAE3G;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;;AAEA;AACA;AACA,UAAU,c;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC,mBAAmB,mBAAmB;AACtC,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA,UAAU,Y;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Y;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0DAA0D,+CAA+C;;AAEzG;AACA;AACA;AACA,YAAY,Y;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qDAAqD,0CAA0C;;AAE/F;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Y;AACZ,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE,mCAAmC,8BAA8B;AACjE;AACA;;AAEA;AACA;AACA;AACA,YAAY,Y;AACZ,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE,mCAAmC,8BAA8B;AACjE;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,YAAY;AACvB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,YAAY;AACvB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,Y;AACV;AACA;;AAEA;AACA;AACA,UAAU,kB;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,a;AACV;AACA,2CAA2C;AAC3C;AACA;AACA,UAAU,a;AACV;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA,iCAAiC;AACjC;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,mB;AACV;AACA,mDAAmD;AACnD;AACA;AACA,UAAU,a;AACV;AACA,6CAA6C;AAC7C;AACA;AACA,UAAU,uB;AACV;AACA,iDAAiD;AACjD;AACA;AACA,UAAU,uB;AACV;AACA,iDAAiD;AACjD;AACA;AACA,UAAU,uB;AACV;AACA,uDAAuD;AACvD;AACA;AACA,UAAU,uB;AACV;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,c;AACV;AACA;AACA;AACA;AACA,UAAU,uB;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,mB;AACV;AACA;AACA;AACA;AACA,UAAU,mB;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,mB;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,mB;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,c;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC;;AAElE;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,+BAA+B;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,mB;AACb;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,a;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,8BAA8B,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,yCAAyC;AACzC;AACA;AACA,UAAU;AACV;AACA,yCAAyC;AACzC;AACA;AACA,UAAU;AACV;AACA,wCAAwC;AACxC;AACA;AACA,UAAU;AACV;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;;AAErE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,kB;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,c;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,E;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,yBAAyB;AACpC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,8CAA8C;AAC9C;AACA;AACA,UAAU;AACV;AACA,gDAAgD;AAChD;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,kEAAkE,sCAAsC;;AAExG;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA,kEAAkE,sCAAsC;;AAExG;AACA;AACA;AACA,YAAY;AACZ;AACA,iEAAiE,8BAA8B;;AAE/F;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA,iEAAiE,8BAA8B;;AAE/F;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sFAAsF;AACtF,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,qDAAqD;AACrD,qDAAqD;AACrD,2CAA2C;AAC3C,qCAAqC;AACrC,uCAAuC;AACvC,uCAAuC;AACvC,qCAAqC;AACrC,uCAAuC;AACvC,2CAA2C;AAC3C,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,0BAA0B;AACrC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,mEAAmE,sCAAsC;;AAEzG;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,mEAAmE,sCAAsC;;AAEzG;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,iEAAiE,qCAAqC;;AAEtG;AACA;AACA;AACA,YAAY;AACZ;AACA,kEAAkE,8BAA8B;;AAEhG;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,6DAA6D;AAC7D;AACA,kDAAkD;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA,iEAAiE,6BAA6B;;AAE9F;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wFAAwF;AACxF,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,qDAAqD;AACrD,qDAAqD;AACrD,mDAAmD;AACnD,2CAA2C;AAC3C,qCAAqC;AACrC,6CAA6C;AAC7C,6CAA6C;AAC7C,qCAAqC;AACrC,uCAAuC;AACvC,0CAA0C;AAC1C,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,gDAAgD;AAChD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4BAA4B,2HAA2H;AACvJ,4BAA4B,2HAA2H;;AAEvJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,qDAAqD,sBAAsB;;AAE3E;AACA;AACA;AACA,YAAY;AACZ;AACA,qDAAqD,sBAAsB;;AAE3E;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,wCAAwC;AACpE;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8EAA8E;AAC9E,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,wCAAwC;AACxC,wCAAwC;AACxC,kCAAkC;AAClC,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,sB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,gBAAgB,kBAAkB;AAClC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,gBAAgB,kBAAkB;AAClC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,oDAAoD;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,qB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,sB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,+CAA+C;AAC/C;AACA;AACA,UAAU;AACV;AACA,+CAA+C;AAC/C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gDAAgD;;AAEhD;AACA;AACA,YAAY,uB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,0CAA0C;AAC1C;AACA;AACA,UAAU;AACV;AACA,0CAA0C;AAC1C;AACA;AACA,UAAU;AACV;AACA,yCAAyC;AACzC;AACA;AACA,UAAU;AACV;AACA,sCAAsC;AACtC;AACA;AACA,UAAU;AACV;AACA,2CAA2C;AAC3C;AACA;AACA,UAAU;AACV;AACA,2CAA2C;;AAE3C;AACA;AACA,YAAY,sB;AACZ,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,sBAAsB;AACtB,kBAAkB;AAClB,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,qBAAqB;AAChC,WAAW,sBAAsB;AACjC,WAAW,kBAAkB;AAC7B,WAAW,sBAAsB;AACjC,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,4BAA4B,sDAAsD;;AAElF;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB;AACA,YAAY,OAAO;;AAEnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,qBAAqB;AAChC,WAAW,sBAAsB;AACjC,YAAY,K;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,gBAAgB;AAC5B;;AAEA;AACA,YAAY,8BAA8B;AAC1C,YAAY,OAAO;;AAEnB;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,OAAO;;AAEnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,uBAAuB;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;;AAE1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;;AAEpB;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,8DAA8D,sCAAsC;;AAEpG;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,8DAA8D,sCAAsC;;AAEpG;AACA;AACA;AACA,YAAY;AACZ;AACA,6DAA6D,8BAA8B;;AAE3F;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA,0DAA0D,yBAAyB;AACnF;AACA;AACA,YAAY;AACZ;AACA,wDAAwD,2BAA2B;;AAEnF;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA,gEAAgE,6BAA6B;AAC7F;AACA;AACA,YAAY;AACZ;AACA,2DAA2D,4BAA4B;;AAEvF;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8EAA8E;AAC9E,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,qDAAqD;AACrD,qDAAqD;AACrD,2CAA2C;AAC3C,wCAAwC;AACxC,yCAAyC;AACzC,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,8DAA8D,sCAAsC;;AAEpG;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,8DAA8D,sCAAsC;;AAEpG;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA,8DAA8D,2BAA2B;AACzF;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8EAA8E;AAC9E,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,qDAAqD;AACrD,qDAAqD;AACrD,sCAAsC;AACtC,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,mB;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,Q;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,kCAAkC;AAClC;AACA;AACA,UAAU;AACV;AACA,sCAAsC;AACtC;AACA;AACA,UAAU;AACV;AACA,uCAAuC;AACvC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,iB;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,mBAAmB;AACnB,2BAA2B;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,gDAAgD,+BAA+B,EAAE;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,gDAAgD,+BAA+B,EAAE;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,6CAA6C;AAC7C;AACA;AACA,UAAU;AACV;AACA,6CAA6C;AAC7C;AACA;AACA,UAAU;AACV;AACA,4CAA4C;AAC5C;AACA;AACA,UAAU;AACV;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA,GAAG;AACH,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA,GAAG;AACH,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA,GAAG;AACH,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA,GAAG;AACH,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,oCAAoC;;AAEpC;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA,GAAG;AACH,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,kDAAkD;AAClD;AACA;AACA,UAAU;AACV;AACA,kDAAkD;AAClD;AACA;AACA,UAAU;AACV;AACA,mDAAmD;AACnD;AACA;AACA,UAAU;AACV;AACA,0CAA0C;;AAE1C;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,gDAAgD,oCAAoC,EAAE;AACtF;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA,+BAA+B,iEAAiE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,iB;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA,+BAA+B,iEAAiE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,8CAA8C;AAC9C;AACA;AACA,UAAU;AACV;AACA,8CAA8C;AAC9C;AACA;AACA,UAAU;AACV;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,2B;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA,gDAAgD,iCAAiC,EAAE;AACnF;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,qB;AACZ,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,sB;AACZ,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,yCAAyC;AACzC;AACA;AACA,UAAU;AACV;AACA,yCAAyC;;AAEzC;AACA;AACA,UAAU;AACV;AACA,2CAA2C;AAC3C;AACA;AACA,UAAU;AACV;AACA,2CAA2C;;AAE3C;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,sBAAsB;AACjC,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,O;AACZ,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,qBAAqB;AAChC,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,4BAA4B,wCAAwC;;AAEpE;AACA;;AAEA,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;AAC9B;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;;AAE1B;AACA,aAAa,aAAa;;AAE1B;AACA,YAAY,aAAa;;AAEzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;;AAE1B;AACA,YAAY,aAAa;;AAEzB;AACA,YAAY,aAAa;;AAEzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;;AAE3B;AACA;;AAEA,cAAc,aAAa;AAC3B,cAAc,aAAa;;AAE3B,cAAc,aAAa;AAC3B,cAAc,aAAa;;AAE3B,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,cAAc,aAAa;AAC3B,aAAa,aAAa;;AAE1B,aAAa,aAAa;;AAE1B;AACA;;AAEA,aAAa,aAAa;AAC1B,aAAa,aAAa;;AAE1B,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;;AAE1B,aAAa,aAAa;;AAE1B;AACA;;AAEA,aAAa,aAAa;AAC1B,aAAa,aAAa;;AAE1B,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;;AAE3B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,OAAO;;AAErB;AACA;;AAEA;AACA;AACA,cAAc,aAAa;AAC3B,aAAa,aAAa;;AAE1B,aAAa,aAAa;AAC1B,aAAa,aAAa;;AAE1B,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;;AAE1B,aAAa,aAAa;AAC1B,aAAa,aAAa;;AAE1B,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,YAAY,sBAAsB;AAClC,YAAY,sBAAsB;;AAElC,YAAY,cAAc;AAC1B,YAAY,cAAc;;AAE1B;AACA;AACA;AACA;;AAEA,YAAY,OAAO;;AAEnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,4BAA4B,oCAAoC;;AAEhE,YAAY,OAAO;AACnB,YAAY,OAAO,6BAA6B;AAChD,YAAY,OAAO;;AAEnB;AACA,YAAY,qBAAqB;AACjC;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B,cAAc,OAAO;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,UAAU;AACV;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,OAAO;;AAEtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,2CAA2C;AAC3C;AACA;AACA,UAAU;AACV;AACA,6CAA6C;AAC7C;AACA;AACA,UAAU;AACV;AACA,0CAA0C;AAC1C;AACA;AACA,UAAU;AACV;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mCAAmC;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gB;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA,YAAY,gB;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA,4BAA4B,yEAAyE;AACrG,4BAA4B,wEAAwE;AACpG;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAwD;AACpF,4BAA4B,uDAAuD;AACnF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gB;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA,YAAY,gB;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA,4BAA4B,sEAAsE;AAClG,4BAA4B,yEAAyE;AACrG;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAqD;AACjF,4BAA4B,wDAAwD;AACpF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;;AAEA;AACA;AACA,YAAY,c;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA,4BAA4B,8CAA8C;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,sBAAsB;AACjC,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;;AAEA;AACA,YAAY,K;AACZ,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb;AACA;AACA;AACA,2EAA2E;;AAE3E;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,c;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,c;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA,4BAA4B,uDAAuD;;AAEnF;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,qB;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,qB;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qB;AACZ,WAAW,qBAAqB;AAChC,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA,4BAA4B,oEAAoE;AAChG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ;AACR;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA,kEAAkE;AAClE,6BAA6B,+DAA+D;AAC5F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qB;AACZ,WAAW,qBAAqB;AAChC,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qB;AACZ,WAAW,qBAAqB;AAChC,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,sBAAsB;AACjC,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,0DAA0D;;AAEtF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,mCAAmC;;AAE/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,yCAAyC;AACrE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,K;AACZ,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,kFAAkF;AAClF,yEAAyE;AACzE,gBAAgB,kBAAkB;AAClC;AACA,8CAA8C;AAC9C;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA,4BAA4B,4BAA4B;;AAExD,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,WAAW,oBAAoB;AAC/B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;AACA,YAAY,aAAa;;AAEzB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,OAAO;;AAEnB,cAAc,uBAAuB;AACrC,YAAY,kBAAkB;AAC9B;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,OAAO;;AAErB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,OAAO;;AAErB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB,4BAA4B,yBAAyB;AACrD,WAAW,aAAa;AACxB;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,QAAQ;AACpB,YAAY,QAAQ;;AAEpB,YAAY,aAAa;AACzB;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;;AAEpB;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,YAAY,eAAe;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,2BAA2B;AACvC,YAAY,sBAAsB;AAClC;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,8CAA8C,SAAS;AACvD;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB,aAAa,OAAO;;AAEpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,2BAA2B;AACvC,YAAY,2BAA2B;AACvC,YAAY,OAAO;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,OAAO;AACnB,kDAAkD,SAAS;AAC3D;AACA,aAAa,OAAO;;AAEpB;;AAEA;AACA;AACA,cAAc,sBAAsB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,eAAe;AAC1B;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,eAAe;AAC1B;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;;AAEA,YAAY,aAAa;;AAEzB,6CAA6C,SAAS;AACtD;AACA,aAAa,aAAa;;AAE1B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb;AACA;AACA;AACA,wEAAwE;;AAExE;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,kB;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,c;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,c;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA,4BAA4B,oDAAoD;;AAEhF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,sBAAsB;AACjC,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,K;AACZ,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,4EAA4E;AAC5E,yCAAyC;AACzC,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD,0CAA0C;AAC1C,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb;AACA;AACA;AACA,yEAAyE;;AAEzE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,mB;AACZ,WAAW,qBAAqB;AAChC,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,4BAA4B,gEAAgE;AAC5F,4BAA4B,4BAA4B;AACxD;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,mB;AACZ,WAAW,qBAAqB;AAChC,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,4BAA4B,gEAAgE;AAC5F,4BAA4B,4BAA4B;AACxD;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,mB;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,mB;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,c;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,c;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA,4BAA4B,qDAAqD;;AAEjF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,wDAAwD;AACpF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,sBAAsB;AACjC,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,2CAA2C;;AAEvE,YAAY,kBAAkB;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,2CAA2C;;AAEvE,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,K;AACZ,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,oDAAoD;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,8EAA8E;AAC9E,yEAAyE;AACzE,gBAAgB,kBAAkB;AAClC;AACA,8CAA8C;AAC9C;AACA,4CAA4C;AAC5C,yDAAyD;AACzD,yDAAyD;AACzD,6CAA6C;AAC7C,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gB;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA,YAAY,gB;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA,4BAA4B,uEAAuE;AACnG,4BAA4B,yEAAyE;AACrG;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAsD;AAClF,4BAA4B,wDAAwD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,eAAe;AAC1B,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,2BAA2B;AACtC,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,8CAA8C;;AAE1E;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,iBAAiB;AAC5B,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;;AAEA,WAAW;AACX,WAAW;AACX;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gB;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA,YAAY,gB;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAwD;AACpF,4BAA4B,wDAAwD;AACpF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,oBAAoB;AAC/B,WAAW,kBAAkB;AAC7B,WAAW,oBAAoB;AAC/B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B,WAAW,oBAAoB;AAC/B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gB;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA,YAAY,gB;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAuD;AACnF,4BAA4B,uDAAuD;AACnF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gB;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA,YAAY,gB;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA,4BAA4B,uEAAuE;AACnG,4BAA4B,wEAAwE;AACpG;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAsD;AAClF,4BAA4B,uDAAuD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gB;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA,YAAY,gB;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA,4BAA4B,sEAAsE;AAClG,4BAA4B,wEAAwE;AACpG;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAqD;AACjF,4BAA4B,uDAAuD;AACnF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,gDAAgD,8CAA8C,EAAE;AAChG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,2DAA2D;AAC3D;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,gDAAgD,gDAAgD,EAAE;AAClG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,gDAAgD,gDAAgD,EAAE;AAClG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,gFAAgF;AAChF;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,sB;AACZ,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,gBAAgB;;AAE5B,YAAY,gBAAgB;AAC5B,YAAY,gBAAgB;AAC5B,YAAY,cAAc;AAC1B,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,iBAAiB;;AAE7B,YAAY,OAAO;;AAEnB,YAAY,kCAAkC;AAC9C,YAAY,kCAAkC;;AAE9C,YAAY,sBAAsB;AAClC,YAAY,gCAAgC;;AAE5C;AACA,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,gCAAgC;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,SAAS;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,kCAAkC;AAC9C,YAAY,kCAAkC;;AAE9C,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,iBAAiB;;AAE7B,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;;AAE9B,YAAY,sBAAsB;;AAElC,YAAY,OAAO;;AAEnB,YAAY,gCAAgC;;AAE5C,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,OAAO;;AAEnB,YAAY,aAAa;;AAEzB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,OAAO;;AAEnB,YAAY,OAAO;;AAEnB,YAAY,gCAAgC;AAC5C,YAAY,gCAAgC;;AAE5C,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,OAAO;;AAEnB,gCAAgC,SAAS;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,yCAAyC;;AAEtE;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2CAA2C;;AAE3C;AACA,+BAA+B,SAAS;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,wBAAwB;;AAExB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,kCAAkC;;AAE9C,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,YAAY,gCAAgC;AAC5C,YAAY,aAAa;;AAEzB;AACA,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;;AAEvB,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,kCAAkC;AAC9C,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,gCAAgC;;AAE5C,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,aAAa;;AAEzB,YAAY,gCAAgC;AAC5C,YAAY,gCAAgC;;AAE5C,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA,6BAA6B,sDAAsD;;AAEnF;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8BAA8B,sCAAsC;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,mEAAmE;AACnG,gCAAgC,mEAAmE;AACnG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,mEAAmE;AACnG;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,mEAAmE;AACnG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,kCAAkC;AAC9C,YAAY,iBAAiB;;AAE7B,gCAAgC,SAAS;AACzC;AACA;AACA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,kCAAkC;AAC7C,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,4BAA4B,mCAAmC;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,kCAAkC;;AAE9C,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;;AAE9B,YAAY,+BAA+B;;AAE3C,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,aAAa;;AAEzB,YAAY,OAAO;;AAEnB,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,kCAAkC;;AAE9C,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;;AAE9B,YAAY,+BAA+B;AAC3C,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,aAAa;;AAEzB,YAAY,OAAO;;AAEnB,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,wB;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,gBAAgB;AAC3B,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mCAAmC;AACnC,iCAAiC;;AAEjC,qDAAqD;AACrD,sDAAsD;AACtD;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA,4BAA4B,wDAAwD;AACpF;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,4BAA4B,8DAA8D;AAC1F;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA,4BAA4B,0DAA0D;AACtF;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,iBAAiB;AAC5B,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,sBAAsB;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,uBAAuB;AACvC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,sBAAsB;AACtC;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,8CAA8C;AAC1E,4BAA4B,8CAA8C;;AAE1E;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,0CAA0C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,yBAAyB;AACzC;AACA,aAAa,gBAAgB;;AAE7B,WAAW,UAAU;;AAErB,aAAa,kCAAkC;;AAE/C;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB,EAAE,GAAG;;AAE3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA,gBAAgB,wCAAwC;AACxD;AACA;;AAEA,iBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,0EAA0E;AACtG,4BAA4B,0EAA0E;;AAEtG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,0EAA0E;AACtG,4BAA4B,0EAA0E;;AAEtG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,yCAAyC;;AAEzC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,EAAE;AACd,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,qCAAqC;AAChD,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA,YAAY,sBAAsB;AAClC;;AAEA;AACA;AACA,aAAa,iBAAiB,0BAA0B,iBAAiB;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,2DAA2D;AACtE,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,4BAA4B,0CAA0C;AACtE;;AAEA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB;AACA;;AAEA,YAAY,OAAO;;AAEnB;AACA,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,YAAY,sBAAsB;AAClC;;AAEA;AACA;AACA,aAAa,iBAAiB,0BAA0B,iBAAiB;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;;AAEA,cAAc,OAAO;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,EAAE;AACb;AACA;AACA;AACA,YAAY,iBAAiB;;AAE7B;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,4BAA4B,gCAAgC;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,WAAW,iBAAiB;AAC5B,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA,4BAA4B,gCAAgC;;AAE5D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;;AAEA,aAAa,OAAO;;AAEpB,aAAa,aAAa;AAC1B;AACA,aAAa,OAAO;;AAEpB;AACA,aAAa,OAAO;;AAEpB;AACA,aAAa,OAAO;;AAEpB;AACA,aAAa,OAAO;AACpB,aAAa,aAAa;AAC1B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,iBAAiB;;AAE7B;AACA,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,iCAAiC;AAC9D,6BAA6B,iCAAiC;;AAE9D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;;AAEA,cAAc,iBAAiB;AAC/B,cAAc,iBAAiB;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,YAAY,iB;AACZ;AACA;AACA;AACA,4BAA4B,4BAA4B;;AAExD;AACA;AACA;AACA;;AAEA,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;;AAE7B,YAAY,OAAO;;AAEnB;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,iBAAiB;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,iBAAiB;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,iBAAiB;AAC7B,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,YAAY,OAAO;;AAEnB;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,uCAAuC;AACpE;;AAEA,YAAY,iBAAiB;;AAE7B,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;;AAE7B;AACA;AACA,6BAA6B,iCAAiC;AAC9D,6BAA6B,iCAAiC;AAC9D,6BAA6B,mCAAmC;AAChE;AACA;;AAEA,4BAA4B,yCAAyC;AACrE,4BAA4B,yCAAyC;;AAErE;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,iBAAiB;;AAE7B,YAAY,iBAAiB;AAC7B,YAAY,iBAAiB;;AAE7B;AACA;AACA,6BAA6B,iCAAiC;AAC9D,6BAA6B,iCAAiC;AAC9D,6BAA6B,mCAAmC;AAChE;AACA;;AAEA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA,4BAA4B,wCAAwC;;AAEpE,YAAY,aAAa;AACzB;;AAEA,4BAA4B,0DAA0D;AACtF,4BAA4B,0DAA0D;;AAEtF;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;;AAEA,YAAY,OAAO;AACnB,YAAY,iBAAiB;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA,4BAA4B,2DAA2D;AACvF;;AAEA;AACA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,yCAAyC;;AAEtE,aAAa,iBAAiB;AAC9B,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB;AACA;;AAEA,YAAY,OAAO;;AAEnB;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,yCAAyC;;AAEtE,aAAa,iBAAiB;AAC9B,aAAa,iBAAiB;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,iB;AACZ,WAAW,aAAa;AACxB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,E;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU,gB;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,oD;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,4BAA4B,gEAAgE;AAC5F,4BAA4B,gEAAgE;AAC5F,6BAA6B;AAC7B,6BAA6B;;AAE7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,kB;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,e;AACZ,WAAW,eAAe;AAC1B;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,6B;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,gDAAgD,mCAAmC,EAAE;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,e;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,E;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,sBAAsB;AACjC,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,iB;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,mEAAmE;AAC/F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;;AAErE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,4BAA4B,yCAAyC;;AAErE;AACA;;AAEA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,E;AACA;AACA;;AAEA,gBAAgB,uBAAuB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,eAAe;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,uCAAuC;AACvC,0CAA0C;AAC1C,sCAAsC;AACtC,oCAAoC;AACpC,+CAA+C;AAC/C,2CAA2C;AAC3C,6CAA6C;;AAE7C;;AAEA;AACA,oCAAoC;AACpC;AACA,gDAAgD;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,iB;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,uCAAuC;AACnE,4BAA4B,6CAA6C;AACzE,4BAA4B,2CAA2C;AACvE,4BAA4B,qDAAqD;AACjF,4BAA4B,0EAA0E;AACtG,4BAA4B,8EAA8E;AAC1G,4BAA4B,4EAA4E;;AAExG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,mCAAmC;AACnC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,sCAAsC;AACtC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU,iB;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,+BAA+B;AAC/B;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA,4BAA4B,mDAAmD;AAC/E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,4BAA4B,mDAAmD;AAC/E;AACA;AACA;AACA;;AAEA,4BAA4B,yCAAyC;;AAErE;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,uBAAuB;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,mDAAmD;AAC/E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sDAAsD,0CAA0C;;AAEhG;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2DAA2D,wCAAwC;;AAEnG;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gB;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,4BAA4B,mDAAmD;AAC/E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6BAA6B,8BAA8B;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,iEAAiE;;AAE7F;AACA;AACA,iCAAiC,GAAG;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,8BAA8B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,4BAA4B,mDAAmD;AAC/E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;;AAEA;AACA,YAAY,mBAAmB;AAC/B,iBAAiB,gBAAgB,+BAA+B,GAAG;AACnE;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA,4BAA4B,mDAAmD;;AAE/E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,GAAG;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,GAAG;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,E;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,IAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA,8BAA8B;AAC9B,iDAAiD;AACjD,kCAAkC;AAClC,uDAAuD;AACvD,4CAA4C;AAC5C,0CAA0C;AAC1C,2CAA2C;AAC3C,oCAAoC;AACpC,+BAA+B;AAC/B,uCAAuC;AACvC,gCAAgC;AAChC,gCAAgC;AAChC,yCAAyC;AACzC;AACA,0DAA0D;AAC1D;AACA,kBAAkB,gBAAgB,+BAA+B,GAAG;AACpE;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,aAAa,4BAA4B,GAAG;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,aAAa,4BAA4B,GAAG;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gB;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,4BAA4B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;;AAEA,YAAY,aAAa;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;;AAEA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA,aAAa,kBAAkB;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;;AAEA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;;AAEA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,aAAa,gBAAgB;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;;AAEA,YAAY,cAAc;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;;AAEA,YAAY,QAAQ;;AAEpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,4BAA4B,uCAAuC;AACnE;;AAEA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB,2CAA2C,YAAY;AAC3F;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa,4BAA4B,GAAG;AAC7D;AACA;AACA;AACA,iBAAiB,gBAAgB,gDAAgD,GAAG;AACpF;AACA;AACA;AACA,iBAAiB,cAAc,6BAA6B,GAAG;AAC/D;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB,YAAY,sBAAsB;AAClC,iBAAiB,aAAa,+BAA+B,MAAM;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,8BAA8B,uCAAuC;AACrE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB,6BAA6B,IAAI;AACxE;AACA,eAAe,gBAAgB;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,aAAa;;AAE5B;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,wCAAwC;AACvE;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB,2BAA2B,IAAI;AACpE;AACA;AACA;AACA;AACA;;AAEA,aAAa,aAAa;;AAE1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,wCAAwC;AACvE;AACA;AACA;AACA;;AAEA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO,cAAc,wBAAwB;AAC/D;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO,cAAc,kBAAkB;AACtD;AACA;AACA;AACA;;AAEA;AACA,aAAa,cAAc;;AAE3B;AACA,gBAAgB,aAAa,4BAA4B,GAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;;AAEA;AACA;AACA,kBAAkB,aAAa,4BAA4B,GAAG;AAC9D;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB,gDAAgD,GAAG;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,OAAO;;AAEpB,gBAAgB,gBAAgB,gDAAgD,GAAG;AACnF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,gBAAgB;;AAE/B;AACA;AACA;AACA;AACA;;AAEA,eAAe,aAAa;AAC5B,eAAe,aAAa;;AAE5B,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,+BAA+B,wGAAwG;;AAEvI,eAAe,QAAQ;AACvB,eAAe,QAAQ;;AAEvB;AACA;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB,eAAe,QAAQ;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,4BAA4B;;AAE3D,eAAe,OAAO;AACtB,eAAe,OAAO;;AAEtB;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA,eAAe,kBAAkB;AACjC;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,aAAa;AACxB,WAAW,aAAa;;AAExB,aAAa,cAAc;AAC3B,aAAa,cAAc;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,aAAa;AAC3B,kBAAkB,OAAO,cAAc,OAAO;AAC9C;AACA,cAAc,aAAa,mCAAmC;AAC9D;AACA;AACA,oBAAoB,oBAAoB,gCAAgC,IAAI;AAC5E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,gBAAgB;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,OAAO,cAAc,wBAAwB;AAC7D;AACA,YAAY,aAAa;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,oBAAoB,gCAAgC,IAAI;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,YAAY,cAAc;;AAE1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA,iBAAiB,aAAa,+BAA+B,MAAM;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW;AACX,eAAe;AACf,WAAW,aAAa;AACxB;AACA;AACA;AACA,YAAY,mBAAmB;;AAE/B;AACA,aAAa,Q;AACb,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,6BAA6B,+DAA+D;AAC5F,WAAW,gBAAgB;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW;AACX,eAAe;AACf,WAAW,cAAc;AACzB,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,YAAY,mBAAmB;;AAE/B;AACA,aAAa,Q;AACb,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,6BAA6B,+DAA+D;AAC5F,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW;AACX,eAAe;AACf,WAAW,aAAa;AACxB;AACA;AACA;AACA,YAAY,mBAAmB;;AAE/B;AACA,aAAa,Q;AACb,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,6BAA6B,+DAA+D;AAC5F,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW;AACX,2CAA2C;AAC3C;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA,YAAY,mBAAmB;;AAE/B;AACA,aAAa,O;AACb,YAAY,qBAAqB;AACjC,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,6BAA6B,+DAA+D;AAC5F,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB,aAAa,sBAAsB;AACnC,aAAa,QAAQ;;AAErB;AACA;AACA,cAAc,OAAO;AACrB,cAAc,aAAa;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gB;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,OAAO;;AAEnB;AACA,aAAa,O;AACb,YAAY,gBAAgB;AAC5B,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,wB;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;;AAEA;AACA,aAAa,O;AACb,YAAY,gBAAgB;AAC5B,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B,WAAW,cAAc;AACzB;AACA;AACA;AACA,YAAY,cAAc;;AAE1B;AACA;AACA;AACA;AACA,cAAc,oBAAoB;;AAElC,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,cAAc,aAAa;;AAE3B;AACA;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;AACA;AACA;;AAEA;AACA;AACA,cAAc,mBAAmB;AACjC,cAAc,OAAO;AACrB,YAAY,qBAAqB;;AAEjC,YAAY,aAAa;AACzB;AACA,mBAAmB,OAAO,cAAc,WAAW;AACnD;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,qBAAqB;AACnC,cAAc,OAAO;AACrB,YAAY,qBAAqB;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;AAC9B,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,YAAY,aAAa;;AAEzB,YAAY,cAAc;;AAE1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oBAAoB;AAClC,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,OAAO;AACnB,YAAY,cAAc;;AAE1B;AACA;AACA,kBAAkB,aAAa,4BAA4B,GAAG;AAC9D;AACA,cAAc,kBAAkB;;AAEhC;;AAEA,mBAAmB,gBAAgB,+BAA+B,GAAG;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc,6BAA6B,GAAG;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,aAAa,qBAAqB;;AAElC,gBAAgB,aAAa,4BAA4B,GAAG;AAC5D;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB,+BAA+B,GAAG;AACnE;AACA,oBAAoB,OAAO,cAAc,oBAAoB;AAC7D;AACA,gBAAgB,qBAAqB;;AAErC,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,aAAa,4BAA4B,GAAG;AAC5D;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,mBAAmB,kCAAkC,GAAG;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,aAAa,4BAA4B,GAAG;AAC7D;AACA,kBAAkB,gBAAgB,4BAA4B,GAAG;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;;AAEA,iBAAiB,aAAa,4BAA4B,GAAG;AAC7D;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,cAAc,6BAA6B,GAAG;AAC/D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,aAAa,2CAA2C;AAClF,0CAA0C;;AAE1C,0BAA0B,qBAAqB,+BAA+B;AAC9E,0BAA0B,sBAAsB,+BAA+B;AAC/E;AACA,kBAAkB,aAAa,4BAA4B,GAAG;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,cAAc,6BAA6B,GAAG;AAChE;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,cAAc,6BAA6B,GAAG;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;;AAEA;AACA,gBAAgB,cAAc,6BAA6B,GAAG;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,mB;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA,4BAA4B,6FAA6F;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA,4BAA4B,yFAAyF;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,sBAAsB;;AAEtB,4BAA4B,wGAAwG;;AAEpI;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mB;AACb;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,Q;AACV;AACA,wDAAwD;AACxD;AACA;AACA;AACA,UAAU,Q;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mB;AACb;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA,YAAY,cAAc;AAC1B,2CAA2C;AAC3C,OAAO;AACP,OAAO;AACP,OAAO;AACP;AACA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,c;AACV;AACA;AACA,0CAA0C;AAC1C,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,yBAAyB;AACpC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,kEAAkE,sCAAsC;;AAExG;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,kEAAkE,sCAAsC;;AAExG;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sFAAsF;AACtF,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,qDAAqD;AACrD,qDAAqD;AACrD,mCAAmC;AACnC,wCAAwC;AACxC,yCAAyC;AACzC,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA,4DAA4D;AAC5D;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,yBAAyB;AACpC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,kEAAkE,sCAAsC;;AAExG;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,kEAAkE,sCAAsC;;AAExG;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sFAAsF;AACtF,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,qDAAqD;AACrD,qDAAqD;AACrD,qCAAqC;AACrC,sCAAsC;AACtC,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,a;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,sCAAsC;AAClE,4BAA4B,oEAAoE;AAChG,4BAA4B,0EAA0E;AACtG,4BAA4B,4EAA4E;;AAExG;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,8CAA8C;AAC1E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,mB;AACb;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,a;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,8BAA8B,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,O;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAA+C;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,uBAAuB;AAClC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,iCAAiC;AAC7D;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kFAAkF;AAClF,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,sDAAsD;AACtD,sDAAsD;AACtD,qDAAqD;AACrD,qDAAqD;AACrD,oCAAoC;AACpC,oCAAoC;AACpC,kCAAkC;AAClC,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA,+DAA+D;;AAE/D;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,c;AACZ,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA,4BAA4B,sDAAsD;;AAElF;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,Q;AACZ,WAAW,sBAAsB;AACjC,WAAW,qBAAqB;AAChC,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,K;AACZ,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;;AAEnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,gFAAgF;AAChF,yCAAyC;AACzC,gDAAgD;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA,0BAA0B,YAAY;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,sB;AACZ,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,4BAA4B,uBAAuB,EAAE;AACrD;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,+DAA+D,sCAAsC;;AAErG;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,+DAA+D,sCAAsC;;AAErG;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA,6DAA6D,qCAAqC;;AAElG;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gFAAgF;AAChF,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;AAC1C,qDAAqD;AACrD,qDAAqD;AACrD,iDAAiD;AACjD,qCAAqC;AACrC,uCAAuC;AACvC,2CAA2C;AAC3C,wCAAwC;AACxC,yCAAyC;AACzC,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,iB;AACb;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,c;AACb,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,a;AACZ,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA,YAAY,O;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,sDAAsD;AAClF;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,wDAAwD;AACpF;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+C;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,Q;AACZ,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gFAAgF;;AAEhF,uCAAuC;AACvC,uCAAuC;AACvC,0CAA0C;;AAE1C,qDAAqD;AACrD,0CAA0C;AAC1C,qCAAqC;AACrC,sCAAsC;AACtC,6CAA6C;AAC7C,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA,iBAAiB,sCAAsC;AACvD;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,4CAA4C;AAC7D;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA,kBAAkB;;AAElB;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC,cAAc,QAAQ;AACtB;AACA;;AAEA,8CAA8C,iBAAiB;;AAE/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,0CAA0C,aAAa;AACvD,2CAA2C,cAAc;AACzD,yCAAyC,YAAY;AACrD,4CAA4C,eAAe;AAC3D,uDAAuD,uBAAuB;AAC9E,mDAAmD,gCAAgC;;AAEnF;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA,0CAA0C,aAAa;AACvD,2CAA2C,cAAc;AACzD,yCAAyC,YAAY;AACrD,4CAA4C,eAAe;AAC3D,uDAAuD,uBAAuB;AAC9E,mDAAmD,4BAA4B;;AAE/E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,uBAAuB;AACtC;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,uBAAuB;AACtC;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,uBAAuB;AACtC;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,uBAAuB;AACtC;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC,eAAe,0BAA0B;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;;AAEA;;AAEA,8CAA8C,GAAG;AACjD;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,OAAO;AACtB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,cAAc,qBAAqB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,MAAM;AACrB;AACA;;AAEA,6CAA6C,iBAAiB;AAC9D,iDAAiD,qBAAqB;;AAEtE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,MAAM;AACrB;AACA;;AAEA,6CAA6C,iBAAiB;AAC9D,iDAAiD,qBAAqB;;AAEtE;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,sBAAsB;AACrC;AACA;;AAEA,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ,E;AAClD,iDAAiD,eAAe;AAChE,+CAA+C,aAAa;;AAE5D;AACA;AACA;AACA,2B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;;AAElD;AACA;AACA;AACA,2B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,sBAAsB;AACrC;AACA;;AAEA,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,kDAAkD,gBAAgB;AAClE,mDAAmD,iBAAiB;AACpE,oDAAoD,sBAAsB;AAC1E,kDAAkD,gBAAgB;AAClE,kDAAkD,gBAAgB;AAClE,oDAAoD,sBAAsB;;AAE1E;AACA;AACA;AACA,2B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,eAAe,uBAAuB;AACtC;AACA;;AAEA,6CAA6C,WAAW;AACxD,6CAA6C,WAAW;AACxD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,kDAAkD,gBAAgB;AAClE,kDAAkD,gBAAgB;AAClE,kDAAkD,gBAAgB;AAClE,kDAAkD,gBAAgB;AAClE,oDAAoD,sBAAsB;AAC1E,oDAAoD,sBAAsB;AAC1E,mDAAmD,iBAAiB;;AAEpE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,sBAAsB;AACrC;AACA;;AAEA,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,gDAAgD,cAAc;AAC9D,iDAAiD,eAAe;;AAEhE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,kBAAkB;AACjC;AACA;;AAEA,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,iDAAiD,eAAe;AAChE,+CAA+C,aAAa;;AAE5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,mBAAmB;AAClC;AACA;;AAEA,+CAA+C,aAAa;AAC5D,+CAA+C,aAAa;AAC5D,mDAAmD,iBAAiB;AACpE,gDAAgD,cAAc;AAC9D,iDAAiD,eAAe;AAChE,wDAAwD,sBAAsB;;AAE9E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,mBAAmB;AAClC;AACA;;AAEA,6CAA6C,WAAW;AACxD,6CAA6C,WAAW;AACxD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,kDAAkD,gBAAgB;AAClE,mDAAmD,iBAAiB;AACpE,oDAAoD,sBAAsB;AAC1E,iDAAiD,eAAe;AAChE,+CAA+C,aAAa;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,wCAAwC;AACtD,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,oBAAoB;AACnC;AACA;;AAEA,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,0CAA0C,QAAQ;AAClD,2CAA2C,SAAS;AACpD,2CAA2C,SAAS;AACpD,2CAA2C,SAAS;AACpD,2CAA2C,SAAS;AACpD,6CAA6C,WAAW;AACxD,+CAA+C,eAAe;AAC9D,+CAA+C,eAAe;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,eAAe,oBAAoB;AACnC;AACA;;AAEA,6CAA6C,WAAW;;AAExD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,kCAAkC;AAChD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,kCAAkC;AAChD,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,MAAM;AACrB;AACA;;AAEA;;AAEA,gDAAgD,mBAAmB;AACnE,8CAA8C,iBAAiB;;AAE/D;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD,OAAO;AAC5D;AACA;;AAEA,wDAAwD,OAAO;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,eAAe,MAAM,mFAAmF,oBAAoB,IAAI,SAAS,KAAK,GAAG,oBAAoB,IAAI,SAAS,KAAK;AACvL;AACA;;AAEA,sDAAsD,uBAAuB;AAC7E,sDAAsD,uBAAuB;;AAE7E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA,yBAAyB;AACzB,0BAA0B;AAC1B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,MAAM,oEAAoE,aAAa,GAAG,aAAa;AACtH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,eAAe,MAAM,oEAAoE,aAAa,GAAG,aAAa;AACtH;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,qBAAqB;AAChC,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,yC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,YAAY,O;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA,uB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY,O;AACZ;AACA;AACA,C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,0BAA0B;AACpC,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,GAAG;AACvC;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,cAAc;AACxB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,qBAAqB;AAC/B;AACA;;AAEA,wCAAwC,eAAe;AACvD,mCAAmC,OAAO;AAC1C,mCAAmC,OAAO;AAC1C,yCAAyC,aAAa;AACtD,uCAAuC,4BAA4B;;AAEnE;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,iBAAiB,qBAAqB;AACtC;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gCAAgC;AACjD;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B;AACA;;AAEA;AACA;AACA,oDAAoD,GAAG;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B;AACA;;AAEA;AACA;AACA,oDAAoD,GAAG;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA;AACA,0C;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA;AACA,0C;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA;AACA,2C;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA;AACA,2C;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,uCAAuC,gBAAgB;AACvD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,uCAAuC,gBAAgB;AACvD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,gBAAgB;;AAEnD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,gBAAgB;;AAEnD;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,GAAG;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA,2CAA2C,YAAY;AACvD,4CAA4C,aAAa;AACzD,6CAA6C,aAAa;AAC1D,6CAA6C,aAAa;AAC1D,8CAA8C,cAAc,E;;AAE5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,gBAAgB;AAC/B;AACA;;AAEA,8CAA8C,aAAa;AAC3D,kCAAkC,aAAa;;AAE/C,gDAAgD,gBAAgB;AAChE,2CAA2C,4CAA4C;;AAEvF;AACA,gCAAgC,wBAAwB;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA,8CAA8C,aAAa;AAC3D,kCAAkC,aAAa,EAAE;;AAEjD,gDAAgD,gBAAgB;AAChE,2CAA2C,4CAA4C;;AAEvF;AACA,gCAAgC,wBAAwB;AACxD,8BAA8B,yEAAyE;AACvG;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA,4CAA4C,aAAa;AACzD,6CAA6C,aAAa;AAC1D,6CAA6C,aAAa;;AAE1D;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,eAAe,gBAAgB;AAC/B;AACA;;AAEA,4CAA4C,sBAAsB;;AAElE;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA,wCAAwC,QAAQ;AAChD,wCAAwC,QAAQ;AAChD,wCAAwC,QAAQ;AAChD,wCAAwC,QAAQ;;AAEhD,6B;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,eAAe,gBAAgB;AAC/B;AACA;;AAEA,8CAA8C,aAAa;AAC3D,kCAAkC,aAAa;;AAE/C,gDAAgD,gBAAgB;AAChE,2CAA2C,4CAA4C;;AAEvF;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,gBAAgB;AAC/B;AACA;;AAEA,8CAA8C,aAAa;AAC3D,kCAAkC,aAAa;;AAE/C,gDAAgD,gBAAgB;AAChE,2CAA2C,4CAA4C;;AAEvF;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA,4CAA4C,eAAe;;AAE3D;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA,2BAA2B,0BAA0B;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,GAAG;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;;AAGD;AACA,oHAAoH;AACpH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,gDAAgD,GAAG;;AAEnD;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,gDAAgD,GAAG;;AAEnD;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,gDAAgD,GAAG;;AAEnD;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD,GAAG;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA,gDAAgD,GAAG;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA,gDAAgD,GAAG;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B,UAAU,IAAI;AACd,UAAU,SAAS;AACnB,UAAU,SAAS;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW,OAAO;AAClB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,K;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,K;AACZ,WAAW,aAAa;AACxB,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,K;AACZ,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,iBAAiB;AAC5B,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,uBAAuB;AAClC,YAAY,K;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;;AAEA,mBAAmB,6BAA6B;AAChD,6BAA6B,+CAA+C;AAC5E;;AAEA;;AAEA;AACA,wEAAwE,KAAK,GAAG,KAAK,GAAG,KAAK;AAC7F,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;;AAEA,mBAAmB,aAAa;AAChC;AACA,qBAAqB,aAAa;AAClC,2CAA2C,aAAa;;AAExD;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,iE;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,6BAA6B;;AAE7B;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,S;;AAEA;AACA,S;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;;AAEA,uCAAuC,WAAW;;AAElD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kB;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA,oE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAY,MAAM,uGAAuG;AACzH;AACA;;AAEA,uCAAuC,WAAW;;AAElD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC,e;;;;;;;;ACpsqCD,SAAS;AACT,2CAA2C;AAU3C,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,GAAG,UAAU,KAAa,EAAE,MAAc;IACpE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACnB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACzB,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,QAAQ,GAAG,UAAU,KAAa;IACrD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACnB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,SAAS,GAAG,UAAU,MAAc;IACvD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACrB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC;;;;;;;;;ACxBF,SAAS;AACT,2CAA2C;AAU3C,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO,GAAG,UAAU,KAAa,EAAE,MAAc;IACrE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACnB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACzB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,GAAG,UAAU,KAAa;IACtD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACnB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,SAAS,GAAG,UAAU,MAAc;IACxD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACrB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC;;;;;;;;;ACxBF,aAAa;;AAEb,IAAiB,UAAU,CAwB1B;AAxBD,WAAiB,UAAU;IACvB,kCAAkC;IACrB,yBAAc,GAAG,IAAI,GAAG,GAAG,CAAC;IAC5B,yBAAc,GAAG,IAAI,GAAG,GAAG,CAAC;IAEzC,4CAA4C;IAC5C,+DAA+D;IAClD,wBAAa,GAAG,GAAG,CAAC;IAIjC,IAAiB,IAAI,CAEpB;IAFD,WAAiB,IAAI;QACJ,mBAAc,GAAS,eAAe;IACvD,CAAC,EAFgB,IAAI,GAAJ,eAAI,KAAJ,eAAI,QAEpB;IACD,mBAA0B,IAAY,EAAE,KAAa,EAAE,MAAY;QAC/D,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE,GAAG,KAAK,GAAG,MAAM,CAAC;QAC9C,IAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QAC3C,MAAM,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;IACtC,CAAC;IAJe,oBAAS,YAIxB;IAED,IAAiB,MAAM,CAGtB;IAHD,WAAiB,MAAM;QACN,YAAK,GAAG,QAAQ,CAAC;QACjB,YAAK,GAAG,QAAQ,CAAC;IAClC,CAAC,EAHgB,MAAM,GAAN,iBAAM,KAAN,iBAAM,QAGtB;AACL,CAAC,EAxBgB,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAwB1B;;;;;;;;;;;;;;;;;;;;AC1BD,2CAAmD;AAEnD;IAA+B,6BAAW;IAA1C;;IAaA,CAAC;IAXG,wBAAI,GAAJ;IAEA,CAAC;IAED,2BAAO,GAAP;QACI,mBAAmB;IACvB,CAAC;IAED,0BAAM,GAAN;QACI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;IAC1C,CAAC;IACL,gBAAC;AAAD,CAAC,CAb8B,yBAAW,GAazC;AAbY,8BAAS;;;;;;;;;;;;;;;;;;;;ACFtB,2CAA2C;AAC3C,2CAAmD;AAEnD;IAAkC,gCAAW;IAEzC;eACI,iBAAO;IACX,CAAC;IAED,2BAAI,GAAJ;QACI,iBAAM,IAAI,WAAE,CAAC;IACjB,CAAC;IAED,8BAAO,GAAP;QACI,oBAAoB;QACpB,qDAAqD;IACzD,CAAC;IAED,6BAAM,GAAN;QACI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;IACvC,CAAC;IACL,mBAAC;AAAD,CAAC,CAlBiC,yBAAW,GAkB5C;AAlBY,oCAAY;;;;;;;;;;;;;;;;;;;;ACHzB,2CAAmD;AAEnD;IAA+B,6BAAW;IAA1C;;IAqBA,CAAC;IAnBG,wBAAI,GAAJ;QACI,iBAAM,IAAI,WAAE,CAAC;IACjB,CAAC;IAED,2BAAO,GAAP;IACA,CAAC;IAED,0BAAM,GAAN;QACI,IAAI,CAAC,MAAM,EAAE,CAAC;IAClB,CAAC;IAED,4BAAQ,GAAR;IACA,CAAC;IAED,0BAAM,GAAN;IACA,CAAC;IAIL,gBAAC;AAAD,CAAC,CArB8B,yBAAW,GAqBzC;AArBY,8BAAS","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 17e930ed7e67b3782151","// 本ゲームのStateは全てこのStateをベースとする\n\nimport {Coord} from \"Core/Coord\";\n\nexport class CustomState extends Phaser.State {\n\n    init () {\n        Coord.updateCanvasAndWorldSize(this.game);\n    }\n\n    resize() {\n        if (!this.game.state.created) {\n            return;\n        }\n        this.adjust();\n    }\n\n    adjust() {\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Core/State/CustomState.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 1\n// module chunks = 0","import {UISettings} from \"Constants/UISettings\";\n\n// 座標変換ユーティリティ\n// worldとは論理座標系，canvasとはHTMLやCSSでCanvasタグに指定する実際の広さによって表現される座標系である\n// 環境によってCanvasの大きさが変化するので，UIやゲームオブジェクトの配置などは一旦論理座標で表現し，最終的にレンダリングするときにCanvas座標に戻す\n// PhaserのAPIに渡す値はcanvas座標系である\n\nexport class Coord {\n    // public\n\n    // 回転やウインドウサイズの変更が起こった際などに呼び，新しいCanvas及びWorldサイズを設定する\n    static updateCanvasAndWorldSize(game: Phaser.Game) {\n        this.calcCanvasSize();\n        \n        // HTML要素にScaleFactor倍されたCanvasサイズを指定し，CSSでScaleFactor倍率分縮小する\n        // これで画面がぼやけると言うことがなくなる\n        game.scale.scaleMode = Phaser.ScaleManager.USER_SCALE;\n        game.scale.setUserScale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio); // HTML要素に対するCSS指定の大きさ\n\n        // 新しいCanvasサイズ適用\n        game.scale.setGameSize(this.canvasWidth, this.canvasHeight);\n\n        // オブジェクトの大きさや位置をWorld座標として扱えるようScaling\n        game.world.scale = new Phaser.Point(1 / this.getWorldScale, 1 / this.getWorldScale);\n\n        // 必要であればStateでオブジェクトの配置を再計算\n        const currentState = game.state.getCurrentState();\n        if (currentState instanceof Phaser.State) {\n            currentState.resize();\n        }\n    }\n\n    // scale\n    static get getWorldScale(): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return this.cachedWorldWidth / this.cachedCanvasWidth;\n    }\n\n    // ゲームにおける論理座標系の横幅\n    static get worldWidth(): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return this.cachedWorldWidth;\n    }\n\n    // ゲームにおける論理座標系の高さ\n    static get worldHeight(): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return this.cachedWorldHeight;\n    }\n\n    // ゲームにおける論理座標系の中心座標\n    static get worldCenterX(): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return this.cachedWorldWidth * 0.5;\n    }\n\n    // ゲームにおける論理座標系の中心座標\n    static get worldCenterY(): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return this.cachedWorldHeight * 0.5;\n    }\n\n    // htmlのcanvasに指定すべき横幅\n    static get canvasWidth(): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return this.cachedCanvasWidth;\n    }\n\n    // htmlのcanvasに指定すべき高さ\n    static get canvasHeight(): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return this.cachedCanvasHeight;\n    }\n\n    static get currentWorldRatio(): number {\n        return this.worldHeight / this.worldWidth;\n    }\n\n    // Canvas座標から論理座標に変換する\n    static worldPoint(point: Phaser.Point): Phaser.Point {\n        return new Phaser.Point(this.toWorldX(point.x), this.toWorldY(point.y));\n    }\n\n    // Canvas座標から論理座標に変換する\n    static toWorldX(canvasX: number): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return (canvasX / this.cachedCanvasWidth) * this.cachedWorldWidth;\n    }\n\n    // Canvas座標から論理座標に変換する\n    static toWorldY(canvasY: number): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return (canvasY / this.cachedCanvasHeight) * this.cachedWorldHeight;\n    }\n    \n    // 論理座標からCanvas座標に変換する\n    static canvasPoint(point: Phaser.Point): Phaser.Point {\n        return new Phaser.Point(this.toCanvasX(point.x), this.toCanvasY(point.y));\n    }\n\n　　// 論理座標からCanvas座標に変換する\n    static toCanvasX(worldX: number): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return (worldX / this.cachedWorldWidth) * this.cachedCanvasWidth;\n    }\n\n    // 論理座標からCanvas座標に変換する\n    static toCanvasY(worldY: number): number {\n        if (!this.isInitialized) {\n            this.calcCanvasSize();\n        }\n        return (worldY / this.cachedWorldHeight) * this.cachedCanvasHeight;\n    }\n\n    // private\n\n    private static isInitialized = false;\n    private static cachedCanvasWidth: number;\n    private static cachedCanvasHeight: number;\n    private static cachedWorldWidth: number;\n    private static cachedWorldHeight: number;\n\n    // ブラウザサイズが変わったらこれを呼び出すことで，ゲームのCanvasサイズの再計算を行う\n    // ゲームにおいて座標に関する計算の呼び出し頻度が多いので1度計算後はキャッシュを利用するため，計算処理だけ分離した。\n    private static calcCanvasSize() {\n        this.calcCanvasWidth();\n        this.calcCanvasHeight();\n        this.calcWorldWidth();\n        this.calcWorldHeight();\n        this.isInitialized = true;\n    }\n\n    // ゲームの論理座標系の横幅を計算\n    private static calcWorldWidth() {\n        this.cachedWorldWidth = UISettings.expectedWidth;\n    }\n\n    // ゲームの論理座標系の縦幅を計算\n    private static calcWorldHeight() {\n        this.cachedWorldHeight = Math.floor(this.cachedWorldWidth * (this.cachedCanvasHeight / this.cachedCanvasWidth))\n    }\n\n    // 画面の比率に応じてCanvasタグに設定する横幅を計算\n    private static calcCanvasWidth() {\n        if (this.currentWindowRatio() < UISettings.minCanvasRatio) {\n            this.cachedCanvasWidth = Math.floor(window.innerHeight / UISettings.minCanvasRatio);\n        } else {\n            this.cachedCanvasWidth = window.innerWidth;\n        }\n\n        // scaleFactor適用\n        this.cachedCanvasWidth *= window.devicePixelRatio;\n    }\n\n    // 画面の比率に応じてCanvasタグに設定する高さを計算\n    private static calcCanvasHeight() {\n        if (this.currentWindowRatio() > UISettings.maxCanvasRatio) {\n            this.cachedCanvasHeight = Math.floor(window.innerWidth * UISettings.maxCanvasRatio);\n        } else {\n            this.cachedCanvasHeight = window.innerHeight;\n        }\n\n        // scaleFactor適用\n        this.cachedCanvasHeight *= window.devicePixelRatio;\n    }\n\n    private static currentWindowRatio(): number {\n        return window.innerHeight / window.innerWidth;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Core/Coord.ts","/// <reference path=\"../node_modules/phaser/typescript/phaser.d.ts\"/>\n\n// 依存ライブラリ\nimport 'pixi';\nimport 'phaser';\nimport 'box2d';\n\n// メソッド拡張宣言\nimport 'Extension/Image';\nimport 'Extension/Sprite';\n\nimport { Coord } from \"Core/Coord\";\nimport { BootState } from \"State/BootState\";\nimport { PreloadState } from \"State/PreloadState\";\nimport { HomeState } from \"State/HomeState\";\n\n// ゲームの初期化\nconst game = new Phaser.Game(Coord.canvasWidth, Coord.canvasHeight, Phaser.AUTO, \"\");\n\n// ウインドウのリサイズや端末の回転が起こった際にCanvasサイズを適切に変更する\nwindow.onresize = window.onorientationchange = () => {\n    Coord.updateCanvasAndWorldSize(game);\n};\n\n// ユーザによる意図しない画面ズームを抑制する\ndocument.addEventListener('touchstart', event => {\n    if (event.touches.length > 1) {\n        event.preventDefault();\n    }\n}, true);\n\n// State(他で言うところのシーン)の登録\ngame.state.add(\"BootState\", BootState);\ngame.state.add(\"PreloadState\", PreloadState);\ngame.state.add(\"HomeState\", HomeState);\n\n// エントリーポイントState開始\ngame.state.start(\"BootState\");\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","module.exports = global[\"PIXI\"] = require(\"-!/Users/tt/working/azarashi_tower_battle/node_modules/source-map-loader/index.js!./pixi-custom.js\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/CustomizedDeps/pixi-custom.js-exposed\n// module id = 4\n// module chunks = 0","/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*\n* @overview\n*\n* Phaser - http://phaser.io\n*\n* v2.6.2 \"Kore Springs\" - Built: Tue Sep 19 2017 00:17:28\n*\n* By Richard Davey http://www.photonstorm.com @photonstorm\n*\n* Phaser is a fun, free and fast 2D game framework for making HTML5 games\n* for desktop and mobile web browsers, supporting Canvas and WebGL rendering.\n*\n* Phaser uses Pixi.js for rendering, created by Mat Groves http://matgroves.com @Doormat23\n* Phaser uses p2.js for full-body physics, created by Stefan Hedman https://github.com/schteppe/p2.js @schteppe\n* Phaser contains a port of N+ Physics, converted by Richard Davey, original by http://www.metanetsoftware.com\n*\n* Many thanks to Adam Saltsman (@ADAMATOMIC) for releasing Flixel, from which both Phaser and my love of framework development originate.\n*\n* Follow development at http://phaser.io and on our forum\n*\n* \"If you want your children to be intelligent,  read them fairy tales.\"\n* \"If you want them to be more intelligent, read them more fairy tales.\"\n*                                                     -- Albert Einstein\n*/\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n(function(){\n\n    var root = this;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The [pixi.js](http://www.pixijs.com/) module/namespace.\n *\n * @module PIXI\n */\n \n/**\n * Namespace-class for [pixi.js](http://www.pixijs.com/).\n *\n * Contains assorted static properties and enumerations.\n *\n * @class PIXI\n * @static\n */\nvar PIXI = PIXI || {};\n\n/**\n * A reference to the Phaser Game instance that owns this Pixi renderer.\n * @property {Phaser.Game} game\n * @static \n */\nPIXI.game = null;\n\n/**\n * @property {Number} WEBGL_RENDERER\n * @protected\n * @static \n */\nPIXI.WEBGL_RENDERER = 0;\n\n/**\n * @property {Number} CANVAS_RENDERER\n * @protected\n * @static\n */\nPIXI.CANVAS_RENDERER = 1;\n\n/**\n * Version of pixi that is loaded.\n * @property {String} VERSION\n * @static \n */\nPIXI.VERSION = \"v2.2.9\";\n\n// used to create uids for various pixi objects.\nPIXI._UID = 0;\n\nif (typeof(Float32Array) != 'undefined')\n{\n    PIXI.Float32Array = Float32Array;\n    PIXI.Uint16Array = Uint16Array;\n\n    // Uint32Array and ArrayBuffer only used by WebGL renderer\n    // We can suppose that if WebGL is supported then typed arrays are supported too\n    // as they predate WebGL support for all browsers:\n    // see typed arrays support: http://caniuse.com/#search=TypedArrays\n    // see WebGL support: http://caniuse.com/#search=WebGL\n    PIXI.Uint32Array = Uint32Array;\n    PIXI.ArrayBuffer = ArrayBuffer;\n}\nelse\n{\n    PIXI.Float32Array = Array;\n    PIXI.Uint16Array = Array;\n}\n\n/**\n * @property {Number} PI_2\n * @static\n */\nPIXI.PI_2 = Math.PI * 2;\n\n/**\n * @property {Number} RAD_TO_DEG\n * @static\n */\nPIXI.RAD_TO_DEG = 180 / Math.PI;\n\n/**\n * @property {Number} DEG_TO_RAD\n * @static\n */\nPIXI.DEG_TO_RAD = Math.PI / 180;\n\n/**\n * @property {String} RETINA_PREFIX\n * @protected\n * @static\n */\nPIXI.RETINA_PREFIX = \"@2x\";\n\n/**\n * The default render options if none are supplied to\n * {{#crossLink \"WebGLRenderer\"}}{{/crossLink}} or {{#crossLink \"CanvasRenderer\"}}{{/crossLink}}.\n *\n * @property {Object} defaultRenderOptions\n * @property {Object} defaultRenderOptions.view=null\n * @property {Boolean} defaultRenderOptions.transparent=false\n * @property {Boolean} defaultRenderOptions.antialias=false\n * @property {Boolean} defaultRenderOptions.preserveDrawingBuffer=false\n * @property {Number} defaultRenderOptions.resolution=1\n * @property {Boolean} defaultRenderOptions.clearBeforeRender=true\n * @property {Boolean} defaultRenderOptions.autoResize=false\n * @static\nPIXI.defaultRenderOptions = {\n    view: null,\n    transparent: false,\n    antialias: false, \n    preserveDrawingBuffer: false,\n    resolution: 1,\n    clearBeforeRender: true,\n    autoResize: false\n};\n */\n\n/**\n* @author       Mat Groves http://matgroves.com @Doormat23\n* @author       Richard Davey <rich@photonstorm.com>\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The base class for all objects that are rendered. Contains properties for position, scaling,\n* rotation, masks and cache handling.\n* \n* This is an abstract class and should not be used on its own, rather it should be extended.\n*\n* It is used internally by the likes of PIXI.Sprite.\n*\n* @class PIXI.DisplayObject\n* @constructor\n*/\nPIXI.DisplayObject = function () {\n\n    /**\n    * The coordinates, in pixels, of this DisplayObject, relative to its parent container.\n    * \n    * The value of this property does not reflect any positioning happening further up the display list.\n    * To obtain that value please see the `worldPosition` property.\n    * \n    * @property {PIXI.Point} position\n    * @default\n    */\n    this.position = new PIXI.Point(0, 0);\n\n    /**\n    * The scale of this DisplayObject. A scale of 1:1 represents the DisplayObject\n    * at its default size. A value of 0.5 would scale this DisplayObject by half, and so on.\n    * \n    * The value of this property does not reflect any scaling happening further up the display list.\n    * To obtain that value please see the `worldScale` property.\n    * \n    * @property {PIXI.Point} scale\n    * @default\n    */\n    this.scale = new PIXI.Point(1, 1);\n\n    /**\n    * The pivot point of this DisplayObject that it rotates around. The values are expressed\n    * in pixel values.\n    * @property {PIXI.Point} pivot\n    * @default\n    */\n    this.pivot = new PIXI.Point(0, 0);\n\n    /**\n    * The rotation of this DisplayObject. The value is given, and expressed, in radians, and is based on\n    * a right-handed orientation.\n    * \n    * The value of this property does not reflect any rotation happening further up the display list.\n    * To obtain that value please see the `worldRotation` property.\n    * \n    * @property {number} rotation\n    * @default\n    */\n    this.rotation = 0;\n\n    /**\n    * The alpha value of this DisplayObject. A value of 1 is fully opaque. A value of 0 is transparent.\n    * Please note that an object with an alpha value of 0 is skipped during the render pass.\n    * \n    * The value of this property does not reflect any alpha values set further up the display list.\n    * To obtain that value please see the `worldAlpha` property.\n    * \n    * @property {number} alpha\n    * @default\n    */\n    this.alpha = 1;\n\n    /**\n    * The visibility of this DisplayObject. A value of `false` makes the object invisible.\n    * A value of `true` makes it visible. Please note that an object with a visible value of\n    * `false` is skipped during the render pass. Equally a DisplayObject with visible false will\n    * not render any of its children.\n    * \n    * The value of this property does not reflect any visible values set further up the display list.\n    * To obtain that value please see the `worldVisible` property.\n    * \n    * @property {boolean} visible\n    * @default\n    */\n    this.visible = true;\n\n    /**\n     * This is the defined area that will pick up mouse / touch events. It is null by default.\n     * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)\n     *\n     * @property hitArea\n     * @type Rectangle|Circle|Ellipse|Polygon\n     */\n    this.hitArea = null;\n\n    /**\n    * Should this DisplayObject be rendered by the renderer? An object with a renderable value of\n    * `false` is skipped during the render pass.\n    * \n    * @property {boolean} renderable\n    * @default\n    */\n    this.renderable = false;\n\n    /**\n    * The parent DisplayObjectContainer that this DisplayObject is a child of.\n    * All DisplayObjects must belong to a parent in order to be rendered.\n    * The root parent is the Stage object. This property is set automatically when the\n    * DisplayObject is added to, or removed from, a DisplayObjectContainer.\n    * \n    * @property {PIXI.DisplayObjectContainer} parent\n    * @default\n    * @readOnly\n    */\n    this.parent = null;\n\n    /**\n    * The multiplied alpha value of this DisplayObject. A value of 1 is fully opaque. A value of 0 is transparent.\n    * This value is the calculated total, based on the alpha values of all parents of this DisplayObjects \n    * in the display list.\n    * \n    * To obtain, and set, the local alpha value, see the `alpha` property.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until \n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    * \n    * @property {number} worldAlpha\n    * @readOnly\n    */\n    this.worldAlpha = 1;\n\n    /**\n    * The current transform of this DisplayObject.\n    * \n    * This property contains the calculated total, based on the transforms of all parents of this \n    * DisplayObject in the display list.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until \n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    *\n    * @property {PIXI.Matrix} worldTransform\n    * @readOnly\n    */\n    this.worldTransform = new PIXI.Matrix();\n\n    /**\n    * The coordinates, in pixels, of this DisplayObject within the world.\n    * \n    * This property contains the calculated total, based on the positions of all parents of this \n    * DisplayObject in the display list.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until \n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    * \n    * @property {PIXI.Point} worldPosition\n    * @readOnly\n    */\n    this.worldPosition = new PIXI.Point(0, 0);\n\n    /**\n    * The global scale of this DisplayObject.\n    * \n    * This property contains the calculated total, based on the scales of all parents of this \n    * DisplayObject in the display list.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until \n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    * \n    * @property {PIXI.Point} worldScale\n    * @readOnly\n    */\n    this.worldScale = new PIXI.Point(1, 1);\n\n    /**\n    * The rotation, in radians, of this DisplayObject.\n    * \n    * This property contains the calculated total, based on the rotations of all parents of this \n    * DisplayObject in the display list.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until \n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    * \n    * @property {number} worldRotation\n    * @readOnly\n    */\n    this.worldRotation = 0;\n\n    /**\n    * The rectangular area used by filters when rendering a shader for this DisplayObject.\n    *\n    * @property {PIXI.Rectangle} filterArea\n    * @type Rectangle\n    * @default\n    */\n    this.filterArea = null;\n\n    /**\n    * @property {number} _sr - Cached rotation value.\n    * @private\n    */\n    this._sr = 0;\n\n    /**\n    * @property {number} _cr - Cached rotation value.\n    * @private\n    */\n    this._cr = 1;\n\n    /**\n    * @property {PIXI.Rectangle} _bounds - The cached bounds of this object.\n    * @private\n    */\n    this._bounds = new PIXI.Rectangle(0, 0, 0, 0);\n\n    /**\n    * @property {PIXI.Rectangle} _currentBounds - The most recently calculated bounds of this object.\n    * @private\n    */\n    this._currentBounds = null;\n\n    /**\n    * @property {PIXI.Rectangle} _mask - The cached mask of this object.\n    * @private\n    */\n    this._mask = null;\n\n    /**\n    * @property {boolean} _cacheAsBitmap - Internal cache as bitmap flag.\n    * @private\n    */\n    this._cacheAsBitmap = false;\n\n    /**\n    * @property {boolean} _cacheIsDirty - Internal dirty cache flag.\n    * @private\n    */\n    this._cacheIsDirty = false;\n\n};\n\nPIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;\n\nPIXI.DisplayObject.prototype = {\n\n    /**\n    * Destroy this DisplayObject.\n    *\n    * Removes any cached sprites, sets renderable flag to false, and nulls filters, bounds and mask.\n    *\n    * Also iteratively calls `destroy` on any children.\n    *\n    * @method PIXI.DisplayObject#destroy\n    */\n    destroy: function () {\n\n        if (this.children)\n        {\n            var i = this.children.length;\n\n            while (i--)\n            {\n                this.children[i].destroy();\n            }\n\n            this.children = [];\n        }\n\n        this.hitArea = null;\n        this.parent = null;\n        this.worldTransform = null;\n        this.filterArea = null;\n        this.renderable = false;\n\n        this._bounds = null;\n        this._currentBounds = null;\n        this._mask = null;\n\n        this._destroyCachedSprite();\n\n    },\n\n    /*\n    * Updates the transform matrix this DisplayObject uses for rendering.\n    *\n    * If the object has no parent, and no parent parameter is provided, it will default to \n    * Phaser.Game.World as the parent transform to use. If that is unavailable the transform fails to take place.\n    *\n    * The `parent` parameter has priority over the actual parent. Use it as a parent override.\n    * Setting it does **not** change the actual parent of this DisplayObject.\n    *\n    * Calling this method updates the `worldTransform`, `worldAlpha`, `worldPosition`, `worldScale` \n    * and `worldRotation` properties.\n    *\n    * If a `transformCallback` has been specified, it is called at the end of this method, and is passed\n    * the new, updated, worldTransform property, along with the parent transform used.\n    *\n    * @method PIXI.DisplayObject#updateTransform\n    * @param {PIXI.DisplayObjectContainer} [parent] - Optional parent to calculate this DisplayObjects transform from.\n    * @return {PIXI.DisplayObject} - A reference to this DisplayObject.\n    */\n    updateTransform: function (parent) {\n\n        if (!parent && !this.parent && !this.game)\n        {\n            return this;\n        }\n\n        var p = this.parent;\n\n        if (parent)\n        {\n            p = parent;\n        }\n        else if (!this.parent)\n        {\n            p = this.game.world;\n        }\n\n        // create some matrix refs for easy access\n        var pt = p.worldTransform;\n        var wt = this.worldTransform;\n\n        // temporary matrix variables\n        var a, b, c, d, tx, ty;\n\n        // so if rotation is between 0 then we can simplify the multiplication process..\n        if (this.rotation % PIXI.PI_2)\n        {\n            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes\n            if (this.rotation !== this.rotationCache)\n            {\n                this.rotationCache = this.rotation;\n                this._sr = Math.sin(this.rotation);\n                this._cr = Math.cos(this.rotation);\n            }\n\n            // get the matrix values of the displayobject based on its transform properties..\n            a  =  this._cr * this.scale.x;\n            b  =  this._sr * this.scale.x;\n            c  = -this._sr * this.scale.y;\n            d  =  this._cr * this.scale.y;\n            tx =  this.position.x;\n            ty =  this.position.y;\n            \n            // check for pivot.. not often used so geared towards that fact!\n            if (this.pivot.x || this.pivot.y)\n            {\n                tx -= this.pivot.x * a + this.pivot.y * c;\n                ty -= this.pivot.x * b + this.pivot.y * d;\n            }\n\n            // concat the parent matrix with the objects transform.\n            wt.a  = a  * pt.a + b  * pt.c;\n            wt.b  = a  * pt.b + b  * pt.d;\n            wt.c  = c  * pt.a + d  * pt.c;\n            wt.d  = c  * pt.b + d  * pt.d;\n            wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n            wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n        }\n        else\n        {\n            // lets do the fast version as we know there is no rotation..\n            a  = this.scale.x;\n            d  = this.scale.y;\n\n            tx = this.position.x - this.pivot.x * a;\n            ty = this.position.y - this.pivot.y * d;\n\n            wt.a  = a  * pt.a;\n            wt.b  = a  * pt.b;\n            wt.c  = d  * pt.c;\n            wt.d  = d  * pt.d;\n            wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n            wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n        }\n\n        //  Set the World values\n        this.worldAlpha = this.alpha * p.worldAlpha;\n        this.worldPosition.set(wt.tx, wt.ty);\n        this.worldScale.set(this.scale.x * Math.sqrt(wt.a * wt.a + wt.c * wt.c), this.scale.y * Math.sqrt(wt.b * wt.b + wt.d * wt.d));\n        this.worldRotation = Math.atan2(-wt.c, wt.d);\n\n        // reset the bounds each time this is called!\n        this._currentBounds = null;\n\n        //  Custom callback?\n        if (this.transformCallback)\n        {\n            this.transformCallback.call(this.transformCallbackContext, wt, pt);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * To be overridden by classes that require it.\n    *\n    * @method PIXI.DisplayObject#preUpdate\n    */\n    preUpdate: function () {\n\n    },\n\n    /**\n    * Generates a RenderTexture based on this DisplayObject, which can they be used to texture other Sprites.\n    * This can be useful if your DisplayObject is static, or complicated, and needs to be reused multiple times.\n    *\n    * Please note that no garbage collection takes place on old textures. It is up to you to destroy old textures,\n    * and references to them, so they don't linger in memory.\n    *\n    * @method PIXI.DisplayObject#generateTexture\n    * @param {number} [resolution=1] - The resolution of the texture being generated.\n    * @param {number} [scaleMode=PIXI.scaleModes.DEFAULT] - See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values.\n    * @param {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - The renderer used to generate the texture.\n    * @return {PIXI.RenderTexture} - A RenderTexture containing an image of this DisplayObject at the time it was invoked.\n    */\n    generateTexture: function (resolution, scaleMode, renderer) {\n\n        var bounds = this.getLocalBounds();\n\n        var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer, scaleMode, resolution);\n        \n        PIXI.DisplayObject._tempMatrix.tx = -bounds.x;\n        PIXI.DisplayObject._tempMatrix.ty = -bounds.y;\n        \n        renderTexture.render(this, PIXI.DisplayObject._tempMatrix);\n\n        return renderTexture;\n\n    },\n\n    /**\n    * If this DisplayObject has a cached Sprite, this method generates and updates it.\n    *\n    * @method PIXI.DisplayObject#updateCache\n    * @return {PIXI.DisplayObject} - A reference to this DisplayObject.\n    */\n    updateCache: function () {\n\n        this._generateCachedSprite();\n\n        return this;\n\n    },\n\n    /**\n    * Calculates the global position of this DisplayObject, based on the position given.\n    *\n    * @method PIXI.DisplayObject#toGlobal\n    * @param {PIXI.Point} position - The global position to calculate from.\n    * @return {PIXI.Point} - A point object representing the position of this DisplayObject based on the global position given.\n    */\n    toGlobal: function (position) {\n\n        this.updateTransform();\n\n        return this.worldTransform.apply(position);\n\n    },\n\n    /**\n    * Calculates the local position of this DisplayObject, relative to another point.\n    *\n    * @method PIXI.DisplayObject#toLocal\n    * @param {PIXI.Point} position - The world origin to calculate from.\n    * @param {PIXI.DisplayObject} [from] - An optional DisplayObject to calculate the global position from.\n    * @return {PIXI.Point} - A point object representing the position of this DisplayObject based on the global position given.\n    */\n    toLocal: function (position, from) {\n\n        if (from)\n        {\n            position = from.toGlobal(position);\n        }\n\n        this.updateTransform();\n\n        return this.worldTransform.applyInverse(position);\n\n    },\n\n    /**\n    * Internal method.\n    *\n    * @method PIXI.DisplayObject#_renderCachedSprite\n    * @private\n    * @param {Object} renderSession - The render session\n    */\n    _renderCachedSprite: function (renderSession) {\n\n        this._cachedSprite.worldAlpha = this.worldAlpha;\n\n        if (renderSession.gl)\n        {\n            PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);\n        }\n        else\n        {\n            PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);\n        }\n\n    },\n\n    /**\n    * Internal method.\n    *\n    * @method PIXI.DisplayObject#_generateCachedSprite\n    * @private\n    */\n    _generateCachedSprite: function () {\n\n        this._cacheAsBitmap = false;\n\n        var bounds = this.getLocalBounds();\n\n        //  Round it off and force non-zero dimensions\n        bounds.width = Math.max(1, Math.ceil(bounds.width));\n        bounds.height = Math.max(1, Math.ceil(bounds.height));\n\n        this.updateTransform();\n\n        if (!this._cachedSprite)\n        {\n            var renderTexture = new PIXI.RenderTexture(bounds.width, bounds.height);\n            this._cachedSprite = new PIXI.Sprite(renderTexture);\n            this._cachedSprite.worldTransform = this.worldTransform;\n        }\n        else\n        {\n            this._cachedSprite.texture.resize(bounds.width, bounds.height);\n        }\n\n        //  Remove filters\n        var tempFilters = this._filters;\n\n        this._filters = null;\n        this._cachedSprite.filters = tempFilters;\n\n        PIXI.DisplayObject._tempMatrix.tx = -bounds.x;\n        PIXI.DisplayObject._tempMatrix.ty = -bounds.y;\n\n        this._cachedSprite.texture.render(this, PIXI.DisplayObject._tempMatrix, true);\n        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);\n        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);\n\n        this._filters = tempFilters;\n\n        this._cacheAsBitmap = true;\n\n    },\n\n    /**\n    * Destroys a cached Sprite.\n    *\n    * @method PIXI.DisplayObject#_destroyCachedSprite\n    * @private\n    */\n    _destroyCachedSprite: function () {\n\n        if (!this._cachedSprite)\n        {\n            return;\n        }\n\n        this._cachedSprite.texture.destroy(true);\n\n        this._cachedSprite = null;\n\n    }\n\n};\n\n//  Alias for updateTransform. As used in DisplayObject container, etc.\nPIXI.DisplayObject.prototype.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;\n\nObject.defineProperties(PIXI.DisplayObject.prototype, {\n\n    /**\n    * The horizontal position of the DisplayObject, in pixels, relative to its parent.\n    * If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.\n    * @name PIXI.DisplayObject#x\n    * @property {number} x - The horizontal position of the DisplayObject, in pixels, relative to its parent.\n    */\n    'x': {\n\n        get: function () {\n\n            return this.position.x;\n\n        },\n\n        set: function (value) {\n\n            this.position.x = value;\n\n        }\n\n    },\n\n    /**\n    * The vertical position of the DisplayObject, in pixels, relative to its parent.\n    * If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.\n    * @name PIXI.DisplayObject#y\n    * @property {number} y - The vertical position of the DisplayObject, in pixels, relative to its parent.\n    */\n    'y': {\n\n        get: function () {\n\n            return this.position.y;\n\n        },\n\n        set: function (value) {\n\n            this.position.y = value;\n\n        }\n\n    },\n\n    /**\n    * Indicates if this DisplayObject is visible, based on it, and all of its parents, `visible` property values.\n    * @name PIXI.DisplayObject#worldVisible\n    * @property {boolean} worldVisible - Indicates if this DisplayObject is visible, based on it, and all of its parents, `visible` property values.\n    */\n    'worldVisible': {\n\n        get: function () {\n\n            if (!this.visible)\n            {\n                return false;\n            }\n            else\n            {\n                var item = this.parent;\n\n                if (!item)\n                {\n                    return this.visible;\n                }\n                else\n                {\n                    do\n                    {\n                        if (!item.visible)\n                        {\n                            return false;\n                        }\n\n                        item = item.parent;\n                    }\n                    while (item);\n\n                }\n\n                return true;\n            }\n\n        }\n\n    },\n\n    /**\n    * Sets a mask for this DisplayObject. A mask is an instance of a Graphics object.\n    * When applied it limits the visible area of this DisplayObject to the shape of the mask.\n    * Under a Canvas renderer it uses shape clipping. Under a WebGL renderer it uses a Stencil Buffer.\n    * To remove a mask, set this property to `null`.\n    * \n    * @name PIXI.DisplayObject#mask\n    * @property {PIXI.Graphics} mask - The mask applied to this DisplayObject. Set to `null` to remove an existing mask.\n    */\n    'mask': {\n\n        get: function () {\n\n            return this._mask;\n\n        },\n\n        set: function (value) {\n\n            if (this._mask)\n            {\n                this._mask.isMask = false;\n            }\n\n            this._mask = value;\n\n            if (value)\n            {\n                this._mask.isMask = true;\n            }\n\n        }\n\n    },\n\n    /**\n    * Sets the filters for this DisplayObject. This is a WebGL only feature, and is ignored by the Canvas\n    * Renderer. A filter is a shader applied to this DisplayObject. You can modify the placement of the filter\n    * using `DisplayObject.filterArea`.\n    * \n    * To remove filters, set this property to `null`.\n    *\n    * Note: You cannot have a filter set, and a MULTIPLY Blend Mode active, at the same time. Setting a \n    * filter will reset this DisplayObjects blend mode to NORMAL.\n    * \n    * @name PIXI.DisplayObject#filters\n    * @property {Array} filters - An Array of PIXI.AbstractFilter objects, or objects that extend them.\n    */\n    'filters': {\n\n        get: function () {\n\n            return this._filters;\n\n        },\n\n        set: function (value) {\n\n            if (Array.isArray(value))\n            {\n                //  Put all the passes in one place.\n                var passes = [];\n\n                for (var i = 0; i < value.length; i++)\n                {\n                    var filterPasses = value[i].passes;\n\n                    for (var j = 0; j < filterPasses.length; j++)\n                    {\n                        passes.push(filterPasses[j]);\n                    }\n                }\n\n                //  Needed any more?\n                this._filterBlock = { target: this, filterPasses: passes };\n            }\n\n            this._filters = value;\n\n            if (this.blendMode && this.blendMode === PIXI.blendModes.MULTIPLY)\n            {\n                this.blendMode = PIXI.blendModes.NORMAL;\n            }\n\n        }\n\n    },\n\n    /**\n    * Sets if this DisplayObject should be cached as a bitmap.\n    *\n    * When invoked it will take a snapshot of the DisplayObject, as it is at that moment, and store it \n    * in a RenderTexture. This is then used whenever this DisplayObject is rendered. It can provide a\n    * performance benefit for complex, but static, DisplayObjects. I.e. those with lots of children.\n    *\n    * Cached Bitmaps do not track their parents. If you update a property of this DisplayObject, it will not\n    * re-generate the cached bitmap automatically. To do that you need to call `DisplayObject.updateCache`.\n    * \n    * To remove a cached bitmap, set this property to `null`.\n    * \n    * @name PIXI.DisplayObject#cacheAsBitmap\n    * @property {boolean} cacheAsBitmap - Cache this DisplayObject as a Bitmap. Set to `null` to remove an existing cached bitmap.\n    */\n    'cacheAsBitmap': {\n\n        get: function () {\n\n            return this._cacheAsBitmap;\n\n        },\n\n        set: function (value) {\n\n            if (this._cacheAsBitmap === value)\n            {\n                return;\n            }\n\n            if (value)\n            {\n                this._generateCachedSprite();\n            }\n            else\n            {\n                this._destroyCachedSprite();\n            }\n\n            this._cacheAsBitmap = value;\n\n        }\n\n    }\n\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A DisplayObjectContainer represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n * @class DisplayObjectContainer\n * @extends DisplayObject\n * @constructor\n */\nPIXI.DisplayObjectContainer = function () {\n\n    PIXI.DisplayObject.call(this);\n\n    /**\n     * [read-only] The array of children of this container.\n     *\n     * @property children\n     * @type Array(DisplayObject)\n     * @readOnly\n     */\n    this.children = [];\n\n    /**\n    * If `ignoreChildInput`  is `false` it will allow this objects _children_ to be considered as valid for Input events.\n    * \n    * If this property is `true` then the children will _not_ be considered as valid for Input events.\n    * \n    * Note that this property isn't recursive: only immediate children are influenced, it doesn't scan further down.\n    * @property {boolean} ignoreChildInput\n    * @default\n    */\n    this.ignoreChildInput = false;\n    \n};\n\nPIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype );\nPIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;\n\n/**\n * Adds a child to the container.\n *\n * @method addChild\n * @param child {DisplayObject} The DisplayObject to add to the container\n * @return {DisplayObject} The child that was added.\n */\nPIXI.DisplayObjectContainer.prototype.addChild = function (child) {\n\n    return this.addChildAt(child, this.children.length);\n\n};\n\n/**\n * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n *\n * @method addChildAt\n * @param child {DisplayObject} The child to add\n * @param index {Number} The index to place the child in\n * @return {DisplayObject} The child that was added.\n */\nPIXI.DisplayObjectContainer.prototype.addChildAt = function (child, index) {\n\n    if (index >= 0 && index <= this.children.length)\n    {\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n\n        this.children.splice(index, 0, child);\n\n        return child;\n    }\n    else\n    {\n        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);\n    }\n\n};\n\n/**\n * Swaps the position of 2 Display Objects within this container.\n *\n * @method swapChildren\n * @param child {DisplayObject}\n * @param child2 {DisplayObject}\n */\nPIXI.DisplayObjectContainer.prototype.swapChildren = function (child, child2) {\n\n    if (child === child2)\n    {\n        return;\n    }\n\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n\n    if (index1 < 0 || index2 < 0)\n    {\n        throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');\n    }\n\n    this.children[index1] = child2;\n    this.children[index2] = child;\n\n};\n\n/**\n * Returns the index position of a child DisplayObject instance\n *\n * @method getChildIndex\n * @param child {DisplayObject} The DisplayObject instance to identify\n * @return {Number} The index position of the child display object to identify\n */\nPIXI.DisplayObjectContainer.prototype.getChildIndex = function (child) {\n\n    var index = this.children.indexOf(child);\n\n    if (index === -1)\n    {\n        throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n\n    return index;\n\n};\n\n/**\n * Changes the position of an existing child in the display object container\n *\n * @method setChildIndex\n * @param child {DisplayObject} The child DisplayObject instance for which you want to change the index number\n * @param index {Number} The resulting index number for the child display object\n */\nPIXI.DisplayObjectContainer.prototype.setChildIndex = function (child, index) {\n\n    if (index < 0 || index >= this.children.length)\n    {\n        throw new Error('The supplied index is out of bounds');\n    }\n\n    var currentIndex = this.getChildIndex(child);\n\n    this.children.splice(currentIndex, 1); //remove from old position\n    this.children.splice(index, 0, child); //add at new position\n\n};\n\n/**\n * Returns the child at the specified index\n *\n * @method getChildAt\n * @param index {Number} The index to get the child from\n * @return {DisplayObject} The child at the given index, if any.\n */\nPIXI.DisplayObjectContainer.prototype.getChildAt = function (index) {\n\n    if (index < 0 || index >= this.children.length)\n    {\n        throw new Error('getChildAt: Supplied index '+ index +' does not exist in the child list, or the supplied DisplayObject must be a child of the caller');\n    }\n\n    return this.children[index];\n    \n};\n\n/**\n * Removes a child from the container.\n *\n * @method removeChild\n * @param child {DisplayObject} The DisplayObject to remove\n * @return {DisplayObject} The child that was removed.\n */\nPIXI.DisplayObjectContainer.prototype.removeChild = function (child) {\n\n    var index = this.children.indexOf(child);\n\n    if (index === -1)\n    {\n        return;\n    }\n    \n    return this.removeChildAt(index);\n\n};\n\n/**\n * Removes a child from the specified index position.\n *\n * @method removeChildAt\n * @param index {Number} The index to get the child from\n * @return {DisplayObject} The child that was removed.\n */\nPIXI.DisplayObjectContainer.prototype.removeChildAt = function (index) {\n\n    var child = this.getChildAt(index);\n\n    if (child)\n    {\n        child.parent = undefined;\n\n        this.children.splice(index, 1);\n    }\n\n    return child;\n\n};\n\n/**\n* Removes all children from this container that are within the begin and end indexes.\n*\n* @method removeChildren\n* @param beginIndex {Number} The beginning position. Default value is 0.\n* @param endIndex {Number} The ending position. Default value is size of the container.\n*/\nPIXI.DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) {\n\n    if (beginIndex === undefined) { beginIndex = 0; }\n    if (endIndex === undefined) { endIndex = this.children.length; }\n\n    var range = endIndex - beginIndex;\n\n    if (range > 0 && range <= endIndex)\n    {\n        var removed = this.children.splice(begin, range);\n\n        for (var i = 0; i < removed.length; i++)\n        {\n            var child = removed[i];\n            child.parent = undefined;\n        }\n\n        return removed;\n    }\n    else if (range === 0 && this.children.length === 0)\n    {\n        return [];\n    }\n    else\n    {\n        throw new Error( 'removeChildren: Range Error, numeric values are outside the acceptable range' );\n    }\n\n};\n\n/*\n * Updates the transform on all children of this container for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.DisplayObjectContainer.prototype.updateTransform = function () {\n\n    if (!this.visible)\n    {\n        return;\n    }\n\n    this.displayObjectUpdateTransform();\n\n    if (this._cacheAsBitmap)\n    {\n        return;\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n};\n\n// performance increase to avoid using call.. (10x faster)\nPIXI.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = PIXI.DisplayObjectContainer.prototype.updateTransform;\n\n/**\n * Retrieves the global bounds of the displayObjectContainer as a rectangle. The bounds calculation takes all visible children into consideration.\n *\n * @method getBounds\n * @param {PIXI.DisplayObject|PIXI.Matrix} [targetCoordinateSpace] Returns a rectangle that defines the area of the display object relative to the coordinate system of the targetCoordinateSpace object.\n * @return {Rectangle} The rectangular bounding area\n */\nPIXI.DisplayObjectContainer.prototype.getBounds = function (targetCoordinateSpace) {\n\n    var isTargetCoordinateSpaceDisplayObject = (targetCoordinateSpace && targetCoordinateSpace instanceof PIXI.DisplayObject);\n    var isTargetCoordinateSpaceThisOrParent = true;\n\n    if (!isTargetCoordinateSpaceDisplayObject) \n\t{\n        targetCoordinateSpace = this;\n    } \n\telse if (targetCoordinateSpace instanceof PIXI.DisplayObjectContainer) \n\t{\n        isTargetCoordinateSpaceThisOrParent = targetCoordinateSpace.contains(this);\n    } \n\telse \n\t{\n        isTargetCoordinateSpaceThisOrParent = false;\n    }\n\n    var i;\n\n    if (isTargetCoordinateSpaceDisplayObject)\n    {\n        var matrixCache = targetCoordinateSpace.worldTransform;\n\n        targetCoordinateSpace.worldTransform = PIXI.identityMatrix;\n\n        for (i = 0; i < targetCoordinateSpace.children.length; i++) \n\t\t{\n            targetCoordinateSpace.children[i].updateTransform();\n        }\n    }\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var childBounds;\n    var childMaxX;\n    var childMaxY;\n\n    var childVisible = false;\n\n    for (i = 0; i < this.children.length; i++)\n    {\n        var child = this.children[i];\n\n        if (!child.visible)\n        {\n            continue;\n        }\n\n        childVisible = true;\n\n        childBounds = this.children[i].getBounds();\n\n        minX = (minX < childBounds.x) ? minX : childBounds.x;\n        minY = (minY < childBounds.y) ? minY : childBounds.y;\n\n        childMaxX = childBounds.width + childBounds.x;\n        childMaxY = childBounds.height + childBounds.y;\n\n        maxX = (maxX > childMaxX) ? maxX : childMaxX;\n        maxY = (maxY > childMaxY) ? maxY : childMaxY;\n    }\n\n    var bounds = this._bounds;\n\n    if (!childVisible) \n\t{\n        bounds = new PIXI.Rectangle();\n\n        var w0 = bounds.x;\n        var w1 = bounds.width + bounds.x;\n\n        var h0 = bounds.y;\n        var h1 = bounds.height + bounds.y;\n\n        var worldTransform = this.worldTransform;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var x1 = a * w1 + c * h1 + tx;\n        var y1 = d * h1 + b * w1 + ty;\n\n        var x2 = a * w0 + c * h1 + tx;\n        var y2 = d * h1 + b * w0 + ty;\n\n        var x3 = a * w0 + c * h0 + tx;\n        var y3 = d * h0 + b * w0 + ty;\n\n        var x4 = a * w1 + c * h0 + tx;\n        var y4 = d * h0 + b * w1 + ty;\n\n        maxX = x1;\n        maxY = y1;\n\n        minX = x1;\n        minY = y1;\n\n        minX = x2 < minX ? x2 : minX;\n        minX = x3 < minX ? x3 : minX;\n        minX = x4 < minX ? x4 : minX;\n\n        minY = y2 < minY ? y2 : minY;\n        minY = y3 < minY ? y3 : minY;\n        minY = y4 < minY ? y4 : minY;\n\n        maxX = x2 > maxX ? x2 : maxX;\n        maxX = x3 > maxX ? x3 : maxX;\n        maxX = x4 > maxX ? x4 : maxX;\n\n        maxY = y2 > maxY ? y2 : maxY;\n        maxY = y3 > maxY ? y3 : maxY;\n        maxY = y4 > maxY ? y4 : maxY;\n    }\n\n    bounds.x = minX;\n    bounds.y = minY;\n    bounds.width = maxX - minX;\n    bounds.height = maxY - minY;\n\n    if (isTargetCoordinateSpaceDisplayObject) \n\t{\n        targetCoordinateSpace.worldTransform = matrixCache;\n\n        for (i = 0; i < targetCoordinateSpace.children.length; i++) \n\t\t{\n            targetCoordinateSpace.children[i].updateTransform();\n        }\n    }\n\n    if (!isTargetCoordinateSpaceThisOrParent) \n\t{\n        var targetCoordinateSpaceBounds = targetCoordinateSpace.getBounds();\n\n        bounds.x -= targetCoordinateSpaceBounds.x;\n        bounds.y -= targetCoordinateSpaceBounds.y;\n    }\n\n    return bounds;\n\n};\n\n/**\n * Retrieves the non-global local bounds of the displayObjectContainer as a rectangle without any transformations. The calculation takes all visible children into consideration.\n *\n * @method getLocalBounds\n * @return {Rectangle} The rectangular bounding area\n */\nPIXI.DisplayObjectContainer.prototype.getLocalBounds = function () {\n\n    return this.getBounds(this);\n\n};\n\n/**\n* Determines whether the specified display object is a child of the DisplayObjectContainer instance or the instance itself.\n*\n* @method contains\n* @param {DisplayObject} child\n* @returns {boolean}\n*/\nPIXI.DisplayObjectContainer.prototype.contains = function (child) {\n\n    if (!child)\n    {\n        return false;\n    }\n    else if (child === this) \n\t{\n        return true;\n    }\n    else \n\t{\n        return this.contains(child.parent);\n    }\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderWebGL = function (renderSession) {\n\n    if (!this.visible || this.alpha <= 0)\n    {\n        return;\n    }\n    \n    if (this._cacheAsBitmap)\n    {\n        this._renderCachedSprite(renderSession);\n        return;\n    }\n    \n    var i;\n\n    if (this._mask || this._filters)\n    {\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (this._filters)\n        {\n            renderSession.spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        if (this._mask)\n        {\n            renderSession.spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            renderSession.spriteBatch.start();\n        }\n\n        // simple render children!\n        for (i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        renderSession.spriteBatch.stop();\n\n        if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);\n        if (this._filters) renderSession.filterManager.popFilter();\n        \n        renderSession.spriteBatch.start();\n    }\n    else\n    {\n        // simple render children!\n        for (i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n    }\n\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderCanvas = function (renderSession) {\n\n    if (this.visible === false || this.alpha === 0)\n    {\n        return;\n    }\n\n    if (this._cacheAsBitmap)\n    {\n        this._renderCachedSprite(renderSession);\n        return;\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession);\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i]._renderCanvas(renderSession);\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession);\n    }\n\n};\n\n/**\n * The width of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', {\n\n    get: function() {\n        return this.getLocalBounds().width * this.scale.x;\n    },\n\n    set: function(value) {\n        \n        var width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n        \n        this._width = value;\n    }\n});\n\n/**\n * The height of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', {\n\n    get: function() {\n        return this.getLocalBounds().height * this.scale.y;\n    },\n\n    set: function(value) {\n\n        var height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n\n});\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * @class Sprite\n * @extends DisplayObjectContainer\n * @constructor\n * @param texture {Texture} The texture for this sprite\n */\nPIXI.Sprite = function (texture) {\n\n    PIXI.DisplayObjectContainer.call(this);\n\n    /**\n     * The anchor sets the origin point of the texture.\n     * The default is 0,0 this means the texture's origin is the top left\n     * Setting than anchor to 0.5,0.5 means the textures origin is centered\n     * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner\n     *\n     * @property anchor\n     * @type Point\n     */\n    this.anchor = new PIXI.Point();\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = texture || PIXI.Texture.emptyTexture;\n\n    /**\n     * The width of the sprite (this is initially set by the texture)\n     *\n     * @property _width\n     * @type Number\n     * @private\n     */\n    this._width = 0;\n\n    /**\n     * The height of the sprite (this is initially set by the texture)\n     *\n     * @property _height\n     * @type Number\n     * @private\n     */\n    this._height = 0;\n\n    /**\n     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n\n    /**\n     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @property cachedTint\n     * @private\n     * @type Number\n     * @default -1\n     */\n    this.cachedTint = -1;\n\n    /**\n     * A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)\n     *\n     * @property tintedTexture\n     * @type Canvas\n     * @default null\n     */\n    this.tintedTexture = null;\n\n    /**\n     * The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n     *\n     * Warning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n\n    /**\n     * The shader that will be used to render this Sprite.\n     * Set to null to remove a current shader.\n     *\n     * @property shader\n     * @type AbstractFilter\n     * @default null\n     */\n    this.shader = null;\n\n    /**\n    * Controls if this Sprite is processed by the core Phaser game loops and Group loops.\n    *\n    * @property exists\n    * @type Boolean\n    * @default true\n    */\n    this.exists = true;\n\n    if (this.texture.baseTexture.hasLoaded)\n    {\n        this.onTextureUpdate();\n    }\n\n    this.renderable = true;\n\n};\n\n// constructor\nPIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.Sprite.prototype.constructor = PIXI.Sprite;\n\n/**\n * The width of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'width', {\n\n    get: function() {\n        return this.scale.x * this.texture.frame.width;\n    },\n\n    set: function(value) {\n        this.scale.x = value / this.texture.frame.width;\n        this._width = value;\n    }\n\n});\n\n/**\n * The height of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'height', {\n\n    get: function() {\n        return  this.scale.y * this.texture.frame.height;\n    },\n\n    set: function(value) {\n        this.scale.y = value / this.texture.frame.height;\n        this._height = value;\n    }\n\n});\n\n/**\n * Sets the texture of the sprite. Be warned that this doesn't remove or destroy the previous\n * texture this Sprite was using.\n *\n * @method setTexture\n * @param texture {Texture} The PIXI texture that is displayed by the sprite\n * @param [destroy=false] {boolean} Call Texture.destroy on the current texture before replacing it with the new one?\n */\nPIXI.Sprite.prototype.setTexture = function(texture, destroyBase)\n{\n    if (destroyBase !== undefined)\n    {\n        this.texture.baseTexture.destroy();\n    }\n\n    //  Over-ridden by loadTexture as needed\n    this.texture.baseTexture.skipRender = false;\n    this.texture = texture;\n    this.texture.valid = true;\n    this.cachedTint = -1;\n};\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.Sprite.prototype.onTextureUpdate = function()\n{\n    // so if _width is 0 then width was not set..\n    if (this._width) this.scale.x = this._width / this.texture.frame.width;\n    if (this._height) this.scale.y = this._height / this.texture.frame.height;\n};\n\n/**\n* Returns the bounds of the Sprite as a rectangle.\n* The bounds calculation takes the worldTransform into account.\n*\n* It is important to note that the transform is not updated when you call this method.\n* So if this Sprite is the child of a Display Object which has had its transform\n* updated since the last render pass, those changes will not yet have been applied\n* to this Sprites worldTransform. If you need to ensure that all parent transforms\n* are factored into this getBounds operation then you should call `updateTransform`\n* on the root most object in this Sprites display list first.\n*\n* @method getBounds\n* @param matrix {Matrix} the transformation matrix of the sprite\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Sprite.prototype.getBounds = function(matrix)\n{\n    var width = this.texture.frame.width;\n    var height = this.texture.frame.height;\n\n    var w0 = width * (1-this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1-this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = matrix || this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    if (b === 0 && c === 0)\n    {\n        // scale may be negative!\n        if (a < 0)\n        {\n            a *= -1;\n            var temp = w0;\n            w0 = -w1;\n            w1 = -temp; \n        }\n\n        if (d < 0)\n        {\n            d *= -1;\n            var temp = h0;\n            h0 = -h1;\n            h1 = -temp; \n        }\n\n        // this means there is no rotation going on right? RIGHT?\n        // if thats the case then we can avoid checking the bound values! yay         \n        minX = a * w1 + tx;\n        maxX = a * w0 + tx;\n        minY = d * h1 + ty;\n        maxY = d * h0 + ty;\n    }\n    else\n    {\n        var x1 = a * w1 + c * h1 + tx;\n        var y1 = d * h1 + b * w1 + ty;\n\n        var x2 = a * w0 + c * h1 + tx;\n        var y2 = d * h1 + b * w0 + ty;\n\n        var x3 = a * w0 + c * h0 + tx;\n        var y3 = d * h0 + b * w0 + ty;\n\n        var x4 =  a * w1 + c * h0 + tx;\n        var y4 =  d * h0 + b * w1 + ty;\n\n        minX = x1 < minX ? x1 : minX;\n        minX = x2 < minX ? x2 : minX;\n        minX = x3 < minX ? x3 : minX;\n        minX = x4 < minX ? x4 : minX;\n\n        minY = y1 < minY ? y1 : minY;\n        minY = y2 < minY ? y2 : minY;\n        minY = y3 < minY ? y3 : minY;\n        minY = y4 < minY ? y4 : minY;\n\n        maxX = x1 > maxX ? x1 : maxX;\n        maxX = x2 > maxX ? x2 : maxX;\n        maxX = x3 > maxX ? x3 : maxX;\n        maxX = x4 > maxX ? x4 : maxX;\n\n        maxY = y1 > maxY ? y1 : maxY;\n        maxY = y2 > maxY ? y2 : maxY;\n        maxY = y3 > maxY ? y3 : maxY;\n        maxY = y4 > maxY ? y4 : maxY;\n    }\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n/**\n * Retrieves the non-global local bounds of the Sprite as a rectangle. The calculation takes all visible children into consideration.\n *\n * @method getLocalBounds\n * @return {Rectangle} The rectangular bounding area\n */\nPIXI.Sprite.prototype.getLocalBounds = function () {\n\n    var matrixCache = this.worldTransform;\n\n    this.worldTransform = PIXI.identityMatrix;\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    var bounds = this.getBounds();\n\n    this.worldTransform = matrixCache;\n\n    for (i = 0; i < this.children.length; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    return bounds;\n\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession}\n* @param {Matrix} [matrix] - Optional matrix. If provided the Display Object will be rendered using this matrix, otherwise it will use its worldTransform.\n* @private\n*/\nPIXI.Sprite.prototype._renderWebGL = function(renderSession, matrix)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.alpha <= 0 || !this.renderable) return;\n\n    //  They provided an alternative rendering matrix, so use it\n    var wt = this.worldTransform;\n\n    if (matrix)\n    {\n        wt = matrix;\n    }\n\n    //  A quick check to see if this element has a mask or a filter.\n    if (this._mask || this._filters)\n    {\n        var spriteBatch = renderSession.spriteBatch;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (this._filters)\n        {\n            spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        if (this._mask)\n        {\n            spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            spriteBatch.start();\n        }\n\n        // add this sprite to the batch\n        spriteBatch.render(this);\n\n        // now loop through the children and make sure they get rendered\n        for (var i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        // time to stop the sprite batch as either a mask element or a filter draw will happen next\n        spriteBatch.stop();\n\n        if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);\n        if (this._filters) renderSession.filterManager.popFilter();\n\n        spriteBatch.start();\n    }\n    else\n    {\n        renderSession.spriteBatch.render(this);\n\n        //  Render children!\n        for (var i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderWebGL(renderSession, wt);\n        }\n\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession}\n* @param {Matrix} [matrix] - Optional matrix. If provided the Display Object will be rendered using this matrix, otherwise it will use its worldTransform.\n* @private\n*/\nPIXI.Sprite.prototype._renderCanvas = function(renderSession, matrix)\n{\n    // If the sprite is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.alpha === 0 || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)\n    {\n        return;\n    }\n\n    var wt = this.worldTransform;\n\n    //  If they provided an alternative rendering matrix then use it\n    if (matrix)\n    {\n        wt = matrix;\n    }\n\n    if (this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession);\n    }\n\n    //  Ignore null sources\n    if (this.texture.valid)\n    {\n        var resolution = this.texture.baseTexture.resolution / renderSession.resolution;\n\n        renderSession.context.globalAlpha = this.worldAlpha;\n\n        //  If smoothingEnabled is supported and we need to change the smoothing property for this texture\n        if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode)\n        {\n            renderSession.scaleMode = this.texture.baseTexture.scaleMode;\n            renderSession.context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR);\n        }\n\n        //  If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions\n        var dx = (this.texture.trim) ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;\n        var dy = (this.texture.trim) ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;\n\n        var tx = (wt.tx * renderSession.resolution) + renderSession.shakeX;\n        var ty = (wt.ty * renderSession.resolution) + renderSession.shakeY;\n\n        //  Allow for pixel rounding\n        if (renderSession.roundPixels)\n        {\n            renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, tx | 0, ty | 0);\n            dx |= 0;\n            dy |= 0;\n        }\n        else\n        {\n            renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, tx, ty);\n        }\n\n        var cw = this.texture.crop.width;\n        var ch = this.texture.crop.height;\n\n        dx /= resolution;\n        dy /= resolution;\n\n        if (this.tint !== 0xFFFFFF)\n        {\n            if (this.texture.requiresReTint || this.cachedTint !== this.tint)\n            {\n                this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);\n\n                this.cachedTint = this.tint;\n                this.texture.requiresReTint = false;\n            }\n\n            renderSession.context.drawImage(this.tintedTexture, 0, 0, cw, ch, dx, dy, cw / resolution, ch / resolution);\n        }\n        else\n        {\n            var cx = this.texture.crop.x;\n            var cy = this.texture.crop.y;\n            renderSession.context.drawImage(this.texture.baseTexture.source, cx, cy, cw, ch, dx, dy, cw / resolution, ch / resolution);\n        }\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i]._renderCanvas(renderSession);\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession);\n    }\n\n};\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * The SpriteBatch class is a really fast version of the DisplayObjectContainer \n * built solely for speed, so use when you need a lot of sprites or particles.\n * And it's extremely easy to use : \n\n    var container = new PIXI.SpriteBatch();\n \n    for(var i  = 0; i < 100; i++)\n    {\n        var sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n        container.addChild(sprite);\n    }\n * And here you have a hundred sprites that will be renderer at the speed of light\n *\n * @class SpriteBatch\n * @constructor\n * @param texture {Texture}\n */\nPIXI.SpriteBatch = function(texture)\n{\n    PIXI.DisplayObjectContainer.call( this);\n\n    this.textureThing = texture;\n\n    this.ready = false;\n};\n\nPIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.SpriteBatch.prototype.constructor = PIXI.SpriteBatch;\n\n/*\n * Initialises the spriteBatch\n *\n * @method initWebGL\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.SpriteBatch.prototype.initWebGL = function(gl)\n{\n    // TODO only one needed for the whole engine really?\n    this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);\n\n    this.ready = true;\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.SpriteBatch.prototype.updateTransform = function()\n{\n    // TODO don't need to!\n    this.displayObjectUpdateTransform();\n    //  PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.SpriteBatch.prototype._renderWebGL = function(renderSession)\n{\n    if (!this.visible || this.alpha <= 0 || !this.children.length) return;\n\n    if (!this.ready)\n    {\n        this.initWebGL(renderSession.gl);\n    }\n    \n    if (this.fastSpriteBatch.gl !== renderSession.gl)\n    {\n        this.fastSpriteBatch.setContext(renderSession.gl);\n    }\n\n    renderSession.spriteBatch.stop();\n    \n    renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader);\n    \n    this.fastSpriteBatch.begin(this, renderSession);\n    this.fastSpriteBatch.render(this);\n\n    renderSession.spriteBatch.start();\n \n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.SpriteBatch.prototype._renderCanvas = function(renderSession)\n{\n    if (!this.visible || this.alpha <= 0 || !this.children.length) return;\n    \n    var context = renderSession.context;\n\n    context.globalAlpha = this.worldAlpha;\n\n    this.displayObjectUpdateTransform();\n\n    var transform = this.worldTransform;\n       \n    var isRotated = true;\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        var child = this.children[i];\n\n        if (!child.visible) continue;\n\n        var texture = child.texture;\n        var frame = texture.frame;\n\n        context.globalAlpha = this.worldAlpha * child.alpha;\n\n        if (child.rotation % (Math.PI * 2) === 0)\n        {\n            if (isRotated)\n            {\n                context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n                isRotated = false;\n            }\n\n            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n            context.drawImage(texture.baseTexture.source,\n                                 frame.x,\n                                 frame.y,\n                                 frame.width,\n                                 frame.height,\n                                 ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x + 0.5 + renderSession.shakeX) | 0,\n                                 ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y + 0.5 + renderSession.shakeY) | 0,\n                                 frame.width * child.scale.x,\n                                 frame.height * child.scale.y);\n        }\n        else\n        {\n            if (!isRotated) isRotated = true;\n    \n            child.displayObjectUpdateTransform();\n           \n            var childTransform = child.worldTransform;\n            var tx = (childTransform.tx * renderSession.resolution) + renderSession.shakeX;\n            var ty = (childTransform.ty * renderSession.resolution) + renderSession.shakeY;\n\n            // allow for trimming\n           \n            if (renderSession.roundPixels)\n            {\n                context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, tx | 0, ty | 0);\n            }\n            else\n            {\n                context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, tx, ty);\n            }\n\n            context.drawImage(texture.baseTexture.source,\n                                 frame.x,\n                                 frame.y,\n                                 frame.width,\n                                 frame.height,\n                                 ((child.anchor.x) * (-frame.width) + 0.5) | 0,\n                                 ((child.anchor.y) * (-frame.height) + 0.5) | 0,\n                                 frame.width,\n                                 frame.height);\n        }\n    }\n\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n \n/**\n * Converts a hex color number to an [R, G, B] array\n *\n * @method hex2rgb\n * @param hex {Number}\n */\nPIXI.hex2rgb = function(hex) {\n    return [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255];\n};\n\n/**\n * Converts a color as an [R, G, B] array to a hex number\n *\n * @method rgb2hex\n * @param rgb {Array}\n */\nPIXI.rgb2hex = function(rgb) {\n    return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);\n};\n\n/**\n * Checks whether the Canvas BlendModes are supported by the current browser for drawImage\n *\n * @method canUseNewCanvasBlendModes\n * @return {Boolean} whether they are supported\n */\nPIXI.canUseNewCanvasBlendModes = function()\n{\n    if (document === undefined) return false;\n\n    var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';\n    var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';\n\n    var magenta = new Image();\n    magenta.src = pngHead + 'AP804Oa6' + pngEnd;\n\n    var yellow = new Image();\n    yellow.src = pngHead + '/wCKxvRF' + pngEnd;\n\n    var canvas = PIXI.CanvasPool.create(this, 6, 1);\n    var context = canvas.getContext('2d');\n    context.globalCompositeOperation = 'multiply';\n    context.drawImage(magenta, 0, 0);\n    context.drawImage(yellow, 2, 0);\n\n    if (!context.getImageData(2,0,1,1))\n    {\n        return false;\n    }\n\n    var data = context.getImageData(2,0,1,1).data;\n\n    PIXI.CanvasPool.remove(this);\n\n    return (data[0] === 255 && data[1] === 0 && data[2] === 0);\n\n};\n\n/**\n * Given a number, this function returns the closest number that is a power of two\n * this function is taken from Starling Framework as its pretty neat ;)\n *\n * @method getNextPowerOfTwo\n * @param number {Number}\n * @return {Number} the closest number that is a power of two\n */\nPIXI.getNextPowerOfTwo = function(number)\n{\n    if (number > 0 && (number & (number - 1)) === 0) // see: http://goo.gl/D9kPj\n        return number;\n    else\n    {\n        var result = 1;\n        while (result < number) result <<= 1;\n        return result;\n    }\n};\n\n/**\n * checks if the given width and height make a power of two texture\n * @method isPowerOfTwo\n * @param width {Number}\n * @param height {Number}\n * @return {Boolean} \n */\nPIXI.isPowerOfTwo = function(width, height)\n{\n    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The CanvasPool is a global static object that allows Pixi and Phaser to pool canvas DOM elements.\n*\n* @class CanvasPool\n* @static\n*/\nPIXI.CanvasPool = {\n\n    /**\n    * Creates a new Canvas DOM element, or pulls one from the pool if free.\n    * \n    * @method create\n    * @static\n    * @param parent {any} The parent of the canvas element.\n    * @param width {number} The width of the canvas element.\n    * @param height {number} The height of the canvas element.\n    * @return {HTMLCanvasElement} The canvas element.\n    */\n    create: function (parent, width, height) {\n\n        var idx = PIXI.CanvasPool.getFirst();\n        var canvas;\n\n        if (idx === -1)\n        {\n            var container = {\n                parent: parent,\n                canvas: document.createElement('canvas')\n            }\n\n            PIXI.CanvasPool.pool.push(container);\n\n            canvas = container.canvas;\n        }\n        else\n        {\n            PIXI.CanvasPool.pool[idx].parent = parent;\n\n            canvas = PIXI.CanvasPool.pool[idx].canvas;\n        }\n\n        if (width !== undefined)\n        {\n            canvas.width = width;\n            canvas.height = height;\n        }\n\n        return canvas;\n\n    },\n\n    /**\n    * Gets the first free canvas index from the pool.\n    * \n    * @method getFirst\n    * @static\n    * @return {number}\n    */\n    getFirst: function () {\n\n        var pool = PIXI.CanvasPool.pool;\n\n        for (var i = 0; i < pool.length; i++)\n        {\n            if (!pool[i].parent)\n            {\n                return i;\n            }\n        }\n\n        return -1;\n\n    },\n\n    /**\n    * Removes the parent from a canvas element from the pool, freeing it up for re-use.\n    * \n    * @method remove\n    * @param parent {any} The parent of the canvas element.\n    * @static\n    */\n    remove: function (parent) {\n\n        var pool = PIXI.CanvasPool.pool;\n\n        for (var i = 0; i < pool.length; i++)\n        {\n            if (pool[i].parent === parent)\n            {\n                pool[i].parent = null;\n                pool[i].canvas.width = 1;\n                pool[i].canvas.height = 1;\n            }\n        }\n\n    },\n\n    /**\n    * Removes the parent from a canvas element from the pool, freeing it up for re-use.\n    * \n    * @method removeByCanvas\n    * @param canvas {HTMLCanvasElement} The canvas element to remove\n    * @static\n    */\n    removeByCanvas: function (canvas) {\n\n        var pool = PIXI.CanvasPool.pool;\n\n        for (var i = 0; i < pool.length; i++)\n        {\n            if (pool[i].canvas === canvas)\n            {\n                pool[i].parent = null;\n                pool[i].canvas.width = 1;\n                pool[i].canvas.height = 1;\n            }\n        }\n\n    },\n\n    /**\n    * Gets the total number of used canvas elements in the pool.\n    * \n    * @method getTotal\n    * @static\n    * @return {number} The number of in-use (parented) canvas elements in the pool.\n    */\n    getTotal: function () {\n\n        var pool = PIXI.CanvasPool.pool;\n        var c = 0;\n\n        for (var i = 0; i < pool.length; i++)\n        {\n            if (pool[i].parent)\n            {\n                c++;\n            }\n        }\n\n        return c;\n\n    },\n\n    /**\n    * Gets the total number of free canvas elements in the pool.\n    * \n    * @method getFree\n    * @static\n    * @return {number} The number of free (un-parented) canvas elements in the pool.\n    */\n    getFree: function () {\n\n        var pool = PIXI.CanvasPool.pool;\n        var c = 0;\n\n        for (var i = 0; i < pool.length; i++)\n        {\n            if (!pool[i].parent)\n            {\n                c++;\n            }\n        }\n\n        return c;\n\n    }\n\n};\n\n/**\n * The pool into which the canvas dom elements are placed.\n *\n * @property pool\n * @type Array\n * @static\n */\nPIXI.CanvasPool.pool = [];\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @method initDefaultShaders\n* @static\n* @private\n*/\nPIXI.initDefaultShaders = function()\n{\n};\n\n/**\n* @method CompileVertexShader\n* @static\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param shaderSrc {Array}\n* @return {Any}\n*/\nPIXI.CompileVertexShader = function(gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);\n};\n\n/**\n* @method CompileFragmentShader\n* @static\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param shaderSrc {Array}\n* @return {Any}\n*/\nPIXI.CompileFragmentShader = function(gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);\n};\n\n/**\n* @method _CompileShader\n* @static\n* @private\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param shaderSrc {Array}\n* @param shaderType {Number}\n* @return {Any}\n*/\nPIXI._CompileShader = function(gl, shaderSrc, shaderType)\n{\n    var src = shaderSrc;\n\n    if (Array.isArray(shaderSrc))\n    {\n        src = shaderSrc.join(\"\\n\");\n    }\n\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n    {\n        window.console.log(gl.getShaderInfoLog(shader));\n        return null;\n    }\n\n    return shader;\n};\n\n/**\n* @method compileProgram\n* @static\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param vertexSrc {Array}\n* @param fragmentSrc {Array}\n* @return {Any}\n*/\nPIXI.compileProgram = function(gl, vertexSrc, fragmentSrc)\n{\n    var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);\n    var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);\n\n    var shaderProgram = gl.createProgram();\n\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))\n    {\n        window.console.log(gl.getProgramInfoLog(shaderProgram));\n        window.console.log(\"Could not initialise shaders\");\n    }\n\n    return shaderProgram;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * @author Richard Davey http://www.photonstorm.com @photonstorm\n */\n\n/**\n* @class PixiShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PixiShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ];\n\n    /**\n     * A local texture counter for multi-texture shaders.\n     * @property textureCount\n     * @type Number\n     */\n    this.textureCount = 0;\n\n    /**\n     * A local flag\n     * @property firstRun\n     * @type Boolean\n     * @private\n     */\n    this.firstRun = true;\n\n    /**\n     * A dirty flag\n     * @property dirty\n     * @type Boolean\n     */\n    this.dirty = true;\n\n    /**\n     * Uniform attributes cache.\n     * @property attributes\n     * @type Array\n     * @private\n     */\n    this.attributes = [];\n\n    this.init();\n};\n\nPIXI.PixiShader.prototype.constructor = PIXI.PixiShader;\n\n/**\n* Initialises the shader.\n*\n* @method init\n*/\nPIXI.PixiShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);\n\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its something to do with the current state of the gl context.\n    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];\n\n    // End worst hack eva //\n\n    // add those custom shaders!\n    for (var key in this.uniforms)\n    {\n        // get the uniform locations..\n        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);\n    }\n\n    this.initUniforms();\n\n    this.program = program;\n};\n\n/**\n* Initialises the shader uniform values.\n*\n* Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\n* http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n*\n* @method initUniforms\n*/\nPIXI.PixiShader.prototype.initUniforms = function()\n{\n    this.textureCount = 1;\n    var gl = this.gl;\n    var uniform;\n\n    for (var key in this.uniforms)\n    {\n        uniform = this.uniforms[key];\n\n        var type = uniform.type;\n\n        if (type === 'sampler2D')\n        {\n            uniform._init = false;\n\n            if (uniform.value !== null)\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n        else if (type === 'mat2' || type === 'mat3' || type === 'mat4')\n        {\n            //  These require special handling\n            uniform.glMatrix = true;\n            uniform.glValueLength = 1;\n\n            if (type === 'mat2')\n            {\n                uniform.glFunc = gl.uniformMatrix2fv;\n            }\n            else if (type === 'mat3')\n            {\n                uniform.glFunc = gl.uniformMatrix3fv;\n            }\n            else if (type === 'mat4')\n            {\n                uniform.glFunc = gl.uniformMatrix4fv;\n            }\n        }\n        else\n        {\n            //  GL function reference\n            uniform.glFunc = gl['uniform' + type];\n\n            if (type === '2f' || type === '2i')\n            {\n                uniform.glValueLength = 2;\n            }\n            else if (type === '3f' || type === '3i')\n            {\n                uniform.glValueLength = 3;\n            }\n            else if (type === '4f' || type === '4i')\n            {\n                uniform.glValueLength = 4;\n            }\n            else\n            {\n                uniform.glValueLength = 1;\n            }\n        }\n    }\n\n};\n\n/**\n* Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)\n*\n* @method initSampler2D\n*/\nPIXI.PixiShader.prototype.initSampler2D = function(uniform)\n{\n    if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);\n\n    //  Extended texture data\n    if (uniform.textureData)\n    {\n        var data = uniform.textureData;\n\n        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);\n        // GLTextureLinear = mag/min linear, wrap clamp\n        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat\n        // GLTextureNearest = mag/min nearest, wrap clamp\n        // AudioTexture = whatever + luminance + width 512, height 2, border 0\n        // KeyTexture = whatever + luminance + width 256, height 2, border 0\n\n        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\n        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\n\n        var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR;\n        var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR;\n        var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE;\n        var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE;\n        var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA;\n\n        if (data.repeat)\n        {\n            wrapS = gl.REPEAT;\n            wrapT = gl.REPEAT;\n        }\n\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\n\n        if (data.width)\n        {\n            var width = (data.width) ? data.width : 512;\n            var height = (data.height) ? data.height : 2;\n            var border = (data.border) ? data.border : 0;\n\n            // void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\n        }\n        else\n        {\n            //  void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);\n        }\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n    }\n\n    gl.uniform1i(uniform.uniformLocation, this.textureCount);\n\n    uniform._init = true;\n\n    this.textureCount++;\n\n};\n\n/**\n* Updates the shader uniform values.\n*\n* @method syncUniforms\n*/\nPIXI.PixiShader.prototype.syncUniforms = function()\n{\n    this.textureCount = 1;\n    var uniform;\n    var gl = this.gl;\n\n    //  This would probably be faster in an array and it would guarantee key order\n    for (var key in this.uniforms)\n    {\n        uniform = this.uniforms[key];\n\n        if (uniform.glValueLength === 1)\n        {\n            if (uniform.glMatrix === true)\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);\n            }\n            else\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);\n            }\n        }\n        else if (uniform.glValueLength === 2)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);\n        }\n        else if (uniform.glValueLength === 3)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);\n        }\n        else if (uniform.glValueLength === 4)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);\n        }\n        else if (uniform.type === 'sampler2D')\n        {\n            if (uniform._init)\n            {\n                gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n\n                if(uniform.value.baseTexture._dirty[gl.id])\n                {\n                    PIXI.instances[gl.id].updateTexture(uniform.value.baseTexture);\n                }\n                else\n                {\n                    // bind the current texture\n                    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);\n                }\n\n                //  gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture( uniform.value.baseTexture, gl));\n                gl.uniform1i(uniform.uniformLocation, this.textureCount);\n                this.textureCount++;\n            }\n            else\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n    }\n\n};\n\n/**\n* Destroys the shader.\n*\n* @method destroy\n*/\nPIXI.PixiShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n* The Default Vertex shader source.\n*\n* @property defaultVertexSrc\n* @type String\n*/\nPIXI.PixiShader.defaultVertexSrc = [\n    'attribute vec2 aVertexPosition;',\n    'attribute vec2 aTextureCoord;',\n    'attribute vec4 aColor;',\n\n    'uniform vec2 projectionVector;',\n    'uniform vec2 offsetVector;',\n\n    'varying vec2 vTextureCoord;',\n    'varying vec4 vColor;',\n\n    'const vec2 center = vec2(-1.0, 1.0);',\n\n    'void main(void) {',\n    '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);',\n    '   vTextureCoord = aTextureCoord;',\n    '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',\n    '}'\n];\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PixiFastShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PixiFastShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n    \n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aPositionCoord;',\n        'attribute vec2 aScale;',\n        'attribute float aRotation;',\n        'attribute vec2 aTextureCoord;',\n        'attribute float aColor;',\n\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform mat3 uMatrix;',\n\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n\n        'const vec2 center = vec2(-1.0, 1.0);',\n\n        'void main(void) {',\n        '   vec2 v;',\n        '   vec2 sv = aVertexPosition * aScale;',\n        '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);',\n        '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);',\n        '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;',\n        '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n      //  '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',\n        '   vColor = aColor;',\n        '}'\n    ];\n\n    /**\n     * A local texture counter for multi-texture shaders.\n     * @property textureCount\n     * @type Number\n     */\n    this.textureCount = 0;\n    \n    this.init();\n};\n\nPIXI.PixiFastShader.prototype.constructor = PIXI.PixiFastShader;\n\n/**\n* Initialises the shader.\n* \n* @method init\n*/\nPIXI.PixiFastShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    \n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n    this.uMatrix = gl.getUniformLocation(program, 'uMatrix');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord');\n\n    this.aScale = gl.getAttribLocation(program, 'aScale');\n    this.aRotation = gl.getAttribLocation(program, 'aRotation');\n\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n   \n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its somthing to do with the current state of the gl context.\n    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [this.aVertexPosition, this.aPositionCoord,  this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];\n    \n    // End worst hack eva //\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n* \n* @method destroy\n*/\nPIXI.PixiFastShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class StripShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.StripShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n    \n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n     //   'varying float vColor;',\n        'uniform float alpha;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;',\n      //  '   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);',//gl_FragColor * alpha;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc  = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aTextureCoord;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n      //  'uniform float alpha;',\n       // 'uniform vec3 tint;',\n        'varying vec2 vTextureCoord;',\n      //  'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n       // '   vColor = aColor * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\nPIXI.StripShader.prototype.constructor = PIXI.StripShader;\n\n/**\n* Initialises the shader.\n* \n* @method init\n*/\nPIXI.StripShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n    //this.dimensions = gl.getUniformLocation(this.program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n\n    this.attributes = [this.aVertexPosition, this.aTextureCoord];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n* \n* @method destroy\n*/\nPIXI.StripShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attribute = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PrimitiveShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PrimitiveShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n \n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   gl_FragColor = vColor;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc  = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec4 aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform float alpha;',\n        'uniform float flipY;',\n        'uniform vec3 tint;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);',\n        '   vColor = aColor * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\nPIXI.PrimitiveShader.prototype.constructor = PIXI.PrimitiveShader;\n\n/**\n* Initialises the shader.\n* \n* @method init\n*/\nPIXI.PrimitiveShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.tintColor = gl.getUniformLocation(program, 'tint');\n    this.flipY = gl.getUniformLocation(program, 'flipY');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    this.attributes = [this.aVertexPosition, this.colorAttribute];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n* \n* @method destroy\n*/\nPIXI.PrimitiveShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class ComplexPrimitiveShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.ComplexPrimitiveShader = function(gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = PIXI._UID++;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n\n        'precision mediump float;',\n\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   gl_FragColor = vColor;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc  = [\n        'attribute vec2 aVertexPosition;',\n        //'attribute vec4 aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        \n        'uniform vec3 tint;',\n        'uniform float alpha;',\n        'uniform vec3 color;',\n        'uniform float flipY;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);',\n        '   vColor = vec4(color * alpha * tint, alpha);',//\" * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\nPIXI.ComplexPrimitiveShader.prototype.constructor = PIXI.ComplexPrimitiveShader;\n\n/**\n* Initialises the shader.\n* \n* @method init\n*/\nPIXI.ComplexPrimitiveShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.tintColor = gl.getUniformLocation(program, 'tint');\n    this.color = gl.getUniformLocation(program, 'color');\n    this.flipY = gl.getUniformLocation(program, 'flipY');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n   // this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    this.attributes = [this.aVertexPosition, this.colorAttribute];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n* \n* @method destroy\n*/\nPIXI.ComplexPrimitiveShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attribute = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.glContexts = []; // this is where we store the webGL contexts for easy access.\nPIXI.instances = [];\n\n/**\n * The WebGLRenderer draws the stage and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class WebGLRenderer\n * @constructor\n * @param game {Phaser.Game} A reference to the Phaser Game instance\n */\nPIXI.WebGLRenderer = function(game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the Phaser Game instance.\n    */\n    this.game = game;\n\n    if (!PIXI.defaultRenderer)\n    {\n        PIXI.defaultRenderer = this;\n    }\n\n    /**\n     * @property type\n     * @type Number\n     */\n    this.type = PIXI.WEBGL_RENDERER;\n\n    /**\n     * The resolution of the renderer\n     *\n     * @property resolution\n     * @type Number\n     * @default 1\n     */\n    this.resolution = game.resolution;\n\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = game.transparent;\n\n    /**\n     * Whether the render view should be resized automatically\n     *\n     * @property autoResize\n     * @type Boolean\n     */\n    this.autoResize = false;\n\n    /**\n     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.\n     *\n     * @property preserveDrawingBuffer\n     * @type Boolean\n     */\n    this.preserveDrawingBuffer = game.preserveDrawingBuffer;\n\n    /**\n     * This sets if the WebGLRenderer will clear the context texture or not before the new render pass. If true:\n     * If the Stage is NOT transparent, Pixi will clear to alpha (0, 0, 0, 0).\n     * If the Stage is transparent, Pixi will clear to the target Stage's background color.\n     * Disable this by setting this to false. For example: if your game has a canvas filling background image, you often don't need this set.\n     *\n     * @property clearBeforeRender\n     * @type Boolean\n     * @default\n     */\n    this.clearBeforeRender = game.clearBeforeRender;\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = game.width;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = game.height;\n\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = game.canvas;\n\n    /**\n     * @property _contextOptions\n     * @type Object\n     * @private\n     */\n    this._contextOptions = {\n        alpha: this.transparent,\n        antialias: game.antialias,\n        premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',\n        stencil: true,\n        preserveDrawingBuffer: this.preserveDrawingBuffer\n    };\n\n    /**\n     * @property projection\n     * @type Point\n     */\n    this.projection = new PIXI.Point();\n\n    /**\n     * @property offset\n     * @type Point\n     */\n    this.offset = new PIXI.Point();\n\n    // time to create the render managers! each one focuses on managing a state in webGL\n\n    /**\n     * Deals with managing the shader programs and their attribs\n     * @property shaderManager\n     * @type WebGLShaderManager\n     */\n    this.shaderManager = new PIXI.WebGLShaderManager();\n\n    /**\n     * Manages the rendering of sprites\n     * @property spriteBatch\n     * @type WebGLSpriteBatch\n     */\n    this.spriteBatch = new PIXI.WebGLSpriteBatch();\n\n    /**\n     * Manages the masks using the stencil buffer\n     * @property maskManager\n     * @type WebGLMaskManager\n     */\n    this.maskManager = new PIXI.WebGLMaskManager();\n\n    /**\n     * Manages the filters\n     * @property filterManager\n     * @type WebGLFilterManager\n     */\n    this.filterManager = new PIXI.WebGLFilterManager();\n\n    /**\n     * Manages the stencil buffer\n     * @property stencilManager\n     * @type WebGLStencilManager\n     */\n    this.stencilManager = new PIXI.WebGLStencilManager();\n\n    /**\n     * Manages the blendModes\n     * @property blendModeManager\n     * @type WebGLBlendModeManager\n     */\n    this.blendModeManager = new PIXI.WebGLBlendModeManager();\n\n    /**\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = {};\n\n    //  Needed?\n    this.renderSession.game = this.game;\n    this.renderSession.gl = this.gl;\n    this.renderSession.drawCount = 0;\n    this.renderSession.shaderManager = this.shaderManager;\n    this.renderSession.maskManager = this.maskManager;\n    this.renderSession.filterManager = this.filterManager;\n    this.renderSession.blendModeManager = this.blendModeManager;\n    this.renderSession.spriteBatch = this.spriteBatch;\n    this.renderSession.stencilManager = this.stencilManager;\n    this.renderSession.renderer = this;\n    this.renderSession.resolution = this.resolution;\n\n    // time init the context..\n    this.initContext();\n\n    // map some webGL blend modes..\n    this.mapBlendModes();\n\n};\n\n// constructor\nPIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;\n\n/**\n* @method initContext\n*/\nPIXI.WebGLRenderer.prototype.initContext = function()\n{\n    var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);\n\n    this.gl = gl;\n\n    if (!gl) {\n        // fail, not able to get a context\n        throw new Error('This browser does not support webGL. Try using the canvas renderer');\n    }\n\n    this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++;\n\n    PIXI.glContexts[this.glContextId] = gl;\n\n    PIXI.instances[this.glContextId] = this;\n\n    // set up the default pixi settings..\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.enable(gl.BLEND);\n\n    // need to set the context for all the managers...\n    this.shaderManager.setContext(gl);\n    this.spriteBatch.setContext(gl);\n    this.maskManager.setContext(gl);\n    this.filterManager.setContext(gl);\n    this.blendModeManager.setContext(gl);\n    this.stencilManager.setContext(gl);\n\n    this.renderSession.gl = this.gl;\n\n    // now resize and we are good to go!\n    this.resize(this.width, this.height);\n};\n\n/**\n * Renders the stage to its webGL view\n *\n * @method render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.WebGLRenderer.prototype.render = function(stage)\n{\n    // no point rendering if our context has been blown up!\n    if (this.contextLost)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    // -- Does this need to be set every frame? -- //\n    gl.viewport(0, 0, this.width, this.height);\n\n    // make sure we are bound to the main frame buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    if (this.game.clearBeforeRender)\n    {\n        gl.clearColor(stage._bgColor.r, stage._bgColor.g, stage._bgColor.b, stage._bgColor.a);\n\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    this.offset.x = this.game.camera._shake.x;\n    this.offset.y = this.game.camera._shake.y;\n\n    this.renderDisplayObject(stage, this.projection);\n};\n\n/**\n * Renders a Display Object.\n *\n * @method renderDisplayObject\n * @param displayObject {DisplayObject} The DisplayObject to render\n * @param projection {Point} The projection\n * @param buffer {Array} a standard WebGL buffer\n */\nPIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer, matrix)\n{\n    this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL);\n\n    // reset the render session data..\n    this.renderSession.drawCount = 0;\n\n    // make sure to flip the Y if using a render texture..\n    this.renderSession.flipY = buffer ? -1 : 1;\n\n    // set the default projection\n    this.renderSession.projection = projection;\n\n    //set the default offset\n    this.renderSession.offset = this.offset;\n\n    // start the sprite batch\n    this.spriteBatch.begin(this.renderSession);\n\n    // start the filter manager\n    this.filterManager.begin(this.renderSession, buffer);\n\n    // render the scene!\n    displayObject._renderWebGL(this.renderSession, matrix);\n\n    // finish the sprite batch\n    this.spriteBatch.end();\n};\n\n/**\n * Resizes the webGL view to the specified width and height.\n *\n * @method resize\n * @param width {Number} the new width of the webGL view\n * @param height {Number} the new height of the webGL view\n */\nPIXI.WebGLRenderer.prototype.resize = function(width, height)\n{\n    this.width = width * this.resolution;\n    this.height = height * this.resolution;\n\n    this.view.width = this.width;\n    this.view.height = this.height;\n\n    if (this.autoResize) {\n        this.view.style.width = this.width / this.resolution + 'px';\n        this.view.style.height = this.height / this.resolution + 'px';\n    }\n\n    this.gl.viewport(0, 0, this.width, this.height);\n\n    this.projection.x =  this.width / 2 / this.resolution;\n    this.projection.y =  -this.height / 2 / this.resolution;\n};\n\n/**\n * Updates and Creates a WebGL texture for the renderers context.\n *\n * @method updateTexture\n * @param texture {Texture} the texture to update\n * @return {boolean} True if the texture was successfully bound, otherwise false.\n */\nPIXI.WebGLRenderer.prototype.updateTexture = function(texture)\n{\n    if (!texture.hasLoaded)\n    {\n        return false;\n    }\n\n    var gl = this.gl;\n\n    if (!texture._glTextures[gl.id])\n    {\n        texture._glTextures[gl.id] = gl.createTexture();\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);\n\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n    if (texture.mipmap && PIXI.isPowerOfTwo(texture.width, texture.height))\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n        gl.generateMipmap(gl.TEXTURE_2D);\n    }\n    else\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n\n    if (!texture._powerOf2)\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n    else\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    }\n\n    texture._dirty[gl.id] = false;\n\n    // return texture._glTextures[gl.id];\n    return true;\n\n};\n\n/**\n * Removes everything from the renderer (event listeners, spritebatch, etc...)\n *\n * @method destroy\n */\nPIXI.WebGLRenderer.prototype.destroy = function()\n{\n    PIXI.glContexts[this.glContextId] = null;\n\n    this.projection = null;\n    this.offset = null;\n\n    this.shaderManager.destroy();\n    this.spriteBatch.destroy();\n    this.maskManager.destroy();\n    this.filterManager.destroy();\n\n    this.shaderManager = null;\n    this.spriteBatch = null;\n    this.maskManager = null;\n    this.filterManager = null;\n\n    this.gl = null;\n    this.renderSession = null;\n\n    PIXI.CanvasPool.remove(this);\n\n    PIXI.instances[this.glContextId] = null;\n\n    PIXI.WebGLRenderer.glContextId--;\n};\n\n/**\n * Maps Pixi blend modes to WebGL blend modes.\n *\n * @method mapBlendModes\n */\nPIXI.WebGLRenderer.prototype.mapBlendModes = function()\n{\n    var gl = this.gl;\n\n    if (!PIXI.blendModesWebGL)\n    {\n        var b = [];\n        var modes = PIXI.blendModes;\n\n        b[modes.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];\n        b[modes.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];\n        b[modes.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        b[modes.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n\n        PIXI.blendModesWebGL = b;\n    }\n};\n\nPIXI.WebGLRenderer.glContextId = 0;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLBlendModeManager\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLBlendModeManager = function()\n{\n    /**\n     * @property currentBlendMode\n     * @type Number\n     */\n    this.currentBlendMode = 99999;\n};\n\nPIXI.WebGLBlendModeManager.prototype.constructor = PIXI.WebGLBlendModeManager;\n\n/**\n * Sets the WebGL Context.\n *\n * @method setContext\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLBlendModeManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Sets-up the given blendMode from WebGL's point of view.\n* \n* @method setBlendMode \n* @param blendMode {Number} the blendMode, should be a Pixi const, such as PIXI.BlendModes.ADD\n*/\nPIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode)\n{\n    if(this.currentBlendMode === blendMode)return false;\n\n    this.currentBlendMode = blendMode;\n    \n    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];\n\n    if (blendModeWebGL)\n    {\n        this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n    }\n    \n    return true;\n};\n\n/**\n* Destroys this object.\n* \n* @method destroy\n*/\nPIXI.WebGLBlendModeManager.prototype.destroy = function()\n{\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLMaskManager\n* @constructor\n* @private\n*/\nPIXI.WebGLMaskManager = function()\n{\n};\n\nPIXI.WebGLMaskManager.prototype.constructor = PIXI.WebGLMaskManager;\n\n/**\n* Sets the drawing context to the one given in parameter.\n* \n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLMaskManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Applies the Mask and adds it to the current filter stack.\n* \n* @method pushMask\n* @param maskData {Array}\n* @param renderSession {Object}\n*/\nPIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession)\n{\n    var gl = renderSession.gl;\n\n    if (maskData.dirty)\n    {\n        PIXI.WebGLGraphics.updateGraphics(maskData, gl);\n    }\n\n    if (maskData._webGL[gl.id] === undefined || maskData._webGL[gl.id].data === undefined || maskData._webGL[gl.id].data.length === 0)\n    {\n        return;\n    }\n\n    renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);\n};\n\n/**\n* Removes the last filter from the filter stack and doesn't return it.\n* \n* @method popMask\n* @param maskData {Array}\n* @param renderSession {Object} an object containing all the useful parameters\n*/\nPIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession)\n{\n    var gl = this.gl;\n\n    if (maskData._webGL[gl.id] === undefined || maskData._webGL[gl.id].data === undefined || maskData._webGL[gl.id].data.length === 0)\n    {\n        return;\n    }\n\n    renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);\n\n};\n\n/**\n* Destroys the mask stack.\n* \n* @method destroy\n*/\nPIXI.WebGLMaskManager.prototype.destroy = function()\n{\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLStencilManager\n* @constructor\n* @private\n*/\nPIXI.WebGLStencilManager = function()\n{\n    this.stencilStack = [];\n    this.reverse = true;\n    this.count = 0;\n};\n\n/**\n* Sets the drawing context to the one given in parameter.\n* \n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLStencilManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Applies the Mask and adds it to the current filter stack.\n* \n* @method pushMask\n* @param graphics {Graphics}\n* @param webGLData {Array}\n* @param renderSession {Object}\n*/\nPIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession)\n{\n    var gl = this.gl;\n    this.bindGraphics(graphics, webGLData, renderSession);\n\n    if(this.stencilStack.length === 0)\n    {\n        gl.enable(gl.STENCIL_TEST);\n        gl.clear(gl.STENCIL_BUFFER_BIT);\n        this.reverse = true;\n        this.count = 0;\n    }\n\n    this.stencilStack.push(webGLData);\n\n    var level = this.count;\n\n    gl.colorMask(false, false, false, false);\n\n    gl.stencilFunc(gl.ALWAYS,0,0xFF);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);\n\n    // draw the triangle strip!\n\n    if(webGLData.mode === 1)\n    {\n        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );\n       \n        if(this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n        }\n\n        // draw a quad to increment..\n        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );\n               \n        if(this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n        }\n\n        this.reverse = !this.reverse;\n    }\n    else\n    {\n        if(!this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n        }\n\n        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );\n\n        if(!this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n        }\n    }\n\n    gl.colorMask(true, true, true, true);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\n    this.count++;\n};\n\n/**\n * TODO this does not belong here!\n * \n * @method bindGraphics\n * @param graphics {Graphics}\n * @param webGLData {Array}\n * @param renderSession {Object}\n */\nPIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession)\n{\n    //if(this._currentGraphics === graphics)return;\n    this._currentGraphics = graphics;\n\n    var gl = this.gl;\n\n     // bind the graphics object..\n    var projection = renderSession.projection,\n        offset = renderSession.offset,\n        shader;// = renderSession.shaderManager.primitiveShader;\n\n    if(webGLData.mode === 1)\n    {\n        shader = renderSession.shaderManager.complexPrimitiveShader;\n\n        renderSession.shaderManager.setShader( shader );\n\n        gl.uniform1f(shader.flipY, renderSession.flipY);\n       \n        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n\n        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n        gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));\n        gl.uniform3fv(shader.color, webGLData.color);\n\n        gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);\n\n\n        // now do the rest..\n        // set the index buffer!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n    }\n    else\n    {\n        //renderSession.shaderManager.activatePrimitiveShader();\n        shader = renderSession.shaderManager.primitiveShader;\n        renderSession.shaderManager.setShader( shader );\n\n        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n\n        gl.uniform1f(shader.flipY, renderSession.flipY);\n        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n        gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));\n\n        gl.uniform1f(shader.alpha, graphics.worldAlpha);\n        \n        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);\n        gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\n        // set the index buffer!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n    }\n};\n\n/**\n * @method popStencil\n * @param graphics {Graphics}\n * @param webGLData {Array}\n * @param renderSession {Object}\n */\nPIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession)\n{\n\tvar gl = this.gl;\n    this.stencilStack.pop();\n   \n    this.count--;\n\n    if(this.stencilStack.length === 0)\n    {\n        // the stack is empty!\n        gl.disable(gl.STENCIL_TEST);\n\n    }\n    else\n    {\n\n        var level = this.count;\n\n        this.bindGraphics(graphics, webGLData, renderSession);\n\n        gl.colorMask(false, false, false, false);\n    \n        if(webGLData.mode === 1)\n        {\n            this.reverse = !this.reverse;\n\n            if(this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n            }\n\n            // draw a quad to increment..\n            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );\n            \n            gl.stencilFunc(gl.ALWAYS,0,0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);\n\n            // draw the triangle strip!\n            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );\n           \n            if(!this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            }\n\n        }\n        else\n        {\n          //  console.log(\"<<>>\")\n            if(!this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n            }\n\n            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );\n\n            if(!this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            }\n        }\n\n        gl.colorMask(true, true, true, true);\n        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\n\n    }\n};\n\n/**\n* Destroys the mask stack.\n* \n* @method destroy\n*/\nPIXI.WebGLStencilManager.prototype.destroy = function()\n{\n    this.stencilStack = null;\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLShaderManager\n* @constructor\n* @private\n*/\nPIXI.WebGLShaderManager = function()\n{\n    /**\n     * @property maxAttibs\n     * @type Number\n     */\n    this.maxAttibs = 10;\n\n    /**\n     * @property attribState\n     * @type Array\n     */\n    this.attribState = [];\n\n    /**\n     * @property tempAttribState\n     * @type Array\n     */\n    this.tempAttribState = [];\n\n    for (var i = 0; i < this.maxAttibs; i++)\n    {\n        this.attribState[i] = false;\n    }\n\n    /**\n     * @property stack\n     * @type Array\n     */\n    this.stack = [];\n\n};\n\nPIXI.WebGLShaderManager.prototype.constructor = PIXI.WebGLShaderManager;\n\n/**\n* Initialises the context and the properties.\n* \n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLShaderManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n    \n    // the next one is used for rendering primitives\n    this.primitiveShader = new PIXI.PrimitiveShader(gl);\n\n    // the next one is used for rendering triangle strips\n    this.complexPrimitiveShader = new PIXI.ComplexPrimitiveShader(gl);\n\n    // this shader is used for the default sprite rendering\n    this.defaultShader = new PIXI.PixiShader(gl);\n\n    // this shader is used for the fast sprite rendering\n    this.fastShader = new PIXI.PixiFastShader(gl);\n\n    // the next one is used for rendering triangle strips\n    this.stripShader = new PIXI.StripShader(gl);\n\n    this.setShader(this.defaultShader);\n};\n\n/**\n* Takes the attributes given in parameters.\n* \n* @method setAttribs\n* @param attribs {Array} attribs \n*/\nPIXI.WebGLShaderManager.prototype.setAttribs = function(attribs)\n{\n    // reset temp state\n    var i;\n\n    for (i = 0; i < this.tempAttribState.length; i++)\n    {\n        this.tempAttribState[i] = false;\n    }\n\n    // set the new attribs\n    for (i = 0; i < attribs.length; i++)\n    {\n        var attribId = attribs[i];\n        this.tempAttribState[attribId] = true;\n    }\n\n    var gl = this.gl;\n\n    for (i = 0; i < this.attribState.length; i++)\n    {\n        if(this.attribState[i] !== this.tempAttribState[i])\n        {\n            this.attribState[i] = this.tempAttribState[i];\n\n            if(this.tempAttribState[i])\n            {\n                gl.enableVertexAttribArray(i);\n            }\n            else\n            {\n                gl.disableVertexAttribArray(i);\n            }\n        }\n    }\n};\n\n/**\n* Sets the current shader.\n* \n* @method setShader\n* @param shader {Any}\n*/\nPIXI.WebGLShaderManager.prototype.setShader = function(shader)\n{\n    if(this._currentId === shader._UID)return false;\n    \n    this._currentId = shader._UID;\n\n    this.currentShader = shader;\n\n    this.gl.useProgram(shader.program);\n    this.setAttribs(shader.attributes);\n\n    return true;\n};\n\n/**\n* Destroys this object.\n* \n* @method destroy\n*/\nPIXI.WebGLShaderManager.prototype.destroy = function()\n{\n    this.attribState = null;\n\n    this.tempAttribState = null;\n\n    this.primitiveShader.destroy();\n\n    this.complexPrimitiveShader.destroy();\n\n    this.defaultShader.destroy();\n\n    this.fastShader.destroy();\n\n    this.stripShader.destroy();\n\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves\n * \n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n * \n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\n /**\n *\n * @class WebGLSpriteBatch\n * @private\n * @constructor\n */\nPIXI.WebGLSpriteBatch = function()\n{\n    /**\n     * @property vertSize\n     * @type Number\n     */\n    this.vertSize = 5;\n\n    /**\n     * The number of images in the SpriteBatch before it flushes\n     * @property size\n     * @type Number\n     */\n    this.size = 2000;//Math.pow(2, 16) /  this.vertSize;\n\n    //the total number of bytes in our batch\n    var numVerts = this.size * 4 * 4 * this.vertSize;\n    //the total number of indices in our batch\n    var numIndices = this.size * 6;\n\n    /**\n    * Holds the vertices\n    *\n    * @property vertices\n    * @type ArrayBuffer\n    */\n    this.vertices = new PIXI.ArrayBuffer(numVerts);\n\n    /**\n    * View on the vertices as a Float32Array\n    *\n    * @property positions\n    * @type Float32Array\n    */\n    this.positions = new PIXI.Float32Array(this.vertices);\n\n    /**\n    * View on the vertices as a Uint32Array\n    *\n    * @property colors\n    * @type Uint32Array\n    */\n    this.colors = new PIXI.Uint32Array(this.vertices);\n\n    /**\n     * Holds the indices\n     *\n     * @property indices\n     * @type Uint16Array\n     */\n    this.indices = new PIXI.Uint16Array(numIndices);\n    \n    /**\n     * @property lastIndexCount\n     * @type Number\n     */\n    this.lastIndexCount = 0;\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * @property drawing\n     * @type Boolean\n     */\n    this.drawing = false;\n\n    /**\n     * @property currentBatchSize\n     * @type Number\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * @property currentBaseTexture\n     * @type BaseTexture\n     */\n    this.currentBaseTexture = null;\n\n    /**\n     * @property dirty\n     * @type Boolean\n     */\n    this.dirty = true;\n\n    /**\n     * @property textures\n     * @type Array\n     */\n    this.textures = [];\n\n    /**\n     * @property blendModes\n     * @type Array\n     */\n    this.blendModes = [];\n\n    /**\n     * @property shaders\n     * @type Array\n     */\n    this.shaders = [];\n\n    /**\n     * @property sprites\n     * @type Array\n     */\n    this.sprites = [];\n\n    /**\n     * @property defaultShader\n     * @type AbstractFilter\n     */\n    this.defaultShader = new PIXI.AbstractFilter([\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ]);\n};\n\n/**\n* @method setContext\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLSpriteBatch.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n\n    this.currentBlendMode = 99999;\n\n    var shader = new PIXI.PixiShader(gl);\n\n    shader.fragmentSrc = this.defaultShader.fragmentSrc;\n    shader.uniforms = {};\n    shader.init();\n\n    this.defaultShader.shaders[gl.id] = shader;\n};\n\n/**\n* @method begin\n* @param renderSession {Object} The RenderSession object\n*/\nPIXI.WebGLSpriteBatch.prototype.begin = function(renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.defaultShader;\n\n    this.start();\n};\n\n/**\n* @method end\n*/\nPIXI.WebGLSpriteBatch.prototype.end = function()\n{\n    this.flush();\n};\n\n/**\n* @method render\n* @param sprite {Sprite} the sprite to render when using this spritebatch\n* @param {Matrix} [matrix] - Optional matrix. If provided the Display Object will be rendered using this matrix, otherwise it will use its worldTransform.\n*/\nPIXI.WebGLSpriteBatch.prototype.render = function(sprite, matrix)\n{\n    var texture = sprite.texture;\n\n    //  They provided an alternative rendering matrix, so use it\n    var wt = sprite.worldTransform;\n\n    if (matrix)\n    {\n        wt = matrix;\n    }\n\n    // check texture..\n    if (this.currentBatchSize >= this.size)\n    {\n        this.flush();\n        this.currentBaseTexture = texture.baseTexture;\n    }\n\n    // get the uvs for the texture\n    var uvs = texture._uvs;\n\n    // if the uvs have not updated then no point rendering just yet!\n    if (!uvs)\n    {\n        return;\n    }\n\n    var aX = sprite.anchor.x;\n    var aY = sprite.anchor.y;\n\n    var w0, w1, h0, h1;\n        \n    if (texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords.\n        var trim = texture.trim;\n\n        w1 = trim.x - aX * trim.width;\n        w0 = w1 + texture.crop.width;\n\n        h1 = trim.y - aY * trim.height;\n        h0 = h1 + texture.crop.height;\n    }\n    else\n    {\n        w0 = (texture.frame.width) * (1-aX);\n        w1 = (texture.frame.width) * -aX;\n\n        h0 = texture.frame.height * (1-aY);\n        h1 = texture.frame.height * -aY;\n    }\n\n    var i = this.currentBatchSize * 4 * this.vertSize;\n    var resolution = texture.baseTexture.resolution;\n\n    var a = wt.a / resolution;\n    var b = wt.b / resolution;\n    var c = wt.c / resolution;\n    var d = wt.d / resolution;\n    var tx = wt.tx;\n    var ty = wt.ty;\n\n    var colors = this.colors;\n    var positions = this.positions;\n\n    if (this.renderSession.roundPixels)\n    {\n        // xy\n        positions[i] = a * w1 + c * h1 + tx | 0;\n        positions[i+1] = d * h1 + b * w1 + ty | 0;\n\n        // xy\n        positions[i+5] = a * w0 + c * h1 + tx | 0;\n        positions[i+6] = d * h1 + b * w0 + ty | 0;\n\n         // xy\n        positions[i+10] = a * w0 + c * h0 + tx | 0;\n        positions[i+11] = d * h0 + b * w0 + ty | 0;\n\n        // xy\n        positions[i+15] = a * w1 + c * h0 + tx | 0;\n        positions[i+16] = d * h0 + b * w1 + ty | 0;\n    }\n    else\n    {\n        // xy\n        positions[i] = a * w1 + c * h1 + tx;\n        positions[i+1] = d * h1 + b * w1 + ty;\n\n        // xy\n        positions[i+5] = a * w0 + c * h1 + tx;\n        positions[i+6] = d * h1 + b * w0 + ty;\n\n         // xy\n        positions[i+10] = a * w0 + c * h0 + tx;\n        positions[i+11] = d * h0 + b * w0 + ty;\n\n        // xy\n        positions[i+15] = a * w1 + c * h0 + tx;\n        positions[i+16] = d * h0 + b * w1 + ty;\n    }\n    \n    // uv\n    positions[i+2] = uvs.x0;\n    positions[i+3] = uvs.y0;\n\n    // uv\n    positions[i+7] = uvs.x1;\n    positions[i+8] = uvs.y1;\n\n     // uv\n    positions[i+12] = uvs.x2;\n    positions[i+13] = uvs.y2;\n\n    // uv\n    positions[i+17] = uvs.x3;\n    positions[i+18] = uvs.y3;\n\n    // color and alpha\n    var tint = sprite.tint;\n\n    colors[i+4] = colors[i+9] = colors[i+14] = colors[i+19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);\n\n    // increment the batchsize\n    this.sprites[this.currentBatchSize++] = sprite;\n\n};\n\n/**\n* Renders a TilingSprite using the spriteBatch.\n* \n* @method renderTilingSprite\n* @param sprite {TilingSprite} the sprite to render\n*/\nPIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(sprite)\n{\n    var texture = sprite.tilingTexture;\n\n    // check texture..\n    if (this.currentBatchSize >= this.size)\n    {\n        this.flush();\n        this.currentBaseTexture = texture.baseTexture;\n    }\n\n    // set the textures uvs temporarily\n    if (!sprite._uvs)\n    {\n        sprite._uvs = new PIXI.TextureUvs();\n    }\n\n    var uvs = sprite._uvs;\n\n    var w = texture.baseTexture.width;\n    var h = texture.baseTexture.height;\n\n    // var w = sprite._frame.sourceSizeW;\n    // var h = sprite._frame.sourceSizeH;\n\n    // w = 16;\n    // h = 16;\n\n    sprite.tilePosition.x %= w * sprite.tileScaleOffset.x;\n    sprite.tilePosition.y %= h * sprite.tileScaleOffset.y;\n\n    var offsetX = sprite.tilePosition.x / (w * sprite.tileScaleOffset.x);\n    var offsetY = sprite.tilePosition.y / (h * sprite.tileScaleOffset.y);\n\n    var scaleX = (sprite.width / w) / (sprite.tileScale.x * sprite.tileScaleOffset.x);\n    var scaleY = (sprite.height / h) / (sprite.tileScale.y * sprite.tileScaleOffset.y);\n\n    uvs.x0 = 0 - offsetX;\n    uvs.y0 = 0 - offsetY;\n\n    uvs.x1 = (1 * scaleX) - offsetX;\n    uvs.y1 = 0 - offsetY;\n\n    uvs.x2 = (1 * scaleX) - offsetX;\n    uvs.y2 = (1 * scaleY) - offsetY;\n\n    uvs.x3 = 0 - offsetX;\n    uvs.y3 = (1 * scaleY) - offsetY;\n\n    //  Get the sprites current alpha and tint and combine them into a single color\n    var tint = sprite.tint;\n    var color = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);\n\n    var positions = this.positions;\n    var colors = this.colors;\n\n    var width = sprite.width;\n    var height = sprite.height;\n\n    // TODO trim??\n    var aX = sprite.anchor.x;\n    var aY = sprite.anchor.y;\n    var w0 = width * (1-aX);\n    var w1 = width * -aX;\n\n    var h0 = height * (1-aY);\n    var h1 = height * -aY;\n\n    var i = this.currentBatchSize * 4 * this.vertSize;\n\n    var resolution = texture.baseTexture.resolution;\n\n    var wt = sprite.worldTransform;\n\n    var a = wt.a / resolution;\n    var b = wt.b / resolution;\n    var c = wt.c / resolution;\n    var d = wt.d / resolution;\n    var tx = wt.tx;\n    var ty = wt.ty;\n\n    // xy\n    positions[i++] = a * w1 + c * h1 + tx;\n    positions[i++] = d * h1 + b * w1 + ty;\n    // uv\n    positions[i++] = uvs.x0;\n    positions[i++] = uvs.y0;\n    // color\n    colors[i++] = color;\n\n    // xy\n    positions[i++] = (a * w0 + c * h1 + tx);\n    positions[i++] = d * h1 + b * w0 + ty;\n    // uv\n    positions[i++] = uvs.x1;\n    positions[i++] = uvs.y1;\n    // color\n    colors[i++] = color;\n    \n    // xy\n    positions[i++] = a * w0 + c * h0 + tx;\n    positions[i++] = d * h0 + b * w0 + ty;\n    // uv\n    positions[i++] = uvs.x2;\n    positions[i++] = uvs.y2;\n    // color\n    colors[i++] = color;\n\n    // xy\n    positions[i++] = a * w1 + c * h0 + tx;\n    positions[i++] = d * h0 + b * w1 + ty;\n    // uv\n    positions[i++] = uvs.x3;\n    positions[i++] = uvs.y3;\n    // color\n    colors[i++] = color;\n\n    // increment the batchsize\n    this.sprites[this.currentBatchSize++] = sprite;\n};\n\n/**\n* Renders the content and empties the current batch.\n*\n* @method flush\n*/\nPIXI.WebGLSpriteBatch.prototype.flush = function()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize === 0)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n    var shader;\n\n    if (this.dirty)\n    {\n        this.dirty = false;\n\n        // bind the main texture\n        gl.activeTexture(gl.TEXTURE0);\n\n        // bind the buffers\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        shader = this.defaultShader.shaders[gl.id];\n\n        // this is the same for each shader?\n        var stride = this.vertSize * 4;\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n\n        // color attributes will be interpreted as unsigned bytes and normalized\n        gl.vertexAttribPointer(shader.colorAttribute, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);\n    }\n\n    // upload the verts to the buffer  \n    if (this.currentBatchSize > (this.size * 0.5))\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.positions.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n\n    var nextTexture, nextBlendMode, nextShader;\n    var batchSize = 0;\n    var start = 0;\n\n    var currentBaseTexture = null;\n    var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode;\n    var currentShader = null;\n\n    var blendSwap = false;\n    var shaderSwap = false;\n    var sprite;\n\n    for (var i = 0, j = this.currentBatchSize; i < j; i++) {\n        \n        sprite = this.sprites[i];\n\n        if (sprite.tilingTexture)\n        {\n            nextTexture = sprite.tilingTexture.baseTexture;\n        }\n        else\n        {\n            nextTexture = sprite.texture.baseTexture;\n        }\n\n        nextBlendMode = sprite.blendMode;\n        nextShader = sprite.shader || this.defaultShader;\n\n        blendSwap = currentBlendMode !== nextBlendMode;\n        shaderSwap = currentShader !== nextShader; // should I use _UIDS???\n\n        var skip = nextTexture.skipRender;\n\n        if (skip && sprite.children.length > 0)\n        {\n            skip = false;\n        }\n\n        if ((currentBaseTexture !== nextTexture && !skip) || blendSwap || shaderSwap)\n        {\n            this.renderBatch(currentBaseTexture, batchSize, start);\n\n            start = i;\n            batchSize = 0;\n            currentBaseTexture = nextTexture;\n\n            if (blendSwap)\n            {\n                currentBlendMode = nextBlendMode;\n                this.renderSession.blendModeManager.setBlendMode(currentBlendMode);\n            }\n\n            if (shaderSwap)\n            {\n                currentShader = nextShader;\n                \n                shader = currentShader.shaders[gl.id];\n\n                if (!shader)\n                {\n                    shader = new PIXI.PixiShader(gl);\n\n                    shader.fragmentSrc = currentShader.fragmentSrc;\n                    shader.uniforms = currentShader.uniforms;\n                    shader.init();\n\n                    currentShader.shaders[gl.id] = shader;\n                }\n\n                // set shader function???\n                this.renderSession.shaderManager.setShader(shader);\n\n                if (shader.dirty)\n                {\n                    shader.syncUniforms();\n                }\n                \n                // both these only need to be set if they are changing..\n                // set the projection\n                var projection = this.renderSession.projection;\n                gl.uniform2f(shader.projectionVector, projection.x, projection.y);\n\n                // TODO - this is temporary!\n                var offsetVector = this.renderSession.offset;\n                gl.uniform2f(shader.offsetVector, offsetVector.x, offsetVector.y);\n\n                // set the pointers\n            }\n        }\n\n        batchSize++;\n    }\n\n    this.renderBatch(currentBaseTexture, batchSize, start);\n\n    // then reset the batch!\n    this.currentBatchSize = 0;\n};\n\n/**\n* @method renderBatch\n* @param texture {Texture}\n* @param size {Number}\n* @param startIndex {Number}\n*/\nPIXI.WebGLSpriteBatch.prototype.renderBatch = function(texture, size, startIndex)\n{\n    if (size === 0)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    // check if a texture is dirty..\n    if (texture._dirty[gl.id])\n    {\n        if (!this.renderSession.renderer.updateTexture(texture))\n        {\n            //  If updateTexture returns false then we cannot render it, so bail out now\n            return;\n        }\n    }\n    else\n    {\n        // bind the current texture\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n    }\n\n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);\n    \n    // increment the draw count\n    this.renderSession.drawCount++;\n};\n\n/**\n* @method stop\n*/\nPIXI.WebGLSpriteBatch.prototype.stop = function()\n{\n    this.flush();\n    this.dirty = true;\n};\n\n/**\n* @method start\n*/\nPIXI.WebGLSpriteBatch.prototype.start = function()\n{\n    this.dirty = true;\n};\n\n/**\n* Destroys the SpriteBatch.\n* \n* @method destroy\n*/\nPIXI.WebGLSpriteBatch.prototype.destroy = function()\n{\n    this.vertices = null;\n    this.indices = null;\n    \n    this.gl.deleteBuffer(this.vertexBuffer);\n    this.gl.deleteBuffer(this.indexBuffer);\n    \n    this.currentBaseTexture = null;\n    \n    this.gl = null;\n};\n/**\n * @author Mat Groves\n * \n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n *\n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\n/**\n* @class WebGLFastSpriteBatch\n* @constructor\n*/\nPIXI.WebGLFastSpriteBatch = function(gl)\n{\n    /**\n     * @property vertSize\n     * @type Number\n     */\n    this.vertSize = 10;\n\n    /**\n     * @property maxSize\n     * @type Number\n     */\n    this.maxSize = 6000;//Math.pow(2, 16) /  this.vertSize;\n\n    /**\n     * @property size\n     * @type Number\n     */\n    this.size = this.maxSize;\n\n    //the total number of floats in our batch\n    var numVerts = this.size * 4 *  this.vertSize;\n\n    //the total number of indices in our batch\n    var numIndices = this.maxSize * 6;\n\n    /**\n     * Vertex data\n     * @property vertices\n     * @type Float32Array\n     */\n    this.vertices = new PIXI.Float32Array(numVerts);\n\n    /**\n     * Index data\n     * @property indices\n     * @type Uint16Array\n     */\n    this.indices = new PIXI.Uint16Array(numIndices);\n    \n    /**\n     * @property vertexBuffer\n     * @type Object\n     */\n    this.vertexBuffer = null;\n\n    /**\n     * @property indexBuffer\n     * @type Object\n     */\n    this.indexBuffer = null;\n\n    /**\n     * @property lastIndexCount\n     * @type Number\n     */\n    this.lastIndexCount = 0;\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * @property drawing\n     * @type Boolean\n     */\n    this.drawing = false;\n\n    /**\n     * @property currentBatchSize\n     * @type Number\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * @property currentBaseTexture\n     * @type BaseTexture\n     */\n    this.currentBaseTexture = null;\n   \n    /**\n     * @property currentBlendMode\n     * @type Number\n     */\n    this.currentBlendMode = 0;\n\n    /**\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = null;\n    \n    /**\n     * @property shader\n     * @type Object\n     */\n    this.shader = null;\n\n    /**\n     * @property matrix\n     * @type Matrix\n     */\n    this.matrix = null;\n\n    this.setContext(gl);\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.constructor = PIXI.WebGLFastSpriteBatch;\n\n/**\n * Sets the WebGL Context.\n *\n * @method setContext\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n};\n\n/**\n * @method begin\n * @param spriteBatch {WebGLSpriteBatch}\n * @param renderSession {Object}\n */\nPIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.fastShader;\n\n    this.matrix = spriteBatch.worldTransform.toArray(true);\n\n    this.start();\n};\n\n/**\n * @method end\n */\nPIXI.WebGLFastSpriteBatch.prototype.end = function()\n{\n    this.flush();\n};\n\n/**\n * @method render\n * @param spriteBatch {WebGLSpriteBatch}\n */\nPIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch)\n{\n    var children = spriteBatch.children;\n    var sprite = children[0];\n\n    // if the uvs have not updated then no point rendering just yet!\n    \n    // check texture.\n    if(!sprite.texture._uvs)return;\n   \n    this.currentBaseTexture = sprite.texture.baseTexture;\n    \n    // check blend mode\n    if(sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode)\n    {\n        this.flush();\n        this.renderSession.blendModeManager.setBlendMode(sprite.blendMode);\n    }\n    \n    for(var i=0,j= children.length; i<j; i++)\n    {\n        this.renderSprite(children[i]);\n    }\n\n    this.flush();\n};\n\n/**\n * @method renderSprite\n * @param sprite {Sprite}\n */\nPIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite)\n{\n    //sprite = children[i];\n    if(!sprite.visible)return;\n    \n    // TODO trim??\n    if(sprite.texture.baseTexture !== this.currentBaseTexture && !sprite.texture.baseTexture.skipRender)\n    {\n        this.flush();\n        this.currentBaseTexture = sprite.texture.baseTexture;\n        \n        if(!sprite.texture._uvs)return;\n    }\n\n    var uvs, vertices = this.vertices, width, height, w0, w1, h0, h1, index;\n\n    uvs = sprite.texture._uvs;\n\n    width = sprite.texture.frame.width;\n    height = sprite.texture.frame.height;\n\n    if (sprite.texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n        var trim = sprite.texture.trim;\n\n        w1 = trim.x - sprite.anchor.x * trim.width;\n        w0 = w1 + sprite.texture.crop.width;\n\n        h1 = trim.y - sprite.anchor.y * trim.height;\n        h0 = h1 + sprite.texture.crop.height;\n    }\n    else\n    {\n        w0 = (sprite.texture.frame.width ) * (1-sprite.anchor.x);\n        w1 = (sprite.texture.frame.width ) * -sprite.anchor.x;\n\n        h0 = sprite.texture.frame.height * (1-sprite.anchor.y);\n        h1 = sprite.texture.frame.height * -sprite.anchor.y;\n    }\n\n    index = this.currentBatchSize * 4 * this.vertSize;\n\n    // xy\n    vertices[index++] = w1;\n    vertices[index++] = h1;\n\n    vertices[index++] = sprite.position.x;\n    vertices[index++] = sprite.position.y;\n\n    //scale\n    vertices[index++] = sprite.scale.x;\n    vertices[index++] = sprite.scale.y;\n\n    //rotation\n    vertices[index++] = sprite.rotation;\n\n    // uv\n    vertices[index++] = uvs.x0;\n    vertices[index++] = uvs.y1;\n    // color\n    vertices[index++] = sprite.alpha;\n \n\n    // xy\n    vertices[index++] = w0;\n    vertices[index++] = h1;\n\n    vertices[index++] = sprite.position.x;\n    vertices[index++] = sprite.position.y;\n\n    //scale\n    vertices[index++] = sprite.scale.x;\n    vertices[index++] = sprite.scale.y;\n\n     //rotation\n    vertices[index++] = sprite.rotation;\n\n    // uv\n    vertices[index++] = uvs.x1;\n    vertices[index++] = uvs.y1;\n    // color\n    vertices[index++] = sprite.alpha;\n  \n\n    // xy\n    vertices[index++] = w0;\n    vertices[index++] = h0;\n\n    vertices[index++] = sprite.position.x;\n    vertices[index++] = sprite.position.y;\n\n    //scale\n    vertices[index++] = sprite.scale.x;\n    vertices[index++] = sprite.scale.y;\n\n     //rotation\n    vertices[index++] = sprite.rotation;\n\n    // uv\n    vertices[index++] = uvs.x2;\n    vertices[index++] = uvs.y2;\n    // color\n    vertices[index++] = sprite.alpha;\n \n\n\n\n    // xy\n    vertices[index++] = w1;\n    vertices[index++] = h0;\n\n    vertices[index++] = sprite.position.x;\n    vertices[index++] = sprite.position.y;\n\n    //scale\n    vertices[index++] = sprite.scale.x;\n    vertices[index++] = sprite.scale.y;\n\n     //rotation\n    vertices[index++] = sprite.rotation;\n\n    // uv\n    vertices[index++] = uvs.x3;\n    vertices[index++] = uvs.y3;\n    // color\n    vertices[index++] = sprite.alpha;\n\n    // increment the batchs\n    this.currentBatchSize++;\n\n    if(this.currentBatchSize >= this.size)\n    {\n        this.flush();\n    }\n};\n\n/**\n * @method flush\n */\nPIXI.WebGLFastSpriteBatch.prototype.flush = function()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize===0)return;\n\n    var gl = this.gl;\n    \n    // bind the current texture\n\n    if(!this.currentBaseTexture._glTextures[gl.id])this.renderSession.renderer.updateTexture(this.currentBaseTexture, gl);\n\n    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);\n\n    // upload the verts to the buffer\n   \n    if(this.currentBatchSize > ( this.size * 0.5 ) )\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n    \n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);\n   \n    // then reset the batch!\n    this.currentBatchSize = 0;\n\n    // increment the draw count\n    this.renderSession.drawCount++;\n};\n\n\n/**\n * @method stop\n */\nPIXI.WebGLFastSpriteBatch.prototype.stop = function()\n{\n    this.flush();\n};\n\n/**\n * @method start\n */\nPIXI.WebGLFastSpriteBatch.prototype.start = function()\n{\n    var gl = this.gl;\n\n    // bind the main texture\n    gl.activeTexture(gl.TEXTURE0);\n\n    // bind the buffers\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // set the projection\n    var projection = this.renderSession.projection;\n    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);\n\n    // set the matrix\n    gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);\n\n    // set the pointers\n    var stride =  this.vertSize * 4;\n\n    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n    gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n    gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);\n    gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);\n    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);\n    gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);\n    \n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLFilterManager\n* @constructor\n*/\nPIXI.WebGLFilterManager = function()\n{\n    /**\n     * @property filterStack\n     * @type Array\n     */\n    this.filterStack = [];\n    \n    /**\n     * @property offsetX\n     * @type Number\n     */\n    this.offsetX = 0;\n\n    /**\n     * @property offsetY\n     * @type Number\n     */\n    this.offsetY = 0;\n};\n\nPIXI.WebGLFilterManager.prototype.constructor = PIXI.WebGLFilterManager;\n\n/**\n* Initialises the context and the properties.\n* \n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLFilterManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n    this.texturePool = [];\n\n    this.initShaderBuffers();\n};\n\n/**\n* @method begin\n* @param renderSession {RenderSession} \n* @param buffer {ArrayBuffer} \n*/\nPIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer)\n{\n    this.renderSession = renderSession;\n    this.defaultShader = renderSession.shaderManager.defaultShader;\n\n    var projection = this.renderSession.projection;\n    this.width = projection.x * 2;\n    this.height = -projection.y * 2;\n    this.buffer = buffer;\n};\n\n/**\n* Applies the filter and adds it to the current filter stack.\n* \n* @method pushFilter\n* @param filterBlock {Object} the filter that will be pushed to the current filter stack\n*/\nPIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock)\n{\n    var gl = this.gl;\n\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n    filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();\n    \n    // >>> modify by nextht\n    filterBlock._previous_stencil_mgr = this.renderSession.stencilManager;\n    this.renderSession.stencilManager = new PIXI.WebGLStencilManager();\n    this.renderSession.stencilManager.setContext(gl);\n    gl.disable(gl.STENCIL_TEST);\n    // <<<  modify by nextht \n   \n    // filter program\n    // OPTIMISATION - the first filter is free if its a simple color change?\n    this.filterStack.push(filterBlock);\n\n    var filter = filterBlock.filterPasses[0];\n\n    this.offsetX += filterBlock._filterArea.x;\n    this.offsetY += filterBlock._filterArea.y;\n\n    var texture = this.texturePool.pop();\n    if(!texture)\n    {\n        texture = new PIXI.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);\n    }\n    else\n    {\n        texture.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D,  texture.texture);\n\n    var filterArea = filterBlock._filterArea;// filterBlock.target.getBounds();///filterBlock.target.filterArea;\n\n    var padding = filter.padding;\n    filterArea.x -= padding;\n    filterArea.y -= padding;\n    filterArea.width += padding * 2;\n    filterArea.height += padding * 2;\n\n    // cap filter to screen size..\n    if(filterArea.x < 0)filterArea.x = 0;\n    if(filterArea.width > this.width)filterArea.width = this.width;\n    if(filterArea.y < 0)filterArea.y = 0;\n    if(filterArea.height > this.height)filterArea.height = this.height;\n\n    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  filterArea.width, filterArea.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);\n\n    // set view port\n    gl.viewport(0, 0, filterArea.width * this.renderSession.resolution, filterArea.height * this.renderSession.resolution);\n\n    projection.x = filterArea.width/2;\n    projection.y = -filterArea.height/2;\n\n    offset.x = -filterArea.x;\n    offset.y = -filterArea.y;\n\n    // update projection\n    // now restore the regular shader..\n    // this.renderSession.shaderManager.setShader(this.defaultShader);\n    //gl.uniform2f(this.defaultShader.projectionVector, filterArea.width/2, -filterArea.height/2);\n    //gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);\n\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    filterBlock._glFilterTexture = texture;\n\n};\n\n/**\n* Removes the last filter from the filter stack and doesn't return it.\n* \n* @method popFilter\n*/\nPIXI.WebGLFilterManager.prototype.popFilter = function()\n{\n    var gl = this.gl;\n    var filterBlock = this.filterStack.pop();\n    var filterArea = filterBlock._filterArea;\n    var texture = filterBlock._glFilterTexture;\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n    if(filterBlock.filterPasses.length > 1)\n    {\n        gl.viewport(0, 0, filterArea.width * this.renderSession.resolution, filterArea.height * this.renderSession.resolution);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n        this.vertexArray[0] = 0;\n        this.vertexArray[1] = filterArea.height;\n\n        this.vertexArray[2] = filterArea.width;\n        this.vertexArray[3] = filterArea.height;\n\n        this.vertexArray[4] = 0;\n        this.vertexArray[5] = 0;\n\n        this.vertexArray[6] = filterArea.width;\n        this.vertexArray[7] = 0;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n        // now set the uvs..\n        this.uvArray[2] = filterArea.width/this.width;\n        this.uvArray[5] = filterArea.height/this.height;\n        this.uvArray[6] = filterArea.width/this.width;\n        this.uvArray[7] = filterArea.height/this.height;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n        var inputTexture = texture;\n        var outputTexture = this.texturePool.pop();\n        if(!outputTexture)outputTexture = new PIXI.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);\n        outputTexture.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);\n\n        // need to clear this FBO as it may have some left over elements from a previous filter.\n        gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        gl.disable(gl.BLEND);\n\n        for (var i = 0; i < filterBlock.filterPasses.length-1; i++)\n        {\n            var filterPass = filterBlock.filterPasses[i];\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );\n\n            // set texture\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);\n\n            // draw texture..\n            //filterPass.applyFilterPass(filterArea.width, filterArea.height);\n            this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);\n\n            // swap the textures..\n            var temp = inputTexture;\n            inputTexture = outputTexture;\n            outputTexture = temp;\n        }\n\n        gl.enable(gl.BLEND);\n\n        texture = inputTexture;\n        this.texturePool.push(outputTexture);\n    }\n\n    var filter = filterBlock.filterPasses[filterBlock.filterPasses.length-1];\n\n    this.offsetX -= filterArea.x;\n    this.offsetY -= filterArea.y;\n\n    var sizeX = this.width;\n    var sizeY = this.height;\n\n    var offsetX = 0;\n    var offsetY = 0;\n\n    var buffer = this.buffer;\n\n    // time to render the filters texture to the previous scene\n    if(this.filterStack.length === 0)\n    {\n        gl.colorMask(true, true, true, true);//this.transparent);\n    }\n    else\n    {\n        var currentFilter = this.filterStack[this.filterStack.length-1];\n        filterArea = currentFilter._filterArea;\n\n        sizeX = filterArea.width;\n        sizeY = filterArea.height;\n\n        offsetX = filterArea.x;\n        offsetY = filterArea.y;\n\n        buffer =  currentFilter._glFilterTexture.frameBuffer;\n    }\n\n    // TODO need to remove these global elements..\n    projection.x = sizeX/2;\n    projection.y = -sizeY/2;\n\n    offset.x = offsetX;\n    offset.y = offsetY;\n\n    filterArea = filterBlock._filterArea;\n\n    var x = filterArea.x-offsetX;\n    var y = filterArea.y-offsetY;\n\n    // update the buffers..\n    // make sure to flip the y!\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n    this.vertexArray[0] = x;\n    this.vertexArray[1] = y + filterArea.height;\n\n    this.vertexArray[2] = x + filterArea.width;\n    this.vertexArray[3] = y + filterArea.height;\n\n    this.vertexArray[4] = x;\n    this.vertexArray[5] = y;\n\n    this.vertexArray[6] = x + filterArea.width;\n    this.vertexArray[7] = y;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\n    this.uvArray[2] = filterArea.width/this.width;\n    this.uvArray[5] = filterArea.height/this.height;\n    this.uvArray[6] = filterArea.width/this.width;\n    this.uvArray[7] = filterArea.height/this.height;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n    gl.viewport(0, 0, sizeX * this.renderSession.resolution, sizeY * this.renderSession.resolution);\n\n    // bind the buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer );\n\n    // set the blend mode! \n    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\n\n    // set texture\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture.texture);\n\n    // >>> modify by nextht\n    if (this.renderSession.stencilManager) {\n        this.renderSession.stencilManager.destroy();\n    }\n    this.renderSession.stencilManager = filterBlock._previous_stencil_mgr;\n    filterBlock._previous_stencil_mgr = null;\n    if (this.renderSession.stencilManager.count > 0) {\n        gl.enable(gl.STENCIL_TEST);\n    }\n    else {\n        gl.disable(gl.STENCIL_TEST);\n    }    \n    // <<< modify by nextht\n\n    // apply!\n    this.applyFilterPass(filter, filterArea, sizeX, sizeY);\n\n    // now restore the regular shader.. should happen automatically now..\n    // this.renderSession.shaderManager.setShader(this.defaultShader);\n    // gl.uniform2f(this.defaultShader.projectionVector, sizeX/2, -sizeY/2);\n    // gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);\n\n    // return the texture to the pool\n    this.texturePool.push(texture);\n    filterBlock._glFilterTexture = null;\n};\n\n\n/**\n* Applies the filter to the specified area.\n* \n* @method applyFilterPass\n* @param filter {AbstractFilter} the filter that needs to be applied\n* @param filterArea {Texture} TODO - might need an update\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n*/\nPIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height)\n{\n    // use program\n    var gl = this.gl;\n    var shader = filter.shaders[gl.id];\n\n    if(!shader)\n    {\n        shader = new PIXI.PixiShader(gl);\n\n        shader.fragmentSrc = filter.fragmentSrc;\n        shader.uniforms = filter.uniforms;\n        shader.init();\n\n        filter.shaders[gl.id] = shader;\n    }\n\n    // set the shader\n    this.renderSession.shaderManager.setShader(shader);\n\n//    gl.useProgram(shader.program);\n\n    gl.uniform2f(shader.projectionVector, width/2, -height/2);\n    gl.uniform2f(shader.offsetVector, 0,0);\n\n    if(filter.uniforms.dimensions)\n    {\n        filter.uniforms.dimensions.value[0] = this.width;//width;\n        filter.uniforms.dimensions.value[1] = this.height;//height;\n        filter.uniforms.dimensions.value[2] = this.vertexArray[0];\n        filter.uniforms.dimensions.value[3] = this.vertexArray[5];//filterArea.height;\n    }\n\n    shader.syncUniforms();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // draw the filter...\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n    this.renderSession.drawCount++;\n};\n\n/**\n* Initialises the shader buffers.\n* \n* @method initShaderBuffers\n*/\nPIXI.WebGLFilterManager.prototype.initShaderBuffers = function()\n{\n    var gl = this.gl;\n\n    // create some buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.uvBuffer = gl.createBuffer();\n    this.colorBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // bind and upload the vertexs..\n    // keep a reference to the vertexFloatData..\n    this.vertexArray = new PIXI.Float32Array([0.0, 0.0,\n                                         1.0, 0.0,\n                                         0.0, 1.0,\n                                         1.0, 1.0]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW);\n\n    // bind and upload the uv buffer\n    this.uvArray = new PIXI.Float32Array([0.0, 0.0,\n                                     1.0, 0.0,\n                                     0.0, 1.0,\n                                     1.0, 1.0]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW);\n\n    this.colorArray = new PIXI.Float32Array([1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW);\n\n    // bind and upload the index\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), gl.STATIC_DRAW);\n\n};\n\n/**\n* Destroys the filter and removes it from the filter stack.\n* \n* @method destroy\n*/\nPIXI.WebGLFilterManager.prototype.destroy = function()\n{\n    var gl = this.gl;\n\n    this.filterStack = null;\n    \n    this.offsetX = 0;\n    this.offsetY = 0;\n\n    // destroy textures\n    for (var i = 0; i < this.texturePool.length; i++) {\n        this.texturePool[i].destroy();\n    }\n    \n    this.texturePool = null;\n\n    //destroy buffers..\n    gl.deleteBuffer(this.vertexBuffer);\n    gl.deleteBuffer(this.uvBuffer);\n    gl.deleteBuffer(this.colorBuffer);\n    gl.deleteBuffer(this.indexBuffer);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class FilterTexture\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n* @param scaleMode {Number} See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values\n*/\nPIXI.FilterTexture = function(gl, width, height, scaleMode)\n{\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    // next time to create a frame buffer and texture\n\n    /**\n     * @property frameBuffer\n     * @type Any\n     */\n    this.frameBuffer = gl.createFramebuffer();\n\n    /**\n     * @property texture\n     * @type Any\n     */\n    this.texture = gl.createTexture();\n\n    /**\n     * @property scaleMode\n     * @type Number\n     */\n    scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\n\n    // required for masking a mask??\n    this.renderBuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);\n  \n    this.resize(width, height);\n};\n\nPIXI.FilterTexture.prototype.constructor = PIXI.FilterTexture;\n\n/**\n* Clears the filter texture.\n* \n* @method clear\n*/\nPIXI.FilterTexture.prototype.clear = function()\n{\n    var gl = this.gl;\n    \n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n};\n\n/**\n * Resizes the texture to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the texture\n * @param height {Number} the new height of the texture\n */\nPIXI.FilterTexture.prototype.resize = function(width, height)\n{\n    if(this.width === width && this.height === height) return;\n\n    this.width = width;\n    this.height = height;\n\n    var gl = this.gl;\n\n    gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width , height , 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    // update the stencil buffer width and height\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width , height );\n};\n\n/**\n* Destroys the filter texture.\n* \n* @method destroy\n*/\nPIXI.FilterTexture.prototype.destroy = function()\n{\n    var gl = this.gl;\n    gl.deleteFramebuffer( this.frameBuffer );\n    gl.deleteTexture( this.texture );\n\n    this.frameBuffer = null;\n    this.texture = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * Creates a Canvas element of the given size.\n *\n * @class CanvasBuffer\n * @constructor\n * @param width {Number} the width for the newly created canvas\n * @param height {Number} the height for the newly created canvas\n */\nPIXI.CanvasBuffer = function(width, height)\n{\n    /**\n     * The width of the Canvas in pixels.\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = width;\n\n    /**\n     * The height of the Canvas in pixels.\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = height;\n\n    /**\n     * The Canvas object that belongs to this CanvasBuffer.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     */\n    this.canvas = PIXI.CanvasPool.create(this, this.width, this.height);\n\n    /**\n     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n    this.context = this.canvas.getContext(\"2d\");\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n};\n\nPIXI.CanvasBuffer.prototype.constructor = PIXI.CanvasBuffer;\n\n/**\n * Clears the canvas that was created by the CanvasBuffer class.\n *\n * @method clear\n * @private\n */\nPIXI.CanvasBuffer.prototype.clear = function()\n{\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n    this.context.clearRect(0,0, this.width, this.height);\n};\n\n/**\n * Resizes the canvas to the specified width and height.\n *\n * @method resize\n * @param width {Number} the new width of the canvas\n * @param height {Number} the new height of the canvas\n */\nPIXI.CanvasBuffer.prototype.resize = function(width, height)\n{\n    this.width = this.canvas.width = width;\n    this.height = this.canvas.height = height;\n};\n\n/**\n * Frees the canvas up for use again.\n *\n * @method destroy\n */\nPIXI.CanvasBuffer.prototype.destroy = function()\n{\n    PIXI.CanvasPool.remove(this);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A set of functions used to handle masking.\n *\n * @class CanvasMaskManager\n * @constructor\n */\nPIXI.CanvasMaskManager = function()\n{\n};\n\nPIXI.CanvasMaskManager.prototype.constructor = PIXI.CanvasMaskManager;\n\n/**\n * This method adds it to the current stack of masks.\n *\n * @method pushMask\n * @param maskData {Object} the maskData that will be pushed\n * @param renderSession {Object} The renderSession whose context will be used for this mask manager.\n */\nPIXI.CanvasMaskManager.prototype.pushMask = function(maskData, renderSession) {\n\n\tvar context = renderSession.context;\n\n    context.save();\n    \n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.worldTransform;\n\n    var resolution = renderSession.resolution;\n\n    context.setTransform(transform.a * resolution,\n                         transform.b * resolution,\n                         transform.c * resolution,\n                         transform.d * resolution,\n                         transform.tx * resolution,\n                         transform.ty * resolution);\n\n    PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);\n\n    context.clip();\n\n    maskData.worldAlpha = cacheAlpha;\n};\n\n/**\n * Restores the current drawing context to the state it was before the mask was applied.\n *\n * @method popMask\n * @param renderSession {Object} The renderSession whose context will be used for this mask manager.\n */\nPIXI.CanvasMaskManager.prototype.popMask = function(renderSession)\n{\n    renderSession.context.restore();\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * @class CanvasTinter\n * @static\n */\nPIXI.CanvasTinter = function() {};\n\n/**\n * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n * \n * @method getTintedTexture \n * @static\n * @param sprite {Sprite} the sprite to tint\n * @param color {Number} the color to use to tint the sprite with\n * @return {HTMLCanvasElement} The tinted canvas\n */\nPIXI.CanvasTinter.getTintedTexture = function(sprite, color)\n{\n    var canvas = sprite.tintedTexture || PIXI.CanvasPool.create(this);\n    \n    PIXI.CanvasTinter.tintMethod(sprite.texture, color, canvas);\n\n    return canvas;\n};\n\n/**\n * Tint a texture using the \"multiply\" operation.\n * \n * @method tintWithMultiply\n * @static\n * @param texture {Texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas)\n{\n    var context = canvas.getContext(\"2d\");\n\n    var crop = texture.crop;\n\n    if (canvas.width !== crop.width || canvas.height !== crop.height)\n    {\n        canvas.width = crop.width;\n        canvas.height = crop.height;\n    }\n\n    context.clearRect(0, 0, crop.width, crop.height);\n\n    context.fillStyle = \"#\" + (\"00000\" + (color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n\n    context.globalCompositeOperation = \"multiply\";\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n\n    context.globalCompositeOperation = \"destination-atop\";\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n\n};\n\n/**\n * Tint a texture pixel per pixel.\n * \n * @method tintPerPixel\n * @static\n * @param texture {Texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */ \nPIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas)\n{\n    var context = canvas.getContext(\"2d\");\n\n    var crop = texture.crop;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n  \n    context.globalCompositeOperation = \"copy\";\n\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n\n    var rgbValues = PIXI.hex2rgb(color);\n    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];\n\n    var pixelData = context.getImageData(0, 0, crop.width, crop.height);\n\n    var pixels = pixelData.data;\n\n    for (var i = 0; i < pixels.length; i += 4)\n    {\n        pixels[i + 0] *= r;\n        pixels[i + 1] *= g;\n        pixels[i + 2] *= b;\n\n        if (!PIXI.CanvasTinter.canHandleAlpha)\n        {\n            var alpha = pixels[i + 3];\n\n            pixels[i + 0] /= 255 / alpha;\n            pixels[i + 1] /= 255 / alpha;\n            pixels[i + 2] /= 255 / alpha;\n        }\n    }\n\n    context.putImageData(pixelData, 0, 0);\n};\n\n/**\n * Checks if the browser correctly supports putImageData alpha channels.\n * \n * @method checkInverseAlpha\n * @static\n */\nPIXI.CanvasTinter.checkInverseAlpha = function()\n{\n    var canvas = new PIXI.CanvasBuffer(2, 1);\n\n    canvas.context.fillStyle = \"rgba(10, 20, 30, 0.5)\";\n\n    //  Draw a single pixel\n    canvas.context.fillRect(0, 0, 1, 1);\n\n    //  Get the color values\n    var s1 = canvas.context.getImageData(0, 0, 1, 1);\n\n    if (s1 === null)\n    {\n        return false;\n    }\n\n    //  Plot them to x2\n    canvas.context.putImageData(s1, 1, 0);\n\n    //  Get those values\n    var s2 = canvas.context.getImageData(1, 0, 1, 1);\n\n    //  Compare and return\n    return (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);\n};\n\n/**\n * If the browser isn't capable of handling tinting with alpha this will be false.\n * This property is only applicable if using tintWithPerPixel.\n *\n * @property canHandleAlpha\n * @type Boolean\n * @static\n */\nPIXI.CanvasTinter.canHandleAlpha = PIXI.CanvasTinter.checkInverseAlpha();\n\n/**\n * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n *\n * @property canUseMultiply\n * @type Boolean\n * @static\n */\nPIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();\n\n/**\n * The tinting method that will be used.\n * \n * @method tintMethod\n * @static\n */\nPIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply :  PIXI.CanvasTinter.tintWithPerPixel;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The CanvasRenderer draws the Stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.\n * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)\n *\n * @class CanvasRenderer\n * @constructor\n * @param game {Phaser.Game} A reference to the Phaser Game instance\n */\nPIXI.CanvasRenderer = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the Phaser Game instance.\n    */\n    this.game = game;\n\n    if (!PIXI.defaultRenderer)\n    {\n        PIXI.defaultRenderer = this;\n    }\n\n    /**\n     * The renderer type.\n     *\n     * @property type\n     * @type Number\n     */\n    this.type = PIXI.CANVAS_RENDERER;\n\n    /**\n     * The resolution of the canvas.\n     *\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = game.resolution;\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the Stage is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.\n     * If the Stage is transparent Pixi will use clearRect to clear the canvas every frame.\n     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.\n     *\n     * @property clearBeforeRender\n     * @type Boolean\n     * @default\n     */\n    this.clearBeforeRender = game.clearBeforeRender;\n\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = game.transparent;\n\n    /**\n     * Whether the render view should be resized automatically\n     *\n     * @property autoResize\n     * @type Boolean\n     */\n    this.autoResize = false;\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     * @default 800\n     */\n    this.width = game.width * this.resolution;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     * @default 600\n     */\n    this.height = game.height * this.resolution;\n\n    /**\n     * The canvas element that everything is drawn to.\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = game.canvas;\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n    this.context = this.view.getContext(\"2d\", { alpha: this.transparent } );\n\n    /**\n     * Boolean flag controlling canvas refresh.\n     *\n     * @property refresh\n     * @type Boolean\n     */\n    this.refresh = true;\n\n    /**\n     * Internal var.\n     *\n     * @property count\n     * @type Number\n     */\n    this.count = 0;\n\n    /**\n     * Instance of a PIXI.CanvasMaskManager, handles masking when using the canvas renderer\n     * @property CanvasMaskManager\n     * @type CanvasMaskManager\n     */\n    this.maskManager = new PIXI.CanvasMaskManager();\n\n    /**\n     * The render session is just a bunch of parameter used for rendering\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = {\n        context: this.context,\n        maskManager: this.maskManager,\n        scaleMode: null,\n        smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),\n\n        /**\n         * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.\n         * Handy for crisp pixel art and speed on legacy devices.\n         */\n        roundPixels: false\n    };\n\n    this.mapBlendModes();\n    \n    this.resize(this.width, this.height);\n\n};\n\n// constructor\nPIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;\n\n/**\n * Renders the DisplayObjectContainer, usually the Phaser.Stage, to this canvas view.\n *\n * @method render\n * @param root {Phaser.Stage|PIXI.DisplayObjectContainer} The root element to be rendered.\n */\nPIXI.CanvasRenderer.prototype.render = function (root) {\n\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n\n    this.context.globalAlpha = 1;\n\n    this.renderSession.currentBlendMode = 0;\n    this.renderSession.shakeX = this.game.camera._shake.x;\n    this.renderSession.shakeY = this.game.camera._shake.y;\n\n    this.context.globalCompositeOperation = 'source-over';\n\n    if (navigator.isCocoonJS && this.view.screencanvas)\n    {\n        this.context.fillStyle = \"black\";\n        this.context.clear();\n    }\n    \n    if (this.clearBeforeRender)\n    {\n        if (this.transparent)\n        {\n            this.context.clearRect(0, 0, this.width, this.height);\n        }\n        else if (root._bgColor)\n        {\n            this.context.fillStyle = root._bgColor.rgba;\n            this.context.fillRect(0, 0, this.width , this.height);\n        }\n    }\n    \n    this.renderDisplayObject(root);\n\n};\n\n\n/**\n * Removes everything from the renderer and optionally removes the Canvas DOM element.\n *\n * @method destroy\n * @param [removeView=true] {boolean} Removes the Canvas element from the DOM.\n */\nPIXI.CanvasRenderer.prototype.destroy = function (removeView) {\n\n    if (removeView === undefined) { removeView = true; }\n\n    if (removeView && this.view.parent)\n    {\n        this.view.parent.removeChild(this.view);\n    }\n\n    this.view = null;\n    this.context = null;\n    this.maskManager = null;\n    this.renderSession = null;\n\n};\n\n/**\n * Resizes the canvas view to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the canvas view\n * @param height {Number} the new height of the canvas view\n */\nPIXI.CanvasRenderer.prototype.resize = function (width, height) {\n\n    this.width = width * this.resolution;\n    this.height = height * this.resolution;\n\n    this.view.width = this.width;\n    this.view.height = this.height;\n\n    if (this.autoResize)\n    {\n        this.view.style.width = this.width / this.resolution + \"px\";\n        this.view.style.height = this.height / this.resolution + \"px\";\n    }\n\n    if (this.renderSession.smoothProperty)\n    {\n        this.context[this.renderSession.smoothProperty] = (this.renderSession.scaleMode === PIXI.scaleModes.LINEAR);\n    }\n\n};\n\n/**\n * Renders a display object\n *\n * @method renderDisplayObject\n * @param displayObject {DisplayObject} The displayObject to render\n * @param context {CanvasRenderingContext2D} the context 2d method of the canvas\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context, matrix) {\n\n    this.renderSession.context = context || this.context;\n    this.renderSession.resolution = this.resolution;\n    displayObject._renderCanvas(this.renderSession, matrix);\n\n};\n\n/**\n * Maps Pixi blend modes to canvas blend modes.\n *\n * @method mapBlendModes\n * @private\n */\nPIXI.CanvasRenderer.prototype.mapBlendModes = function () {\n\n    if (!PIXI.blendModesCanvas)\n    {\n        var b = [];\n        var modes = PIXI.blendModes;\n        var useNew = PIXI.canUseNewCanvasBlendModes();\n\n        b[modes.NORMAL] = 'source-over';\n        b[modes.ADD] = 'lighter';\n        b[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over';\n        b[modes.SCREEN] = (useNew) ? 'screen' : 'source-over';\n        b[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over';\n        b[modes.DARKEN] = (useNew) ? 'darken' : 'source-over';\n        b[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over';\n        b[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over';\n        b[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over';\n        b[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over';\n        b[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over';\n        b[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over';\n        b[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over';\n        b[modes.HUE] = (useNew) ? 'hue' : 'source-over';\n        b[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over';\n        b[modes.COLOR] = (useNew) ? 'color' : 'source-over';\n        b[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over';\n\n        PIXI.blendModesCanvas = b;\n    }\n\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture.\n *\n * @class BaseTexture\n * @uses EventTarget\n * @constructor\n * @param source {String|Canvas} the source object (image or canvas)\n * @param scaleMode {Number} See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values\n */\nPIXI.BaseTexture = function(source, scaleMode)\n{\n    /**\n     * The Resolution of the texture. \n     *\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = 1;\n    \n    /**\n     * [read-only] The width of the base texture set when the image has loaded\n     *\n     * @property width\n     * @type Number\n     * @readOnly\n     */\n    this.width = 100;\n\n    /**\n     * [read-only] The height of the base texture set when the image has loaded\n     *\n     * @property height\n     * @type Number\n     * @readOnly\n     */\n    this.height = 100;\n\n    /**\n     * The scale mode to apply when scaling this texture\n     * \n     * @property scaleMode\n     * @type {Number}\n     * @default PIXI.scaleModes.LINEAR\n     */\n    this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    /**\n     * [read-only] Set to true once the base texture has loaded\n     *\n     * @property hasLoaded\n     * @type Boolean\n     * @readOnly\n     */\n    this.hasLoaded = false;\n\n    /**\n     * The image source that is used to create the texture.\n     *\n     * @property source\n     * @type Image\n     */\n    this.source = source;\n\n    /**\n     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)\n     *\n     * @property premultipliedAlpha\n     * @type Boolean\n     * @default true\n     */\n    this.premultipliedAlpha = true;\n\n    // used for webGL\n\n    /**\n     * @property _glTextures\n     * @type Array\n     * @private\n     */\n    this._glTextures = [];\n\n    /**\n     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used\n     * Also the texture must be a power of two size to work\n     * \n     * @property mipmap\n     * @type {Boolean}\n     */\n    this.mipmap = false;\n\n    /**\n     * @property _dirty\n     * @type Array\n     * @private\n     */\n    this._dirty = [true, true, true, true];\n\n    if (!source)\n    {\n        return;\n    }\n\n    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)\n    {\n        this.hasLoaded = true;\n        this.width = this.source.naturalWidth || this.source.width;\n        this.height = this.source.naturalHeight || this.source.height;\n        this.dirty();\n    }\n\n    /**\n     * A BaseTexture can be set to skip the rendering phase in the WebGL Sprite Batch.\n     * \n     * You may want to do this if you have a parent Sprite with no visible texture (i.e. uses the internal `__default` texture)\n     * that has children that you do want to render, without causing a batch flush in the process.\n     * \n     * @property skipRender\n     * @type Boolean\n     */\n    this.skipRender = false;\n\n    /**\n     * @property _powerOf2\n     * @type Boolean\n     * @private\n     */\n    this._powerOf2 = false;\n\n};\n\nPIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;\n\n/**\n * Forces this BaseTexture to be set as loaded, with the given width and height.\n * Then calls BaseTexture.dirty.\n * Important for when you don't want to modify the source object by forcing in `complete` or dimension properties it may not have.\n *\n * @method forceLoaded\n * @param {number} width - The new width to force the BaseTexture to be.\n * @param {number} height - The new height to force the BaseTexture to be.\n */\nPIXI.BaseTexture.prototype.forceLoaded = function(width, height)\n{\n    this.hasLoaded = true;\n    this.width = width;\n    this.height = height;\n    this.dirty();\n};\n\n/**\n * Destroys this base texture\n *\n * @method destroy\n */\nPIXI.BaseTexture.prototype.destroy = function()\n{\n    if (this.source)\n    {\n        PIXI.CanvasPool.removeByCanvas(this.source);\n    }\n\n    this.source = null;\n\n    this.unloadFromGPU();\n};\n\n/**\n * Changes the source image of the texture\n *\n * @method updateSourceImage\n * @param newSrc {String} the path of the image\n * @deprecated This method is deprecated. Please use Phaser.Sprite.loadTexture instead.\n */\nPIXI.BaseTexture.prototype.updateSourceImage = function(newSrc)\n{\n    console.warn(\"PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.\");\n};\n\n/**\n * Sets all glTextures to be dirty.\n *\n * @method dirty\n */\nPIXI.BaseTexture.prototype.dirty = function()\n{\n    for (var i = 0; i < this._glTextures.length; i++)\n    {\n        this._dirty[i] = true;\n    }\n};\n\n/**\n * Removes the base texture from the GPU, useful for managing resources on the GPU.\n * Atexture is still 100% usable and will simply be reuploaded if there is a sprite on screen that is using it.\n *\n * @method unloadFromGPU\n */\nPIXI.BaseTexture.prototype.unloadFromGPU = function()\n{\n    this.dirty();\n\n    // delete the webGL textures if any.\n    for (var i = this._glTextures.length - 1; i >= 0; i--)\n    {\n        var glTexture = this._glTextures[i];\n        var gl = PIXI.glContexts[i];\n\n        if(gl && glTexture)\n        {\n            gl.deleteTexture(glTexture);\n        }\n        \n    }\n\n    this._glTextures.length = 0;\n\n    this.dirty();\n};\n\n/**\n * Helper function that creates a base texture from the given canvas element.\n *\n * @static\n * @method fromCanvas\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {Number} See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values\n * @return {BaseTexture}\n */\nPIXI.BaseTexture.fromCanvas = function(canvas, scaleMode)\n{\n    if (canvas.width === 0)\n    {\n        canvas.width = 1;\n    }\n\n    if (canvas.height === 0)\n    {\n        canvas.height = 1;\n    }\n\n    return new PIXI.BaseTexture(canvas, scaleMode);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * TextureSilentFail is a boolean that defaults to `false`. \n * If `true` then `PIXI.Texture.setFrame` will no longer throw an error if the texture dimensions are incorrect. \n * Instead `Texture.valid` will be set to `false` (#1556)\n *\n * @type {boolean}\n */\nPIXI.TextureSilentFail = false;\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a PIXI.Sprite. If no frame is provided then the whole image is used.\n *\n * @class Texture\n * @uses EventTarget\n * @constructor\n * @param baseTexture {BaseTexture} The base texture source to create the texture from\n * @param frame {Rectangle} The rectangle frame of the texture to show\n * @param [crop] {Rectangle} The area of original texture \n * @param [trim] {Rectangle} Trimmed texture rectangle\n */\nPIXI.Texture = function(baseTexture, frame, crop, trim)\n{\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * @property noFrame\n     * @type Boolean\n     */\n    this.noFrame = false;\n\n    if (!frame)\n    {\n        this.noFrame = true;\n        frame = new PIXI.Rectangle(0,0,1,1);\n    }\n\n    if (baseTexture instanceof PIXI.Texture)\n    {\n        baseTexture = baseTexture.baseTexture;\n    }\n\n    /**\n     * The base texture that this texture uses.\n     *\n     * @property baseTexture\n     * @type BaseTexture\n     */\n    this.baseTexture = baseTexture;\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses\n     *\n     * @property frame\n     * @type Rectangle\n     */\n    this.frame = frame;\n\n    /**\n     * The texture trim data.\n     *\n     * @property trim\n     * @type Rectangle\n     */\n    this.trim = trim;\n\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @property valid\n     * @type Boolean\n     */\n    this.valid = false;\n\n    /**\n     * Is this a tiling texture? As used by the likes of a TilingSprite.\n     *\n     * @property isTiling\n     * @type Boolean\n     */\n    this.isTiling = false;\n\n    /**\n     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n     *\n     * @property requiresUpdate\n     * @type Boolean\n     */\n    this.requiresUpdate = false;\n\n    /**\n     * This will let a renderer know that a tinted parent has updated its texture.\n     *\n     * @property requiresReTint\n     * @type Boolean\n     */\n    this.requiresReTint = false;\n\n    /**\n     * The WebGL UV data cache.\n     *\n     * @property _uvs\n     * @type Object\n     * @private\n     */\n    this._uvs = null;\n\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = 0;\n\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = 0;\n\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @property crop\n     * @type Rectangle\n     */\n    this.crop = crop || new PIXI.Rectangle(0, 0, 1, 1);\n\n    if (baseTexture.hasLoaded)\n    {\n        if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n        this.setFrame(frame);\n    }\n\n};\n\nPIXI.Texture.prototype.constructor = PIXI.Texture;\n\n/**\n * Called when the base texture is loaded\n *\n * @method onBaseTextureLoaded\n * @private\n */\nPIXI.Texture.prototype.onBaseTextureLoaded = function()\n{\n    var baseTexture = this.baseTexture;\n\n    if (this.noFrame)\n    {\n        this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n    }\n\n    this.setFrame(this.frame);\n};\n\n/**\n * Destroys this texture\n *\n * @method destroy\n * @param destroyBase {Boolean} Whether to destroy the base texture as well\n */\nPIXI.Texture.prototype.destroy = function(destroyBase)\n{\n    if (destroyBase) this.baseTexture.destroy();\n\n    this.valid = false;\n};\n\n/**\n * Specifies the region of the baseTexture that this texture will use.\n *\n * @method setFrame\n * @param frame {Rectangle} The frame of the texture to set it to\n */\nPIXI.Texture.prototype.setFrame = function(frame)\n{\n    this.noFrame = false;\n\n    this.frame = frame;\n    this.width = frame.width;\n    this.height = frame.height;\n\n    this.crop.x = frame.x;\n    this.crop.y = frame.y;\n    this.crop.width = frame.width;\n    this.crop.height = frame.height;\n\n    if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))\n    {\n        if (!PIXI.TextureSilentFail)\n        {\n            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);\n        }\n\n        this.valid = false;\n        return;\n    }\n\n    this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;\n\n    if (this.trim)\n    {\n        this.width = this.trim.width;\n        this.height = this.trim.height;\n        this.frame.width = this.trim.width;\n        this.frame.height = this.trim.height;\n    }\n    \n    if (this.valid) this._updateUvs();\n\n};\n\n/**\n * Updates the internal WebGL UV cache.\n *\n * @method _updateUvs\n * @private\n */\nPIXI.Texture.prototype._updateUvs = function()\n{\n    if(!this._uvs)this._uvs = new PIXI.TextureUvs();\n\n    var frame = this.crop;\n    var tw = this.baseTexture.width;\n    var th = this.baseTexture.height;\n    \n    this._uvs.x0 = frame.x / tw;\n    this._uvs.y0 = frame.y / th;\n\n    this._uvs.x1 = (frame.x + frame.width) / tw;\n    this._uvs.y1 = frame.y / th;\n\n    this._uvs.x2 = (frame.x + frame.width) / tw;\n    this._uvs.y2 = (frame.y + frame.height) / th;\n\n    this._uvs.x3 = frame.x / tw;\n    this._uvs.y3 = (frame.y + frame.height) / th;\n};\n\n/**\n * Helper function that creates a new a Texture based on the given canvas element.\n *\n * @static\n * @method fromCanvas\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {Number} See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values\n * @return {Texture}\n */\nPIXI.Texture.fromCanvas = function(canvas, scaleMode)\n{\n    var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);\n\n    return new PIXI.Texture(baseTexture);\n};\n\nPIXI.TextureUvs = function()\n{\n    this.x0 = 0;\n    this.y0 = 0;\n\n    this.x1 = 0;\n    this.y1 = 0;\n\n    this.x2 = 0;\n    this.y2 = 0;\n\n    this.x3 = 0;\n    this.y3 = 0;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded otherwise black rectangles will be drawn instead.\n *\n * A RenderTexture takes a snapshot of any Display Object given to its render method. The position and rotation of the given Display Objects is ignored. For example:\n *\n *    var renderTexture = new PIXI.RenderTexture(800, 600);\n *    var sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *    sprite.position.x = 800/2;\n *    sprite.position.y = 600/2;\n *    sprite.anchor.x = 0.5;\n *    sprite.anchor.y = 0.5;\n *    renderTexture.render(sprite);\n *\n * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual position a DisplayObjectContainer should be used:\n *\n *    var doc = new PIXI.DisplayObjectContainer();\n *    doc.addChild(sprite);\n *    renderTexture.render(doc);  // Renders to center of renderTexture\n *\n * @class RenderTexture\n * @extends Texture\n * @constructor\n * @param width {Number} The width of the render texture\n * @param height {Number} The height of the render texture\n * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used for this RenderTexture\n * @param scaleMode {Number} See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values\n * @param resolution {Number} The resolution of the texture being generated\n */\nPIXI.RenderTexture = function(width, height, renderer, scaleMode, resolution)\n{\n    /**\n     * The with of the render texture\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = width || 100;\n\n    /**\n     * The height of the render texture\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = height || 100;\n\n    /**\n     * The Resolution of the texture.\n     *\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = resolution || 1;\n\n    /**\n     * The framing rectangle of the render texture\n     *\n     * @property frame\n     * @type Rectangle\n     */\n    this.frame = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @property crop\n     * @type Rectangle\n     */\n    this.crop = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n    /**\n     * The base texture object that this texture uses\n     *\n     * @property baseTexture\n     * @type BaseTexture\n     */\n    this.baseTexture = new PIXI.BaseTexture();\n    this.baseTexture.width = this.width * this.resolution;\n    this.baseTexture.height = this.height * this.resolution;\n    this.baseTexture._glTextures = [];\n    this.baseTexture.resolution = this.resolution;\n\n    this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    this.baseTexture.hasLoaded = true;\n\n    PIXI.Texture.call(this,\n        this.baseTexture,\n        new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)\n    );\n\n    /**\n     * The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.\n     *\n     * @property renderer\n     * @type CanvasRenderer|WebGLRenderer\n     */\n    this.renderer = renderer || PIXI.defaultRenderer;\n\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        var gl = this.renderer.gl;\n        this.baseTexture._dirty[gl.id] = false;\n\n        this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height, this.baseTexture.scaleMode);\n        this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture;\n\n        this.render = this.renderWebGL;\n        this.projection = new PIXI.Point(this.width * 0.5, -this.height * 0.5);\n    }\n    else\n    {\n        this.render = this.renderCanvas;\n        this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution);\n        this.baseTexture.source = this.textureBuffer.canvas;\n    }\n\n    /**\n     * @property valid\n     * @type Boolean\n     */\n    this.valid = true;\n\n    this.tempMatrix = new Phaser.Matrix();\n\n    this._updateUvs();\n};\n\nPIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);\nPIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;\n\n/**\n * Resizes the RenderTexture.\n *\n * @method resize\n * @param width {Number} The width to resize to.\n * @param height {Number} The height to resize to.\n * @param updateBase {Boolean} Should the baseTexture.width and height values be resized as well?\n */\nPIXI.RenderTexture.prototype.resize = function(width, height, updateBase)\n{\n    if (width === this.width && height === this.height)return;\n\n    this.valid = (width > 0 && height > 0);\n\n    this.width = width;\n    this.height = height;\n    this.frame.width = this.crop.width = width * this.resolution;\n    this.frame.height = this.crop.height = height * this.resolution;\n\n    if (updateBase)\n    {\n        this.baseTexture.width = this.width * this.resolution;\n        this.baseTexture.height = this.height * this.resolution;\n    }\n\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.projection.x = this.width / 2;\n        this.projection.y = -this.height / 2;\n    }\n\n    if(!this.valid)return;\n\n    this.textureBuffer.resize(this.width, this.height);\n};\n\n/**\n * Clears the RenderTexture.\n *\n * @method clear\n */\nPIXI.RenderTexture.prototype.clear = function()\n{\n    if (!this.valid)\n    {\n        return;\n    }\n\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n    }\n\n    this.textureBuffer.clear();\n};\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderWebGL\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear] {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderWebGL = function(displayObject, matrix, clear)\n{\n    if (!this.valid || displayObject.alpha === 0)\n    {\n        return;\n    }\n   \n    //  Let's create a nice matrix to apply to our display object.\n    //  Frame buffers come in upside down so we need to flip the matrix.\n    var wt = displayObject.worldTransform;\n    wt.identity();\n    wt.translate(0, this.projection.y * 2);\n\n    if (matrix)\n    {\n        wt.append(matrix);\n    }\n\n    wt.scale(1, -1);\n\n    //  Time to update all the children of the displayObject with the new matrix.\n    for (var i = 0; i < displayObject.children.length; i++)\n    {\n        displayObject.children[i].updateTransform();\n    }\n    \n    //  Time for the webGL fun stuff!\n    var gl = this.renderer.gl;\n\n    gl.viewport(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer );\n\n    if (clear)\n    {\n        this.textureBuffer.clear();\n    }\n\n    this.renderer.spriteBatch.dirty = true;\n\n    this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer, matrix);\n\n    this.renderer.spriteBatch.dirty = true;\n\n};\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderCanvas\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear] {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderCanvas = function(displayObject, matrix, clear)\n{\n    if (!this.valid || displayObject.alpha === 0)\n    {\n        return;\n    }\n\n    //  Let's create a nice matrix to apply to our display object.\n    //  Frame buffers come in upside down so we need to flip the matrix.\n    var wt = displayObject.worldTransform;\n    wt.identity();\n\n    if (matrix)\n    {\n        wt.append(matrix);\n    }\n\n    // Time to update all the children of the displayObject with the new matrix (what new matrix? there isn't one!)\n    for (var i = 0; i < displayObject.children.length; i++)\n    {\n        displayObject.children[i].updateTransform();\n    }\n\n    if (clear)\n    {\n        this.textureBuffer.clear();\n    }\n\n    var realResolution = this.renderer.resolution;\n\n    this.renderer.resolution = this.resolution;\n\n    this.renderer.renderDisplayObject(displayObject, this.textureBuffer.context, matrix);\n\n    this.renderer.resolution = realResolution;\n};\n\n/**\n * Will return a HTML Image of the texture\n *\n * @method getImage\n * @return {Image}\n */\nPIXI.RenderTexture.prototype.getImage = function()\n{\n    var image = new Image();\n    image.src = this.getBase64();\n    return image;\n};\n\n/**\n * Will return a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.\n *\n * @method getBase64\n * @return {String} A base64 encoded string of the texture.\n */\nPIXI.RenderTexture.prototype.getBase64 = function()\n{\n    return this.getCanvas().toDataURL();\n};\n\n/**\n * Creates a Canvas element, renders this RenderTexture to it and then returns it.\n *\n * @method getCanvas\n * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n */\nPIXI.RenderTexture.prototype.getCanvas = function()\n{\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        var gl =  this.renderer.gl;\n        var width = this.textureBuffer.width;\n        var height = this.textureBuffer.height;\n\n        var webGLPixels = new Uint8Array(4 * width * height);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        var tempCanvas = new PIXI.CanvasBuffer(width, height);\n        var canvasData = tempCanvas.context.getImageData(0, 0, width, height);\n        canvasData.data.set(webGLPixels);\n\n        tempCanvas.context.putImageData(canvasData, 0, 0);\n\n        return tempCanvas.canvas;\n    }\n    else\n    {\n        return this.textureBuffer.canvas;\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This is the base class for creating a PIXI filter. Currently only webGL supports filters.\n * If you want to make a custom filter this should be your base class.\n * \n * @class AbstractFilter\n * @constructor\n * @param fragmentSrc {Array} The fragment source in an array of strings.\n * @param uniforms {Object} An object containing the uniforms for this filter.\n */\nPIXI.AbstractFilter = function(fragmentSrc, uniforms)\n{\n    /**\n    * An array of passes - some filters contain a few steps this array simply stores the steps in a liniear fashion.\n    * For example the blur filter has two passes blurX and blurY.\n    * @property passes\n    * @type Array\n    * @private\n    */\n    this.passes = [this];\n\n    /**\n    * @property shaders\n    * @type Array\n    * @private\n    */\n    this.shaders = [];\n    \n    /**\n    * @property dirty\n    * @type Boolean\n    */\n    this.dirty = true;\n\n    /**\n    * @property padding\n    * @type Number\n    */\n    this.padding = 0;\n\n    /**\n    * @property uniforms\n    * @type Object\n    * @private\n    */\n    this.uniforms = uniforms || {};\n\n    /**\n    * @property fragmentSrc\n    * @type Array\n    * @private\n    */\n    this.fragmentSrc = fragmentSrc || [];\n};\n\nPIXI.AbstractFilter.prototype.constructor = PIXI.AbstractFilter;\n\n/**\n * Syncs the uniforms between the class object and the shaders.\n *\n * @method syncUniforms\n */\nPIXI.AbstractFilter.prototype.syncUniforms = function()\n{\n    for(var i=0,j=this.shaders.length; i<j; i++)\n    {\n        this.shaders[i].dirty = true;\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = PIXI;\n        }\n        exports.PIXI = PIXI;\n    } else if (typeof define !== 'undefined' && define.amd) {\n        define('PIXI', (function() { return root.PIXI = PIXI; })() );\n    } else {\n        root.PIXI = PIXI;\n    }\n\n    return PIXI;\n}).call(this);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/source-map-loader!./src/CustomizedDeps/pixi-custom.js\n// module id = 5\n// module chunks = 0","module.exports = global[\"Phaser\"] = require(\"-!/Users/tt/working/azarashi_tower_battle/node_modules/source-map-loader/index.js!./phaser-custom.js\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/CustomizedDeps/phaser-custom.js-exposed\n// module id = 6\n// module chunks = 0","/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*\n* @overview\n*\n* Phaser - http://phaser.io\n*\n* v2.6.2 \"Kore Springs\" - Built: Tue Sep 19 2017 00:23:48\n*\n* By Richard Davey http://www.photonstorm.com @photonstorm\n*\n* Phaser is a fun, free and fast 2D game framework for making HTML5 games\n* for desktop and mobile web browsers, supporting Canvas and WebGL rendering.\n*\n* Phaser uses Pixi.js for rendering, created by Mat Groves http://matgroves.com @Doormat23\n* Phaser uses p2.js for full-body physics, created by Stefan Hedman https://github.com/schteppe/p2.js @schteppe\n* Phaser contains a port of N+ Physics, converted by Richard Davey, original by http://www.metanetsoftware.com\n*\n* Many thanks to Adam Saltsman (@ADAMATOMIC) for releasing Flixel, from which both Phaser and my love of framework development originate.\n*\n* Follow development at http://phaser.io and on our forum\n*\n* \"If you want your children to be intelligent,  read them fairy tales.\"\n* \"If you want them to be more intelligent, read them more fairy tales.\"\n*                                                     -- Albert Einstein\n*/\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n(function(){\n\n    var root = this;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @namespace Phaser\n*/\nvar Phaser = Phaser || {    // jshint ignore:line\n\n    /**\n    * The Phaser version number.\n    * @constant\n    * @type {string}\n    */\n    VERSION: '2.6.2',\n\n    /**\n    * An array of Phaser game instances.\n    * @constant\n    * @type {array}\n    */\n    GAMES: [],\n\n    /**\n    * AUTO renderer - picks between WebGL or Canvas based on device.\n    * @constant\n    * @type {integer}\n    */\n    AUTO: 0,\n\n    /**\n    * Canvas Renderer.\n    * @constant\n    * @type {integer}\n    */\n    CANVAS: 1,\n\n    /**\n    * WebGL Renderer.\n    * @constant\n    * @type {integer}\n    */\n    WEBGL: 2,\n\n    /**\n    * Headless renderer (not visual output)\n    * @constant\n    * @type {integer}\n    */\n    HEADLESS: 3,\n\n    /**\n    * Direction constant.\n    * @constant\n    * @type {integer}\n    */\n    NONE: 0,\n\n    /**\n    * Direction constant.\n    * @constant\n    * @type {integer}\n    */\n    LEFT: 1,\n\n    /**\n    * Direction constant.\n    * @constant\n    * @type {integer}\n    */\n    RIGHT: 2,\n\n    /**\n    * Direction constant.\n    * @constant\n    * @type {integer}\n    */\n    UP: 3,\n\n    /**\n    * Direction constant.\n    * @constant\n    * @type {integer}\n    */\n    DOWN: 4,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    SPRITE: 0,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    BUTTON: 1,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    IMAGE: 2,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    GRAPHICS: 3,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    TEXT: 4,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    TILESPRITE: 5,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    BITMAPTEXT: 6,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    GROUP: 7,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    RENDERTEXTURE: 8,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    TILEMAP: 9,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    TILEMAPLAYER: 10,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    EMITTER: 11,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    POLYGON: 12,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    BITMAPDATA: 13,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    CANVAS_FILTER: 14,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    WEBGL_FILTER: 15,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    ELLIPSE: 16,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    SPRITEBATCH: 17,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    RETROFONT: 18,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    POINTER: 19,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    ROPE: 20,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    CIRCLE: 21,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    RECTANGLE: 22,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    LINE: 23,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    MATRIX: 24,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    POINT: 25,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    ROUNDEDRECTANGLE: 26,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    CREATURE: 27,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    VIDEO: 28,\n\n    /**\n    * Game Object type.\n    * @constant\n    * @type {integer}\n    */\n    PENDING_ATLAS: -1,\n\n    /**\n    * A horizontal orientation\n    * @constant\n    * @type {integer}\n    */\n    HORIZONTAL: 0,\n\n    /**\n    * A vertical orientation\n    * @constant\n    * @type {integer}\n    */\n    VERTICAL: 1,\n\n    /**\n    * A landscape orientation\n    * @constant\n    * @type {integer}\n    */\n    LANDSCAPE: 0,\n\n    /**\n    * A portrait orientation\n    * @constant\n    * @type {integer}\n    */\n    PORTRAIT: 1,\n\n    /**\n    * The Angle (in degrees) a Game Object needs to be set to in order to face up.\n    * @constant\n    * @type {integer}\n    */\n    ANGLE_UP: 270,\n\n    /**\n    * The Angle (in degrees) a Game Object needs to be set to in order to face down.\n    * @constant\n    * @type {integer}\n    */\n    ANGLE_DOWN: 90,\n\n    /**\n    * The Angle (in degrees) a Game Object needs to be set to in order to face left.\n    * @constant\n    * @type {integer}\n    */\n    ANGLE_LEFT: 180,\n\n    /**\n    * The Angle (in degrees) a Game Object needs to be set to in order to face right.\n    * @constant\n    * @type {integer}\n    */\n    ANGLE_RIGHT: 0,\n\n    /**\n    * The Angle (in degrees) a Game Object needs to be set to in order to face north east.\n    * @constant\n    * @type {integer}\n    */\n    ANGLE_NORTH_EAST: 315,\n\n    /**\n    * The Angle (in degrees) a Game Object needs to be set to in order to face north west.\n    * @constant\n    * @type {integer}\n    */\n    ANGLE_NORTH_WEST: 225,\n\n    /**\n    * The Angle (in degrees) a Game Object needs to be set to in order to face south east.\n    * @constant\n    * @type {integer}\n    */\n    ANGLE_SOUTH_EAST: 45,\n\n    /**\n    * The Angle (in degrees) a Game Object needs to be set to in order to face south west.\n    * @constant\n    * @type {integer}\n    */\n    ANGLE_SOUTH_WEST: 135,\n\n    /**\n    * A constant representing a top-left alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    TOP_LEFT: 0,\n\n    /**\n    * A constant representing a top-center alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    TOP_CENTER: 1,\n\n    /**\n    * A constant representing a top-right alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    TOP_RIGHT: 2,\n\n    /**\n    * A constant representing a left-top alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    LEFT_TOP: 3,\n\n    /**\n    * A constant representing a left-center alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    LEFT_CENTER: 4,\n\n    /**\n    * A constant representing a left-bottom alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    LEFT_BOTTOM: 5,\n\n    /**\n    * A constant representing a center alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    CENTER: 6,\n\n    /**\n    * A constant representing a right-top alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    RIGHT_TOP: 7,\n\n    /**\n    * A constant representing a right-center alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    RIGHT_CENTER: 8,\n\n    /**\n    * A constant representing a right-bottom alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    RIGHT_BOTTOM: 9,\n\n    /**\n    * A constant representing a bottom-left alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    BOTTOM_LEFT: 10,\n\n    /**\n    * A constant representing a bottom-center alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    BOTTOM_CENTER: 11,\n\n    /**\n    * A constant representing a bottom-right alignment or position.\n    * @constant\n    * @type {integer}\n    */\n    BOTTOM_RIGHT: 12,\n\n    /**\n     * Various blend modes supported by Pixi.\n     * \n     * IMPORTANT: The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.\n     * \n     * @constant\n     * @property {Number} blendModes.NORMAL\n     * @property {Number} blendModes.ADD\n     * @property {Number} blendModes.MULTIPLY\n     * @property {Number} blendModes.SCREEN\n     * @property {Number} blendModes.OVERLAY\n     * @property {Number} blendModes.DARKEN\n     * @property {Number} blendModes.LIGHTEN\n     * @property {Number} blendModes.COLOR_DODGE\n     * @property {Number} blendModes.COLOR_BURN\n     * @property {Number} blendModes.HARD_LIGHT\n     * @property {Number} blendModes.SOFT_LIGHT\n     * @property {Number} blendModes.DIFFERENCE\n     * @property {Number} blendModes.EXCLUSION\n     * @property {Number} blendModes.HUE\n     * @property {Number} blendModes.SATURATION\n     * @property {Number} blendModes.COLOR\n     * @property {Number} blendModes.LUMINOSITY\n     * @static\n     */\n    blendModes: {\n        NORMAL:0,\n        ADD:1,\n        MULTIPLY:2,\n        SCREEN:3,\n        OVERLAY:4,\n        DARKEN:5,\n        LIGHTEN:6,\n        COLOR_DODGE:7,\n        COLOR_BURN:8,\n        HARD_LIGHT:9,\n        SOFT_LIGHT:10,\n        DIFFERENCE:11,\n        EXCLUSION:12,\n        HUE:13,\n        SATURATION:14,\n        COLOR:15,\n        LUMINOSITY:16\n    },\n\n    /**\n     * The scale modes that are supported by Pixi.\n     *\n     * The DEFAULT scale mode affects the default scaling mode of future operations.\n     * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.\n     *\n     * @constant\n     * @property {Object} Phaser.scaleModes\n     * @property {Number} scaleModes.DEFAULT=LINEAR\n     * @property {Number} scaleModes.LINEAR Smooth scaling\n     * @property {Number} scaleModes.NEAREST Pixelating scaling\n     * @static\n     */\n    scaleModes: {\n        DEFAULT:0,\n        LINEAR:0,\n        NEAREST:1\n    },\n\n    PIXI: PIXI || {}\n\n};\n\n/**\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\nif (!Math.trunc) {\n    Math.trunc = function trunc(x) {\n        return x < 0 ? Math.ceil(x) : Math.floor(x);\n    };\n}\n\n/**\n* A polyfill for Function.prototype.bind\n*/\nif (!Function.prototype.bind) {\n\n    /* jshint freeze: false */\n    Function.prototype.bind = (function () {\n\n        var slice = Array.prototype.slice;\n\n        return function (thisArg) {\n\n            var target = this, boundArgs = slice.call(arguments, 1);\n\n            if (typeof target !== 'function')\n            {\n                throw new TypeError();\n            }\n\n            function bound() {\n                var args = boundArgs.concat(slice.call(arguments));\n                target.apply(this instanceof bound ? this : thisArg, args);\n            }\n\n            bound.prototype = (function F(proto) {\n                if (proto)\n                {\n                    F.prototype = proto;\n                }\n\n                if (!(this instanceof F))\n                {\n                    /* jshint supernew: true */\n                    return new F;\n                }\n            })(target.prototype);\n\n            return bound;\n        };\n    })();\n}\n\n/**\n* A polyfill for Array.isArray\n*/\nif (!Array.isArray)\n{\n    Array.isArray = function (arg)\n    {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n}\n\n/**\n* A polyfill for Array.forEach\n* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n*/\nif (!Array.prototype.forEach)\n{\n    Array.prototype.forEach = function(fun /*, thisArg */)\n    {\n        \"use strict\";\n\n        if (this === void 0 || this === null)\n        {\n            throw new TypeError();\n        }\n\n        var t = Object(this);\n        var len = t.length >>> 0;\n\n        if (typeof fun !== \"function\")\n        {\n            throw new TypeError();\n        }\n\n        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n\n        for (var i = 0; i < len; i++)\n        {\n            if (i in t)\n            {\n                fun.call(thisArg, t[i], i, t);\n            }\n        }\n    };\n}\n\n/**\n* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9\n* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/\n* Cameron Foale (http://www.kibibu.com)\n*/\nif (typeof window.Uint32Array !== \"function\" && typeof window.Uint32Array !== \"object\")\n{\n    var CheapArray = function(type)\n    {\n        var proto = new Array(); // jshint ignore:line\n\n        window[type] = function(arg) {\n\n            if (typeof(arg) === \"number\")\n            {\n                Array.call(this, arg);\n                this.length = arg;\n\n                for (var i = 0; i < this.length; i++)\n                {\n                    this[i] = 0;\n                }\n            }\n            else\n            {\n                Array.call(this, arg.length);\n\n                this.length = arg.length;\n\n                for (var i = 0; i < this.length; i++)\n                {\n                    this[i] = arg[i];\n                }\n            }\n        };\n\n        window[type].prototype = proto;\n        window[type].constructor = window[type];\n    };\n\n    CheapArray('Uint32Array'); // jshint ignore:line\n    CheapArray('Int16Array');  // jshint ignore:line\n}\n\n/**\n * Also fix for the absent console in IE9\n */\nif (!window.console)\n{\n    window.console = {};\n    window.console.log = window.console.assert = function(){};\n    window.console.warn = window.console.assert = function(){};\n}\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Utils\n* @static\n*/\nPhaser.Utils = {\n\n    /**\n    * Takes the given string and reverses it, returning the reversed string.\n    * For example if given the string `Atari 520ST` it would return `TS025 iratA`.\n    *\n    * @method Phaser.Utils.reverseString\n    * @param {string} string - The string to be reversed.\n    * @return {string} The reversed string.\n    */\n    reverseString: function (string) {\n\n        return string.split('').reverse().join('');\n\n    },\n\n    /**\n     * Gets an objects property by string.\n     *\n     * @method Phaser.Utils.getProperty\n     * @param {object} obj - The object to traverse.\n     * @param {string} prop - The property whose value will be returned.\n     * @return {*} the value of the property or null if property isn't found .\n     */\n    getProperty: function(obj, prop) {\n\n        var parts = prop.split('.'),\n            last = parts.pop(),\n            l = parts.length,\n            i = 1,\n            current = parts[0];\n\n        while (i < l && (obj = obj[current]))\n        {\n            current = parts[i];\n            i++;\n        }\n\n        if (obj)\n        {\n            return obj[last];\n        }\n        else\n        {\n            return null;\n        }\n\n    },\n\n    /**\n     * Sets an objects property by string.\n     *\n     * @method Phaser.Utils.setProperty\n     * @param {object} obj - The object to traverse\n     * @param {string} prop - The property whose value will be changed\n     * @return {object} The object on which the property was set.\n     */\n    setProperty: function(obj, prop, value) {\n\n        var parts = prop.split('.'),\n            last = parts.pop(),\n            l = parts.length,\n            i = 1,\n            current = parts[0];\n\n        while (i < l && (obj = obj[current]))\n        {\n            current = parts[i];\n            i++;\n        }\n\n        if (obj)\n        {\n            obj[last] = value;\n        }\n\n        return obj;\n\n    },\n\n    /**\n    * Generate a random bool result based on the chance value.\n    *\n    * Returns true or false based on the chance value (default 50%). For example if you wanted a player to have a 30% chance\n    * of getting a bonus, call chanceRoll(30) - true means the chance passed, false means it failed.\n    *\n    * @method Phaser.Utils#chanceRoll\n    * @param {number} chance - The chance of receiving the value. A number between 0 and 100 (effectively 0% to 100%).\n    * @return {boolean} True if the roll passed, or false otherwise.\n    */\n    chanceRoll: function (chance) {\n        if (chance === undefined) { chance = 50; }\n        return chance > 0 && (Math.random() * 100 <= chance);\n    },\n\n    /**\n    * Choose between one of two values randomly.\n    *\n    * @method Phaser.Utils#randomChoice\n    * @param {any} choice1\n    * @param {any} choice2\n    * @return {any} The randomly selected choice\n    */\n    randomChoice: function (choice1, choice2) {\n        return (Math.random() < 0.5) ? choice1 : choice2;\n    },\n\n    /**\n    * Get a unit dimension from a string.\n    *\n    * @method Phaser.Utils.parseDimension\n    * @param {string|number} size - The size to parse.\n    * @param {number} dimension - The window dimension to check.\n    * @return {number} The parsed dimension.\n    */\n    parseDimension: function (size, dimension) {\n\n        var f = 0;\n        var px = 0;\n\n        if (typeof size === 'string')\n        {\n            //  %?\n            if (size.substr(-1) === '%')\n            {\n                f = parseInt(size, 10) / 100;\n\n                if (dimension === 0)\n                {\n                    px = window.innerWidth * f;\n                }\n                else\n                {\n                    px = window.innerHeight * f;\n                }\n            }\n            else\n            {\n                px = parseInt(size, 10);\n            }\n        }\n        else\n        {\n            px = size;\n        }\n\n        return px;\n\n    },\n\n    /**\n    * Takes the given string and pads it out, to the length required, using the character\n    * specified. For example if you need a string to be 6 characters long, you can call:\n    *\n    * `pad('bob', 6, '-', 2)`\n    *\n    * This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.\n    *\n    * You can also use it to pad numbers (they are always returned as strings):\n    * \n    * `pad(512, 6, '0', 1)`\n    *\n    * Would return: `000512` with the string padded to the left.\n    *\n    * If you don't specify a direction it'll pad to both sides:\n    * \n    * `pad('c64', 7, '*')`\n    *\n    * Would return: `**c64**`\n    *\n    * @method Phaser.Utils.pad\n    * @param {string} str - The target string. `toString()` will be called on the string, which means you can also pass in common data types like numbers.\n    * @param {integer} [len=0] - The number of characters to be added.\n    * @param {string} [pad=\" \"] - The string to pad it out with (defaults to a space).\n    * @param {integer} [dir=3] - The direction dir = 1 (left), 2 (right), 3 (both).\n    * @return {string} The padded string.\n    */\n    pad: function (str, len, pad, dir) {\n\n        if (len === undefined) { var len = 0; }\n        if (pad === undefined) { var pad = ' '; }\n        if (dir === undefined) { var dir = 3; }\n\n        str = str.toString();\n\n        var padlen = 0;\n\n        if (len + 1 >= str.length)\n        {\n            switch (dir)\n            {\n                case 1:\n                    str = new Array(len + 1 - str.length).join(pad) + str;\n                    break;\n\n                case 3:\n                    var right = Math.ceil((padlen = len - str.length) / 2);\n                    var left = padlen - right;\n                    str = new Array(left+1).join(pad) + str + new Array(right+1).join(pad);\n                    break;\n\n                default:\n                    str = str + new Array(len + 1 - str.length).join(pad);\n                    break;\n            }\n        }\n\n        return str;\n\n    },\n\n    /**\n    * This is a slightly modified version of jQuery.isPlainObject.\n    * A plain object is an object whose internal class property is [object Object].\n    * @method Phaser.Utils.isPlainObject\n    * @param {object} obj - The object to inspect.\n    * @return {boolean} - true if the object is plain, otherwise false.\n    */\n    isPlainObject: function (obj) {\n\n        // Not plain objects:\n        // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n        // - DOM nodes\n        // - window\n        if (typeof(obj) !== \"object\" || obj.nodeType || obj === obj.window)\n        {\n            return false;\n        }\n\n        // Support: Firefox <20\n        // The try/catch suppresses exceptions thrown when attempting to access\n        // the \"constructor\" property of certain host objects, ie. |window.location|\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n        try {\n            if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\"))\n            {\n                return false;\n            }\n        } catch (e) {\n            return false;\n        }\n\n        // If the function hasn't returned already, we're confident that\n        // |obj| is a plain object, created by {} or constructed with new Object\n        return true;\n    },\n\n    /**\n    * This is a slightly modified version of http://api.jquery.com/jQuery.extend/\n    * \n    * @method Phaser.Utils.extend\n    * @param {boolean} deep - Perform a deep copy?\n    * @param {object} target - The target object to copy to.\n    * @return {object} The extended object.\n    */\n    extend: function () {\n\n        var options, name, src, copy, copyIsArray, clone,\n            target = arguments[0] || {},\n            i = 1,\n            length = arguments.length,\n            deep = false;\n\n        // Handle a deep copy situation\n        if (typeof target === \"boolean\")\n        {\n            deep = target;\n            target = arguments[1] || {};\n            // skip the boolean and the target\n            i = 2;\n        }\n\n        // extend Phaser if only one argument is passed\n        if (length === i)\n        {\n            target = this;\n            --i;\n        }\n\n        for (; i < length; i++)\n        {\n            // Only deal with non-null/undefined values\n            if ((options = arguments[i]) != null)\n            {\n                // Extend the base object\n                for (name in options)\n                {\n                    src = target[name];\n                    copy = options[name];\n\n                    // Prevent never-ending loop\n                    if (target === copy)\n                    {\n                        continue;\n                    }\n\n                    // Recurse if we're merging plain objects or arrays\n                    if (deep && copy && (Phaser.Utils.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))))\n                    {\n                        if (copyIsArray)\n                        {\n                            copyIsArray = false;\n                            clone = src && Array.isArray(src) ? src : [];\n                        }\n                        else\n                        {\n                            clone = src && Phaser.Utils.isPlainObject(src) ? src : {};\n                        }\n\n                        // Never move original objects, clone them\n                        target[name] = Phaser.Utils.extend(deep, clone, copy);\n\n                    // Don't bring in undefined values\n                    }\n                    else if (copy !== undefined)\n                    {\n                        target[name] = copy;\n                    }\n                }\n            }\n        }\n\n        // Return the modified object\n        return target;\n\n    },\n\n    /**\n    * Mixes in an existing mixin object with the target.\n    *\n    * Values in the mixin that have either `get` or `set` functions are created as properties via `defineProperty`\n    * _except_ if they also define a `clone` method - if a clone method is defined that is called instead and\n    * the result is assigned directly.\n    *\n    * @method Phaser.Utils.mixinPrototype\n    * @param {object} target - The target object to receive the new functions.\n    * @param {object} mixin - The object to copy the functions from.\n    * @param {boolean} [replace=false] - If the target object already has a matching function should it be overwritten or not?\n    */\n    mixinPrototype: function (target, mixin, replace) {\n    \n        if (replace === undefined) { replace = false; }\n\n        var mixinKeys = Object.keys(mixin);\n\n        for (var i = 0; i < mixinKeys.length; i++)\n        {\n            var key = mixinKeys[i];\n            var value = mixin[key];\n\n            if (!replace && (key in target))\n            {\n                //  Not overwriting existing property\n                continue;\n            }\n            else\n            {\n                if (value &&\n                    (typeof value.get === 'function' || typeof value.set === 'function'))\n                {\n                    //  Special case for classes like Phaser.Point which has a 'set' function!\n                    if (typeof value.clone === 'function')\n                    {\n                        target[key] = value.clone();\n                    }\n                    else\n                    {\n                        Object.defineProperty(target, key, value);\n                    }\n                }\n                else\n                {\n                    target[key] = value;\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Mixes the source object into the destination object, returning the newly modified destination object.\n    * Based on original code by @mudcube\n    *\n    * @method Phaser.Utils.mixin\n    * @param {object} from - The object to copy (the source object).\n    * @param {object} to - The object to copy to (the destination object).\n    * @return {object} The modified destination object.\n    */\n    mixin: function (from, to) {\n\n        if (!from || typeof (from) !== \"object\")\n        {\n            return to;\n        }\n\n        for (var key in from)\n        {\n            var o = from[key];\n\n            if (o.childNodes || o.cloneNode)\n            {\n                continue;\n            }\n\n            var type = typeof (from[key]);\n\n            if (!from[key] || type !== \"object\")\n            {\n                to[key] = from[key];\n            }\n            else\n            {\n                //  Clone sub-object\n                if (typeof (to[key]) === type)\n                {\n                    to[key] = Phaser.Utils.mixin(from[key], to[key]);\n                }\n                else\n                {\n                    to[key] = Phaser.Utils.mixin(from[key], new o.constructor());\n                }\n            }\n        }\n\n        return to;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new Circle object with the center coordinate specified by the x and y parameters and the diameter specified by the diameter parameter.\n* If you call this function without parameters, a circle with x, y, diameter and radius properties set to 0 is created.\n* \n* @class Phaser.Circle\n* @constructor\n* @param {number} [x=0] - The x coordinate of the center of the circle.\n* @param {number} [y=0] - The y coordinate of the center of the circle.\n* @param {number} [diameter=0] - The diameter of the circle.\n*/\nPhaser.Circle = function (x, y, diameter) {\n\n    x = x || 0;\n    y = y || 0;\n    diameter = diameter || 0;\n\n    /**\n    * @property {number} x - The x coordinate of the center of the circle.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The y coordinate of the center of the circle.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} _diameter - The diameter of the circle.\n    * @private\n    */\n    this._diameter = diameter;\n\n    /**\n   * @property {number} _radius - The radius of the circle.\n   * @private\n   */\n    this._radius = 0;\n\n    if (diameter > 0)\n    {\n        this._radius = diameter * 0.5;\n    }\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.CIRCLE;\n\n};\n\nPhaser.Circle.prototype = {\n\n    /**\n    * The circumference of the circle.\n    * \n    * @method Phaser.Circle#circumference\n    * @return {number} The circumference of the circle.\n    */\n    circumference: function () {\n\n        return 2 * (Math.PI * this._radius);\n\n    },\n\n    /**\n    * Returns a uniformly distributed random point from anywhere within this Circle.\n    * \n    * @method Phaser.Circle#random\n    * @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.\n    *     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.\n    * @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.\n    */\n    random: function (out) {\n\n        if (out === undefined) { out = new Phaser.Point(); }\n\n        var t = 2 * Math.PI * Math.random();\n        var u = Math.random() + Math.random();\n        var r = (u > 1) ? 2 - u : u;\n        var x = r * Math.cos(t);\n        var y = r * Math.sin(t);\n\n        out.x = this.x + (x * this.radius);\n        out.y = this.y + (y * this.radius);\n\n        return out;\n\n    },\n\n    /**\n    * Returns the framing rectangle of the circle as a Phaser.Rectangle object.\n    * \n    * @method Phaser.Circle#getBounds\n    * @return {Phaser.Rectangle} The bounds of the Circle.\n    */\n    getBounds: function () {\n\n        return new Phaser.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter);\n\n    },\n\n    /**\n    * Sets the members of Circle to the specified values.\n    * @method Phaser.Circle#setTo\n    * @param {number} x - The x coordinate of the center of the circle.\n    * @param {number} y - The y coordinate of the center of the circle.\n    * @param {number} diameter - The diameter of the circle.\n    * @return {Circle} This circle object.\n    */\n    setTo: function (x, y, diameter) {\n\n        this.x = x;\n        this.y = y;\n        this._diameter = diameter;\n        this._radius = diameter * 0.5;\n\n        return this;\n\n    },\n\n    /**\n    * Copies the x, y and diameter properties from any given object to this Circle.\n    * @method Phaser.Circle#copyFrom\n    * @param {any} source - The object to copy from.\n    * @return {Circle} This Circle object.\n    */\n    copyFrom: function (source) {\n\n        return this.setTo(source.x, source.y, source.diameter);\n\n    },\n\n    /**\n    * Copies the x, y and diameter properties from this Circle to any given object.\n    * @method Phaser.Circle#copyTo\n    * @param {any} dest - The object to copy to.\n    * @return {object} This dest object.\n    */\n    copyTo: function (dest) {\n\n        dest.x = this.x;\n        dest.y = this.y;\n        dest.diameter = this._diameter;\n\n        return dest;\n\n    },\n\n    /**\n    * Returns the distance from the center of the Circle object to the given object\n    * (can be Circle, Point or anything with x/y properties)\n    * @method Phaser.Circle#distance\n    * @param {object} dest - The target object. Must have visible x and y properties that represent the center of the object.\n    * @param {boolean} [round=false] - Round the distance to the nearest integer.\n    * @return {number} The distance between this Point object and the destination Point object.\n    */\n    distance: function (dest, round) {\n\n        var distance = Phaser.Math.distance(this.x, this.y, dest.x, dest.y);\n        return round ? Math.round(distance) : distance;\n\n    },\n\n    /**\n    * Returns a new Circle object with the same values for the x, y, width, and height properties as this Circle object.\n    * @method Phaser.Circle#clone\n    * @param {Phaser.Circle} output - Optional Circle object. If given the values will be set into the object, otherwise a brand new Circle object will be created and returned.\n    * @return {Phaser.Circle} The cloned Circle object.\n    */\n    clone: function (output) {\n\n        if (output === undefined || output === null)\n        {\n            output = new Phaser.Circle(this.x, this.y, this.diameter);\n        }\n        else\n        {\n            output.setTo(this.x, this.y, this.diameter);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Return true if the given x/y coordinates are within this Circle object.\n    * @method Phaser.Circle#contains\n    * @param {number} x - The X value of the coordinate to test.\n    * @param {number} y - The Y value of the coordinate to test.\n    * @return {boolean} True if the coordinates are within this circle, otherwise false.\n    */\n    contains: function (x, y) {\n\n        return Phaser.Circle.contains(this, x, y);\n\n    },\n\n    /**\n    * Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.\n    * @method Phaser.Circle#circumferencePoint\n    * @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.\n    * @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?\n    * @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.\n    * @return {Phaser.Point} The Point object holding the result.\n    */\n    circumferencePoint: function (angle, asDegrees, out) {\n\n        return Phaser.Circle.circumferencePoint(this, angle, asDegrees, out);\n\n    },\n\n    /**\n    * Adjusts the location of the Circle object, as determined by its center coordinate, by the specified amounts.\n    * @method Phaser.Circle#offset\n    * @param {number} dx - Moves the x value of the Circle object by this amount.\n    * @param {number} dy - Moves the y value of the Circle object by this amount.\n    * @return {Circle} This Circle object.\n    */\n    offset: function (dx, dy) {\n\n        this.x += dx;\n        this.y += dy;\n\n        return this;\n\n    },\n\n    /**\n    * Adjusts the location of the Circle object using a Point object as a parameter. This method is similar to the Circle.offset() method, except that it takes a Point object as a parameter.\n    * @method Phaser.Circle#offsetPoint\n    * @param {Point} point A Point object to use to offset this Circle object (or any valid object with exposed x and y properties).\n    * @return {Circle} This Circle object.\n    */\n    offsetPoint: function (point) {\n        return this.offset(point.x, point.y);\n    },\n\n    /**\n    * Returns a string representation of this object.\n    * @method Phaser.Circle#toString\n    * @return {string} a string representation of the instance.\n    */\n    toString: function () {\n        return \"[{Phaser.Circle (x=\" + this.x + \" y=\" + this.y + \" diameter=\" + this.diameter + \" radius=\" + this.radius + \")}]\";\n    }\n\n};\n\nPhaser.Circle.prototype.constructor = Phaser.Circle;\n\n/**\n* The largest distance between any two points on the circle. The same as the radius * 2.\n* \n* @name Phaser.Circle#diameter\n* @property {number} diameter - Gets or sets the diameter of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"diameter\", {\n\n    get: function () {\n        return this._diameter;\n    },\n\n    set: function (value) {\n\n        if (value > 0)\n        {\n            this._diameter = value;\n            this._radius = value * 0.5;\n        }\n    }\n\n});\n\n/**\n* The length of a line extending from the center of the circle to any point on the circle itself. The same as half the diameter.\n* @name Phaser.Circle#radius\n* @property {number} radius - Gets or sets the radius of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"radius\", {\n\n    get: function () {\n        return this._radius;\n    },\n\n    set: function (value) {\n\n        if (value > 0)\n        {\n            this._radius = value;\n            this._diameter = value * 2;\n        }\n\n    }\n\n});\n\n/**\n* The x coordinate of the leftmost point of the circle. Changing the left property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.\n* @name Phaser.Circle#left\n* @propety {number} left - Gets or sets the value of the leftmost point of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"left\", {\n\n    get: function () {\n        return this.x - this._radius;\n    },\n\n    set: function (value) {\n\n        if (value > this.x)\n        {\n            this._radius = 0;\n            this._diameter = 0;\n        }\n        else\n        {\n            this.radius = this.x - value;\n        }\n\n    }\n\n});\n\n/**\n* The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.\n* @name Phaser.Circle#right\n* @property {number} right - Gets or sets the value of the rightmost point of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"right\", {\n\n    get: function () {\n        return this.x + this._radius;\n    },\n\n    set: function (value) {\n\n        if (value < this.x)\n        {\n            this._radius = 0;\n            this._diameter = 0;\n        }\n        else\n        {\n            this.radius = value - this.x;\n        }\n\n    }\n\n});\n\n/**\n* The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter.\n* @name Phaser.Circle#top\n* @property {number} top - Gets or sets the top of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"top\", {\n\n    get: function () {\n        return this.y - this._radius;\n    },\n\n    set: function (value) {\n\n        if (value > this.y)\n        {\n            this._radius = 0;\n            this._diameter = 0;\n        }\n        else\n        {\n            this.radius = this.y - value;\n        }\n\n    }\n\n});\n\n/**\n* The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.\n* @name Phaser.Circle#bottom\n* @property {number} bottom - Gets or sets the bottom of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"bottom\", {\n\n    get: function () {\n        return this.y + this._radius;\n    },\n\n    set: function (value) {\n\n        if (value < this.y)\n        {\n            this._radius = 0;\n            this._diameter = 0;\n        }\n        else\n        {\n            this.radius = value - this.y;\n        }\n\n    }\n\n});\n\n/**\n* The area of this Circle.\n* @name Phaser.Circle#area\n* @property {number} area - The area of this circle.\n* @readonly\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"area\", {\n\n    get: function () {\n\n        if (this._radius > 0)\n        {\n            return Math.PI * this._radius * this._radius;\n        }\n        else\n        {\n            return 0;\n        }\n\n    }\n\n});\n\n/**\n* Determines whether or not this Circle object is empty. Will return a value of true if the Circle objects diameter is less than or equal to 0; otherwise false.\n* If set to true it will reset all of the Circle objects properties to 0. A Circle object is empty if its diameter is less than or equal to 0.\n* @name Phaser.Circle#empty\n* @property {boolean} empty - Gets or sets the empty state of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"empty\", {\n\n    get: function () {\n        return (this._diameter === 0);\n    },\n\n    set: function (value) {\n\n        if (value === true)\n        {\n            this.setTo(0, 0, 0);\n        }\n\n    }\n\n});\n\n/**\n* Return true if the given x/y coordinates are within the Circle object.\n* @method Phaser.Circle.contains\n* @param {Phaser.Circle} a - The Circle to be checked.\n* @param {number} x - The X value of the coordinate to test.\n* @param {number} y - The Y value of the coordinate to test.\n* @return {boolean} True if the coordinates are within this circle, otherwise false.\n*/\nPhaser.Circle.contains = function (a, x, y) {\n\n    //  Check if x/y are within the bounds first\n    if (a.radius > 0 && x >= a.left && x <= a.right && y >= a.top && y <= a.bottom)\n    {\n        var dx = (a.x - x) * (a.x - x);\n        var dy = (a.y - y) * (a.y - y);\n\n        return (dx + dy) <= (a.radius * a.radius);\n    }\n    else\n    {\n        return false;\n    }\n\n};\n\n/**\n* Determines whether the two Circle objects match. This method compares the x, y and diameter properties.\n* @method Phaser.Circle.equals\n* @param {Phaser.Circle} a - The first Circle object.\n* @param {Phaser.Circle} b - The second Circle object.\n* @return {boolean} A value of true if the object has exactly the same values for the x, y and diameter properties as this Circle object; otherwise false.\n*/\nPhaser.Circle.equals = function (a, b) {\n\n    return (a.x === b.x && a.y === b.y && a.diameter === b.diameter);\n\n};\n\n/**\n* Determines whether the two Circle objects intersect.\n* This method checks the radius distances between the two Circle objects to see if they intersect.\n* @method Phaser.Circle.intersects\n* @param {Phaser.Circle} a - The first Circle object.\n* @param {Phaser.Circle} b - The second Circle object.\n* @return {boolean} A value of true if the specified object intersects with this Circle object; otherwise false.\n*/\nPhaser.Circle.intersects = function (a, b) {\n\n    return (Phaser.Math.distance(a.x, a.y, b.x, b.y) <= (a.radius + b.radius));\n\n};\n\n/**\n* Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.\n* @method Phaser.Circle.circumferencePoint\n* @param {Phaser.Circle} a - The first Circle object.\n* @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.\n* @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?\n* @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.\n* @return {Phaser.Point} The Point object holding the result.\n*/\nPhaser.Circle.circumferencePoint = function (a, angle, asDegrees, out) {\n\n    if (asDegrees === undefined) { asDegrees = false; }\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    if (asDegrees === true)\n    {\n        angle = Phaser.Math.degToRad(angle);\n    }\n\n    out.x = a.x + a.radius * Math.cos(angle);\n    out.y = a.y + a.radius * Math.sin(angle);\n\n    return out;\n\n};\n\n/**\n* Checks if the given Circle and Rectangle objects intersect.\n* @method Phaser.Circle.intersectsRectangle\n* @param {Phaser.Circle} c - The Circle object to test.\n* @param {Phaser.Rectangle} r - The Rectangle object to test.\n* @return {boolean} True if the two objects intersect, otherwise false.\n*/\nPhaser.Circle.intersectsRectangle = function (c, r) {\n\n    var cx = Math.abs(c.x - r.x - r.halfWidth);\n    var xDist = r.halfWidth + c.radius;\n\n    if (cx > xDist)\n    {\n        return false;\n    }\n\n    var cy = Math.abs(c.y - r.y - r.halfHeight);\n    var yDist = r.halfHeight + c.radius;\n\n    if (cy > yDist)\n    {\n        return false;\n    }\n\n    if (cx <= r.halfWidth || cy <= r.halfHeight)\n    {\n        return true;\n    }\n\n    var xCornerDist = cx - r.halfWidth;\n    var yCornerDist = cy - r.halfHeight;\n    var xCornerDistSq = xCornerDist * xCornerDist;\n    var yCornerDistSq = yCornerDist * yCornerDist;\n    var maxCornerDistSq = c.radius * c.radius;\n\n    return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;\n\n};\n\n//   Because PIXI uses its own Circle, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Circle = Phaser.Circle;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @author       Chad Engler <chad@pantherdev.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a Ellipse object. A curve on a plane surrounding two focal points.\n* \n* @class Phaser.Ellipse\n* @constructor\n* @param {number} [x=0] - The X coordinate of the upper-left corner of the framing rectangle of this ellipse.\n* @param {number} [y=0] - The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.\n* @param {number} [width=0] - The overall width of this ellipse.\n* @param {number} [height=0] - The overall height of this ellipse.\n*/\nPhaser.Ellipse = function (x, y, width, height) {\n\n    x = x || 0;\n    y = y || 0;\n    width = width || 0;\n    height = height || 0;\n\n    /**\n    * @property {number} x - The X coordinate of the upper-left corner of the framing rectangle of this ellipse.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} width - The overall width of this ellipse.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The overall height of this ellipse.\n    */\n    this.height = height;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.ELLIPSE;\n\n};\n\nPhaser.Ellipse.prototype = {\n\n    /**\n    * Sets the members of the Ellipse to the specified values.\n    * @method Phaser.Ellipse#setTo\n    * @param {number} x - The X coordinate of the upper-left corner of the framing rectangle of this ellipse.\n    * @param {number} y - The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.\n    * @param {number} width - The overall width of this ellipse.\n    * @param {number} height - The overall height of this ellipse.\n    * @return {Phaser.Ellipse} This Ellipse object.\n    */\n    setTo: function (x, y, width, height) {\n\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        return this;\n\n    },\n\n    /**\n    * Returns the framing rectangle of the ellipse as a Phaser.Rectangle object.\n    * \n    * @method Phaser.Ellipse#getBounds\n    * @return {Phaser.Rectangle} The bounds of the Ellipse.\n    */\n    getBounds: function () {\n\n        return new Phaser.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n\n    },\n\n    /**\n    * Copies the x, y, width and height properties from any given object to this Ellipse.\n    * \n    * @method Phaser.Ellipse#copyFrom\n    * @param {any} source - The object to copy from.\n    * @return {Phaser.Ellipse} This Ellipse object.\n    */\n    copyFrom: function (source) {\n\n        return this.setTo(source.x, source.y, source.width, source.height);\n\n    },\n\n    /**\n    * Copies the x, y, width and height properties from this Ellipse to any given object.\n    * @method Phaser.Ellipse#copyTo\n    * @param {any} dest - The object to copy to.\n    * @return {object} This dest object.\n    */\n    copyTo: function(dest) {\n\n        dest.x = this.x;\n        dest.y = this.y;\n        dest.width = this.width;\n        dest.height = this.height;\n\n        return dest;\n\n    },\n\n    /**\n    * Returns a new Ellipse object with the same values for the x, y, width, and height properties as this Ellipse object.\n    * @method Phaser.Ellipse#clone\n    * @param {Phaser.Ellipse} output - Optional Ellipse object. If given the values will be set into the object, otherwise a brand new Ellipse object will be created and returned.\n    * @return {Phaser.Ellipse} The cloned Ellipse object.\n    */\n    clone: function(output) {\n\n        if (output === undefined || output === null)\n        {\n            output = new Phaser.Ellipse(this.x, this.y, this.width, this.height);\n        }\n        else\n        {\n            output.setTo(this.x, this.y, this.width, this.height);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Return true if the given x/y coordinates are within this Ellipse object.\n    * \n    * @method Phaser.Ellipse#contains\n    * @param {number} x - The X value of the coordinate to test.\n    * @param {number} y - The Y value of the coordinate to test.\n    * @return {boolean} True if the coordinates are within this ellipse, otherwise false.\n    */\n    contains: function (x, y) {\n\n        return Phaser.Ellipse.contains(this, x, y);\n\n    },\n\n    /**\n    * Returns a uniformly distributed random point from anywhere within this Ellipse.\n    * \n    * @method Phaser.Ellipse#random\n    * @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.\n    *     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.\n    * @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.\n    */\n    random: function (out) {\n\n        if (out === undefined) { out = new Phaser.Point(); }\n\n        var p = Math.random() * Math.PI * 2;\n        var r = Math.random();\n\n        out.x = Math.sqrt(r) * Math.cos(p);\n        out.y = Math.sqrt(r) * Math.sin(p);\n\n        out.x = this.x + (out.x * this.width / 2.0);\n        out.y = this.y + (out.y * this.height / 2.0);\n\n        return out;\n\n    },\n\n    /**\n    * Returns a string representation of this object.\n    * @method Phaser.Ellipse#toString\n    * @return {string} A string representation of the instance.\n    */\n    toString: function () {\n        return \"[{Phaser.Ellipse (x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \")}]\";\n    }\n\n};\n\nPhaser.Ellipse.prototype.constructor = Phaser.Ellipse;\n\n/**\n* The left coordinate of the Ellipse. The same as the X coordinate.\n* @name Phaser.Ellipse#left\n* @propety {number} left - Gets or sets the value of the leftmost point of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"left\", {\n\n    get: function () {\n        return this.x;\n    },\n\n    set: function (value) {\n\n        this.x = value;\n\n    }\n\n});\n\n/**\n* The x coordinate of the rightmost point of the Ellipse. Changing the right property of an Ellipse object has no effect on the x property, but does adjust the width.\n* @name Phaser.Ellipse#right\n* @property {number} right - Gets or sets the value of the rightmost point of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"right\", {\n\n    get: function () {\n        return this.x + this.width;\n    },\n\n    set: function (value) {\n\n        if (value < this.x)\n        {\n            this.width = 0;\n        }\n        else\n        {\n            this.width = value - this.x;\n        }\n    }\n\n});\n\n/**\n* The top of the Ellipse. The same as its y property.\n* @name Phaser.Ellipse#top\n* @property {number} top - Gets or sets the top of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"top\", {\n\n    get: function () {\n        return this.y;\n    },\n\n    set: function (value) {\n        this.y = value;\n    }\n\n});\n\n/**\n* The sum of the y and height properties. Changing the bottom property of an Ellipse doesn't adjust the y property, but does change the height.\n* @name Phaser.Ellipse#bottom\n* @property {number} bottom - Gets or sets the bottom of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"bottom\", {\n\n    get: function () {\n        return this.y + this.height;\n    },\n\n    set: function (value) {\n\n        if (value < this.y)\n        {\n            this.height = 0;\n        }\n        else\n        {\n            this.height = value - this.y;\n        }\n    }\n\n});\n\n/**\n* Determines whether or not this Ellipse object is empty. Will return a value of true if the Ellipse objects dimensions are less than or equal to 0; otherwise false.\n* If set to true it will reset all of the Ellipse objects properties to 0. An Ellipse object is empty if its width or height is less than or equal to 0.\n* @name Phaser.Ellipse#empty\n* @property {boolean} empty - Gets or sets the empty state of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"empty\", {\n\n    get: function () {\n        return (this.width === 0 || this.height === 0);\n    },\n\n    set: function (value) {\n\n        if (value === true)\n        {\n            this.setTo(0, 0, 0, 0);\n        }\n\n    }\n\n});\n\n/**\n* Return true if the given x/y coordinates are within the Ellipse object.\n* \n* @method Phaser.Ellipse.contains\n* @param {Phaser.Ellipse} a - The Ellipse to be checked.\n* @param {number} x - The X value of the coordinate to test.\n* @param {number} y - The Y value of the coordinate to test.\n* @return {boolean} True if the coordinates are within this ellipse, otherwise false.\n*/\nPhaser.Ellipse.contains = function (a, x, y) {\n \n    if (a.width <= 0 || a.height <= 0) {\n        return false;\n    }\n \n    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5\n    var normx = ((x - a.x) / a.width) - 0.5;\n    var normy = ((y - a.y) / a.height) - 0.5;\n \n    normx *= normx;\n    normy *= normy;\n \n    return (normx + normy < 0.25);\n \n};\n\n//   Because PIXI uses its own Ellipse, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Ellipse = Phaser.Ellipse;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new Line object with a start and an end point.\n*\n* @class Phaser.Line\n* @constructor\n* @param {number} [x1=0] - The x coordinate of the start of the line.\n* @param {number} [y1=0] - The y coordinate of the start of the line.\n* @param {number} [x2=0] - The x coordinate of the end of the line.\n* @param {number} [y2=0] - The y coordinate of the end of the line.\n*/\nPhaser.Line = function (x1, y1, x2, y2) {\n\n    x1 = x1 || 0;\n    y1 = y1 || 0;\n    x2 = x2 || 0;\n    y2 = y2 || 0;\n\n    /**\n    * @property {Phaser.Point} start - The start point of the line.\n    */\n    this.start = new Phaser.Point(x1, y1);\n\n    /**\n    * @property {Phaser.Point} end - The end point of the line.\n    */\n    this.end = new Phaser.Point(x2, y2);\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.LINE;\n\n};\n\nPhaser.Line.prototype = {\n\n    /**\n    * Sets the components of the Line to the specified values.\n    *\n    * @method Phaser.Line#setTo\n    * @param {number} [x1=0] - The x coordinate of the start of the line.\n    * @param {number} [y1=0] - The y coordinate of the start of the line.\n    * @param {number} [x2=0] - The x coordinate of the end of the line.\n    * @param {number} [y2=0] - The y coordinate of the end of the line.\n    * @return {Phaser.Line} This line object\n    */\n    setTo: function (x1, y1, x2, y2) {\n\n        this.start.setTo(x1, y1);\n        this.end.setTo(x2, y2);\n\n        return this;\n\n    },\n\n    /**\n    * Sets the line to match the x/y coordinates of the two given sprites.\n    * Can optionally be calculated from their center coordinates.\n    *\n    * @method Phaser.Line#fromSprite\n    * @param {Phaser.Sprite} startSprite - The coordinates of this Sprite will be set to the Line.start point.\n    * @param {Phaser.Sprite} endSprite - The coordinates of this Sprite will be set to the Line.start point.\n    * @param {boolean} [useCenter=false] - If true it will use startSprite.center.x, if false startSprite.x. Note that Sprites don't have a center property by default, so only enable if you've over-ridden your Sprite with a custom class.\n    * @return {Phaser.Line} This line object\n    */\n    fromSprite: function (startSprite, endSprite, useCenter) {\n\n        if (useCenter === undefined) { useCenter = false; }\n\n        if (useCenter)\n        {\n            return this.setTo(startSprite.center.x, startSprite.center.y, endSprite.center.x, endSprite.center.y);\n        }\n\n        return this.setTo(startSprite.x, startSprite.y, endSprite.x, endSprite.y);\n\n    },\n\n    /**\n    * Sets this line to start at the given `x` and `y` coordinates and for the segment to extend at `angle` for the given `length`.\n    *\n    * @method Phaser.Line#fromAngle\n    * @param {number} x - The x coordinate of the start of the line.\n    * @param {number} y - The y coordinate of the start of the line.\n    * @param {number} angle - The angle of the line in radians.\n    * @param {number} length - The length of the line in pixels.\n    * @return {Phaser.Line} This line object\n    */\n    fromAngle: function (x, y, angle, length) {\n\n        this.start.setTo(x, y);\n        this.end.setTo(x + (Math.cos(angle) * length), y + (Math.sin(angle) * length));\n\n        return this;\n\n    },\n\n    /**\n    * Rotates the line by the amount specified in `angle`.\n    *\n    * Rotation takes place from the center of the line.\n    * If you wish to rotate around a different point see Line.rotateAround.\n    *\n    * If you wish to rotate the ends of the Line then see Line.start.rotate or Line.end.rotate.\n    *\n    * @method Phaser.Line#rotate\n    * @param {number} angle - The angle in radians (unless asDegrees is true) to rotate the line by.\n    * @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?\n    * @return {Phaser.Line} This line object\n    */\n    rotate: function (angle, asDegrees) {\n\n        var cx = (this.start.x + this.end.x) / 2;\n        var cy = (this.start.y + this.end.y) / 2;\n\n        this.start.rotate(cx, cy, angle, asDegrees);\n        this.end.rotate(cx, cy, angle, asDegrees);\n\n        return this;\n\n    },\n\n    /**\n    * Rotates the line by the amount specified in `angle`.\n    *\n    * Rotation takes place around the coordinates given.\n    *\n    * @method Phaser.Line#rotateAround\n    * @param {number} x - The x coordinate to offset the rotation from.\n    * @param {number} y - The y coordinate to offset the rotation from.\n    * @param {number} angle - The angle in radians (unless asDegrees is true) to rotate the line by.\n    * @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?\n    * @return {Phaser.Line} This line object\n    */\n    rotateAround: function (x, y, angle, asDegrees) {\n\n        this.start.rotate(x, y, angle, asDegrees);\n        this.end.rotate(x, y, angle, asDegrees);\n\n        return this;\n\n    },\n\n    /**\n    * Checks for intersection between this line and another Line.\n    * If asSegment is true it will check for segment intersection. If asSegment is false it will check for line intersection.\n    * Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.\n    *\n    * @method Phaser.Line#intersects\n    * @param {Phaser.Line} line - The line to check against this one.\n    * @param {boolean} [asSegment=true] - If true it will check for segment intersection, otherwise full line intersection.\n    * @param {Phaser.Point} [result] - A Point object to store the result in, if not given a new one will be created.\n    * @return {Phaser.Point} The intersection segment of the two lines as a Point, or null if there is no intersection.\n    */\n    intersects: function (line, asSegment, result) {\n\n        return Phaser.Line.intersectsPoints(this.start, this.end, line.start, line.end, asSegment, result);\n\n    },\n\n    /**\n    * Returns the reflected angle between two lines.\n    * This is the outgoing angle based on the angle of this line and the normalAngle of the given line.\n    *\n    * @method Phaser.Line#reflect\n    * @param {Phaser.Line} line - The line to reflect off this line.\n    * @return {number} The reflected angle in radians.\n    */\n    reflect: function (line) {\n\n        return Phaser.Line.reflect(this, line);\n\n    },\n\n    /**\n    * Returns a Point object where the x and y values correspond to the center (or midpoint) of the Line segment.\n    *\n    * @method Phaser.Line#midPoint\n    * @param {Phaser.Point} [out] - A Phaser.Point object into which the result will be populated. If not given a new Point object is created.\n    * @return {Phaser.Point} A Phaser.Point object with the x and y values set to the center of the line segment.\n    */\n    midPoint: function (out) {\n\n        if (out === undefined) { out = new Phaser.Point(); }\n\n        out.x = (this.start.x + this.end.x) / 2;\n        out.y = (this.start.y + this.end.y) / 2;\n\n        return out;\n\n    },\n\n    /**\n    * Centers this Line on the given coordinates.\n    *\n    * The line is centered by positioning the start and end points so that the lines midpoint matches\n    * the coordinates given.\n    *\n    * @method Phaser.Line#centerOn\n    * @param {number} x - The x position to center the line on.\n    * @param {number} y - The y position to center the line on.\n    * @return {Phaser.Line} This line object\n    */\n    centerOn: function (x, y) {\n\n        var cx = (this.start.x + this.end.x) / 2;\n        var cy = (this.start.y + this.end.y) / 2;\n\n        var tx = x - cx;\n        var ty = y - cy;\n\n        this.start.add(tx, ty);\n        this.end.add(tx, ty);\n\n    },\n\n    /**\n    * Tests if the given coordinates fall on this line. See pointOnSegment to test against just the line segment.\n    *\n    * @method Phaser.Line#pointOnLine\n    * @param {number} x - The line to check against this one.\n    * @param {number} y - The line to check against this one.\n    * @return {boolean} True if the point is on the line, false if not.\n    */\n    pointOnLine: function (x, y) {\n\n        return ((x - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (y - this.start.y));\n\n    },\n\n    /**\n    * Tests if the given coordinates fall on this line and within the segment. See pointOnLine to test against just the line.\n    *\n    * @method Phaser.Line#pointOnSegment\n    * @param {number} x - The line to check against this one.\n    * @param {number} y - The line to check against this one.\n    * @return {boolean} True if the point is on the line and segment, false if not.\n    */\n    pointOnSegment: function (x, y) {\n\n        var xMin = Math.min(this.start.x, this.end.x);\n        var xMax = Math.max(this.start.x, this.end.x);\n        var yMin = Math.min(this.start.y, this.end.y);\n        var yMax = Math.max(this.start.y, this.end.y);\n\n        return (this.pointOnLine(x, y) && (x >= xMin && x <= xMax) && (y >= yMin && y <= yMax));\n\n    },\n\n    /**\n    * Picks a random point from anywhere on the Line segment and returns it.\n    *\n    * @method Phaser.Line#random\n    * @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.\n    *     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an object.\n    * @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.\n    */\n    random: function (out) {\n\n        if (out === undefined) { out = new Phaser.Point(); }\n\n        var t = Math.random();\n\n        out.x = this.start.x + t * (this.end.x - this.start.x);\n        out.y = this.start.y + t * (this.end.y - this.start.y);\n\n        return out;\n\n    },\n\n    /**\n    * Using Bresenham's line algorithm this will return an array of all coordinates on this line.\n    * The start and end points are rounded before this runs as the algorithm works on integers.\n    *\n    * @method Phaser.Line#coordinatesOnLine\n    * @param {number} [stepRate=1] - How many steps will we return? 1 = every coordinate on the line, 2 = every other coordinate, etc.\n    * @param {array} [results] - The array to store the results in. If not provided a new one will be generated.\n    * @return {array} An array of coordinates.\n    */\n    coordinatesOnLine: function (stepRate, results) {\n\n        if (stepRate === undefined) { stepRate = 1; }\n        if (results === undefined) { results = []; }\n\n        var x1 = Math.round(this.start.x);\n        var y1 = Math.round(this.start.y);\n        var x2 = Math.round(this.end.x);\n        var y2 = Math.round(this.end.y);\n\n        var dx = Math.abs(x2 - x1);\n        var dy = Math.abs(y2 - y1);\n        var sx = (x1 < x2) ? 1 : -1;\n        var sy = (y1 < y2) ? 1 : -1;\n        var err = dx - dy;\n\n        results.push([x1, y1]);\n\n        var i = 1;\n\n        while (!((x1 === x2) && (y1 === y2)))\n        {\n            var e2 = err << 1;\n\n            if (e2 > -dy)\n            {\n                err -= dy;\n                x1 += sx;\n            }\n\n            if (e2 < dx)\n            {\n                err += dx;\n                y1 += sy;\n            }\n\n            if (i % stepRate === 0)\n            {\n                results.push([x1, y1]);\n            }\n\n            i++;\n\n        }\n\n        return results;\n\n    },\n\n    /**\n     * Returns a new Line object with the same values for the start and end properties as this Line object.\n     * @method Phaser.Line#clone\n     * @param {Phaser.Line} output - Optional Line object. If given the values will be set into the object, otherwise a brand new Line object will be created and returned.\n     * @return {Phaser.Line} The cloned Line object.\n     */\n    clone: function (output) {\n\n        if (output === undefined || output === null)\n        {\n            output = new Phaser.Line(this.start.x, this.start.y, this.end.x, this.end.y);\n        }\n        else\n        {\n            output.setTo(this.start.x, this.start.y, this.end.x, this.end.y);\n        }\n\n        return output;\n\n    }\n\n};\n\n/**\n* @name Phaser.Line#length\n* @property {number} length - Gets the length of the line segment.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"length\", {\n\n    get: function () {\n        return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));\n    }\n\n});\n\n/**\n* @name Phaser.Line#angle\n* @property {number} angle - Gets the angle of the line in radians.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"angle\", {\n\n    get: function () {\n        return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#slope\n* @property {number} slope - Gets the slope of the line (y/x).\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"slope\", {\n\n    get: function () {\n        return (this.end.y - this.start.y) / (this.end.x - this.start.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#perpSlope\n* @property {number} perpSlope - Gets the perpendicular slope of the line (x/y).\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"perpSlope\", {\n\n    get: function () {\n        return -((this.end.x - this.start.x) / (this.end.y - this.start.y));\n    }\n\n});\n\n/**\n* @name Phaser.Line#x\n* @property {number} x - Gets the x coordinate of the top left of the bounds around this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"x\", {\n\n    get: function () {\n        return Math.min(this.start.x, this.end.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#y\n* @property {number} y - Gets the y coordinate of the top left of the bounds around this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"y\", {\n\n    get: function () {\n        return Math.min(this.start.y, this.end.y);\n    }\n\n});\n\n/**\n* @name Phaser.Line#left\n* @property {number} left - Gets the left-most point of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"left\", {\n\n    get: function () {\n        return Math.min(this.start.x, this.end.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#right\n* @property {number} right - Gets the right-most point of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"right\", {\n\n    get: function () {\n        return Math.max(this.start.x, this.end.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#top\n* @property {number} top - Gets the top-most point of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"top\", {\n\n    get: function () {\n        return Math.min(this.start.y, this.end.y);\n    }\n\n});\n\n/**\n* @name Phaser.Line#bottom\n* @property {number} bottom - Gets the bottom-most point of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"bottom\", {\n\n    get: function () {\n        return Math.max(this.start.y, this.end.y);\n    }\n\n});\n\n/**\n* @name Phaser.Line#width\n* @property {number} width - Gets the width of this bounds of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"width\", {\n\n    get: function () {\n        return Math.abs(this.start.x - this.end.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#height\n* @property {number} height - Gets the height of this bounds of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"height\", {\n\n    get: function () {\n        return Math.abs(this.start.y - this.end.y);\n    }\n\n});\n\n/**\n* @name Phaser.Line#normalX\n* @property {number} normalX - Gets the x component of the left-hand normal of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"normalX\", {\n\n    get: function () {\n        return Math.cos(this.angle - 1.5707963267948966);\n    }\n\n});\n\n/**\n* @name Phaser.Line#normalY\n* @property {number} normalY - Gets the y component of the left-hand normal of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"normalY\", {\n\n    get: function () {\n        return Math.sin(this.angle - 1.5707963267948966);\n    }\n\n});\n\n/**\n* @name Phaser.Line#normalAngle\n* @property {number} normalAngle - Gets the angle in radians of the normal of this line (line.angle - 90 degrees.)\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"normalAngle\", {\n\n    get: function () {\n        return Phaser.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI);\n    }\n\n});\n\n/**\n* Checks for intersection between two lines as defined by the given start and end points.\n* If asSegment is true it will check for line segment intersection. If asSegment is false it will check for line intersection.\n* Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.\n* Adapted from code by Keith Hair\n*\n* @method Phaser.Line.intersectsPoints\n* @param {Phaser.Point} a - The start of the first Line to be checked.\n* @param {Phaser.Point} b - The end of the first line to be checked.\n* @param {Phaser.Point} e - The start of the second Line to be checked.\n* @param {Phaser.Point} f - The end of the second line to be checked.\n* @param {boolean} [asSegment=true] - If true it will check for segment intersection, otherwise full line intersection.\n* @param {Phaser.Point|object} [result] - A Point object to store the result in, if not given a new one will be created.\n* @return {Phaser.Point} The intersection segment of the two lines as a Point, or null if there is no intersection.\n*/\nPhaser.Line.intersectsPoints = function (a, b, e, f, asSegment, result) {\n\n    if (asSegment === undefined) { asSegment = true; }\n    if (result === undefined) { result = new Phaser.Point(); }\n\n    var a1 = b.y - a.y;\n    var a2 = f.y - e.y;\n    var b1 = a.x - b.x;\n    var b2 = e.x - f.x;\n    var c1 = (b.x * a.y) - (a.x * b.y);\n    var c2 = (f.x * e.y) - (e.x * f.y);\n    var denom = (a1 * b2) - (a2 * b1);\n\n    if (denom === 0)\n    {\n        return null;\n    }\n\n    result.x = ((b1 * c2) - (b2 * c1)) / denom;\n    result.y = ((a2 * c1) - (a1 * c2)) / denom;\n\n    if (asSegment)\n    {\n        var uc = ((f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y));\n        var ua = (((f.x - e.x) * (a.y - e.y)) - (f.y - e.y) * (a.x - e.x)) / uc;\n        var ub = (((b.x - a.x) * (a.y - e.y)) - ((b.y - a.y) * (a.x - e.x))) / uc;\n\n        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)\n        {\n            return result;\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    return result;\n\n};\n\n/**\n* Checks for intersection between two lines.\n* If asSegment is true it will check for segment intersection.\n* If asSegment is false it will check for line intersection.\n* Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.\n* Adapted from code by Keith Hair\n*\n* @method Phaser.Line.intersects\n* @param {Phaser.Line} a - The first Line to be checked.\n* @param {Phaser.Line} b - The second Line to be checked.\n* @param {boolean} [asSegment=true] - If true it will check for segment intersection, otherwise full line intersection.\n* @param {Phaser.Point} [result] - A Point object to store the result in, if not given a new one will be created.\n* @return {Phaser.Point} The intersection segment of the two lines as a Point, or null if there is no intersection.\n*/\nPhaser.Line.intersects = function (a, b, asSegment, result) {\n\n    return Phaser.Line.intersectsPoints(a.start, a.end, b.start, b.end, asSegment, result);\n\n};\n\n/**\n* Checks for intersection between the Line and a Rectangle shape, or a rectangle-like\n* object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.\n*\n* An intersection is considered valid if:\n*\n* The line starts within, or ends within, the Rectangle.\n* The line segment intersects one of the 4 rectangle edges.\n*\n* The for the purposes of this function rectangles are considered 'solid'.\n*\n* @method Phaser.Line.intersectsRectangle\n* @param {Phaser.Line} line - The line to check for intersection with.\n* @param {Phaser.Rectangle|object} rect - The rectangle, or rectangle-like object, to check for intersection with.\n* @return {boolean} True if the line intersects with the rectangle edges, or starts or ends within the rectangle.\n*/\nPhaser.Line.intersectsRectangle = function (line, rect) {\n\n    //  Quick bail out of the Line and Rect bounds don't intersect\n    if (!Phaser.Rectangle.intersects(line, rect))\n    {\n        return false;\n    }\n\n    var x1 = line.start.x;\n    var y1 = line.start.y;\n\n    var x2 = line.end.x;\n    var y2 = line.end.y;\n\n    var bx1 = rect.x;\n    var by1 = rect.y;\n    var bx2 = rect.right;\n    var by2 = rect.bottom;\n\n    var t = 0;\n\n    //  If the start or end of the line is inside the rect then we assume\n    //  collision, as rects are solid for our use-case.\n\n    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||\n        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))\n    {\n        return true;\n    }\n\n    if (x1 < bx1 && x2 >= bx1)\n    {\n        //  Left edge\n        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);\n\n        if (t > by1 && t <= by2)\n        {\n            return true;\n        }\n    }\n    else if (x1 > bx2 && x2 <= bx2)\n    {\n        //  Right edge\n        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);\n\n        if (t >= by1 && t <= by2)\n        {\n            return true;\n        }\n    }\n\n    if (y1 < by1 && y2 >= by1)\n    {\n        //  Top edge\n        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);\n\n        if (t >= bx1 && t <= bx2)\n        {\n            return true;\n        }\n    }\n    else if (y1 > by2 && y2 <= by2)\n    {\n        //  Bottom edge\n        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);\n\n        if (t >= bx1 && t <= bx2)\n        {\n            return true;\n        }\n    }\n\n    return false;\n\n};\n\n/**\n* Returns the reflected angle between two lines.\n* This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.\n*\n* @method Phaser.Line.reflect\n* @param {Phaser.Line} a - The base line.\n* @param {Phaser.Line} b - The line to be reflected from the base line.\n* @return {number} The reflected angle in radians.\n*/\nPhaser.Line.reflect = function (a, b) {\n\n    return 2 * b.normalAngle - 3.141592653589793 - a.angle;\n\n};\n\n/**\n* @author       Mat Groves http://matgroves.com/ @Doormat23\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Matrix is a 3x3 matrix mostly used for display transforms within the renderer.\n* \n* It is represented like so:\n* \n* | a | b | tx |\n* | c | d | ty |\n* | 0 | 0 | 1 |\n*\n* @class Phaser.Matrix\n* @constructor\n* @param {number} [a=1] - Horizontal scaling\n* @param {number} [b=0] - Horizontal skewing\n* @param {number} [c=0] - Vertical skewing\n* @param {number} [d=1] - Vertical scaling\n* @param {number} [tx=0] - Horizontal translation\n* @param {number} [ty=0] - Vertical translation\n*/\nPhaser.Matrix = function (a, b, c, d, tx, ty) {\n\n    if (a === undefined || a === null) { a = 1; }\n    if (b === undefined || b === null) { b = 0; }\n    if (c === undefined || c === null) { c = 0; }\n    if (d === undefined || d === null) { d = 1; }\n    if (tx === undefined || tx === null) { tx = 0; }\n    if (ty === undefined || ty === null) { ty = 0; }\n\n    /**\n    * @property {number} a\n    * @default 1\n    */\n    this.a = a;\n\n    /**\n    * @property {number} b\n    * @default 0\n    */\n    this.b = b;\n\n    /**\n    * @property {number} c\n    * @default 0\n    */\n    this.c = c;\n\n    /**\n    * @property {number} d\n    * @default 1\n    */\n    this.d = d;\n\n    /**\n    * @property {number} tx\n    * @default 0\n    */\n    this.tx = tx;\n\n    /**\n    * @property {number} ty\n    * @default 0\n    */\n    this.ty = ty;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.MATRIX;\n\n};\n\nPhaser.Matrix.prototype = {\n\n    /**\n    * Sets the values of this Matrix to the values in the given array.\n    * \n    * The Array elements should be set as follows:\n    *\n    * a = array[0]\n    * b = array[1]\n    * c = array[3]\n    * d = array[4]\n    * tx = array[2]\n    * ty = array[5]\n    *\n    * @method Phaser.Matrix#fromArray\n    * @param {Array} array - The array to copy from.\n    * @return {Phaser.Matrix} This Matrix object.\n    */\n    fromArray: function (array) {\n\n        return this.setTo(array[0], array[1], array[3], array[4], array[2], array[5]);\n\n    },\n\n    /**\n    * Sets the values of this Matrix to the given values.\n    *\n    * @method Phaser.Matrix#setTo\n    * @param {number} a - Horizontal scaling\n    * @param {number} b - Horizontal skewing\n    * @param {number} c - Vertical skewing\n    * @param {number} d - Vertical scaling\n    * @param {number} tx - Horizontal translation\n    * @param {number} ty - Vertical translation\n    * @return {Phaser.Matrix} This Matrix object.\n    */\n    setTo: function (a, b, c, d, tx, ty) {\n\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n\n    },\n\n    /**\n     * Creates a new Matrix object based on the values of this Matrix.\n     * If you provide the output parameter the values of this Matrix will be copied over to it.\n     * If the output parameter is blank a new Matrix object will be created.\n     *\n     * @method Phaser.Matrix#clone\n     * @param {Phaser.Matrix} [output] - If provided the values of this Matrix will be copied to it, otherwise a new Matrix object is created.\n     * @return {Phaser.Matrix} A clone of this Matrix.\n     */\n    clone: function (output) {\n\n        if (output === undefined || output === null)\n        {\n            output = new Phaser.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\n        }\n        else\n        {\n            output.a = this.a;\n            output.b = this.b;\n            output.c = this.c;\n            output.d = this.d;\n            output.tx = this.tx;\n            output.ty = this.ty;\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Copies the properties from this Matrix to the given Matrix.\n    *\n    * @method Phaser.Matrix#copyTo\n    * @param {Phaser.Matrix} matrix - The Matrix to copy from.\n    * @return {Phaser.Matrix} The destination Matrix object.\n    */\n    copyTo: function (matrix) {\n\n        matrix.copyFrom(this);\n\n        return matrix;\n\n    },\n\n    /**\n    * Copies the properties from the given Matrix into this Matrix.\n    *\n    * @method Phaser.Matrix#copyFrom\n    * @param {Phaser.Matrix} matrix - The Matrix to copy from.\n    * @return {Phaser.Matrix} This Matrix object.\n    */\n    copyFrom: function (matrix) {\n\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n\n        return this;\n\n    },\n\n    /**\n    * Creates a Float32 Array with values populated from this Matrix object.\n    *\n    * @method Phaser.Matrix#toArray\n    * @param {boolean} [transpose=false] - Whether the values in the array are transposed or not.\n    * @param {PIXI.Float32Array} [array] - If provided the values will be set into this array, otherwise a new Float32Array is created.\n    * @return {PIXI.Float32Array} The newly created array which contains the matrix.\n    */\n    toArray: function (transpose, array) {\n\n        if (array === undefined) { array = new PIXI.Float32Array(9); }\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n\n    },\n\n    /**\n    * Get a new position with the current transformation applied.\n    * \n    * Can be used to go from a childs coordinate space to the world coordinate space (e.g. rendering)\n    *\n    * @method Phaser.Matrix#apply\n    * @param {Phaser.Point} pos - The origin Point.\n    * @param {Phaser.Point} [newPos] - The point that the new position is assigned to. This can be same as input point.\n    * @return {Phaser.Point} The new point, transformed through this matrix.\n    */\n    apply: function (pos, newPos) {\n\n        if (newPos === undefined) { newPos = new Phaser.Point(); }\n\n        newPos.x = this.a * pos.x + this.c * pos.y + this.tx;\n        newPos.y = this.b * pos.x + this.d * pos.y + this.ty;\n\n        return newPos;\n\n    },\n\n    /**\n    * Get a new position with the inverse of the current transformation applied.\n    * \n    * Can be used to go from the world coordinate space to a childs coordinate space. (e.g. input)\n    *\n    * @method Phaser.Matrix#applyInverse\n    * @param {Phaser.Point} pos - The origin Point.\n    * @param {Phaser.Point} [newPos] - The point that the new position is assigned to. This can be same as input point.\n    * @return {Phaser.Point} The new point, inverse transformed through this matrix.\n    */\n    applyInverse: function (pos, newPos) {\n\n        if (newPos === undefined) { newPos = new Phaser.Point(); }\n\n        var id = 1 / (this.a * this.d + this.c * -this.b);\n        var x = pos.x;\n        var y = pos.y;\n\n        newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;\n        newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;\n\n        return newPos;\n\n    },\n\n    /**\n    * Translates the matrix on the x and y.\n    * This is the same as Matrix.tx += x.\n    * \n    * @method Phaser.Matrix#translate\n    * @param {number} x - The x value to translate on.\n    * @param {number} y - The y value to translate on.\n    * @return {Phaser.Matrix} This Matrix object.\n    */\n    translate: function (x, y) {\n\n        this.tx += x;\n        this.ty += y;\n        \n        return this;\n\n    },\n\n    /**\n    * Applies a scale transformation to this matrix.\n    * \n    * @method Phaser.Matrix#scale\n    * @param {number} x - The amount to scale horizontally.\n    * @param {number} y - The amount to scale vertically.\n    * @return {Phaser.Matrix} This Matrix object.\n    */\n    scale: function (x, y) {\n\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n\n    },\n\n    /**\n    * Applies a rotation transformation to this matrix.\n    * \n    * @method Phaser.Matrix#rotate\n    * @param {number} angle - The angle to rotate by, given in radians.\n    * @return {Phaser.Matrix} This Matrix object.\n    */\n    rotate: function (angle) {\n\n        var cos = Math.cos(angle);\n        var sin = Math.sin(angle);\n\n        var a1 = this.a;\n        var c1 = this.c;\n        var tx1 = this.tx;\n\n        this.a = a1 * cos-this.b * sin;\n        this.b = a1 * sin+this.b * cos;\n        this.c = c1 * cos-this.d * sin;\n        this.d = c1 * sin+this.d * cos;\n        this.tx = tx1 * cos - this.ty * sin;\n        this.ty = tx1 * sin + this.ty * cos;\n     \n        return this;\n\n    },\n\n    /**\n    * Appends the given Matrix to this Matrix.\n    * \n    * @method Phaser.Matrix#append\n    * @param {Phaser.Matrix} matrix - The matrix to append to this one.\n    * @return {Phaser.Matrix} This Matrix object.\n    */\n    append: function (matrix) {\n\n        var a1 = this.a;\n        var b1 = this.b;\n        var c1 = this.c;\n        var d1 = this.d;\n\n        this.a  = matrix.a * a1 + matrix.b * c1;\n        this.b  = matrix.a * b1 + matrix.b * d1;\n        this.c  = matrix.c * a1 + matrix.d * c1;\n        this.d  = matrix.c * b1 + matrix.d * d1;\n\n        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n        \n        return this;\n\n    },\n\n    /**\n    * Resets this Matrix to an identity (default) matrix.\n    * \n    * @method Phaser.Matrix#identity\n    * @return {Phaser.Matrix} This Matrix object.\n    */\n    identity: function () {\n\n        return this.setTo(1, 0, 0, 1, 0, 0);\n\n    }\n\n};\n\nPhaser.identityMatrix = new Phaser.Matrix();\n\n//  Because PIXI uses its own type, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Matrix = Phaser.Matrix;\nPIXI.identityMatrix = Phaser.identityMatrix;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.\n* The following code creates a point at (0,0):\n* `var myPoint = new Phaser.Point();`\n* You can also use them as 2D Vectors and you'll find different vector related methods in this class.\n* \n* @class Phaser.Point\n* @constructor\n* @param {number} [x=0] - The horizontal position of this Point.\n* @param {number} [y=0] - The vertical position of this Point.\n*/\nPhaser.Point = function (x, y) {\n\n    x = x || 0;\n    y = y || 0;\n\n    /**\n    * @property {number} x - The x value of the point.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The y value of the point.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.POINT;\n\n};\n\nPhaser.Point.prototype = {\n\n    /**\n    * Copies the x and y properties from any given object to this Point.\n    *\n    * @method Phaser.Point#copyFrom\n    * @param {any} source - The object to copy from.\n    * @return {Phaser.Point} This Point object.\n    */\n    copyFrom: function (source) {\n\n        return this.setTo(source.x, source.y);\n\n    },\n\n    /**\n    * Inverts the x and y values of this Point\n    *\n    * @method Phaser.Point#invert\n    * @return {Phaser.Point} This Point object.\n    */\n    invert: function () {\n\n        return this.setTo(this.y, this.x);\n\n    },\n\n    /**\n    * Sets the `x` and `y` values of this Point object to the given values.\n    * If you omit the `y` value then the `x` value will be applied to both, for example:\n    * `Point.setTo(2)` is the same as `Point.setTo(2, 2)`\n    *\n    * @method Phaser.Point#setTo\n    * @param {number} x - The horizontal value of this point.\n    * @param {number} [y] - The vertical value of this point. If not given the x value will be used in its place.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    setTo: function (x, y) {\n\n        this.x = x || 0;\n        this.y = y || ( (y !== 0) ? this.x : 0 );\n\n        return this;\n\n    },\n\n    /**\n    * Sets the `x` and `y` values of this Point object to the given values.\n    * If you omit the `y` value then the `x` value will be applied to both, for example:\n    * `Point.set(2)` is the same as `Point.set(2, 2)`\n    *\n    * @method Phaser.Point#set\n    * @param {number} x - The horizontal value of this point.\n    * @param {number} [y] - The vertical value of this point. If not given the x value will be used in its place.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    set: function (x, y) {\n\n        this.x = x || 0;\n        this.y = y || ( (y !== 0) ? this.x : 0 );\n\n        return this;\n\n    },\n\n    /**\n    * Adds the given x and y values to this Point.\n    *\n    * @method Phaser.Point#add\n    * @param {number} x - The value to add to Point.x.\n    * @param {number} y - The value to add to Point.y.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    add: function (x, y) {\n\n        this.x += x;\n        this.y += y;\n        return this;\n\n    },\n\n    /**\n    * Subtracts the given x and y values from this Point.\n    *\n    * @method Phaser.Point#subtract\n    * @param {number} x - The value to subtract from Point.x.\n    * @param {number} y - The value to subtract from Point.y.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    subtract: function (x, y) {\n\n        this.x -= x;\n        this.y -= y;\n        return this;\n\n    },\n\n    /**\n    * Multiplies Point.x and Point.y by the given x and y values. Sometimes known as `Scale`.\n    *\n    * @method Phaser.Point#multiply\n    * @param {number} x - The value to multiply Point.x by.\n    * @param {number} y - The value to multiply Point.x by.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    multiply: function (x, y) {\n\n        this.x *= x;\n        this.y *= y;\n        return this;\n\n    },\n\n    /**\n    * Divides Point.x and Point.y by the given x and y values.\n    *\n    * @method Phaser.Point#divide\n    * @param {number} x - The value to divide Point.x by.\n    * @param {number} y - The value to divide Point.x by.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    divide: function (x, y) {\n\n        this.x /= x;\n        this.y /= y;\n        return this;\n\n    },\n\n    /**\n    * Clamps the x value of this Point to be between the given min and max.\n    *\n    * @method Phaser.Point#clampX\n    * @param {number} min - The minimum value to clamp this Point to.\n    * @param {number} max - The maximum value to clamp this Point to.\n    * @return {Phaser.Point} This Point object.\n    */\n    clampX: function (min, max) {\n\n        this.x = Phaser.Math.clamp(this.x, min, max);\n        return this;\n\n    },\n\n    /**\n    * Clamps the y value of this Point to be between the given min and max\n    *\n    * @method Phaser.Point#clampY\n    * @param {number} min - The minimum value to clamp this Point to.\n    * @param {number} max - The maximum value to clamp this Point to.\n    * @return {Phaser.Point} This Point object.\n    */\n    clampY: function (min, max) {\n\n        this.y = Phaser.Math.clamp(this.y, min, max);\n        return this;\n\n    },\n\n    /**\n    * Clamps this Point object values to be between the given min and max.\n    *\n    * @method Phaser.Point#clamp\n    * @param {number} min - The minimum value to clamp this Point to.\n    * @param {number} max - The maximum value to clamp this Point to.\n    * @return {Phaser.Point} This Point object.\n    */\n    clamp: function (min, max) {\n\n        this.x = Phaser.Math.clamp(this.x, min, max);\n        this.y = Phaser.Math.clamp(this.y, min, max);\n        return this;\n\n    },\n\n    /**\n    * Creates a copy of the given Point.\n    *\n    * @method Phaser.Point#clone\n    * @param {Phaser.Point} [output] Optional Point object. If given the values will be set into this object, otherwise a brand new Point object will be created and returned.\n    * @return {Phaser.Point} The new Point object.\n    */\n    clone: function (output) {\n\n        if (output === undefined || output === null)\n        {\n            output = new Phaser.Point(this.x, this.y);\n        }\n        else\n        {\n            output.setTo(this.x, this.y);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Copies the x and y properties from this Point to any given object.\n    *\n    * @method Phaser.Point#copyTo\n    * @param {any} dest - The object to copy to.\n    * @return {object} The dest object.\n    */\n    copyTo: function (dest) {\n\n        dest.x = this.x;\n        dest.y = this.y;\n\n        return dest;\n\n    },\n\n    /**\n    * Returns the distance of this Point object to the given object (can be a Circle, Point or anything with x/y properties)\n    *\n    * @method Phaser.Point#distance\n    * @param {object} dest - The target object. Must have visible x and y properties that represent the center of the object.\n    * @param {boolean} [round] - Round the distance to the nearest integer (default false).\n    * @return {number} The distance between this Point object and the destination Point object.\n    */\n    distance: function (dest, round) {\n\n        return Phaser.Point.distance(this, dest, round);\n\n    },\n\n    /**\n    * Determines whether the given objects x/y values are equal to this Point object.\n    *\n    * @method Phaser.Point#equals\n    * @param {Phaser.Point|any} a - The object to compare with this Point.\n    * @return {boolean} A value of true if the x and y points are equal, otherwise false.\n    */\n    equals: function (a) {\n\n        return (a.x === this.x && a.y === this.y);\n\n    },\n\n    /**\n    * Returns the angle between this Point object and another object with public x and y properties.\n    *\n    * @method Phaser.Point#angle\n    * @param {Phaser.Point|any} a - The object to get the angle from this Point to.\n    * @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?\n    * @return {number} The angle between the two objects.\n    */\n    angle: function (a, asDegrees) {\n\n        if (asDegrees === undefined) { asDegrees = false; }\n\n        if (asDegrees)\n        {\n            return Phaser.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x));\n        }\n        else\n        {\n            return Math.atan2(a.y - this.y, a.x - this.x);\n        }\n\n    },\n\n    /**\n    * Rotates this Point around the x/y coordinates given to the desired angle.\n    *\n    * @method Phaser.Point#rotate\n    * @param {number} x - The x coordinate of the anchor point.\n    * @param {number} y - The y coordinate of the anchor point.\n    * @param {number} angle - The angle in radians (unless asDegrees is true) to rotate the Point to.\n    * @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?\n    * @param {number} [distance] - An optional distance constraint between the Point and the anchor.\n    * @return {Phaser.Point} The modified point object.\n    */\n    rotate: function (x, y, angle, asDegrees, distance) {\n\n        return Phaser.Point.rotate(this, x, y, angle, asDegrees, distance);\n\n    },\n\n    /**\n    * Calculates the length of the Point object.\n    *\n    * @method Phaser.Point#getMagnitude\n    * @return {number} The length of the Point.\n    */\n    getMagnitude: function () {\n\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\n\n    },\n\n    /**\n    * Calculates the length squared of the Point object.\n    *\n    * @method Phaser.Point#getMagnitudeSq\n    * @return {number} The length ^ 2 of the Point.\n    */\n    getMagnitudeSq: function () {\n\n        return (this.x * this.x) + (this.y * this.y);\n\n    },\n\n    /**\n    * Alters the length of the Point without changing the direction.\n    *\n    * @method Phaser.Point#setMagnitude\n    * @param {number} magnitude - The desired magnitude of the resulting Point.\n    * @return {Phaser.Point} This Point object.\n    */\n    setMagnitude: function (magnitude) {\n\n        return this.normalize().multiply(magnitude, magnitude);\n\n    },\n\n    /**\n    * Alters the Point object so that its length is 1, but it retains the same direction.\n    *\n    * @method Phaser.Point#normalize\n    * @return {Phaser.Point} This Point object.\n    */\n    normalize: function () {\n\n        if (!this.isZero())\n        {\n            var m = this.getMagnitude();\n            this.x /= m;\n            this.y /= m;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Determine if this point is at 0,0.\n    *\n    * @method Phaser.Point#isZero\n    * @return {boolean} True if this Point is 0,0, otherwise false.\n    */\n    isZero: function () {\n\n        return (this.x === 0 && this.y === 0);\n\n    },\n\n    /**\n    * The dot product of this and another Point object.\n    * \n    * @method Phaser.Point#dot\n    * @param {Phaser.Point} a - The Point object to get the dot product combined with this Point.\n    * @return {number} The result.\n    */\n    dot: function (a) {\n\n        return ((this.x * a.x) + (this.y * a.y));\n\n    },\n\n    /**\n    * The cross product of this and another Point object.\n    * \n    * @method Phaser.Point#cross\n    * @param {Phaser.Point} a - The Point object to get the cross product combined with this Point.\n    * @return {number} The result.\n    */\n    cross: function (a) {\n\n        return ((this.x * a.y) - (this.y * a.x));\n\n    },\n\n    /**\n    * Make this Point perpendicular (90 degrees rotation)\n    * \n    * @method Phaser.Point#perp\n    * @return {Phaser.Point} This Point object.\n    */\n    perp: function () {\n\n        return this.setTo(-this.y, this.x);\n\n    },\n\n    /**\n    * Make this Point perpendicular (-90 degrees rotation)\n    * \n    * @method Phaser.Point#rperp\n    * @return {Phaser.Point} This Point object.\n    */\n    rperp: function () {\n\n        return this.setTo(this.y, -this.x);\n\n    },\n\n    /**\n    * Right-hand normalize (make unit length) this Point.\n    *\n    * @method Phaser.Point#normalRightHand\n    * @return {Phaser.Point} This Point object.\n    */\n    normalRightHand: function () {\n\n        return this.setTo(this.y * -1, this.x);\n\n    },\n\n    /**\n    * Math.floor() both the x and y properties of this Point.\n    *\n    * @method Phaser.Point#floor\n    * @return {Phaser.Point} This Point object.\n    */\n    floor: function () {\n\n        return this.setTo(Math.floor(this.x), Math.floor(this.y));\n\n    },\n\n    /**\n    * Math.ceil() both the x and y properties of this Point.\n    *\n    * @method Phaser.Point#ceil\n    * @return {Phaser.Point} This Point object.\n    */\n    ceil: function () {\n\n        return this.setTo(Math.ceil(this.x), Math.ceil(this.y));\n\n    },\n\n    /**\n    * Returns a string representation of this object.\n    *\n    * @method Phaser.Point#toString\n    * @return {string} A string representation of the instance.\n    */\n    toString: function () {\n\n        return '[{Point (x=' + this.x + ' y=' + this.y + ')}]';\n\n    }\n\n};\n\nPhaser.Point.prototype.constructor = Phaser.Point;\n\n/**\n* Adds the coordinates of two points together to create a new point.\n*\n* @method Phaser.Point.add\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.add = function (a, b, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    out.x = a.x + b.x;\n    out.y = a.y + b.y;\n\n    return out;\n\n};\n\n/**\n* Subtracts the coordinates of two points to create a new point.\n*\n* @method Phaser.Point.subtract\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.subtract = function (a, b, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    out.x = a.x - b.x;\n    out.y = a.y - b.y;\n\n    return out;\n\n};\n\n/**\n* Multiplies the coordinates of two points to create a new point.\n*\n* @method Phaser.Point.multiply\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.multiply = function (a, b, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    out.x = a.x * b.x;\n    out.y = a.y * b.y;\n\n    return out;\n\n};\n\n/**\n* Divides the coordinates of two points to create a new point.\n*\n* @method Phaser.Point.divide\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.divide = function (a, b, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    out.x = a.x / b.x;\n    out.y = a.y / b.y;\n\n    return out;\n\n};\n\n/**\n* Determines whether the two given Point objects are equal. They are considered equal if they have the same x and y values.\n*\n* @method Phaser.Point.equals\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @return {boolean} A value of true if the Points are equal, otherwise false.\n*/\nPhaser.Point.equals = function (a, b) {\n\n    return (a.x === b.x && a.y === b.y);\n\n};\n\n/**\n* Returns the angle between two Point objects.\n*\n* @method Phaser.Point.angle\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @return {number} The angle between the two Points.\n*/\nPhaser.Point.angle = function (a, b) {\n\n    // return Math.atan2(a.x * b.y - a.y * b.x, a.x * b.x + a.y * b.y);\n    return Math.atan2(a.y - b.y, a.x - b.x);\n\n};\n\n/**\n* Creates a negative Point.\n*\n* @method Phaser.Point.negative\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.negative = function (a, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    return out.setTo(-a.x, -a.y);\n\n};\n\n/**\n* Adds two 2D Points together and multiplies the result by the given scalar.\n* \n* @method Phaser.Point.multiplyAdd\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {number} s - The scaling value.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.multiplyAdd = function (a, b, s, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    return out.setTo(a.x + b.x * s, a.y + b.y * s);\n\n};\n\n/**\n* Interpolates the two given Points, based on the `f` value (between 0 and 1) and returns a new Point.\n* \n* @method Phaser.Point.interpolate\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {number} f - The level of interpolation between the two points. Indicates where the new point will be, along the line between pt1 and pt2. If f=1, pt1 is returned; if f=0, pt2 is returned.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.interpolate = function (a, b, f, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    return out.setTo(a.x + (b.x - a.x) * f, a.y + (b.y - a.y) * f);\n\n};\n\n/**\n* Return a perpendicular vector (90 degrees rotation)\n*\n* @method Phaser.Point.perp\n* @param {Phaser.Point} a - The Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.perp = function (a, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    return out.setTo(-a.y, a.x);\n\n};\n\n/**\n* Return a perpendicular vector (-90 degrees rotation)\n*\n* @method Phaser.Point.rperp\n* @param {Phaser.Point} a - The Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.rperp = function (a, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    return out.setTo(a.y, -a.x);\n\n};\n\n/**\n* Returns the euclidian distance of this Point object to the given object (can be a Circle, Point or anything with x/y properties).\n*\n* @method Phaser.Point.distance\n* @param {object} a - The target object. Must have visible x and y properties that represent the center of the object.\n* @param {object} b - The target object. Must have visible x and y properties that represent the center of the object.\n* @param {boolean} [round=false] - Round the distance to the nearest integer.\n* @return {number} The distance between this Point object and the destination Point object.\n*/\nPhaser.Point.distance = function (a, b, round) {\n\n    var distance = Phaser.Math.distance(a.x, a.y, b.x, b.y);\n    return round ? Math.round(distance) : distance;\n\n};\n\n/**\n* Project two Points onto another Point.\n* \n* @method Phaser.Point.project\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.project = function (a, b, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    var amt = a.dot(b) / b.getMagnitudeSq();\n\n    if (amt !== 0)\n    {\n        out.setTo(amt * b.x, amt * b.y);\n    }\n\n    return out;\n\n};\n\n/**\n* Project two Points onto a Point of unit length.\n* \n* @method Phaser.Point.projectUnit\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.projectUnit = function (a, b, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    var amt = a.dot(b);\n\n    if (amt !== 0)\n    {\n        out.setTo(amt * b.x, amt * b.y);\n    }\n\n    return out;\n\n};\n\n/**\n* Right-hand normalize (make unit length) a Point.\n*\n* @method Phaser.Point.normalRightHand\n* @param {Phaser.Point} a - The Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.normalRightHand = function (a, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    return out.setTo(a.y * -1, a.x);\n\n};\n\n/**\n* Normalize (make unit length) a Point.\n*\n* @method Phaser.Point.normalize\n* @param {Phaser.Point} a - The Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.normalize = function (a, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    var m = a.getMagnitude();\n\n    if (m !== 0)\n    {\n        out.setTo(a.x / m, a.y / m);\n    }\n\n    return out;\n\n};\n\n/**\n* Rotates a Point object, or any object with exposed x/y properties, around the given coordinates by\n* the angle specified. If the angle between the point and coordinates was 45 deg and the angle argument\n* is 45 deg then the resulting angle will be 90 deg, as the angle argument is added to the current angle.\n*\n* The distance allows you to specify a distance constraint for the rotation between the point and the \n* coordinates. If none is given the distance between the two is calculated and used.\n*\n* @method Phaser.Point.rotate\n* @param {Phaser.Point} a - The Point object to rotate.\n* @param {number} x - The x coordinate of the anchor point\n* @param {number} y - The y coordinate of the anchor point\n* @param {number} angle - The angle in radians (unless asDegrees is true) to rotate the Point by.\n* @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?\n* @param {number} [distance] - An optional distance constraint between the Point and the anchor.\n* @return {Phaser.Point} The modified point object.\n*/\nPhaser.Point.rotate = function (a, x, y, angle, asDegrees, distance) {\n\n    if (asDegrees) { angle = Phaser.Math.degToRad(angle); }\n\n    if (distance === undefined)\n    {\n        a.subtract(x, y);\n\n        var s = Math.sin(angle);\n        var c = Math.cos(angle);\n\n        var tx = c * a.x - s * a.y;\n        var ty = s * a.x + c * a.y;\n\n        a.x = tx + x;\n        a.y = ty + y;\n    }\n    else\n    {\n        var t = angle + Math.atan2(a.y - y, a.x - x);\n        a.x = x + distance * Math.cos(t);\n        a.y = y + distance * Math.sin(t);\n    }\n\n    return a;\n\n};\n\n/**\n* Calculates centroid (or midpoint) from an array of points. If only one point is provided, that point is returned.\n*\n* @method Phaser.Point.centroid\n* @param {Phaser.Point[]} points - The array of one or more points.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.centroid = function (points, out) {\n\n    if (out === undefined) { out = new Phaser.Point(); }\n\n    if (Object.prototype.toString.call(points) !== '[object Array]')\n    {\n        throw new Error(\"Phaser.Point. Parameter 'points' must be an array\");\n    }\n\n    var pointslength = points.length;\n\n    if (pointslength < 1)\n    {\n        throw new Error(\"Phaser.Point. Parameter 'points' array must not be empty\");\n    }\n\n    if (pointslength === 1)\n    {\n        out.copyFrom(points[0]);\n        return out;\n    }\n\n    for (var i = 0; i < pointslength; i++)\n    {\n        Phaser.Point.add(out, points[i], out);\n    }\n\n    out.divide(pointslength, pointslength);\n\n    return out;\n\n};\n\n/**\n* Parses an object for x and/or y properties and returns a new Phaser.Point with matching values.\n* If the object doesn't contain those properties a Point with x/y of zero will be returned.\n*\n* @method Phaser.Point.parse\n* @static\n* @param {object} obj - The object to parse.\n* @param {string} [xProp='x'] - The property used to set the Point.x value.\n* @param {string} [yProp='y'] - The property used to set the Point.y value.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.parse = function(obj, xProp, yProp) {\n\n    xProp = xProp || 'x';\n    yProp = yProp || 'y';\n\n    var point = new Phaser.Point();\n\n    if (obj[xProp])\n    {\n        point.x = parseInt(obj[xProp], 10);\n    }\n\n    if (obj[yProp])\n    {\n        point.y = parseInt(obj[yProp], 10);\n    }\n\n    return point;\n\n};\n\n//   Because PIXI uses its own Point, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Point = Phaser.Point;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @author       Adrien Brault <adrien.brault@gmail.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new Polygon.\n* \n* The points can be set from a variety of formats:\n*\n* - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`\n* - An array of objects with public x/y properties: `[obj1, obj2, ...]`\n* - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\n* - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`\n* - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`\n* - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`\n*\n* @class Phaser.Polygon\n* @constructor\n* @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.\n*/\nPhaser.Polygon = function () {\n\n    /**\n    * @property {number} area - The area of this Polygon.\n    */\n    this.area = 0;\n\n    /**\n    * @property {array} _points - An array of Points that make up this Polygon.\n    * @private\n    */\n    this._points = [];\n\n    if (arguments.length > 0)\n    {\n        this.setTo.apply(this, arguments);\n    }\n\n    /**\n    * @property {boolean} closed - Is the Polygon closed or not?\n    */\n    this.closed = true;\n\n    /**\n    * @property {boolean} flattened - Has this Polygon been flattened by a call to `Polygon.flatten` ?\n    */\n    this.flattened = false;\n\n    /**\n     * @property {number} type - The base object type.\n     */\n    this.type = Phaser.POLYGON;\n\n};\n\nPhaser.Polygon.prototype = {\n\n    /**\n     * Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]\n     *\n     * @method Phaser.Polygon#toNumberArray\n     * @param {array} [output] - The array to append the points to. If not specified a new array will be created.\n     * @return {array} The flattened array.\n     */\n    toNumberArray: function (output) {\n\n        if (output === undefined) { output = []; }\n\n        for (var i = 0; i < this._points.length; i++)\n        {\n            if (typeof this._points[i] === 'number')\n            {\n                output.push(this._points[i]);\n                output.push(this._points[i + 1]);\n                i++;\n            }\n            else\n            {\n                output.push(this._points[i].x);\n                output.push(this._points[i].y);\n            }\n        }\n\n        return output;\n\n    },\n\n    /**\n     * Flattens this Polygon so the points are a sequence of numbers.\n     * Any Point objects found are removed and replaced with two numbers.\n     * Also sets the Polygon.flattened property to `true`.\n     *\n     * @method Phaser.Polygon#flatten\n     * @return {Phaser.Polygon} This Polygon object\n     */\n    flatten: function () {\n\n        this._points = this.toNumberArray();\n\n        this.flattened = true;\n\n        return this;\n\n    },\n\n    /**\n     * Creates a copy of the given Polygon.\n     * This is a deep clone, the resulting copy contains new Phaser.Point objects\n     *\n     * @method Phaser.Polygon#clone\n     * @param {Phaser.Polygon} [output=(new Polygon)] - The polygon to update. If not specified a new polygon will be created.\n     * @return {Phaser.Polygon} The cloned (`output`) polygon object.\n     */\n    clone: function (output) {\n\n        var points = this._points.slice();\n\n        if (output === undefined || output === null)\n        {\n            output = new Phaser.Polygon(points);\n        }\n        else\n        {\n            output.setTo(points);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Checks whether the x and y coordinates are contained within this polygon.\n    *\n    * @method Phaser.Polygon#contains\n    * @param {number} x - The X value of the coordinate to test.\n    * @param {number} y - The Y value of the coordinate to test.\n    * @return {boolean} True if the coordinates are within this polygon, otherwise false.\n    */\n    contains: function (x, y) {\n\n        //  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva\n\n        var inside = false;\n\n        if (this.flattened)\n        {\n            for (var i = -2, j = this._points.length - 2; (i += 2) < this._points.length; j = i)\n            {\n                var ix = this._points[i];\n                var iy = this._points[i + 1];\n\n                var jx = this._points[j];\n                var jy = this._points[j + 1];\n\n                if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))\n                {\n                    inside = !inside;\n                }\n            }\n\n        }\n        else\n        {\n            for (var i = -1, j = this._points.length - 1; ++i < this._points.length; j = i)\n            {\n                var ix = this._points[i].x;\n                var iy = this._points[i].y;\n\n                var jx = this._points[j].x;\n                var jy = this._points[j].y;\n\n                if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))\n                {\n                    inside = !inside;\n                }\n            }\n        }\n\n        return inside;\n\n    },\n\n    /**\n     * Sets this Polygon to the given points.\n     *\n     * The points can be set from a variety of formats:\n     *\n     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`\n     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`\n     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\n     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\n     * - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`\n     * - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`\n     * - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`\n     *\n     * `setTo` may also be called without any arguments to remove all points.\n     *\n     * @method Phaser.Polygon#setTo\n     * @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.\n     * @return {Phaser.Polygon} This Polygon object\n     */\n    setTo: function (points) {\n\n        this.area = 0;\n        this._points = [];\n\n        if (arguments.length > 0)\n        {\n            //  If points isn't an array, use arguments as the array\n            if (!Array.isArray(points))\n            {\n                points = Array.prototype.slice.call(arguments);\n            }\n\n            var y0 = Number.MAX_VALUE;\n\n            //  Allows for mixed-type arguments\n            for (var i = 0, len = points.length; i < len; i++)\n            {\n                if (typeof points[i] === 'number')\n                {\n                    var p = new PIXI.Point(points[i], points[i + 1]);\n                    i++;\n                }\n                else if (Array.isArray(points[i]))\n                {\n                    var p = new PIXI.Point(points[i][0], points[i][1]);\n                }\n                else\n                {\n                    var p = new PIXI.Point(points[i].x, points[i].y);\n                }\n\n                this._points.push(p);\n\n                //  Lowest boundary\n                if (p.y < y0)\n                {\n                    y0 = p.y;\n                }\n            }\n\n            this.calculateArea(y0);\n        }\n\n        return this;\n\n    },\n\n    /**\n     * Calcuates the area of the Polygon. This is available in the property Polygon.area\n     *\n     * @method Phaser.Polygon#calculateArea\n     * @private\n     * @param {number} y0 - The lowest boundary\n     * @return {number} The area of the Polygon.\n     */\n    calculateArea: function (y0) {\n\n        var p1;\n        var p2;\n        var avgHeight;\n        var width;\n\n        for (var i = 0, len = this._points.length; i < len; i++)\n        {\n            p1 = this._points[i];\n\n            if (i === len - 1)\n            {\n                p2 = this._points[0];\n            }\n            else\n            {\n                p2 = this._points[i + 1];\n            }\n\n            avgHeight = ((p1.y - y0) + (p2.y - y0)) / 2;\n            width = p1.x - p2.x;\n            this.area += avgHeight * width;\n        }\n\n        return this.area;\n\n    }\n\n};\n\nPhaser.Polygon.prototype.constructor = Phaser.Polygon;\n\n/**\n* Sets and modifies the points of this polygon.\n*\n* See {@link Phaser.Polygon#setTo setTo} for the different kinds of arrays formats that can be assigned.\n*\n* @name Phaser.Polygon#points\n* @property {Phaser.Point[]} points - The array of vertex points.\n* @deprecated Use `setTo`.\n*/\nObject.defineProperty(Phaser.Polygon.prototype, 'points', {\n\n    get: function() {\n        return this._points;\n    },\n\n    set: function(points) {\n\n        if (points != null)\n        {\n            this.setTo(points);\n        }\n        else\n        {\n            //  Clear the points\n            this.setTo();\n        }\n\n    }\n\n});\n\n//  Because PIXI uses its own type, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Polygon = Phaser.Polygon;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new Rectangle object with the top-left corner specified by the x and y parameters and with the specified width and height parameters.\n* If you call this function without parameters, a Rectangle with x, y, width, and height properties set to 0 is created.\n*\n* @class Phaser.Rectangle\n* @constructor\n* @param {number} x - The x coordinate of the top-left corner of the Rectangle.\n* @param {number} y - The y coordinate of the top-left corner of the Rectangle.\n* @param {number} width - The width of the Rectangle. Should always be either zero or a positive value.\n* @param {number} height - The height of the Rectangle. Should always be either zero or a positive value.\n*/\nPhaser.Rectangle = function (x, y, width, height) {\n\n    x = x || 0;\n    y = y || 0;\n    width = width || 0;\n    height = height || 0;\n\n    /**\n    * @property {number} x - The x coordinate of the top-left corner of the Rectangle.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The y coordinate of the top-left corner of the Rectangle.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} width - The width of the Rectangle. This value should never be set to a negative.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The height of the Rectangle. This value should never be set to a negative.\n    */\n    this.height = height;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.RECTANGLE;\n\n};\n\nPhaser.Rectangle.prototype = {\n\n    /**\n    * Adjusts the location of the Rectangle object, as determined by its top-left corner, by the specified amounts.\n    * @method Phaser.Rectangle#offset\n    * @param {number} dx - Moves the x value of the Rectangle object by this amount.\n    * @param {number} dy - Moves the y value of the Rectangle object by this amount.\n    * @return {Phaser.Rectangle} This Rectangle object.\n    */\n    offset: function (dx, dy) {\n\n        this.x += dx;\n        this.y += dy;\n\n        return this;\n\n    },\n\n    /**\n    * Adjusts the location of the Rectangle object using a Point object as a parameter. This method is similar to the Rectangle.offset() method, except that it takes a Point object as a parameter.\n    * @method Phaser.Rectangle#offsetPoint\n    * @param {Phaser.Point} point - A Point object to use to offset this Rectangle object.\n    * @return {Phaser.Rectangle} This Rectangle object.\n    */\n    offsetPoint: function (point) {\n\n        return this.offset(point.x, point.y);\n\n    },\n\n    /**\n    * Sets the members of Rectangle to the specified values.\n    * @method Phaser.Rectangle#setTo\n    * @param {number} x - The x coordinate of the top-left corner of the Rectangle.\n    * @param {number} y - The y coordinate of the top-left corner of the Rectangle.\n    * @param {number} width - The width of the Rectangle. Should always be either zero or a positive value.\n    * @param {number} height - The height of the Rectangle. Should always be either zero or a positive value.\n    * @return {Phaser.Rectangle} This Rectangle object\n    */\n    setTo: function (x, y, width, height) {\n\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        return this;\n\n    },\n\n    /**\n    * Scales the width and height of this Rectangle by the given amounts.\n    * \n    * @method Phaser.Rectangle#scale\n    * @param {number} x - The amount to scale the width of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the width, etc.\n    * @param {number} [y] - The amount to scale the height of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the height, etc.\n    * @return {Phaser.Rectangle} This Rectangle object\n    */\n    scale: function (x, y) {\n\n        if (y === undefined) { y = x; }\n\n        this.width *= x;\n        this.height *= y;\n\n        return this;\n\n    },\n\n    /**\n    * Centers this Rectangle so that the center coordinates match the given x and y values.\n    *\n    * @method Phaser.Rectangle#centerOn\n    * @param {number} x - The x coordinate to place the center of the Rectangle at.\n    * @param {number} y - The y coordinate to place the center of the Rectangle at.\n    * @return {Phaser.Rectangle} This Rectangle object\n    */\n    centerOn: function (x, y) {\n\n        this.centerX = x;\n        this.centerY = y;\n\n        return this;\n\n    },\n\n    /**\n    * Runs Math.floor() on both the x and y values of this Rectangle.\n    * @method Phaser.Rectangle#floor\n    */\n    floor: function () {\n\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n\n    },\n\n    /**\n    * Runs Math.floor() on the x, y, width and height values of this Rectangle.\n    * @method Phaser.Rectangle#floorAll\n    */\n    floorAll: function () {\n\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n        this.width = Math.floor(this.width);\n        this.height = Math.floor(this.height);\n\n    },\n\n    /**\n    * Runs Math.ceil() on both the x and y values of this Rectangle.\n    * @method Phaser.Rectangle#ceil\n    */\n    ceil: function () {\n\n        this.x = Math.ceil(this.x);\n        this.y = Math.ceil(this.y);\n\n    },\n\n    /**\n    * Runs Math.ceil() on the x, y, width and height values of this Rectangle.\n    * @method Phaser.Rectangle#ceilAll\n    */\n    ceilAll: function () {\n\n        this.x = Math.ceil(this.x);\n        this.y = Math.ceil(this.y);\n        this.width = Math.ceil(this.width);\n        this.height = Math.ceil(this.height);\n\n    },\n\n    /**\n    * Copies the x, y, width and height properties from any given object to this Rectangle.\n    * @method Phaser.Rectangle#copyFrom\n    * @param {any} source - The object to copy from.\n    * @return {Phaser.Rectangle} This Rectangle object.\n    */\n    copyFrom: function (source) {\n\n        return this.setTo(source.x, source.y, source.width, source.height);\n\n    },\n\n    /**\n    * Copies the x, y, width and height properties from this Rectangle to any given object.\n    * @method Phaser.Rectangle#copyTo\n    * @param {any} source - The object to copy to.\n    * @return {object} This object.\n    */\n    copyTo: function (dest) {\n\n        dest.x = this.x;\n        dest.y = this.y;\n        dest.width = this.width;\n        dest.height = this.height;\n\n        return dest;\n\n    },\n\n    /**\n    * Increases the size of the Rectangle object by the specified amounts. The center point of the Rectangle object stays the same, and its size increases to the left and right by the dx value, and to the top and the bottom by the dy value.\n    * @method Phaser.Rectangle#inflate\n    * @param {number} dx - The amount to be added to the left side of the Rectangle.\n    * @param {number} dy - The amount to be added to the bottom side of the Rectangle.\n    * @return {Phaser.Rectangle} This Rectangle object.\n    */\n    inflate: function (dx, dy) {\n\n        return Phaser.Rectangle.inflate(this, dx, dy);\n\n    },\n\n    /**\n    * The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.\n    * @method Phaser.Rectangle#size\n    * @param {Phaser.Point} [output] - Optional Point object. If given the values will be set into the object, otherwise a brand new Point object will be created and returned.\n    * @return {Phaser.Point} The size of the Rectangle object.\n    */\n    size: function (output) {\n\n        return Phaser.Rectangle.size(this, output);\n\n    },\n\n    /**\n    * Resize the Rectangle by providing a new width and height.\n    * The x and y positions remain unchanged.\n    * \n    * @method Phaser.Rectangle#resize\n    * @param {number} width - The width of the Rectangle. Should always be either zero or a positive value.\n    * @param {number} height - The height of the Rectangle. Should always be either zero or a positive value.\n    * @return {Phaser.Rectangle} This Rectangle object\n    */\n    resize: function (width, height) {\n\n        this.width = width;\n        this.height = height;\n\n        return this;\n\n    },\n\n    /**\n    * Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.\n    * @method Phaser.Rectangle#clone\n    * @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the values will be set into the object, otherwise a brand new Rectangle object will be created and returned.\n    * @return {Phaser.Rectangle}\n    */\n    clone: function (output) {\n\n        return Phaser.Rectangle.clone(this, output);\n\n    },\n\n    /**\n    * Determines whether the specified coordinates are contained within the region defined by this Rectangle object.\n    * @method Phaser.Rectangle#contains\n    * @param {number} x - The x coordinate of the point to test.\n    * @param {number} y - The y coordinate of the point to test.\n    * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n    */\n    contains: function (x, y) {\n\n        return Phaser.Rectangle.contains(this, x, y);\n\n    },\n\n    /**\n    * Determines whether the first Rectangle object is fully contained within the second Rectangle object.\n    * A Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.\n    * @method Phaser.Rectangle#containsRect\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n    */\n    containsRect: function (b) {\n\n        return Phaser.Rectangle.containsRect(b, this);\n\n    },\n\n    /**\n    * Determines whether the two Rectangles are equal.\n    * This method compares the x, y, width and height properties of each Rectangle.\n    * @method Phaser.Rectangle#equals\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @return {boolean} A value of true if the two Rectangles have exactly the same values for the x, y, width and height properties; otherwise false.\n    */\n    equals: function (b) {\n\n        return Phaser.Rectangle.equals(this, b);\n\n    },\n\n    /**\n    * If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the Rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.\n    * @method Phaser.Rectangle#intersection\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @param {Phaser.Rectangle} out - Optional Rectangle object. If given the intersection values will be set into this object, otherwise a brand new Rectangle object will be created and returned.\n    * @return {Phaser.Rectangle} A Rectangle object that equals the area of intersection. If the Rectangles do not intersect, this method returns an empty Rectangle object; that is, a Rectangle with its x, y, width, and height properties set to 0.\n    */\n    intersection: function (b, out) {\n\n        return Phaser.Rectangle.intersection(this, b, out);\n\n    },\n\n    /**\n    * Determines whether this Rectangle and another given Rectangle intersect with each other.\n    * This method checks the x, y, width, and height properties of the two Rectangles.\n    * \n    * @method Phaser.Rectangle#intersects\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @return {boolean} A value of true if the specified object intersects with this Rectangle object; otherwise false.\n    */\n    intersects: function (b) {\n\n        return Phaser.Rectangle.intersects(this, b);\n\n    },\n\n    /**\n    * Determines whether the coordinates given intersects (overlaps) with this Rectangle.\n    *\n    * @method Phaser.Rectangle#intersectsRaw\n    * @param {number} left - The x coordinate of the left of the area.\n    * @param {number} right - The right coordinate of the area.\n    * @param {number} top - The y coordinate of the area.\n    * @param {number} bottom - The bottom coordinate of the area.\n    * @param {number} tolerance - A tolerance value to allow for an intersection test with padding, default to 0\n    * @return {boolean} A value of true if the specified object intersects with the Rectangle; otherwise false.\n    */\n    intersectsRaw: function (left, right, top, bottom, tolerance) {\n\n        return Phaser.Rectangle.intersectsRaw(this, left, right, top, bottom, tolerance);\n\n    },\n\n    /**\n    * Adds two Rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two Rectangles.\n    * @method Phaser.Rectangle#union\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @param {Phaser.Rectangle} [out] - Optional Rectangle object. If given the new values will be set into this object, otherwise a brand new Rectangle object will be created and returned.\n    * @return {Phaser.Rectangle} A Rectangle object that is the union of the two Rectangles.\n    */\n    union: function (b, out) {\n\n        return Phaser.Rectangle.union(this, b, out);\n\n    },\n\n    /**\n    * Returns a uniformly distributed random point from anywhere within this Rectangle.\n    * \n    * @method Phaser.Rectangle#random\n    * @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.\n    *     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.\n    * @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.\n    */\n    random: function (out) {\n\n        if (out === undefined) { out = new Phaser.Point(); }\n\n        out.x = this.randomX;\n        out.y = this.randomY;\n\n        return out;\n\n    },\n\n    /**\n    * Returns a point based on the given position constant, which can be one of:\n    * \n    * `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`,\n    * `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` \n    * and `Phaser.BOTTOM_RIGHT`.\n    *\n    * This method returns the same values as calling Rectangle.bottomLeft, etc, but those\n    * calls always create a new Point object, where-as this one allows you to use your own.\n    * \n    * @method Phaser.Rectangle#getPoint\n    * @param {integer} [position] - One of the Phaser position constants, such as `Phaser.TOP_RIGHT`.\n    * @param {Phaser.Point} [out] - A Phaser.Point that the values will be set in.\n    *     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.\n    * @return {Phaser.Point} An object containing the point in its `x` and `y` properties.\n    */\n    getPoint: function (position, out) {\n\n        if (out === undefined) { out = new Phaser.Point(); }\n\n        switch (position)\n        {\n            default:\n            case Phaser.TOP_LEFT:\n                return out.set(this.x, this.y);\n\n            case Phaser.TOP_CENTER:\n                return out.set(this.centerX, this.y);\n\n            case Phaser.TOP_RIGHT:\n                return out.set(this.right, this.y);\n\n            case Phaser.LEFT_CENTER:\n                return out.set(this.x, this.centerY);\n\n            case Phaser.CENTER:\n                return out.set(this.centerX, this.centerY);\n\n            case Phaser.RIGHT_CENTER:\n                return out.set(this.right, this.centerY);\n\n            case Phaser.BOTTOM_LEFT:\n                return out.set(this.x, this.bottom);\n\n            case Phaser.BOTTOM_CENTER:\n                return out.set(this.centerX, this.bottom);\n\n            case Phaser.BOTTOM_RIGHT:\n                return out.set(this.right, this.bottom);\n        }\n\n    },\n\n    /**\n    * Returns a string representation of this object.\n    * @method Phaser.Rectangle#toString\n    * @return {string} A string representation of the instance.\n    */\n    toString: function () {\n\n        return \"[{Rectangle (x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \" empty=\" + this.empty + \")}]\";\n\n    }\n\n};\n\n/**\n* @name Phaser.Rectangle#halfWidth\n* @property {number} halfWidth - Half of the width of the Rectangle.\n* @readonly\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"halfWidth\", {\n\n    get: function () {\n        return Math.round(this.width / 2);\n    }\n\n});\n\n/**\n* @name Phaser.Rectangle#halfHeight\n* @property {number} halfHeight - Half of the height of the Rectangle.\n* @readonly\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"halfHeight\", {\n\n    get: function () {\n        return Math.round(this.height / 2);\n    }\n\n});\n\n/**\n* The sum of the y and height properties. Changing the bottom property of a Rectangle object has no effect on the x, y and width properties, but does change the height property.\n* @name Phaser.Rectangle#bottom\n* @property {number} bottom - The sum of the y and height properties.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"bottom\", {\n\n    get: function () {\n        return this.y + this.height;\n    },\n\n    set: function (value) {\n\n        if (value <= this.y)\n        {\n            this.height = 0;\n        }\n        else\n        {\n            this.height = value - this.y;\n        }\n\n    }\n\n});\n\n/**\n* The location of the Rectangles bottom left corner as a Point object.\n* @name Phaser.Rectangle#bottomLeft\n* @property {Phaser.Point} bottomLeft - Gets or sets the location of the Rectangles bottom left corner as a Point object.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"bottomLeft\", {\n\n    get: function () {\n        return new Phaser.Point(this.x, this.bottom);\n    },\n\n    set: function (value) {\n        this.x = value.x;\n        this.bottom = value.y;\n    }\n\n});\n\n/**\n* The location of the Rectangles bottom right corner as a Point object.\n* @name Phaser.Rectangle#bottomRight\n* @property {Phaser.Point} bottomRight - Gets or sets the location of the Rectangles bottom right corner as a Point object.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"bottomRight\", {\n\n    get: function () {\n        return new Phaser.Point(this.right, this.bottom);\n    },\n\n    set: function (value) {\n        this.right = value.x;\n        this.bottom = value.y;\n    }\n\n});\n\n/**\n* The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.\n* @name Phaser.Rectangle#left\n* @property {number} left - The x coordinate of the left of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"left\", {\n\n    get: function () {\n        return this.x;\n    },\n\n    set: function (value) {\n        if (value >= this.right) {\n            this.width = 0;\n        } else {\n            this.width = this.right - value;\n        }\n        this.x = value;\n    }\n\n});\n\n/**\n* The sum of the x and width properties. Changing the right property of a Rectangle object has no effect on the x, y and height properties, however it does affect the width property.\n* @name Phaser.Rectangle#right\n* @property {number} right - The sum of the x and width properties.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"right\", {\n\n    get: function () {\n        return this.x + this.width;\n    },\n\n    set: function (value) {\n        if (value <= this.x) {\n            this.width = 0;\n        } else {\n            this.width = value - this.x;\n        }\n    }\n\n});\n\n/**\n* The volume of the Rectangle derived from width * height.\n* @name Phaser.Rectangle#volume\n* @property {number} volume - The volume of the Rectangle derived from width * height.\n* @readonly\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"volume\", {\n\n    get: function () {\n        return this.width * this.height;\n    }\n\n});\n\n/**\n* The perimeter size of the Rectangle. This is the sum of all 4 sides.\n* @name Phaser.Rectangle#perimeter\n* @property {number} perimeter - The perimeter size of the Rectangle. This is the sum of all 4 sides.\n* @readonly\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"perimeter\", {\n\n    get: function () {\n        return (this.width * 2) + (this.height * 2);\n    }\n\n});\n\n/**\n* The x coordinate of the center of the Rectangle.\n* @name Phaser.Rectangle#centerX\n* @property {number} centerX - The x coordinate of the center of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"centerX\", {\n\n    get: function () {\n        return this.x + this.halfWidth;\n    },\n\n    set: function (value) {\n        this.x = value - this.halfWidth;\n    }\n\n});\n\n/**\n* The y coordinate of the center of the Rectangle.\n* @name Phaser.Rectangle#centerY\n* @property {number} centerY - The y coordinate of the center of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"centerY\", {\n\n    get: function () {\n        return this.y + this.halfHeight;\n    },\n\n    set: function (value) {\n        this.y = value - this.halfHeight;\n    }\n\n});\n\n/**\n* A random value between the left and right values (inclusive) of the Rectangle.\n*\n* @name Phaser.Rectangle#randomX\n* @property {number} randomX - A random value between the left and right values (inclusive) of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"randomX\", {\n\n    get: function () {\n\n        return this.x + (Math.random() * this.width);\n\n    }\n\n});\n\n/**\n* A random value between the top and bottom values (inclusive) of the Rectangle.\n*\n* @name Phaser.Rectangle#randomY\n* @property {number} randomY - A random value between the top and bottom values (inclusive) of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"randomY\", {\n\n    get: function () {\n\n        return this.y + (Math.random() * this.height);\n\n    }\n\n});\n\n/**\n* The y coordinate of the top of the Rectangle. Changing the top property of a Rectangle object has no effect on the x and width properties.\n* However it does affect the height property, whereas changing the y value does not affect the height property.\n* @name Phaser.Rectangle#top\n* @property {number} top - The y coordinate of the top of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"top\", {\n\n    get: function () {\n        return this.y;\n    },\n\n    set: function (value) {\n        if (value >= this.bottom) {\n            this.height = 0;\n            this.y = value;\n        } else {\n            this.height = (this.bottom - value);\n        }\n    }\n\n});\n\n/**\n* The location of the Rectangles top left corner as a Point object.\n* @name Phaser.Rectangle#topLeft\n* @property {Phaser.Point} topLeft - The location of the Rectangles top left corner as a Point object.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"topLeft\", {\n\n    get: function () {\n        return new Phaser.Point(this.x, this.y);\n    },\n\n    set: function (value) {\n        this.x = value.x;\n        this.y = value.y;\n    }\n\n});\n\n/**\n* The location of the Rectangles top right corner as a Point object.\n* @name Phaser.Rectangle#topRight\n* @property {Phaser.Point} topRight - The location of the Rectangles top left corner as a Point object.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"topRight\", {\n\n    get: function () {\n        return new Phaser.Point(this.x + this.width, this.y);\n    },\n\n    set: function (value) {\n        this.right = value.x;\n        this.y = value.y;\n    }\n\n});\n\n/**\n* Determines whether or not this Rectangle object is empty. A Rectangle object is empty if its width or height is less than or equal to 0.\n* If set to true then all of the Rectangle properties are set to 0.\n* @name Phaser.Rectangle#empty\n* @property {boolean} empty - Gets or sets the Rectangles empty state.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"empty\", {\n\n    get: function () {\n        return (!this.width || !this.height);\n    },\n\n    set: function (value) {\n\n        if (value === true)\n        {\n            this.setTo(0, 0, 0, 0);\n        }\n\n    }\n\n});\n\nPhaser.Rectangle.prototype.constructor = Phaser.Rectangle;\n\n/**\n* Increases the size of the Rectangle object by the specified amounts. The center point of the Rectangle object stays the same, and its size increases to the left and right by the dx value, and to the top and the bottom by the dy value.\n* @method Phaser.Rectangle.inflate\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {number} dx - The amount to be added to the left side of the Rectangle.\n* @param {number} dy - The amount to be added to the bottom side of the Rectangle.\n* @return {Phaser.Rectangle} This Rectangle object.\n*/\nPhaser.Rectangle.inflate = function (a, dx, dy) {\n\n    a.x -= dx;\n    a.width += 2 * dx;\n    a.y -= dy;\n    a.height += 2 * dy;\n\n    return a;\n\n};\n\n/**\n* Increases the size of the Rectangle object. This method is similar to the Rectangle.inflate() method except it takes a Point object as a parameter.\n* @method Phaser.Rectangle.inflatePoint\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {Phaser.Point} point - The x property of this Point object is used to increase the horizontal dimension of the Rectangle object. The y property is used to increase the vertical dimension of the Rectangle object.\n* @return {Phaser.Rectangle} The Rectangle object.\n*/\nPhaser.Rectangle.inflatePoint = function (a, point) {\n\n    return Phaser.Rectangle.inflate(a, point.x, point.y);\n\n};\n\n/**\n* The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.\n* @method Phaser.Rectangle.size\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {Phaser.Point} [output] - Optional Point object. If given the values will be set into the object, otherwise a brand new Point object will be created and returned.\n* @return {Phaser.Point} The size of the Rectangle object\n*/\nPhaser.Rectangle.size = function (a, output) {\n\n    if (output === undefined || output === null)\n    {\n        output = new Phaser.Point(a.width, a.height);\n    }\n    else\n    {\n        output.setTo(a.width, a.height);\n    }\n\n    return output;\n\n};\n\n/**\n* Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.\n* @method Phaser.Rectangle.clone\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the values will be set into the object, otherwise a brand new Rectangle object will be created and returned.\n* @return {Phaser.Rectangle}\n*/\nPhaser.Rectangle.clone = function (a, output) {\n\n    if (output === undefined || output === null)\n    {\n        output = new Phaser.Rectangle(a.x, a.y, a.width, a.height);\n    }\n    else\n    {\n        output.setTo(a.x, a.y, a.width, a.height);\n    }\n\n    return output;\n\n};\n\n/**\n* Determines whether the specified coordinates are contained within the region defined by this Rectangle object.\n* @method Phaser.Rectangle.contains\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {number} x - The x coordinate of the point to test.\n* @param {number} y - The y coordinate of the point to test.\n* @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n*/\nPhaser.Rectangle.contains = function (a, x, y) {\n\n    if (a.width <= 0 || a.height <= 0)\n    {\n        return false;\n    }\n\n    return (x >= a.x && x < a.right && y >= a.y && y < a.bottom);\n\n};\n\n/**\n* Determines whether the specified coordinates are contained within the region defined by the given raw values.\n* @method Phaser.Rectangle.containsRaw\n* @param {number} rx - The x coordinate of the top left of the area.\n* @param {number} ry - The y coordinate of the top left of the area.\n* @param {number} rw - The width of the area.\n* @param {number} rh - The height of the area.\n* @param {number} x - The x coordinate of the point to test.\n* @param {number} y - The y coordinate of the point to test.\n* @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n*/\nPhaser.Rectangle.containsRaw = function (rx, ry, rw, rh, x, y) {\n\n    return (x >= rx && x < (rx + rw) && y >= ry && y < (ry + rh));\n\n};\n\n/**\n* Determines whether the specified point is contained within the rectangular region defined by this Rectangle object. This method is similar to the Rectangle.contains() method, except that it takes a Point object as a parameter.\n* @method Phaser.Rectangle.containsPoint\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {Phaser.Point} point - The point object being checked. Can be Point or any object with .x and .y values.\n* @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n*/\nPhaser.Rectangle.containsPoint = function (a, point) {\n\n    return Phaser.Rectangle.contains(a, point.x, point.y);\n\n};\n\n/**\n* Determines whether the first Rectangle object is fully contained within the second Rectangle object.\n* A Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.\n* @method Phaser.Rectangle.containsRect\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n*/\nPhaser.Rectangle.containsRect = function (a, b) {\n\n    //  If the given rect has a larger volume than this one then it can never contain it\n    if (a.volume > b.volume)\n    {\n        return false;\n    }\n\n    return (a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom);\n\n};\n\n/**\n* Determines whether the two Rectangles are equal.\n* This method compares the x, y, width and height properties of each Rectangle.\n* @method Phaser.Rectangle.equals\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @return {boolean} A value of true if the two Rectangles have exactly the same values for the x, y, width and height properties; otherwise false.\n*/\nPhaser.Rectangle.equals = function (a, b) {\n\n    return (a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height);\n\n};\n\n/**\n* Determines if the two objects (either Rectangles or Rectangle-like) have the same width and height values under strict equality.\n* @method Phaser.Rectangle.sameDimensions\n* @param {Rectangle-like} a - The first Rectangle object.\n* @param {Rectangle-like} b - The second Rectangle object.\n* @return {boolean} True if the object have equivalent values for the width and height properties.\n*/\nPhaser.Rectangle.sameDimensions = function (a, b) {\n\n    return (a.width === b.width && a.height === b.height);\n\n};\n\n/**\n* If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the Rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.\n* @method Phaser.Rectangle.intersection\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the intersection values will be set into this object, otherwise a brand new Rectangle object will be created and returned.\n* @return {Phaser.Rectangle} A Rectangle object that equals the area of intersection. If the Rectangles do not intersect, this method returns an empty Rectangle object; that is, a Rectangle with its x, y, width, and height properties set to 0.\n*/\nPhaser.Rectangle.intersection = function (a, b, output) {\n\n    if (output === undefined)\n    {\n        output = new Phaser.Rectangle();\n    }\n\n    if (Phaser.Rectangle.intersects(a, b))\n    {\n        output.x = Math.max(a.x, b.x);\n        output.y = Math.max(a.y, b.y);\n        output.width = Math.min(a.right, b.right) - output.x;\n        output.height = Math.min(a.bottom, b.bottom) - output.y;\n    }\n\n    return output;\n\n};\n\n/**\n* Determines whether the two Rectangles intersect with each other.\n* This method checks the x, y, width, and height properties of the Rectangles.\n* @method Phaser.Rectangle.intersects\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @return {boolean} A value of true if the specified object intersects with this Rectangle object; otherwise false.\n*/\nPhaser.Rectangle.intersects = function (a, b) {\n\n    if (a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0)\n    {\n        return false;\n    }\n\n    return !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);\n\n};\n\n/**\n* Determines whether the object specified intersects (overlaps) with the given values.\n* @method Phaser.Rectangle.intersectsRaw\n* @param {number} left - The x coordinate of the left of the area.\n* @param {number} right - The right coordinate of the area.\n* @param {number} top - The y coordinate of the area.\n* @param {number} bottom - The bottom coordinate of the area.\n* @param {number} tolerance - A tolerance value to allow for an intersection test with padding, default to 0\n* @return {boolean} A value of true if the specified object intersects with the Rectangle; otherwise false.\n*/\nPhaser.Rectangle.intersectsRaw = function (a, left, right, top, bottom, tolerance) {\n\n    if (tolerance === undefined) { tolerance = 0; }\n\n    return !(left > a.right + tolerance || right < a.left - tolerance || top > a.bottom + tolerance || bottom < a.top - tolerance);\n\n};\n\n/**\n* Adds two Rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two Rectangles.\n* @method Phaser.Rectangle.union\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the new values will be set into this object, otherwise a brand new Rectangle object will be created and returned.\n* @return {Phaser.Rectangle} A Rectangle object that is the union of the two Rectangles.\n*/\nPhaser.Rectangle.union = function (a, b, output) {\n\n    if (output === undefined)\n    {\n        output = new Phaser.Rectangle();\n    }\n\n    return output.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));\n\n};\n\n/**\n* Calculates the Axis Aligned Bounding Box (or aabb) from an array of points.\n*\n* @method Phaser.Rectangle#aabb\n* @param {Phaser.Point[]} points - The array of one or more points.\n* @param {Phaser.Rectangle} [out] - Optional Rectangle to store the value in, if not supplied a new Rectangle object will be created.\n* @return {Phaser.Rectangle} The new Rectangle object.\n* @static\n*/\nPhaser.Rectangle.aabb = function(points, out) {\n\n    if (out === undefined) {\n        out = new Phaser.Rectangle();\n    }\n\n    var xMax = Number.NEGATIVE_INFINITY,\n        xMin = Number.POSITIVE_INFINITY,\n        yMax = Number.NEGATIVE_INFINITY,\n        yMin = Number.POSITIVE_INFINITY;\n\n    points.forEach(function(point) {\n        if (point.x > xMax) {\n            xMax = point.x;\n        }\n        if (point.x < xMin) {\n            xMin = point.x;\n        }\n\n        if (point.y > yMax) {\n            yMax = point.y;\n        }\n        if (point.y < yMin) {\n            yMin = point.y;\n        }\n    });\n\n    out.setTo(xMin, yMin, xMax - xMin, yMax - yMin);\n\n    return out;\n};\n\n//   Because PIXI uses its own Rectangle, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Rectangle = Phaser.Rectangle;\nPIXI.EmptyRectangle = new Phaser.Rectangle(0, 0, 0, 0);\n\n/**\n* @author       Mat Groves http://matgroves.com/\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Rounded Rectangle object is an area defined by its position and has nice rounded corners, \n* as indicated by its top-left corner point (x, y) and by its width and its height.\n*\n* @class Phaser.RoundedRectangle\n* @constructor\n* @param {number} [x=0] - The x coordinate of the top-left corner of the Rectangle.\n* @param {number} [y=0] - The y coordinate of the top-left corner of the Rectangle.\n* @param {number} [width=0] - The width of the Rectangle. Should always be either zero or a positive value.\n* @param {number} [height=0] - The height of the Rectangle. Should always be either zero or a positive value.\n* @param {number} [radius=20] - Controls the radius of the rounded corners.\n*/\nPhaser.RoundedRectangle = function(x, y, width, height, radius)\n{\n    if (x === undefined) { x = 0; }\n    if (y === undefined) { y = 0; }\n    if (width === undefined) { width = 0; }\n    if (height === undefined) { height = 0; }\n    if (radius === undefined) { radius = 20; }\n\n    /**\n    * @property {number} x - The x coordinate of the top-left corner of the Rectangle.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The y coordinate of the top-left corner of the Rectangle.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} width - The width of the Rectangle. This value should never be set to a negative.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The height of the Rectangle. This value should never be set to a negative.\n    */\n    this.height = height;\n\n    /**\n    * @property {number} radius - The radius of the rounded corners.\n    */\n    this.radius = radius || 20;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.ROUNDEDRECTANGLE;\n};\n\nPhaser.RoundedRectangle.prototype = {\n\n    /**\n    * Returns a new RoundedRectangle object with the same values for the x, y, width, height and\n    * radius properties as this RoundedRectangle object.\n    * \n    * @method Phaser.RoundedRectangle#clone\n    * @return {Phaser.RoundedRectangle}\n    */\n    clone: function () {\n\n        return new Phaser.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n\n    },\n\n    /**\n    * Determines whether the specified coordinates are contained within the region defined by this Rounded Rectangle object.\n    * \n    * @method Phaser.RoundedRectangle#contains\n    * @param {number} x - The x coordinate of the point to test.\n    * @param {number} y - The y coordinate of the point to test.\n    * @return {boolean} A value of true if the RoundedRectangle Rectangle object contains the specified point; otherwise false.\n    */\n    contains: function (x, y) {\n\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        var x1 = this.x;\n\n        if (x >= x1 && x <= x1 + this.width)\n        {\n            var y1 = this.y;\n\n            if (y >= y1 && y <= y1 + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    }\n\n};\n\nPhaser.RoundedRectangle.prototype.constructor = Phaser.RoundedRectangle;\n\n//  Because PIXI uses its own type, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.RoundedRectangle = Phaser.RoundedRectangle;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.\n* The game automatically creates a single Stage sized camera on boot. Move the camera around the world with Phaser.Camera.x/y\n*\n* @class Phaser.Camera\n* @constructor\n* @param {Phaser.Game} game - Game reference to the currently running game.\n* @param {number} id - Not being used at the moment, will be when Phaser supports multiple camera\n* @param {number} x - Position of the camera on the X axis\n* @param {number} y - Position of the camera on the Y axis\n* @param {number} width - The width of the view rectangle\n* @param {number} height - The height of the view rectangle\n*/\nPhaser.Camera = function (game, id, x, y, width, height) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.World} world - A reference to the game world.\n    */\n    this.world = game.world;\n\n    /**\n    * @property {number} id - Reserved for future multiple camera set-ups.\n    * @default\n    */\n    this.id = 0;\n\n    /**\n    * Camera view.\n    * The view into the world we wish to render (by default the game dimensions).\n    * The x/y values are in world coordinates, not screen coordinates, the width/height is how many pixels to render.\n    * Sprites outside of this view are not rendered if Sprite.autoCull is set to `true`. Otherwise they are always rendered.\n    * @property {Phaser.Rectangle} view\n    */\n    this.view = new Phaser.Rectangle(x, y, width, height);\n\n    /**\n    * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.\n    * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound\n    * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.\n    *\n    * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.\n    */\n    this.bounds = new Phaser.Rectangle(x, y, width, height);\n\n    /**\n    * @property {Phaser.Rectangle} deadzone - Moving inside this Rectangle will not cause the camera to move.\n    */\n    this.deadzone = null;\n\n    /**\n    * @property {boolean} visible - Whether this camera is visible or not.\n    * @default\n    */\n    this.visible = true;\n\n    /**\n    * @property {boolean} roundPx - If a Camera has roundPx set to `true` it will call `view.floor` as part of its update loop, keeping its boundary to integer values. Set this to `false` to disable this from happening.\n    * @default\n    */\n    this.roundPx = true;\n\n    /**\n    * @property {boolean} atLimit - Whether this camera is flush with the World Bounds or not.\n    */\n    this.atLimit = { x: false, y: false };\n\n    /**\n    * @property {Phaser.Sprite} target - If the camera is tracking a Sprite, this is a reference to it, otherwise null.\n    * @default\n    */\n    this.target = null;\n\n    /**\n    * @property {PIXI.DisplayObject} displayObject - The display object to which all game objects are added. Set by World.boot.\n    */\n    this.displayObject = null;\n\n    /**\n    * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot.\n    */\n    this.scale = null;\n\n    /**\n    * @property {number} totalInView - The total number of Sprites with `autoCull` set to `true` that are visible by this Camera.\n    * @readonly\n    */\n    this.totalInView = 0;\n\n    /**\n    * The linear interpolation value to use when following a target.\n    * The default values of 1 means the camera will instantly snap to the target coordinates.\n    * A lower value, such as 0.1 means the camera will more slowly track the target, giving\n    * a smooth transition. You can set the horizontal and vertical values independently, and also\n    * adjust this value in real-time during your game.\n    * @property {Phaser.Point} lerp\n    * @default\n    */\n    this.lerp = new Phaser.Point(1, 1);\n\n    /**\n    * @property {Phaser.Signal} onShakeComplete - This signal is dispatched when the camera shake effect completes.\n    */\n    this.onShakeComplete = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onFlashComplete - This signal is dispatched when the camera flash effect completes.\n    */\n    this.onFlashComplete = new Phaser.Signal();\n\n    /**\n    * This signal is dispatched when the camera fade effect completes.\n    * When the fade effect completes you will be left with the screen black (or whatever\n    * color you faded to). In order to reset this call `Camera.resetFX`. This is called\n    * automatically when you change State.\n    * @property {Phaser.Signal} onFadeComplete\n    */\n    this.onFadeComplete = new Phaser.Signal();\n\n    /**\n    * The Graphics object used to handle camera fx such as fade and flash.\n    * @property {Phaser.Graphics} fx\n    * @protected\n    */\n    this.fx = null;\n\n    /**\n    * @property {Phaser.Point} _targetPosition - Internal point used to calculate target position.\n    * @private\n    */\n    this._targetPosition = new Phaser.Point();\n\n    /**\n    * @property {number} edge - Edge property.\n    * @private\n    * @default\n    */\n    this._edge = 0;\n\n    /**\n    * @property {Phaser.Point} position - Current position of the camera in world.\n    * @private\n    * @default\n    */\n    this._position = new Phaser.Point();\n\n    /**\n    * @property {Object} _shake - The shake effect container.\n    * @private\n    */\n    this._shake = {\n        intensity: 0,\n        duration: 0,\n        horizontal: false,\n        vertical: false,\n        shakeBounds: true,\n        x: 0,\n        y: 0\n    };\n\n    /**\n    * @property {number} _fxDuration - FX duration timer.\n    * @private\n    */\n    this._fxDuration = 0;\n\n    /**\n    * @property {number} _fxType - The FX type running.\n    * @private\n    */\n    this._fxType = 0;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.FOLLOW_LOCKON = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.FOLLOW_PLATFORMER = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.FOLLOW_TOPDOWN = 2;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.FOLLOW_TOPDOWN_TIGHT = 3;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.SHAKE_BOTH = 4;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.SHAKE_HORIZONTAL = 5;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.SHAKE_VERTICAL = 6;\n\n/**\n* @constant\n* @type {boolean}\n*/\nPhaser.Camera.ENABLE_FX = true;\n\nPhaser.Camera.prototype = {\n\n    /**\n    * Called automatically by Phaser.World.\n    *\n    * @method Phaser.Camera#boot\n    * @private\n    */\n    boot: function () {\n\n        this.displayObject = this.game.world;\n\n        this.scale = this.game.world.scale;\n\n        this.game.camera = this;\n\n        if (Phaser.Graphics && Phaser.Camera.ENABLE_FX)\n        {\n            this.fx = new Phaser.Graphics(this.game);\n\n            this.game.stage.addChild(this.fx);\n        }\n\n    },\n\n    /**\n    * Camera preUpdate. Sets the total view counter to zero.\n    *\n    * @method Phaser.Camera#preUpdate\n    */\n    preUpdate: function () {\n\n        this.totalInView = 0;\n\n    },\n\n    /**\n    * Tell the camera which sprite to follow.\n    *\n    * You can set the follow type and a linear interpolation value.\n    * Use low lerp values (such as 0.1) to automatically smooth the camera motion.\n    *\n    * If you find you're getting a slight \"jitter\" effect when following a Sprite it's probably to do with sub-pixel rendering of the Sprite position.\n    * This can be disabled by setting `game.renderer.renderSession.roundPixels = true` to force full pixel rendering.\n    *\n    * @method Phaser.Camera#follow\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.Text} target - The object you want the camera to track. Set to null to not follow anything.\n    * @param {number} [style] - Leverage one of the existing \"deadzone\" presets. If you use a custom deadzone, ignore this parameter and manually specify the deadzone after calling follow().\n    * @param {float} [lerpX=1] - A value between 0 and 1. This value specifies the amount of linear interpolation to use when horizontally tracking the target. The closer the value to 1, the faster the camera will track.\n    * @param {float} [lerpY=1] - A value between 0 and 1. This value specifies the amount of linear interpolation to use when vertically tracking the target. The closer the value to 1, the faster the camera will track.\n    */\n    follow: function (target, style, lerpX, lerpY) {\n\n        if (style === undefined) { style = Phaser.Camera.FOLLOW_LOCKON; }\n        if (lerpX === undefined) { lerpX = 1; }\n        if (lerpY === undefined) { lerpY = 1; }\n\n        this.target = target;\n        this.lerp.set(lerpX, lerpY);\n\n        var helper;\n\n        switch (style) {\n\n            case Phaser.Camera.FOLLOW_PLATFORMER:\n                var w = this.width / 8;\n                var h = this.height / 3;\n                this.deadzone = new Phaser.Rectangle((this.width - w) / 2, (this.height - h) / 2 - h * 0.25, w, h);\n                break;\n\n            case Phaser.Camera.FOLLOW_TOPDOWN:\n                helper = Math.max(this.width, this.height) / 4;\n                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);\n                break;\n\n            case Phaser.Camera.FOLLOW_TOPDOWN_TIGHT:\n                helper = Math.max(this.width, this.height) / 8;\n                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);\n                break;\n\n            case Phaser.Camera.FOLLOW_LOCKON:\n                this.deadzone = null;\n                break;\n\n            default:\n                this.deadzone = null;\n                break;\n        }\n\n    },\n\n    /**\n    * Sets the Camera follow target to null, stopping it from following an object if it's doing so.\n    *\n    * @method Phaser.Camera#unfollow\n    */\n    unfollow: function () {\n\n        this.target = null;\n\n    },\n\n    /**\n    * Move the camera focus on a display object instantly.\n    * @method Phaser.Camera#focusOn\n    * @param {any} displayObject - The display object to focus the camera on. Must have visible x/y properties.\n    */\n    focusOn: function (displayObject) {\n\n        this.setPosition(Math.round(displayObject.x - this.view.halfWidth), Math.round(displayObject.y - this.view.halfHeight));\n\n    },\n\n    /**\n    * Move the camera focus on a location instantly.\n    * @method Phaser.Camera#focusOnXY\n    * @param {number} x - X position.\n    * @param {number} y - Y position.\n    */\n    focusOnXY: function (x, y) {\n\n        this.setPosition(Math.round(x - this.view.halfWidth), Math.round(y - this.view.halfHeight));\n\n    },\n\n    /**\n    * This creates a camera shake effect. It works by applying a random amount of additional\n    * spacing on the x and y axis each frame. You can control the intensity and duration\n    * of the effect, and if it should effect both axis or just one.\n    *\n    * When the shake effect ends the signal Camera.onShakeComplete is dispatched.\n    *\n    * @method Phaser.Camera#shake\n    * @param {float} [intensity=0.05] - The intensity of the camera shake. Given as a percentage of the camera size representing the maximum distance that the camera can move while shaking.\n    * @param {number} [duration=500] - The duration of the shake effect in milliseconds.\n    * @param {boolean} [force=true] - If a camera shake effect is already running and force is true it will replace the previous effect, resetting the duration.\n    * @param {number} [direction=Phaser.Camera.SHAKE_BOTH] - The directions in which the camera can shake. Either Phaser.Camera.SHAKE_BOTH, Phaser.Camera.SHAKE_HORIZONTAL or Phaser.Camera.SHAKE_VERTICAL.\n    * @param {boolean} [shakeBounds=true] - Is the effect allowed to shake the camera beyond its bounds (if set?).\n    * @return {boolean} True if the shake effect was started, otherwise false.\n    */\n    shake: function (intensity, duration, force, direction, shakeBounds) {\n\n        if (intensity === undefined) { intensity = 0.05; }\n        if (duration === undefined) { duration = 500; }\n        if (force === undefined) { force = true; }\n        if (direction === undefined) { direction = Phaser.Camera.SHAKE_BOTH; }\n        if (shakeBounds === undefined) { shakeBounds = true; }\n\n        if (!force && this._shake.duration > 0)\n        {\n            //  Can't reset an already running shake\n            return false;\n        }\n\n        this._shake.intensity = intensity;\n        this._shake.duration = duration;\n        this._shake.shakeBounds = shakeBounds;\n\n        this._shake.x = 0;\n        this._shake.y = 0;\n\n        this._shake.horizontal = (direction === Phaser.Camera.SHAKE_BOTH || direction === Phaser.Camera.SHAKE_HORIZONTAL);\n        this._shake.vertical = (direction === Phaser.Camera.SHAKE_BOTH || direction === Phaser.Camera.SHAKE_VERTICAL);\n\n        return true;\n\n    },\n\n    /**\n    * This creates a camera flash effect. It works by filling the game with the solid fill\n    * color specified, and then fading it away to alpha 0 over the duration given.\n    *\n    * You can use this for things such as hit feedback effects.\n    *\n    * When the effect ends the signal Camera.onFlashComplete is dispatched.\n    *\n    * @method Phaser.Camera#flash\n    * @param {numer} [color=0xffffff] - The color of the flash effect. I.e. 0xffffff for white, 0xff0000 for red, etc.\n    * @param {number} [duration=500] - The duration of the flash effect in milliseconds.\n    * @param {boolean} [force=false] - If a camera flash or fade effect is already running and force is true it will replace the previous effect, resetting the duration.\n    * @return {boolean} True if the effect was started, otherwise false.\n    */\n    flash: function (color, duration, force) {\n\n        if (color === undefined) { color = 0xffffff; }\n        if (duration === undefined) { duration = 500; }\n        if (force === undefined) { force = false; }\n\n        if (!this.fx || (!force && this._fxDuration > 0))\n        {\n            return false;\n        }\n\n        this.fx.clear();\n\n        this.fx.beginFill(color);\n        this.fx.drawRect(0, 0, this.width, this.height);\n        this.fx.endFill();\n\n        this.fx.alpha = 1;\n\n        this._fxDuration = duration;\n        this._fxType = 0;\n\n        return true;\n\n    },\n\n    /**\n    * This creates a camera fade effect. It works by filling the game with the\n    * color specified, over the duration given, ending with a solid fill.\n    *\n    * You can use this for things such as transitioning to a new scene.\n    *\n    * The game will be left 'filled' at the end of this effect, likely obscuring\n    * everything. In order to reset it you can call `Camera.resetFX` and it will clear the\n    * fade. Or you can call `Camera.flash` with the same color as the fade, and it will\n    * reverse the process, bringing the game back into view again.\n    *\n    * When the effect ends the signal Camera.onFadeComplete is dispatched.\n    *\n    * @method Phaser.Camera#fade\n    * @param {numer} [color=0x000000] - The color the game will fade to. I.e. 0x000000 for black, 0xff0000 for red, etc.\n    * @param {number} [duration=500] - The duration of the fade in milliseconds.\n    * @param {boolean} [force=false] - If a camera flash or fade effect is already running and force is true it will replace the previous effect, resetting the duration.\n    * @return {boolean} True if the effect was started, otherwise false.\n    */\n    fade: function (color, duration, force) {\n\n        if (color === undefined) { color = 0x000000; }\n        if (duration === undefined) { duration = 500; }\n        if (force === undefined) { force = false; }\n\n        if (!this.fx || (!force && this._fxDuration > 0))\n        {\n            return false;\n        }\n\n        this.fx.clear();\n\n        this.fx.beginFill(color);\n        this.fx.drawRect(0, 0, this.width, this.height);\n        this.fx.endFill();\n\n        this.fx.alpha = 0;\n\n        this._fxDuration = duration;\n        this._fxType = 1;\n\n        return true;\n\n    },\n\n    /**\n    * The camera update loop. This is called automatically by the core game loop.\n    *\n    * @method Phaser.Camera#update\n    * @protected\n    */\n    update: function () {\n\n        if (this._fxDuration > 0)\n        {\n            this.updateFX();\n        }\n\n        if (this._shake.duration > 0)\n        {\n            this.updateShake();\n        }\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n\n        if (this.roundPx)\n        {\n            this.view.floor();\n            this._shake.x = Math.floor(this._shake.x);\n            this._shake.y = Math.floor(this._shake.y);\n        }\n\n        this.displayObject.position.x = -this.view.x;\n        this.displayObject.position.y = -this.view.y;\n\n    },\n\n    /**\n    * Update the camera flash and fade effects.\n    *\n    * @method Phaser.Camera#updateFX\n    * @private\n    */\n    updateFX: function () {\n\n        if (this._fxType === 0)\n        {\n            //  flash\n            this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration;\n\n            if (this.fx.alpha <= 0)\n            {\n                this._fxDuration = 0;\n                this.fx.alpha = 0;\n                this.onFlashComplete.dispatch();\n            }\n        }\n        else\n        {\n            //  fade\n            this.fx.alpha += this.game.time.elapsedMS / this._fxDuration;\n\n            if (this.fx.alpha >= 1)\n            {\n                this._fxDuration = 0;\n                this.fx.alpha = 1;\n                this.onFadeComplete.dispatch();\n            }\n        }\n\n    },\n\n    /**\n    * Update the camera shake effect.\n    *\n    * @method Phaser.Camera#updateShake\n    * @private\n    */\n    updateShake: function () {\n\n        this._shake.duration -= this.game.time.elapsedMS;\n\n        if (this._shake.duration <= 0)\n        {\n            this.onShakeComplete.dispatch();\n            this._shake.x = 0;\n            this._shake.y = 0;\n        }\n        else\n        {\n            if (this._shake.horizontal)\n            {\n                this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width;\n            }\n\n            if (this._shake.vertical)\n            {\n                this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height;\n            }\n        }\n\n    },\n\n    /**\n    * Internal method that handles tracking a sprite.\n    *\n    * @method Phaser.Camera#updateTarget\n    * @private\n    */\n    updateTarget: function () {\n\n        this._targetPosition.x = this.view.x + this.target.worldPosition.x;\n        this._targetPosition.y = this.view.y + this.target.worldPosition.y;\n\n        if (this.deadzone)\n        {\n            this._edge = this._targetPosition.x - this.view.x;\n\n            if (this._edge < this.deadzone.left)\n            {\n                this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x);\n            }\n            else if (this._edge > this.deadzone.right)\n            {\n                this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x);\n            }\n\n            this._edge = this._targetPosition.y - this.view.y;\n\n            if (this._edge < this.deadzone.top)\n            {\n                this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y);\n            }\n            else if (this._edge > this.deadzone.bottom)\n            {\n                this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y);\n            }\n        }\n        else\n        {\n            this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x);\n            this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y);\n        }\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n\n        if (this.roundPx)\n        {\n            this.view.floor();\n        }\n\n        this.displayObject.position.x = -this.view.x;\n        this.displayObject.position.y = -this.view.y;\n\n    },\n\n    /**\n    * Update the Camera bounds to match the game world.\n    *\n    * @method Phaser.Camera#setBoundsToWorld\n    */\n    setBoundsToWorld: function () {\n\n        if (this.bounds)\n        {\n            this.bounds.copyFrom(this.game.world.bounds);\n        }\n\n    },\n\n    /**\n    * Method called to ensure the camera doesn't venture outside of the game world.\n    * Called automatically by Camera.update.\n    *\n    * @method Phaser.Camera#checkBounds\n    * @protected\n    */\n    checkBounds: function () {\n\n        this.atLimit.x = false;\n        this.atLimit.y = false;\n\n        var vx = this.view.x + this._shake.x;\n        var vw = this.view.right + this._shake.x;\n        var vy = this.view.y + this._shake.y;\n        var vh = this.view.bottom + this._shake.y;\n\n        //  Make sure we didn't go outside the cameras bounds\n        if (vx <= this.bounds.x * this.scale.x)\n        {\n            this.atLimit.x = true;\n            this.view.x = this.bounds.x * this.scale.x;\n\n            if (!this._shake.shakeBounds)\n            {\n                //  The camera is up against the bounds, so reset the shake\n                this._shake.x = 0;\n            }\n        }\n\n        if (vw >= this.bounds.right * this.scale.x)\n        {\n            this.atLimit.x = true;\n            this.view.x = (this.bounds.right * this.scale.x) - this.width;\n\n            if (!this._shake.shakeBounds)\n            {\n                //  The camera is up against the bounds, so reset the shake\n                this._shake.x = 0;\n            }\n        }\n\n        if (vy <= this.bounds.top * this.scale.y)\n        {\n            this.atLimit.y = true;\n            this.view.y = this.bounds.top * this.scale.y;\n\n            if (!this._shake.shakeBounds)\n            {\n                //  The camera is up against the bounds, so reset the shake\n                this._shake.y = 0;\n            }\n        }\n\n        if (vh >= this.bounds.bottom * this.scale.y)\n        {\n            this.atLimit.y = true;\n            this.view.y = (this.bounds.bottom * this.scale.y) - this.height;\n\n            if (!this._shake.shakeBounds)\n            {\n                //  The camera is up against the bounds, so reset the shake\n                this._shake.y = 0;\n            }\n        }\n\n    },\n\n    /**\n    * A helper function to set both the X and Y properties of the camera at once\n    * without having to use game.camera.x and game.camera.y.\n    *\n    * @method Phaser.Camera#setPosition\n    * @param {number} x - X position.\n    * @param {number} y - Y position.\n    */\n    setPosition: function (x, y) {\n\n        this.view.x = x;\n        this.view.y = y;\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n\n    },\n\n    /**\n    * Sets the size of the view rectangle given the width and height in parameters.\n    *\n    * @method Phaser.Camera#setSize\n    * @param {number} width - The desired width.\n    * @param {number} height - The desired height.\n    */\n    setSize: function (width, height) {\n\n        this.view.width = width;\n        this.view.height = height;\n\n    },\n\n    /**\n    * Resets the camera back to 0,0 and un-follows any object it may have been tracking.\n    * Also immediately resets any camera effects that may have been running such as\n    * shake, flash or fade.\n    *\n    * @method Phaser.Camera#reset\n    */\n    reset: function () {\n\n        this.target = null;\n\n        this.view.x = 0;\n        this.view.y = 0;\n\n        this._shake.duration = 0;\n\n        this.resetFX();\n\n    },\n\n    /**\n    * Resets any active FX, such as a fade or flash and immediately clears it.\n    * Useful to calling after a fade in order to remove the fade from the Stage.\n    *\n    * @method Phaser.Camera#resetFX\n    */\n    resetFX: function () {\n\n        this.fx.clear();\n\n        this.fx.alpha = 0;\n\n        this._fxDuration = 0;\n\n    }\n\n};\n\nPhaser.Camera.prototype.constructor = Phaser.Camera;\n\n/**\n* The Cameras x coordinate. This value is automatically clamped if it falls outside of the World bounds.\n* @name Phaser.Camera#x\n* @property {number} x - Gets or sets the cameras x position.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"x\", {\n\n    get: function () {\n\n        return this.view.x;\n\n    },\n\n    set: function (value) {\n\n        this.view.x = value;\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n    }\n\n});\n\n/**\n* The Cameras y coordinate. This value is automatically clamped if it falls outside of the World bounds.\n* @name Phaser.Camera#y\n* @property {number} y - Gets or sets the cameras y position.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"y\", {\n\n    get: function () {\n\n        return this.view.y;\n\n    },\n\n    set: function (value) {\n\n        this.view.y = value;\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n    }\n\n});\n\n/**\n* The Cameras position. This value is automatically clamped if it falls outside of the World bounds.\n* @name Phaser.Camera#position\n* @property {Phaser.Point} position - Gets or sets the cameras xy position using Phaser.Point object.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"position\", {\n\n    get: function () {\n\n        this._position.set(this.view.x, this.view.y);\n\n        return this._position;\n\n    },\n\n    set: function (value) {\n\n        if (typeof value.x !== \"undefined\") { this.view.x = value.x; }\n        if (typeof value.y !== \"undefined\") { this.view.y = value.y; }\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n    }\n\n});\n\n/**\n* The Cameras width. By default this is the same as the Game size and should not be adjusted for now.\n* @name Phaser.Camera#width\n* @property {number} width - Gets or sets the cameras width.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"width\", {\n\n    get: function () {\n\n        return this.view.width;\n\n    },\n\n    set: function (value) {\n\n        this.view.width = value;\n\n    }\n\n});\n\n/**\n* The Cameras height. By default this is the same as the Game size and should not be adjusted for now.\n* @name Phaser.Camera#height\n* @property {number} height - Gets or sets the cameras height.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"height\", {\n\n    get: function () {\n\n        return this.view.height;\n\n    },\n\n    set: function (value) {\n\n        this.view.height = value;\n\n    }\n\n});\n\n\n/**\n* The Cameras shake intensity.\n* @name Phaser.Camera#shakeIntensity\n* @property {number} shakeIntensity - Gets or sets the cameras shake intensity.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"shakeIntensity\", {\n\n    get: function () {\n\n        return this._shake.intensity;\n\n    },\n\n    set: function (value) {\n\n        this._shake.intensity = value;\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* This is a base State class which can be extended if you are creating your own game.\n* It provides quick access to common functions such as the camera, cache, input, match, sound and more.\n*\n* @class Phaser.State\n* @constructor\n*/\nPhaser.State = function () {\n\n    /**\n    * @property {Phaser.Game} game - This is a reference to the currently running Game.\n    */\n    this.game = null;\n\n    /**\n    * @property {string} key - The string based identifier given to the State when added into the State Manager.\n    */\n    this.key = '';\n\n    /**\n    * @property {Phaser.GameObjectFactory} add - A reference to the GameObjectFactory which can be used to add new objects to the World.\n    */\n    this.add = null;\n\n    /**\n    * @property {Phaser.GameObjectCreator} make - A reference to the GameObjectCreator which can be used to make new objects.\n    */\n    this.make = null;\n\n    /**\n    * @property {Phaser.Camera} camera - A handy reference to World.camera.\n    */\n    this.camera = null;\n\n    /**\n    * @property {Phaser.Cache} cache - A reference to the game cache which contains any loaded or generated assets, such as images, sound and more.\n    */\n    this.cache = null;\n\n    /**\n    * @property {Phaser.Input} input - A reference to the Input Manager.\n    */\n    this.input = null;\n\n    /**\n    * @property {Phaser.Loader} load - A reference to the Loader, which you mostly use in the preload method of your state to load external assets.\n    */\n    this.load = null;\n\n    /**\n    * @property {Phaser.Math} math - A reference to Math class with lots of helpful functions.\n    */\n    this.math = null;\n\n    /**\n    * @property {Phaser.SoundManager} sound - A reference to the Sound Manager which can create, play and stop sounds, as well as adjust global volume.\n    */\n    this.sound = null;\n\n    /**\n    * @property {Phaser.ScaleManager} scale - A reference to the Scale Manager which controls the way the game scales on different displays.\n    */\n    this.scale = null;\n\n    /**\n    * @property {Phaser.Stage} stage - A reference to the Stage.\n    */\n    this.stage = null;\n\n    /**\n    * @property {Phaser.StateManager} stage - A reference to the State Manager, which controls state changes.\n    */\n    this.state = null;\n\n    /**\n    * @property {Phaser.Time} time - A reference to the game clock and timed events system.\n    */\n    this.time = null;\n\n    /**\n    * @property {Phaser.TweenManager} tweens - A reference to the tween manager.\n    */\n    this.tweens = null;\n\n    /**\n    * @property {Phaser.World} world - A reference to the game world. All objects live in the Game World and its size is not bound by the display resolution.\n    */\n    this.world = null;\n\n    /**\n    * @property {Phaser.Particles} particles - The Particle Manager. It is called during the core gameloop and updates any Particle Emitters it has created.\n    */\n    this.particles = null;\n\n    /**\n    * @property {Phaser.Physics} physics - A reference to the physics manager which looks after the different physics systems available within Phaser.\n    */\n    this.physics = null;\n\n    /**\n    * @property {Phaser.RandomDataGenerator} rnd - A reference to the seeded and repeatable random data generator.\n    */\n    this.rnd = null;\n\n};\n\nPhaser.State.prototype = {\n\n    /**\n    * init is the very first function called when your State starts up. It's called before preload, create or anything else.\n    * If you need to route the game away to another State you could do so here, or if you need to prepare a set of variables\n    * or objects before the preloading starts.\n    *\n    * @method Phaser.State#init\n    */\n    init: function () {\n    },\n\n    /**\n    * preload is called first. Normally you'd use this to load your game assets (or those needed for the current State)\n    * You shouldn't create any objects in this method that require assets that you're also loading in this method, as\n    * they won't yet be available.\n    *\n    * @method Phaser.State#preload\n    */\n    preload: function () {\n    },\n\n    /**\n    * loadUpdate is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.\n    *\n    * @method Phaser.State#loadUpdate\n    */\n    loadUpdate: function () {\n    },\n\n    /**\n    * loadRender is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.\n    * The difference between loadRender and render is that any objects you render in this method you must be sure their assets exist.\n    *\n    * @method Phaser.State#loadRender\n    */\n    loadRender: function () {\n    },\n\n    /**\n    * create is called once preload has completed, this includes the loading of any assets from the Loader.\n    * If you don't have a preload method then create is the first method called in your State.\n    *\n    * @method Phaser.State#create\n    */\n    create: function () {\n    },\n\n    /**\n    * The update method is left empty for your own use.\n    * It is called during the core game loop AFTER debug, physics, plugins and the Stage have had their preUpdate methods called.\n    * It is called BEFORE Stage, Tweens, Sounds, Input, Physics, Particles and Plugins have had their postUpdate methods called.\n    *\n    * @method Phaser.State#update\n    */\n    update: function () {\n    },\n\n    /**\n    * The preRender method is called after all Game Objects have been updated, but before any rendering takes place.\n    *\n    * @method Phaser.State#preRender\n    */\n    preRender: function () {\n    },\n\n    /**\n    * Nearly all display objects in Phaser render automatically, you don't need to tell them to render.\n    * However the render method is called AFTER the game renderer and plugins have rendered, so you're able to do any\n    * final post-processing style effects here. Note that this happens before plugins postRender takes place.\n    *\n    * @method Phaser.State#render\n    */\n    render: function () {\n    },\n\n    /**\n    * If your game is set to Scalemode RESIZE then each time the browser resizes it will call this function, passing in the new width and height.\n    *\n    * @method Phaser.State#resize\n    */\n    resize: function () {\n    },\n\n    /**\n    * This method will be called if the core game loop is paused.\n    *\n    * @method Phaser.State#paused\n    */\n    paused: function () {\n    },\n\n    /**\n    * This method will be called when the core game loop resumes from a paused state.\n    *\n    * @method Phaser.State#resumed\n    */\n    resumed: function () {\n    },\n\n    /**\n    * pauseUpdate is called while the game is paused instead of preUpdate, update and postUpdate.\n    *\n    * @method Phaser.State#pauseUpdate\n    */\n    pauseUpdate: function () {\n    },\n\n    /**\n    * This method will be called when the State is shutdown (i.e. you switch to another state from this one).\n    *\n    * @method Phaser.State#shutdown\n    */\n    shutdown: function () {\n    }\n\n};\n\nPhaser.State.prototype.constructor = Phaser.State;\n\n/* jshint newcap: false */\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The State Manager is responsible for loading, setting up and switching game states.\n*\n* @class Phaser.StateManager\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {Phaser.State|Object} [pendingState=null] - A State object to seed the manager with.\n*/\nPhaser.StateManager = function (game, pendingState) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {object} states - The object containing Phaser.States.\n    */\n    this.states = {};\n\n    /**\n    * @property {Phaser.State} _pendingState - The state to be switched to in the next frame.\n    * @private\n    */\n    this._pendingState = null;\n\n    if (typeof pendingState !== 'undefined' && pendingState !== null)\n    {\n        this._pendingState = pendingState;\n    }\n\n    /**\n    * @property {boolean} _clearWorld - Clear the world when we switch state?\n    * @private\n    */\n    this._clearWorld = false;\n\n    /**\n    * @property {boolean} _clearCache - Clear the cache when we switch state?\n    * @private\n    */\n    this._clearCache = false;\n\n    /**\n    * @property {boolean} _created - Flag that sets if the State has been created or not.\n    * @private\n    */\n    this._created = false;\n\n    /**\n    * @property {any[]} _args - Temporary container when you pass vars from one State to another.\n    * @private\n    */\n    this._args = [];\n\n    /**\n    * @property {string} current - The current active State object.\n    * @default\n    */\n    this.current = '';\n\n    /**\n    * onStateChange is a Phaser.Signal that is dispatched whenever the game changes state.\n    * \n    * It is dispatched only when the new state is started, which isn't usually at the same time as StateManager.start\n    * is called because state swapping is done in sync with the game loop. It is dispatched *before* any of the new states\n    * methods (such as preload and create) are called, and *after* the previous states shutdown method has been run.\n    *\n    * The callback you specify is sent two parameters: the string based key of the new state, \n    * and the second parameter is the string based key of the old / previous state.\n    * \n    * @property {Phaser.Signal} onStateChange\n    */\n    this.onStateChange = new Phaser.Signal();\n\n    /**\n    * @property {function} onInitCallback - This is called when the state is set as the active state.\n    * @default\n    */\n    this.onInitCallback = null;\n\n    /**\n    * @property {function} onPreloadCallback - This is called when the state starts to load assets.\n    * @default\n    */\n    this.onPreloadCallback = null;\n\n    /**\n    * @property {function} onCreateCallback - This is called when the state preload has finished and creation begins.\n    * @default\n    */\n    this.onCreateCallback = null;\n\n    /**\n    * @property {function} onUpdateCallback - This is called when the state is updated, every game loop. It doesn't happen during preload (@see onLoadUpdateCallback).\n    * @default\n    */\n    this.onUpdateCallback = null;\n\n    /**\n    * @property {function} onRenderCallback - This is called post-render. It doesn't happen during preload (see onLoadRenderCallback).\n    * @default\n    */\n    this.onRenderCallback = null;\n\n    /**\n    * @property {function} onResizeCallback - This is called if ScaleManager.scalemode is RESIZE and a resize event occurs. It's passed the new width and height.\n    * @default\n    */\n    this.onResizeCallback = null;\n\n    /**\n    * @property {function} onPreRenderCallback - This is called before the state is rendered and before the stage is cleared but after all game objects have had their final properties adjusted.\n    * @default\n    */\n    this.onPreRenderCallback = null;\n\n    /**\n    * @property {function} onLoadUpdateCallback - This is called when the State is updated during the preload phase.\n    * @default\n    */\n    this.onLoadUpdateCallback = null;\n\n    /**\n    * @property {function} onLoadRenderCallback - This is called when the State is rendered during the preload phase.\n    * @default\n    */\n    this.onLoadRenderCallback = null;\n\n    /**\n    * @property {function} onPausedCallback - This is called when the game is paused.\n    * @default\n    */\n    this.onPausedCallback = null;\n\n    /**\n    * @property {function} onResumedCallback - This is called when the game is resumed from a paused state.\n    * @default\n    */\n    this.onResumedCallback = null;\n\n    /**\n    * @property {function} onPauseUpdateCallback - This is called every frame while the game is paused.\n    * @default\n    */\n    this.onPauseUpdateCallback = null;\n\n    /**\n    * @property {function} onShutDownCallback - This is called when the state is shut down (i.e. swapped to another state).\n    * @default\n    */\n    this.onShutDownCallback = null;\n\n};\n\nPhaser.StateManager.prototype = {\n\n    /**\n    * The Boot handler is called by Phaser.Game when it first starts up.\n    * @method Phaser.StateManager#boot\n    * @private\n    */\n    boot: function () {\n\n        this.game.onPause.add(this.pause, this);\n        this.game.onResume.add(this.resume, this);\n\n        if (this._pendingState !== null && typeof this._pendingState !== 'string')\n        {\n            this.add('default', this._pendingState, true);\n        }\n\n    },\n\n    /**\n    * Adds a new State into the StateManager. You must give each State a unique key by which you'll identify it.\n    * The State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.\n    * If a function is given a new state object will be created by calling it.\n    *\n    * @method Phaser.StateManager#add\n    * @param {string} key - A unique key you use to reference this state, i.e. \"MainMenu\", \"Level1\".\n    * @param {Phaser.State|object|function} state  - The state you want to switch to.\n    * @param {boolean} [autoStart=false]  - If true the State will be started immediately after adding it.\n    */\n    add: function (key, state, autoStart) {\n\n        if (autoStart === undefined) { autoStart = false; }\n\n        var newState;\n\n        if (state instanceof Phaser.State)\n        {\n            newState = state;\n        }\n        else if (typeof state === 'object')\n        {\n            newState = state;\n            newState.game = this.game;\n        }\n        else if (typeof state === 'function')\n        {\n            newState = new state(this.game);\n        }\n\n        this.states[key] = newState;\n\n        if (autoStart)\n        {\n            if (this.game.isBooted)\n            {\n                this.start(key);\n            }\n            else\n            {\n                this._pendingState = key;\n            }\n        }\n\n        return newState;\n\n    },\n\n    /**\n    * Delete the given state.\n    * @method Phaser.StateManager#remove\n    * @param {string} key - A unique key you use to reference this state, i.e. \"MainMenu\", \"Level1\".\n    */\n    remove: function (key) {\n\n        if (this.current === key)\n        {\n            this.callbackContext = null;\n\n            this.onInitCallback = null;\n            this.onShutDownCallback = null;\n\n            this.onPreloadCallback = null;\n            this.onLoadRenderCallback = null;\n            this.onLoadUpdateCallback = null;\n            this.onCreateCallback = null;\n            this.onUpdateCallback = null;\n            this.onPreRenderCallback = null;\n            this.onRenderCallback = null;\n            this.onResizeCallback = null;\n            this.onPausedCallback = null;\n            this.onResumedCallback = null;\n            this.onPauseUpdateCallback = null;\n        }\n\n        delete this.states[key];\n\n    },\n\n    /**\n    * Start the given State. If a State is already running then State.shutDown will be called (if it exists) before switching to the new State.\n    *\n    * @method Phaser.StateManager#start\n    * @param {string} key - The key of the state you want to start.\n    * @param {boolean} [clearWorld=true] - Clear everything in the world? This clears the World display list fully (but not the Stage, so if you've added your own objects to the Stage they will need managing directly)\n    * @param {boolean} [clearCache=false] - Clear the Game.Cache? This purges out all loaded assets. The default is false and you must have clearWorld=true if you want to clearCache as well.\n    * @param {...*} parameter - Additional parameters that will be passed to the State.init function (if it has one).\n    */\n    start: function (key, clearWorld, clearCache) {\n\n        if (clearWorld === undefined) { clearWorld = true; }\n        if (clearCache === undefined) { clearCache = false; }\n\n        if (this.checkState(key))\n        {\n            //  Place the state in the queue. It will be started the next time the game loop begins.\n            this._pendingState = key;\n            this._clearWorld = clearWorld;\n            this._clearCache = clearCache;\n\n            if (arguments.length > 3)\n            {\n                this._args = Array.prototype.splice.call(arguments, 3);\n            }\n        }\n\n    },\n\n    /**\n    * Restarts the current State. State.shutDown will be called (if it exists) before the State is restarted.\n    *\n    * @method Phaser.StateManager#restart\n    * @param {boolean} [clearWorld=true] - Clear everything in the world? This clears the World display list fully (but not the Stage, so if you've added your own objects to the Stage they will need managing directly)\n    * @param {boolean} [clearCache=false] - Clear the Game.Cache? This purges out all loaded assets. The default is false and you must have clearWorld=true if you want to clearCache as well.\n    * @param {...*} parameter - Additional parameters that will be passed to the State.init function if it has one.\n    */\n    restart: function (clearWorld, clearCache) {\n\n        if (clearWorld === undefined) { clearWorld = true; }\n        if (clearCache === undefined) { clearCache = false; }\n\n        //  Place the state in the queue. It will be started the next time the game loop starts.\n        this._pendingState = this.current;\n        this._clearWorld = clearWorld;\n        this._clearCache = clearCache;\n\n        if (arguments.length > 2)\n        {\n            this._args = Array.prototype.slice.call(arguments, 2);\n        }\n\n    },\n\n    /**\n    * Used by onInit and onShutdown when those functions don't exist on the state\n    * @method Phaser.StateManager#dummy\n    * @private\n    */\n    dummy: function () {\n    },\n\n    /**\n    * preUpdate is called right at the start of the game loop. It is responsible for changing to a new state that was requested previously.\n    *\n    * @method Phaser.StateManager#preUpdate\n    */\n    preUpdate: function () {\n\n        if (this._pendingState && this.game.isBooted)\n        {\n            var previousStateKey = this.current;\n\n            //  Already got a state running?\n            this.clearCurrentState();\n\n            this.setCurrentState(this._pendingState);\n\n            this.onStateChange.dispatch(this.current, previousStateKey);\n\n            if (this.current !== this._pendingState)\n            {\n                return;\n            }\n            else\n            {\n                this._pendingState = null;\n            }\n\n            //  If StateManager.start has been called from the init of a State that ALSO has a preload, then\n            //  onPreloadCallback will be set, but must be ignored\n            if (this.onPreloadCallback)\n            {\n                this.game.load.reset(true);\n                this.onPreloadCallback.call(this.callbackContext, this.game);\n\n                //  Is the loader empty?\n                if (this.game.load.totalQueuedFiles() === 0 && this.game.load.totalQueuedPacks() === 0)\n                {\n                    this.loadComplete();\n                }\n                else\n                {\n                    //  Start the loader going as we have something in the queue\n                    this.game.load.start();\n                }\n            }\n            else\n            {\n                //  No init? Then there was nothing to load either\n                this.loadComplete();\n            }\n        }\n\n    },\n\n    /**\n    * This method clears the current State, calling its shutdown callback. The process also removes any active tweens,\n    * resets the camera, resets input, clears physics, removes timers and if set clears the world and cache too.\n    *\n    * @method Phaser.StateManager#clearCurrentState\n    */\n    clearCurrentState: function () {\n\n        if (this.current)\n        {\n            if (this.onShutDownCallback)\n            {\n                this.onShutDownCallback.call(this.callbackContext, this.game);\n            }\n\n            this.game.tweens.removeAll();\n\n            this.game.camera.reset();\n\n            this.game.input.reset(true);\n\n            this.game.physics.clear();\n\n            this.game.time.removeAll();\n\n            this.game.scale.reset(this._clearWorld);\n\n            if (this.game.debug)\n            {\n                this.game.debug.reset();\n            }\n\n            if (this._clearWorld)\n            {\n                this.game.world.shutdown();\n\n                if (this._clearCache)\n                {\n                    this.game.cache.destroy();\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Checks if a given phaser state is valid. A State is considered valid if it has at least one of the core functions: preload, create, update or render.\n    *\n    * @method Phaser.StateManager#checkState\n    * @param {string} key - The key of the state you want to check.\n    * @return {boolean} true if the State has the required functions, otherwise false.\n    */\n    checkState: function (key) {\n\n        if (this.states[key])\n        {\n            if (this.states[key]['preload'] || this.states[key]['create'] || this.states[key]['update'] || this.states[key]['render'])\n            {\n                return true;\n            }\n            else\n            {\n                console.warn(\"Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render\");\n                return false;\n            }\n        }\n        else\n        {\n            console.warn(\"Phaser.StateManager - No state found with the key: \" + key);\n            return false;\n        }\n\n    },\n\n    /**\n    * Links game properties to the State given by the key.\n    *\n    * @method Phaser.StateManager#link\n    * @param {string} key - State key.\n    * @protected\n    */\n    link: function (key) {\n\n        this.states[key].game = this.game;\n        this.states[key].add = this.game.add;\n        this.states[key].make = this.game.make;\n        this.states[key].camera = this.game.camera;\n        this.states[key].cache = this.game.cache;\n        this.states[key].input = this.game.input;\n        this.states[key].load = this.game.load;\n        this.states[key].math = this.game.math;\n        this.states[key].sound = this.game.sound;\n        this.states[key].scale = this.game.scale;\n        this.states[key].state = this;\n        this.states[key].stage = this.game.stage;\n        this.states[key].time = this.game.time;\n        this.states[key].tweens = this.game.tweens;\n        this.states[key].world = this.game.world;\n        this.states[key].particles = this.game.particles;\n        this.states[key].rnd = this.game.rnd;\n        this.states[key].physics = this.game.physics;\n        this.states[key].key = key;\n\n    },\n\n    /**\n    * Nulls all State level Phaser properties, including a reference to Game.\n    *\n    * @method Phaser.StateManager#unlink\n    * @param {string} key - State key.\n    * @protected\n    */\n    unlink: function (key) {\n\n        if (this.states[key])\n        {\n            this.states[key].game = null;\n            this.states[key].add = null;\n            this.states[key].make = null;\n            this.states[key].camera = null;\n            this.states[key].cache = null;\n            this.states[key].input = null;\n            this.states[key].load = null;\n            this.states[key].math = null;\n            this.states[key].sound = null;\n            this.states[key].scale = null;\n            this.states[key].state = null;\n            this.states[key].stage = null;\n            this.states[key].time = null;\n            this.states[key].tweens = null;\n            this.states[key].world = null;\n            this.states[key].particles = null;\n            this.states[key].rnd = null;\n            this.states[key].physics = null;\n        }\n\n    },\n\n    /**\n    * Sets the current State. Should not be called directly (use StateManager.start)\n    *\n    * @method Phaser.StateManager#setCurrentState\n    * @param {string} key - State key.\n    * @private\n    */\n    setCurrentState: function (key) {\n\n        this.callbackContext = this.states[key];\n\n        this.link(key);\n\n        //  Used when the state is set as being the current active state\n        this.onInitCallback = this.states[key]['init'] || this.dummy;\n\n        this.onPreloadCallback = this.states[key]['preload'] || null;\n        this.onLoadRenderCallback = this.states[key]['loadRender'] || null;\n        this.onLoadUpdateCallback = this.states[key]['loadUpdate'] || null;\n        this.onCreateCallback = this.states[key]['create'] || null;\n        this.onUpdateCallback = this.states[key]['update'] || null;\n        this.onPreRenderCallback = this.states[key]['preRender'] || null;\n        this.onRenderCallback = this.states[key]['render'] || null;\n        this.onResizeCallback = this.states[key]['resize'] || null;\n        this.onPausedCallback = this.states[key]['paused'] || null;\n        this.onResumedCallback = this.states[key]['resumed'] || null;\n        this.onPauseUpdateCallback = this.states[key]['pauseUpdate'] || null;\n\n        //  Used when the state is no longer the current active state\n        this.onShutDownCallback = this.states[key]['shutdown'] || this.dummy;\n\n        //  Reset the physics system, but not on the first state start\n        if (this.current !== '')\n        {\n            this.game.physics.reset();\n        }\n\n        this.current = key;\n        this._created = false;\n\n        //  At this point key and pendingState should equal each other\n        this.onInitCallback.apply(this.callbackContext, this._args);\n\n        //  If they no longer do then the init callback hit StateManager.start\n        if (key === this._pendingState)\n        {\n            this._args = [];\n        }\n\n        this.game._kickstart = true;\n\n    },\n\n    /**\n     * Gets the current State.\n     *\n     * @method Phaser.StateManager#getCurrentState\n     * @return {Phaser.State}\n     * @public\n     */\n    getCurrentState: function() {\n        return this.states[this.current];\n    },\n\n    /**\n    * @method Phaser.StateManager#loadComplete\n    * @protected\n    */\n    loadComplete: function () {\n\n        //  Make sure to do load-update one last time before state is set to _created\n        if (this._created === false && this.onLoadUpdateCallback)\n        {\n            this.onLoadUpdateCallback.call(this.callbackContext, this.game);\n        }\n\n        if (this._created === false && this.onCreateCallback)\n        {\n            this._created = true;\n            this.onCreateCallback.call(this.callbackContext, this.game);\n        }\n        else\n        {\n            this._created = true;\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#pause\n    * @protected\n    */\n    pause: function () {\n\n        if (this._created && this.onPausedCallback)\n        {\n            this.onPausedCallback.call(this.callbackContext, this.game);\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#resume\n    * @protected\n    */\n    resume: function () {\n\n        if (this._created && this.onResumedCallback)\n        {\n            this.onResumedCallback.call(this.callbackContext, this.game);\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#update\n    * @protected\n    */\n    update: function () {\n\n        if (this._created)\n        {\n            if (this.onUpdateCallback)\n            {\n                this.onUpdateCallback.call(this.callbackContext, this.game);\n            }\n        }\n        else\n        {\n            if (this.onLoadUpdateCallback)\n            {\n                this.onLoadUpdateCallback.call(this.callbackContext, this.game);\n            }\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#pauseUpdate\n    * @protected\n    */\n    pauseUpdate: function () {\n\n        if (this._created)\n        {\n            if (this.onPauseUpdateCallback)\n            {\n                this.onPauseUpdateCallback.call(this.callbackContext, this.game);\n            }\n        }\n        else\n        {\n            if (this.onLoadUpdateCallback)\n            {\n                this.onLoadUpdateCallback.call(this.callbackContext, this.game);\n            }\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#preRender\n    * @protected\n    * @param {number} elapsedTime - The time elapsed since the last update.\n    */\n    preRender: function (elapsedTime) {\n\n        if (this._created && this.onPreRenderCallback)\n        {\n            this.onPreRenderCallback.call(this.callbackContext, this.game, elapsedTime);\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#resize\n    * @protected\n    */\n    resize: function (width, height) {\n\n        if (this.onResizeCallback)\n        {\n            this.onResizeCallback.call(this.callbackContext, width, height);\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#render\n    * @protected\n    */\n    render: function () {\n\n        if (this._created)\n        {\n            if (this.onRenderCallback)\n            {\n                if (this.game.renderType === Phaser.CANVAS)\n                {\n                    this.game.context.save();\n                    this.game.context.setTransform(1, 0, 0, 1, 0, 0);\n                    this.onRenderCallback.call(this.callbackContext, this.game);\n                    this.game.context.restore();\n                }\n                else\n                {\n                    this.onRenderCallback.call(this.callbackContext, this.game);\n                }\n            }\n        }\n        else\n        {\n            if (this.onLoadRenderCallback)\n            {\n                this.onLoadRenderCallback.call(this.callbackContext, this.game);\n            }\n        }\n\n    },\n\n    /**\n    * Removes all StateManager callback references to the State object, nulls the game reference and clears the States object.\n    * You don't recover from this without rebuilding the Phaser instance again.\n    * @method Phaser.StateManager#destroy\n    */\n    destroy: function () {\n\n        this._clearWorld = true;\n        this._clearCache = true;\n\n        this.clearCurrentState();\n\n        this.callbackContext = null;\n\n        this.onInitCallback = null;\n        this.onShutDownCallback = null;\n\n        this.onPreloadCallback = null;\n        this.onLoadRenderCallback = null;\n        this.onLoadUpdateCallback = null;\n        this.onCreateCallback = null;\n        this.onUpdateCallback = null;\n        this.onRenderCallback = null;\n        this.onPausedCallback = null;\n        this.onResumedCallback = null;\n        this.onPauseUpdateCallback = null;\n\n        this.game = null;\n        this.states = {};\n        this._pendingState = null;\n        this.current = '';\n\n    }\n\n};\n\nPhaser.StateManager.prototype.constructor = Phaser.StateManager;\n\n/**\n* @name Phaser.StateManager#created\n* @property {boolean} created - True if the current state has had its `create` method run (if it has one, if not this is true by default).\n* @readOnly\n*/\nObject.defineProperty(Phaser.StateManager.prototype, \"created\", {\n\n    get: function () {\n\n        return this._created;\n\n    }\n\n});\n\n/**\n* \"It's like nailing jelly to a kitten\" - Gary Penn\n*/\n\n/**\n* @author       Miller Medeiros http://millermedeiros.github.com/js-signals/\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Signals are what Phaser uses to handle events and event dispatching.\n* You can listen for a Signal by binding a callback / function to it.\n* This is done by using either `Signal.add` or `Signal.addOnce`.\n*\n* For example you can listen for a touch or click event from the Input Manager \n* by using its `onDown` Signal:\n*\n* `game.input.onDown.add(function() { ... });`\n*\n* Rather than inline your function, you can pass a reference:\n*\n* `game.input.onDown.add(clicked, this);`\n* `function clicked () { ... }`\n*\n* In this case the second argument (`this`) is the context in which your function should be called.\n*\n* Now every time the InputManager dispatches the `onDown` signal (or event), your function\n* will be called.\n*\n* Very often a Signal will send arguments to your function.\n* This is specific to the Signal itself.\n* If you're unsure then check the documentation, or failing that simply do:\n*\n* `Signal.add(function() { console.log(arguments); })`\n*\n* and it will log all of the arguments your function received from the Signal.\n*\n* Sprites have lots of default signals you can listen to in their Events class, such as:\n*\n* `sprite.events.onKilled`\n* \n* Which is called automatically whenever the Sprite is killed.\n* There are lots of other events, see the Events component for a list.\n*\n* As well as listening to pre-defined Signals you can also create your own:\n*\n* `var mySignal = new Phaser.Signal();`\n*\n* This creates a new Signal. You can bind a callback to it:\n*\n* `mySignal.add(myCallback, this);`\n*\n* and then finally when ready you can dispatch the Signal:\n*\n* `mySignal.dispatch(your arguments);`\n*\n* And your callback will be invoked. See the dispatch method for more details.\n*\n* @class Phaser.Signal\n* @constructor\n*/\nPhaser.Signal = function () {};\n\nPhaser.Signal.prototype = {\n\n    /**\n    * @property {?Array.<Phaser.SignalBinding>} _bindings - Internal variable.\n    * @private\n    */\n    _bindings: null,\n\n    /**\n    * @property {any} _prevParams - Internal variable.\n    * @private\n    */\n    _prevParams: null,\n\n    /**\n    * Memorize the previously dispatched event?\n    *\n    * If an event has been memorized it is automatically dispatched when a new listener is added with {@link #add} or {@link #addOnce}.\n    * Use {@link #forget} to clear any currently memorized event.\n    *\n    * @property {boolean} memorize\n    */\n    memorize: false,\n\n    /**\n    * @property {boolean} _shouldPropagate\n    * @private\n    */\n    _shouldPropagate: true,\n\n    /**\n    * Is the Signal active? Only active signals will broadcast dispatched events.\n    *\n    * Setting this property during a dispatch will only affect the next dispatch. To stop the propagation of a signal from a listener use {@link #halt}.\n    *\n    * @property {boolean} active\n    * @default\n    */\n    active: true,\n\n    /**\n    * @property {function} _boundDispatch - The bound dispatch function, if any.\n    * @private\n    */\n    _boundDispatch: false,\n\n    /**\n    * @method Phaser.Signal#validateListener\n    * @param {function} listener - Signal handler function.\n    * @param {string} fnName - Function name.\n    * @private\n    */\n    validateListener: function (listener, fnName) {\n\n        if (typeof listener !== 'function')\n        {\n            throw new Error('Phaser.Signal: listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName));\n        }\n\n    },\n\n    /**\n    * @method Phaser.Signal#_registerListener\n    * @private\n    * @param {function} listener - Signal handler function.\n    * @param {boolean} isOnce - Should the listener only be called once?\n    * @param {object} [listenerContext] - The context under which the listener is invoked.\n    * @param {number} [priority] - The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0).\n    * @return {Phaser.SignalBinding} An Object representing the binding between the Signal and listener.\n    */\n    _registerListener: function (listener, isOnce, listenerContext, priority, args) {\n\n        var prevIndex = this._indexOfListener(listener, listenerContext);\n        var binding;\n\n        if (prevIndex !== -1)\n        {\n            binding = this._bindings[prevIndex];\n\n            if (binding.isOnce() !== isOnce)\n            {\n                throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');\n            }\n        }\n        else\n        {\n            binding = new Phaser.SignalBinding(this, listener, isOnce, listenerContext, priority, args);\n            this._addBinding(binding);\n        }\n\n        if (this.memorize && this._prevParams)\n        {\n            binding.execute(this._prevParams);\n        }\n\n        return binding;\n\n    },\n\n    /**\n    * @method Phaser.Signal#_addBinding\n    * @private\n    * @param {Phaser.SignalBinding} binding - An Object representing the binding between the Signal and listener.\n    */\n    _addBinding: function (binding) {\n\n        if (!this._bindings)\n        {\n            this._bindings = [];\n        }\n\n        //  Simplified insertion sort\n        var n = this._bindings.length;\n\n        do {\n            n--;\n        }\n        while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);\n\n        this._bindings.splice(n + 1, 0, binding);\n\n    },\n\n    /**\n    * @method Phaser.Signal#_indexOfListener\n    * @private\n    * @param {function} listener - Signal handler function.\n    * @param {object} [context=null] - Signal handler function.\n    * @return {number} The index of the listener within the private bindings array.\n    */\n    _indexOfListener: function (listener, context) {\n\n        if (!this._bindings)\n        {\n            return -1;\n        }\n\n        if (context === undefined) { context = null; }\n\n        var n = this._bindings.length;\n        var cur;\n\n        while (n--)\n        {\n            cur = this._bindings[n];\n\n            if (cur._listener === listener && cur.context === context)\n            {\n                return n;\n            }\n        }\n\n        return -1;\n\n    },\n\n    /**\n    * Check if a specific listener is attached.\n    *\n    * @method Phaser.Signal#has\n    * @param {function} listener - Signal handler function.\n    * @param {object} [context] - Context on which listener will be executed (object that should represent the `this` variable inside listener function).\n    * @return {boolean} If Signal has the specified listener.\n    */\n    has: function (listener, context) {\n\n        return this._indexOfListener(listener, context) !== -1;\n\n    },\n\n    /**\n    * Add an event listener for this signal.\n    *\n    * An event listener is a callback with a related context and priority.\n    *\n    * You can optionally provide extra arguments which will be passed to the callback after any internal parameters.\n    *\n    * For example: `Phaser.Key.onDown` when dispatched will send the Phaser.Key object that caused the signal as the first parameter.\n    * Any arguments you've specified after `priority` will be sent as well:\n    *\n    * `fireButton.onDown.add(shoot, this, 0, 'lazer', 100);`\n    *\n    * When onDown dispatches it will call the `shoot` callback passing it: `Phaser.Key, 'lazer', 100`.\n    *\n    * Where the first parameter is the one that Key.onDown dispatches internally and 'lazer', \n    * and the value 100 were the custom arguments given in the call to 'add'.\n    *\n    * @method Phaser.Signal#add\n    * @param {function} listener - The function to call when this Signal is dispatched.\n    * @param {object} [listenerContext] - The context under which the listener will be executed (i.e. the object that should represent the `this` variable).\n    * @param {number} [priority] - The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added (default = 0)\n    * @param {...any} [args=(none)] - Additional arguments to pass to the callback (listener) function. They will be appended after any arguments usually dispatched.\n    * @return {Phaser.SignalBinding} An Object representing the binding between the Signal and listener.\n    */\n    add: function (listener, listenerContext, priority) {\n\n        this.validateListener(listener, 'add');\n\n        var args = [];\n\n        if (arguments.length > 3)\n        {\n            for (var i = 3; i < arguments.length; i++)\n            {\n                args.push(arguments[i]);\n            }\n        }\n\n        return this._registerListener(listener, false, listenerContext, priority, args);\n\n    },\n\n    /**\n    * Add a one-time listener - the listener is automatically removed after the first execution.\n    *\n    * If there is as {@link Phaser.Signal#memorize memorized} event then it will be dispatched and\n    * the listener will be removed immediately.\n    *\n    * @method Phaser.Signal#addOnce\n    * @param {function} listener - The function to call when this Signal is dispatched.\n    * @param {object} [listenerContext] - The context under which the listener will be executed (i.e. the object that should represent the `this` variable).\n    * @param {number} [priority] - The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added (default = 0)\n    * @param {...any} [args=(none)] - Additional arguments to pass to the callback (listener) function. They will be appended after any arguments usually dispatched.\n    * @return {Phaser.SignalBinding} An Object representing the binding between the Signal and listener.\n    */\n    addOnce: function (listener, listenerContext, priority) {\n\n        this.validateListener(listener, 'addOnce');\n\n        var args = [];\n\n        if (arguments.length > 3)\n        {\n            for (var i = 3; i < arguments.length; i++)\n            {\n                args.push(arguments[i]);\n            }\n        }\n\n        return this._registerListener(listener, true, listenerContext, priority, args);\n\n    },\n\n    /**\n    * Remove a single event listener.\n    *\n    * @method Phaser.Signal#remove\n    * @param {function} listener - Handler function that should be removed.\n    * @param {object} [context=null] - Execution context (since you can add the same handler multiple times if executing in a different context).\n    * @return {function} Listener handler function.\n    */\n    remove: function (listener, context) {\n\n        this.validateListener(listener, 'remove');\n\n        var i = this._indexOfListener(listener, context);\n\n        if (i !== -1)\n        {\n            this._bindings[i]._destroy(); //no reason to a Phaser.SignalBinding exist if it isn't attached to a signal\n            this._bindings.splice(i, 1);\n        }\n\n        return listener;\n\n    },\n\n    /**\n    * Remove all event listeners.\n    *\n    * @method Phaser.Signal#removeAll\n    * @param {object} [context=null] - If specified only listeners for the given context will be removed.\n    */\n    removeAll: function (context) {\n\n        if (context === undefined) { context = null; }\n\n        if (!this._bindings)\n        {\n            return;\n        }\n\n        var n = this._bindings.length;\n\n        while (n--)\n        {\n            if (context)\n            {\n                if (this._bindings[n].context === context)\n                {\n                    this._bindings[n]._destroy();\n                    this._bindings.splice(n, 1);\n                }\n            }\n            else\n            {\n                this._bindings[n]._destroy();\n            }\n        }\n\n        if (!context)\n        {\n            this._bindings.length = 0;\n        }\n\n    },\n\n    /**\n    * Gets the total number of listeners attached to this Signal.\n    *\n    * @method Phaser.Signal#getNumListeners\n    * @return {integer} Number of listeners attached to the Signal.\n    */\n    getNumListeners: function () {\n\n        return this._bindings ? this._bindings.length : 0;\n\n    },\n\n    /**\n    * Stop propagation of the event, blocking the dispatch to next listener on the queue.\n    *\n    * This should be called only during event dispatch as calling it before/after dispatch won't affect another broadcast.\n    * See {@link #active} to enable/disable the signal entirely.\n    *\n    * @method Phaser.Signal#halt\n    */\n    halt: function () {\n\n        this._shouldPropagate = false;\n\n    },\n\n    /**\n    * Dispatch / broadcast the event to all listeners.\n    *\n    * To create an instance-bound dispatch for this Signal, use {@link #boundDispatch}.\n    *\n    * @method Phaser.Signal#dispatch\n    * @param {any} [params] - Parameters that should be passed to each handler.\n    */\n    dispatch: function () {\n\n        if (!this.active || !this._bindings)\n        {\n            return;\n        }\n\n        var paramsArr = Array.prototype.slice.call(arguments);\n        var n = this._bindings.length;\n        var bindings;\n\n        if (this.memorize)\n        {\n            this._prevParams = paramsArr;\n        }\n\n        if (!n)\n        {\n            //  Should come after memorize\n            return;\n        }\n\n        bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch\n        this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.\n\n        //execute all callbacks until end of the list or until a callback returns `false` or stops propagation\n        //reverse loop since listeners with higher priority will be added at the end of the list\n        do {\n            n--;\n        }\n        while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);\n\n    },\n\n    /**\n    * Forget the currently {@link Phaser.Signal#memorize memorized} event, if any.\n    *\n    * @method Phaser.Signal#forget\n    */\n    forget: function() {\n\n        if (this._prevParams)\n        {\n            this._prevParams = null;\n        }\n\n    },\n\n    /**\n    * Dispose the signal - no more events can be dispatched.\n    *\n    * This removes all event listeners and clears references to external objects.\n    * Calling methods on a disposed objects results in undefined behavior.\n    *\n    * @method Phaser.Signal#dispose\n    */\n    dispose: function () {\n\n        this.removeAll();\n\n        this._bindings = null;\n        if (this._prevParams)\n        {\n            this._prevParams = null;\n        }\n\n    },\n\n    /**\n    * A string representation of the object.\n    *\n    * @method Phaser.Signal#toString\n    * @return {string} String representation of the object.\n    */\n    toString: function () {\n\n        return '[Phaser.Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';\n\n    }\n\n};\n\n/**\n* Create a `dispatch` function that maintains a binding to the original Signal context.\n*\n* Use the resulting value if the dispatch function needs to be passed somewhere\n* or called independently of the Signal object.\n*\n* @memberof Phaser.Signal\n* @property {function} boundDispatch\n*/\nObject.defineProperty(Phaser.Signal.prototype, \"boundDispatch\", {\n\n    get: function () {\n        var _this = this;\n        return this._boundDispatch || (this._boundDispatch = function () {\n            return _this.dispatch.apply(_this, arguments);\n        });\n    }\n\n});\n\nPhaser.Signal.prototype.constructor = Phaser.Signal;\n\n/**\n* @author       Miller Medeiros http://millermedeiros.github.com/js-signals/\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Object that represents a binding between a Signal and a listener function.\n* This is an internal constructor and shouldn't be created directly.\n* Inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.\n* \n* @class Phaser.SignalBinding\n* @constructor\n* @param {Phaser.Signal} signal - Reference to Signal object that listener is currently bound to.\n* @param {function} listener - Handler function bound to the signal.\n* @param {boolean} isOnce - If binding should be executed just once.\n* @param {object} [listenerContext=null] - Context on which listener will be executed (object that should represent the `this` variable inside listener function).\n* @param {number} [priority] - The priority level of the event listener. (default = 0).\n* @param {...any} [args=(none)] - Additional arguments to pass to the callback (listener) function. They will be appended after any arguments usually dispatched.\n*/\nPhaser.SignalBinding = function (signal, listener, isOnce, listenerContext, priority, args) {\n\n    /**\n    * @property {Phaser.Game} _listener - Handler function bound to the signal.\n    * @private\n    */\n    this._listener = listener;\n\n    if (isOnce)\n    {\n        this._isOnce = true;\n    }\n\n    if (listenerContext != null) /* not null/undefined */\n    {\n        this.context = listenerContext;\n    }\n\n    /**\n    * @property {Phaser.Signal} _signal - Reference to Signal object that listener is currently bound to.\n    * @private\n    */\n    this._signal = signal;\n\n    if (priority)\n    {\n        this._priority = priority;\n    }\n\n    if (args && args.length)\n    {\n        this._args = args;\n    }\n\n};\n\nPhaser.SignalBinding.prototype = {\n\n    /**\n    * @property {?object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).\n    */\n    context: null,\n\n    /**\n    * @property {boolean} _isOnce - If binding should be executed just once.\n    * @private\n    */\n    _isOnce: false,\n\n    /**\n    * @property {number} _priority - Listener priority.\n    * @private\n    */\n    _priority: 0,\n\n    /**\n    * @property {array} _args - Listener arguments.\n    * @private\n    */\n    _args: null,\n\n    /**\n    * @property {number} callCount - The number of times the handler function has been called.\n    */\n    callCount: 0,\n\n    /**\n    * If binding is active and should be executed.\n    * @property {boolean} active\n    * @default\n    */\n    active: true,\n\n    /**\n    * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute` (curried parameters).\n    * @property {array|null} params\n    * @default\n    */\n    params: null,\n\n    /**\n    * Call listener passing arbitrary parameters.\n    * If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.\n    * @method Phaser.SignalBinding#execute\n    * @param {any[]} [paramsArr] - Array of parameters that should be passed to the listener.\n    * @return {any} Value returned by the listener.\n    */\n    execute: function(paramsArr) {\n\n        var handlerReturn, params;\n\n        if (this.active && !!this._listener)\n        {\n            params = this.params ? this.params.concat(paramsArr) : paramsArr;\n\n            if (this._args)\n            {\n                params = params.concat(this._args);\n            }\n\n            handlerReturn = this._listener.apply(this.context, params);\n\n            this.callCount++;\n\n            if (this._isOnce)\n            {\n                this.detach();\n            }\n        }\n\n        return handlerReturn;\n\n    },\n\n    /**\n    * Detach binding from signal.\n    * alias to: @see mySignal.remove(myBinding.getListener());\n    * @method Phaser.SignalBinding#detach\n    * @return {function|null} Handler function bound to the signal or `null` if binding was previously detached.\n    */\n    detach: function () {\n        return this.isBound() ? this._signal.remove(this._listener, this.context) : null;\n    },\n\n    /**\n    * @method Phaser.SignalBinding#isBound\n    * @return {boolean} True if binding is still bound to the signal and has a listener.\n    */\n    isBound: function () {\n        return (!!this._signal && !!this._listener);\n    },\n\n    /**\n    * @method Phaser.SignalBinding#isOnce\n    * @return {boolean} If SignalBinding will only be executed once.\n    */\n    isOnce: function () {\n        return this._isOnce;\n    },\n\n    /**\n    * @method Phaser.SignalBinding#getListener\n    * @return {function} Handler function bound to the signal.\n    */\n    getListener: function () {\n        return this._listener;\n    },\n\n    /**\n    * @method Phaser.SignalBinding#getSignal\n    * @return {Phaser.Signal} Signal that listener is currently bound to.\n    */\n    getSignal: function () {\n        return this._signal;\n    },\n\n    /**\n    * Delete instance properties\n    * @method Phaser.SignalBinding#_destroy\n    * @private\n    */\n    _destroy: function () {\n        delete this._signal;\n        delete this._listener;\n        delete this.context;\n    },\n\n    /**\n    * @method Phaser.SignalBinding#toString\n    * @return {string} String representation of the object.\n    */\n    toString: function () {\n        return '[Phaser.SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';\n    }\n\n};\n\nPhaser.SignalBinding.prototype.constructor = Phaser.SignalBinding;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* This is a base Filter class to use for any Phaser filter development.\n*\n* The vast majority of filters (including all of those that ship with Phaser) use fragment shaders, and\n* therefore only work in WebGL and are not supported by Canvas at all.\n*\n* @class Phaser.Filter\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {object} uniforms - Uniform mappings object\n* @param {Array|string} fragmentSrc - The fragment shader code. Either an array, one element per line of code, or a string.\n*/\nPhaser.Filter = function (game, uniforms, fragmentSrc) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {number} type - The const type of this object, either Phaser.WEBGL_FILTER or Phaser.CANVAS_FILTER.\n    * @default\n    */\n    this.type = Phaser.WEBGL_FILTER;\n\n    /**\n    * An array of passes - some filters contain a few steps this array simply stores the steps in a linear fashion.\n    * For example the blur filter has two passes blurX and blurY.\n    * @property {array} passes - An array of filter objects.\n    * @private\n    */\n    this.passes = [this];\n\n    /**\n    * @property {array} shaders - Array an array of shaders.\n    * @private\n    */\n    this.shaders = [];\n\n    /**\n    * @property {boolean} dirty - Internal PIXI var.\n    * @default\n    */\n    this.dirty = true;\n\n    /**\n    * @property {number} padding - Internal PIXI var.\n    * @default\n    */\n    this.padding = 0;\n\n    /**\n    * @property {Phaser.Point} prevPoint - The previous position of the pointer (we don't update the uniform if the same)\n    */\n    this.prevPoint = new Phaser.Point();\n\n    /*\n    * The supported types are: 1f, 1fv, 1i, 2f, 2fv, 2i, 2iv, 3f, 3fv, 3i, 3iv, 4f, 4fv, 4i, 4iv, mat2, mat3, mat4 and sampler2D.\n    */\n\n    var d = new Date();\n\n    /**\n    * @property {object} uniforms - Default uniform mappings. Compatible with ShaderToy and GLSLSandbox.\n    */\n    this.uniforms = {\n\n        resolution: { type: '2f', value: { x: 256, y: 256 }},\n        time: { type: '1f', value: 0 },\n        mouse: { type: '2f', value: { x: 0.0, y: 0.0 } },\n        date: { type: '4fv', value: [ d.getFullYear(),  d.getMonth(),  d.getDate(), d.getHours() *60 * 60 + d.getMinutes() * 60 + d.getSeconds() ] },\n        sampleRate: { type: '1f', value: 44100.0 },\n        iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: true } },\n        iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: true } },\n        iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: true } },\n        iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: true } }\n\n    };\n\n    //  Copy over/replace any passed in the constructor\n    if (uniforms)\n    {\n        for (var key in uniforms)\n        {\n            this.uniforms[key] = uniforms[key];\n        }\n    }\n\n    /**\n    * @property {array|string} fragmentSrc - The fragment shader code.\n    */\n    this.fragmentSrc = fragmentSrc || '';\n\n};\n\nPhaser.Filter.prototype = {\n\n    /**\n    * Should be over-ridden.\n    * @method Phaser.Filter#init\n    */\n    init: function () {\n        //  This should be over-ridden. Will receive a variable number of arguments.\n    },\n\n    /**\n    * Set the resolution uniforms on the filter.\n    * @method Phaser.Filter#setResolution\n    * @param {number} width - The width of the display.\n    * @param {number} height - The height of the display.\n    */\n    setResolution: function (width, height) {\n\n        this.uniforms.resolution.value.x = width;\n        this.uniforms.resolution.value.y = height;\n\n    },\n\n    /**\n    * Updates the filter.\n    * @method Phaser.Filter#update\n    * @param {Phaser.Pointer} [pointer] - A Pointer object to use for the filter. The coordinates are mapped to the mouse uniform.\n    */\n    update: function (pointer) {\n\n        if (typeof pointer !== 'undefined')\n        {\n            var x = pointer.x / this.game.width;\n            var y = 1 - pointer.y / this.game.height;\n\n            if (x !== this.prevPoint.x || y !== this.prevPoint.y)\n            {\n                this.uniforms.mouse.value.x = x.toFixed(2);\n                this.uniforms.mouse.value.y = y.toFixed(2);\n                this.prevPoint.set(x, y);\n            }\n        }\n\n        this.uniforms.time.value = this.game.time.totalElapsedSeconds();\n\n    },\n\n    /**\n    * Creates a new Phaser.Image object using a blank texture and assigns \n    * this Filter to it. The image is then added to the world.\n    *\n    * If you don't provide width and height values then Filter.width and Filter.height are used.\n    *\n    * If you do provide width and height values then this filter will be resized to match those\n    * values.\n    *\n    * @method Phaser.Filter#addToWorld\n    * @param {number} [x=0] - The x coordinate to place the Image at.\n    * @param {number} [y=0] - The y coordinate to place the Image at.\n    * @param {number} [width] - The width of the Image. If not specified (or null) it will use Filter.width. If specified Filter.width will be set to this value.\n    * @param {number} [height] - The height of the Image. If not specified (or null) it will use Filter.height. If specified Filter.height will be set to this value.\n    * @param {number} [anchorX=0] - Set the x anchor point of the Image. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.\n    * @param {number} [anchorY=0] - Set the y anchor point of the Image. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.\n    * @return {Phaser.Image} The newly added Image object.\n    */\n    addToWorld: function (x, y, width, height, anchorX, anchorY) {\n\n        if (anchorX === undefined) { anchorX = 0; }\n        if (anchorY === undefined) { anchorY = 0; }\n\n        if (width !== undefined && width !== null)\n        {\n            this.width = width;\n        }\n        else\n        {\n            width = this.width;\n        }\n\n        if (height !== undefined && height !== null)\n        {\n            this.height = height;\n        }\n        else\n        {\n            height = this.height;\n        }\n\n        var image = this.game.add.image(x, y, '__default');\n\n        image.width = width;\n        image.height = height;\n\n        image.anchor.set(anchorX, anchorY);\n\n        image.filters = [ this ];\n\n        return image;\n\n    },\n\n    /**\n    * Clear down this Filter and null out references\n    * @method Phaser.Filter#destroy\n    */\n    destroy: function () {\n\n        this.game = null;\n\n    }\n\n};\n\nPhaser.Filter.prototype.constructor = Phaser.Filter;\n\n/**\n* @name Phaser.Filter#width\n* @property {number} width - The width (resolution uniform)\n*/\nObject.defineProperty(Phaser.Filter.prototype, 'width', {\n\n    get: function() {\n        return this.uniforms.resolution.value.x;\n    },\n\n    set: function(value) {\n        this.uniforms.resolution.value.x = value;\n    }\n\n});\n\n/**\n* @name Phaser.Filter#height\n* @property {number} height - The height (resolution uniform)\n*/\nObject.defineProperty(Phaser.Filter.prototype, 'height', {\n\n    get: function() {\n        return this.uniforms.resolution.value.y;\n    },\n\n    set: function(value) {\n        this.uniforms.resolution.value.y = value;\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* This is a base Plugin template to use for any Phaser plugin development.\n*\n* @class Phaser.Plugin\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {any} parent - The object that owns this plugin, usually Phaser.PluginManager.\n*/\nPhaser.Plugin = function (game, parent) {\n\n    if (parent === undefined) { parent = null; }\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {any} parent - The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.\n    */\n    this.parent = parent;\n\n    /**\n    * @property {boolean} active - A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.\n    * @default\n    */\n    this.active = false;\n\n    /**\n    * @property {boolean} visible - A Plugin with visible=true has its render and postRender methods called by the parent, otherwise they are skipped.\n    * @default\n    */\n    this.visible = false;\n\n    /**\n    * @property {boolean} hasPreUpdate - A flag to indicate if this plugin has a preUpdate method.\n    * @default\n    */\n    this.hasPreUpdate = false;\n\n    /**\n    * @property {boolean} hasUpdate - A flag to indicate if this plugin has an update method.\n    * @default\n    */\n    this.hasUpdate = false;\n\n    /**\n    * @property {boolean} hasPostUpdate - A flag to indicate if this plugin has a postUpdate method.\n    * @default\n    */\n    this.hasPostUpdate = false;\n\n    /**\n    * @property {boolean} hasRender - A flag to indicate if this plugin has a render method.\n    * @default\n    */\n    this.hasRender = false;\n\n    /**\n    * @property {boolean} hasPostRender - A flag to indicate if this plugin has a postRender method.\n    * @default\n    */\n    this.hasPostRender = false;\n\n};\n\nPhaser.Plugin.prototype = {\n\n    /**\n    * Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).\n    * It is only called if active is set to true.\n    * @method Phaser.Plugin#preUpdate\n    */\n    preUpdate: function () {\n    },\n\n    /**\n    * Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.\n    * It is only called if active is set to true.\n    * @method Phaser.Plugin#update\n    */\n    update: function () {\n    },\n\n    /**\n    * Render is called right after the Game Renderer completes, but before the State.render.\n    * It is only called if visible is set to true.\n    * @method Phaser.Plugin#render\n    */\n    render: function () {\n    },\n\n    /**\n    * Post-render is called after the Game Renderer and State.render have run.\n    * It is only called if visible is set to true.\n    * @method Phaser.Plugin#postRender\n    */\n    postRender: function () {\n    },\n\n    /**\n    * Clear down this Plugin and null out references\n    * @method Phaser.Plugin#destroy\n    */\n    destroy: function () {\n\n        this.game = null;\n        this.parent = null;\n        this.active = false;\n        this.visible = false;\n\n    }\n\n};\n\nPhaser.Plugin.prototype.constructor = Phaser.Plugin;\n\n/* jshint newcap: false */\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Plugin Manager is responsible for the loading, running and unloading of Phaser Plugins.\n*\n* @class Phaser.PluginManager\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.PluginManager = function(game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Plugin[]} plugins - An array of all the plugins being managed by this PluginManager.\n    */\n    this.plugins = [];\n\n    /**\n    * @property {number} _len - Internal cache var.\n    * @private\n    */\n    this._len = 0;\n\n    /**\n    * @property {number} _i - Internal cache var.\n    * @private\n    */\n    this._i = 0;\n\n};\n\nPhaser.PluginManager.prototype = {\n\n    /**\n    * Add a new Plugin into the PluginManager.\n    * The Plugin must have 2 properties: game and parent. Plugin.game is set to the game reference the PluginManager uses, and parent is set to the PluginManager.\n    *\n    * @method Phaser.PluginManager#add\n    * @param {object|Phaser.Plugin} plugin - The Plugin to add into the PluginManager. This can be a function or an existing object.\n    * @param {...*} parameter - Additional arguments that will be passed to the Plugin.init method.\n    * @return {Phaser.Plugin} The Plugin that was added to the manager.\n    */\n    add: function (plugin) {\n\n        var args = Array.prototype.slice.call(arguments, 1);\n        var result = false;\n\n        //  Prototype?\n        if (typeof plugin === 'function')\n        {\n            plugin = new plugin(this.game, this);\n        }\n        else\n        {\n            plugin.game = this.game;\n            plugin.parent = this;\n        }\n\n        //  Check for methods now to avoid having to do this every loop\n        if (typeof plugin['preUpdate'] === 'function')\n        {\n            plugin.hasPreUpdate = true;\n            result = true;\n        }\n\n        if (typeof plugin['update'] === 'function')\n        {\n            plugin.hasUpdate = true;\n            result = true;\n        }\n\n        if (typeof plugin['postUpdate'] === 'function')\n        {\n            plugin.hasPostUpdate = true;\n            result = true;\n        }\n\n        if (typeof plugin['render'] === 'function')\n        {\n            plugin.hasRender = true;\n            result = true;\n        }\n\n        if (typeof plugin['postRender'] === 'function')\n        {\n            plugin.hasPostRender = true;\n            result = true;\n        }\n\n        //  The plugin must have at least one of the above functions to be added to the PluginManager.\n        if (result)\n        {\n            if (plugin.hasPreUpdate || plugin.hasUpdate || plugin.hasPostUpdate)\n            {\n                plugin.active = true;\n            }\n\n            if (plugin.hasRender || plugin.hasPostRender)\n            {\n                plugin.visible = true;\n            }\n\n            this._len = this.plugins.push(plugin);\n\n            // Allows plugins to run potentially destructive code outside of the constructor, and only if being added to the PluginManager\n            if (typeof plugin['init'] === 'function')\n            {\n                plugin.init.apply(plugin, args);\n            }\n\n            return plugin;\n        }\n        else\n        {\n            return null;\n        }\n    },\n\n    /**\n    * Remove a Plugin from the PluginManager. It calls Plugin.destroy on the plugin before removing it from the manager.\n    *\n    * @method Phaser.PluginManager#remove\n    * @param {Phaser.Plugin} plugin - The plugin to be removed.\n    * @param {boolean} [destroy=true] - Call destroy on the plugin that is removed?\n    */\n    remove: function (plugin, destroy) {\n\n        if (destroy === undefined) { destroy = true; }\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i] === plugin)\n            {\n                if (destroy)\n                {\n                    plugin.destroy();\n                }\n\n                this.plugins.splice(this._i, 1);\n                this._len--;\n                return;\n            }\n        }\n\n    },\n\n    /**\n    * Remove all Plugins from the PluginManager. It calls Plugin.destroy on every plugin before removing it from the manager.\n    *\n    * @method Phaser.PluginManager#removeAll\n    */\n    removeAll: function() {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            this.plugins[this._i].destroy();\n        }\n\n        this.plugins.length = 0;\n        this._len = 0;\n\n    },\n\n    /**\n    * Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).\n    * It only calls plugins who have active=true.\n    *\n    * @method Phaser.PluginManager#preUpdate\n    */\n    preUpdate: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate)\n            {\n                this.plugins[this._i].preUpdate();\n            }\n        }\n\n    },\n\n    /**\n    * Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.\n    * It only calls plugins who have active=true.\n    *\n    * @method Phaser.PluginManager#update\n    */\n    update: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].active && this.plugins[this._i].hasUpdate)\n            {\n                this.plugins[this._i].update();\n            }\n        }\n\n    },\n\n    /**\n    * PostUpdate is the last thing to be called before the world render.\n    * In particular, it is called after the world postUpdate, which means the camera has been adjusted.\n    * It only calls plugins who have active=true.\n    *\n    * @method Phaser.PluginManager#postUpdate\n    */\n    postUpdate: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate)\n            {\n                this.plugins[this._i].postUpdate();\n            }\n        }\n\n    },\n\n    /**\n    * Render is called right after the Game Renderer completes, but before the State.render.\n    * It only calls plugins who have visible=true.\n    *\n    * @method Phaser.PluginManager#render\n    */\n    render: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].visible && this.plugins[this._i].hasRender)\n            {\n                this.plugins[this._i].render();\n            }\n        }\n\n    },\n\n    /**\n    * Post-render is called after the Game Renderer and State.render have run.\n    * It only calls plugins who have visible=true.\n    *\n    * @method Phaser.PluginManager#postRender\n    */\n    postRender: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].visible && this.plugins[this._i].hasPostRender)\n            {\n                this.plugins[this._i].postRender();\n            }\n        }\n\n    },\n\n    /**\n    * Clear down this PluginManager, calls destroy on every plugin and nulls out references.\n    *\n    * @method Phaser.PluginManager#destroy\n    */\n    destroy: function () {\n\n        this.removeAll();\n\n        this.game = null;\n\n    }\n\n};\n\nPhaser.PluginManager.prototype.constructor = Phaser.PluginManager;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Stage controls root level display objects upon which everything is displayed.\n* It also handles browser visibility handling and the pausing due to loss of focus.\n*\n* @class Phaser.Stage\n* @extends PIXI.DisplayObjectContainer\n* @constructor\n* @param {Phaser.Game} game - Game reference to the currently running game.\n */\nPhaser.Stage = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    PIXI.DisplayObjectContainer.call(this);\n\n    /**\n    * @property {string} name - The name of this object.\n    * @default\n    */\n    this.name = '_stage_root';\n\n    /**\n    * By default if the browser tab loses focus the game will pause.\n    * You can stop that behavior by setting this property to true.\n    * Note that the browser can still elect to pause your game if it wishes to do so,\n    * for example swapping to another browser tab. This will cause the RAF callback to halt,\n    * effectively pausing your game, even though no in-game pause event is triggered if you enable this property.\n    * @property {boolean} disableVisibilityChange\n    * @default\n    */\n    this.disableVisibilityChange = false;\n\n    /**\n    * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.\n    * @default\n    */\n    this.exists = true;\n\n    /**\n    * @property {PIXI.Matrix} worldTransform - Current transform of the object based on world (parent) factors\n    * @private\n    * @readOnly\n    */\n    this.worldTransform = new PIXI.Matrix();\n\n    /**\n    * @property {Phaser.Stage} stage - The stage reference (the Stage is its own stage)\n    * @private\n    * @readOnly\n    */\n    this.stage = this;\n\n    /**\n    * @property {number} currentRenderOrderID - Reset each frame, keeps a count of the total number of objects updated.\n    */\n    this.currentRenderOrderID = 0;\n\n    /**\n    * @property {string} hiddenVar - The page visibility API event name.\n    * @private\n    */\n    this._hiddenVar = 'hidden';\n\n    /**\n    * @property {function} _onChange - The blur/focus event handler.\n    * @private\n    */\n    this._onChange = null;\n\n    /**\n    * @property {number} _bgColor - Stage background color object. Populated by setBackgroundColor.\n    * @private\n    */\n    this._bgColor = { r: 0, g: 0, b: 0, a: 0, color: 0, rgba: '#000000' };\n\n    if (!this.game.transparent)\n    {\n        //  transparent = 0,0,0,0 - otherwise r,g,b,1\n        this._bgColor.a = 1;\n    }\n\n    if (game.config)\n    {\n        this.parseConfig(game.config);\n    }\n\n};\n\nPhaser.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPhaser.Stage.prototype.constructor = Phaser.Stage;\n\n/**\n* Parses a Game configuration object.\n*\n* @method Phaser.Stage#parseConfig\n* @protected\n* @param {object} config -The configuration object to parse.\n*/\nPhaser.Stage.prototype.parseConfig = function (config) {\n\n    if (config['disableVisibilityChange'])\n    {\n        this.disableVisibilityChange = config['disableVisibilityChange'];\n    }\n\n    if (config['backgroundColor'])\n    {\n        this.setBackgroundColor(config['backgroundColor']);\n    }\n\n};\n\n/**\n* Initialises the stage and adds the event listeners.\n* @method Phaser.Stage#boot\n* @private\n*/\nPhaser.Stage.prototype.boot = function () {\n\n    Phaser.DOM.getOffset(this.game.canvas, this.offset);\n\n    Phaser.Canvas.setUserSelect(this.game.canvas, 'none');\n    Phaser.Canvas.setTouchAction(this.game.canvas, 'none');\n\n    this.checkVisibility();\n\n};\n\n/**\n* This is called automatically after the plugins preUpdate and before the State.update.\n* Most objects have preUpdate methods and it's where initial movement and positioning is done.\n*\n* @method Phaser.Stage#preUpdate\n*/\nPhaser.Stage.prototype.preUpdate = function () {\n\n    this.currentRenderOrderID = 0;\n\n    //  This can't loop in reverse, we need the renderOrderID to be in sequence\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].preUpdate();\n    }\n\n};\n\n/**\n* This is called automatically after the State.update, but before particles or plugins update.\n*\n* @method Phaser.Stage#update\n*/\nPhaser.Stage.prototype.update = function () {\n\n    //  Goes in reverse, because it's highly likely the child will destroy itself in `update`\n    var i = this.children.length;\n\n    while (i--)\n    {\n        this.children[i].update();\n    }\n\n};\n\n/**\n* This is called automatically before the renderer runs and after the plugins have updated.\n* In postUpdate this is where all the final physics calculations and object positioning happens.\n* The objects are processed in the order of the display list.\n*\n* @method Phaser.Stage#postUpdate\n*/\nPhaser.Stage.prototype.postUpdate = function () {\n\n    //  Apply the camera shake, fade, bounds, etc\n    this.game.camera.update();\n\n    //  Camera target first?\n    if (this.game.camera.target)\n    {\n        this.game.camera.target.postUpdate();\n\n        this.updateTransform();\n\n        this.game.camera.updateTarget();\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].postUpdate();\n    }\n\n    this.updateTransform();\n\n};\n\n/**\n* Updates the transforms for all objects on the display list.\n* This overrides the Pixi default as we don't need the interactionManager, but do need the game property check.\n* \n* @method Phaser.Stage#updateTransform\n*/\nPhaser.Stage.prototype.updateTransform = function () {\n\n    this.worldAlpha = 1;\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n};\n\n/**\n* Starts a page visibility event listener running, or window.onpagehide/onpageshow if not supported by the browser.\n* Also listens for window.onblur and window.onfocus.\n* \n* @method Phaser.Stage#checkVisibility\n*/\nPhaser.Stage.prototype.checkVisibility = function () {\n\n    if (document.hidden !== undefined)\n    {\n        this._hiddenVar = 'visibilitychange';\n    }\n    else if (document.webkitHidden !== undefined)\n    {\n        this._hiddenVar = 'webkitvisibilitychange';\n    }\n    else if (document.mozHidden !== undefined)\n    {\n        this._hiddenVar = 'mozvisibilitychange';\n    }\n    else if (document.msHidden !== undefined)\n    {\n        this._hiddenVar = 'msvisibilitychange';\n    }\n    else\n    {\n        this._hiddenVar = null;\n    }\n\n    var _this = this;\n\n    this._onChange = function (event) {\n        return _this.visibilityChange(event);\n    };\n\n    //  Does browser support it? If not (like in IE9 or old Android) we need to fall back to blur/focus\n    if (this._hiddenVar)\n    {\n        document.addEventListener(this._hiddenVar, this._onChange, false);\n    }\n\n    window.onblur = this._onChange;\n    window.onfocus = this._onChange;\n\n    window.onpagehide = this._onChange;\n    window.onpageshow = this._onChange;\n    \n    if (this.game.device.cocoonJSApp)\n    {\n        CocoonJS.App.onSuspended.addEventListener(function () {\n            Phaser.Stage.prototype.visibilityChange.call(_this, { type: \"pause\" });\n        });\n\n        CocoonJS.App.onActivated.addEventListener(function () {\n            Phaser.Stage.prototype.visibilityChange.call(_this, { type: \"resume\" });\n        });\n    }\n\n};\n\n/**\n* This method is called when the document visibility is changed.\n* \n* @method Phaser.Stage#visibilityChange\n* @param {Event} event - Its type will be used to decide whether the game should be paused or not.\n*/\nPhaser.Stage.prototype.visibilityChange = function (event) {\n\n    if (event.type === 'pagehide' || event.type === 'blur' || event.type === 'pageshow' || event.type === 'focus')\n    {\n        if (event.type === 'pagehide' || event.type === 'blur')\n        {\n            this.game.focusLoss(event);\n        }\n        else if (event.type === 'pageshow' || event.type === 'focus')\n        {\n            this.game.focusGain(event);\n        }\n\n        return;\n    }\n\n    if (this.disableVisibilityChange)\n    {\n        return;\n    }\n\n    if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || event.type === \"pause\")\n    {\n        this.game.gamePaused(event);\n    }\n    else\n    {\n        this.game.gameResumed(event);\n    }\n\n};\n\n/**\n* Sets the background color for the Stage.\n*\n* The color can be given as a hex string (`'#RRGGBB'`), a CSS color string (`'rgb(r,g,b)'`), or a numeric value (`0xRRGGBB`).\n*\n* An alpha channel is _not_ supported and will be ignored.\n*\n* If you've set your game to be transparent then calls to setBackgroundColor are ignored.\n*\n* @method Phaser.Stage#setBackgroundColor\n* @param {number|string} color - The color of the background.\n*/\nPhaser.Stage.prototype.setBackgroundColor = function (color) {\n\n    if (this.game.transparent) { return; }\n\n    Phaser.Color.valueToColor(color, this._bgColor);\n    Phaser.Color.updateColor(this._bgColor);\n\n    //  For gl.clearColor (canvas uses _bgColor.rgba)\n    this._bgColor.r /= 255;\n    this._bgColor.g /= 255;\n    this._bgColor.b /= 255;\n    this._bgColor.a = 1;\n\n};\n\n/**\n* Destroys the Stage and removes event listeners.\n*\n* @method Phaser.Stage#destroy\n*/\nPhaser.Stage.prototype.destroy = function () {\n\n    if (this._hiddenVar)\n    {\n        document.removeEventListener(this._hiddenVar, this._onChange, false);\n    }\n\n    window.onpagehide = null;\n    window.onpageshow = null;\n\n    window.onblur = null;\n    window.onfocus = null;\n\n};\n\n/**\n* @name Phaser.Stage#backgroundColor\n* @property {number|string} backgroundColor - Gets and sets the background color of the stage. The color can be given as a number: 0xff0000 or a hex string: '#ff0000'\n*/\nObject.defineProperty(Phaser.Stage.prototype, \"backgroundColor\", {\n\n    get: function () {\n\n        return this._bgColor.color;\n\n    },\n\n    set: function (color) {\n\n        this.setBackgroundColor(color);\n\n    }\n\n});\n\n/**\n* Enable or disable texture smoothing for all objects on this Stage. Only works for bitmap/image textures. Smoothing is enabled by default.\n*\n* @name Phaser.Stage#smoothed\n* @property {boolean} smoothed - Set to true to smooth all sprites rendered on this Stage, or false to disable smoothing (great for pixel art)\n*/\nObject.defineProperty(Phaser.Stage.prototype, \"smoothed\", {\n\n    get: function () {\n\n        return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR;\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            PIXI.scaleModes.DEFAULT = PIXI.scaleModes.LINEAR;\n        }\n        else\n        {\n            PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST;\n        }\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Group is a container for {@link DisplayObject display objects} including {@link Phaser.Sprite Sprites} and {@link Phaser.Image Images}.\n*\n* Groups form the logical tree structure of the display/scene graph where local transformations are applied to children.\n* For instance, all children are also moved/rotated/scaled when the group is moved/rotated/scaled.\n*\n* In addition, Groups provides support for fast pooling and object recycling.\n*\n* Groups are also display objects and can be nested as children within other Groups.\n*\n* @class Phaser.Group\n* @extends PIXI.DisplayObjectContainer\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {DisplayObject|null} [parent=(game world)] - The parent Group (or other {@link DisplayObject}) that this group will be added to.\n*     If undefined/unspecified the Group will be added to the {@link Phaser.Game#world Game World}; if null the Group will not be added to any parent.\n* @param {string} [name='group'] - A name for this group. Not used internally but useful for debugging.\n* @param {boolean} [addToStage=false] - If true this group will be added directly to the Game.Stage instead of Game.World.\n* @param {boolean} [enableBody=false] - If true all Sprites created with {@link #create} or {@link #createMulitple} will have a physics body created on them. Change the body type with {@link #physicsBodyType}.\n* @param {integer} [physicsBodyType=0] - The physics body type to use when physics bodies are automatically added. See {@link #physicsBodyType} for values.\n*/\nPhaser.Group = function (game, parent, name, addToStage, enableBody, physicsBodyType) {\n\n    if (addToStage === undefined) { addToStage = false; }\n    if (enableBody === undefined) { enableBody = false; }\n    if (physicsBodyType === undefined) { physicsBodyType = Phaser.Physics.ARCADE; }\n\n    /**\n    * A reference to the currently running Game.\n    * @property {Phaser.Game} game\n    * @protected\n    */\n    this.game = game;\n\n    if (parent === undefined)\n    {\n        parent = game.world;\n    }\n\n    /**\n    * A name for this group. Not used internally but useful for debugging.\n    * @property {string} name\n    */\n    this.name = name || 'group';\n\n    /**\n    * The z-depth value of this object within its parent container/Group - the World is a Group as well.\n    * This value must be unique for each child in a Group.\n    * @property {integer} z\n    * @readOnly\n    */\n    this.z = 0;\n\n    PIXI.DisplayObjectContainer.call(this);\n\n    if (addToStage)\n    {\n        this.game.stage.addChild(this);\n        this.z = this.game.stage.children.length;\n    }\n    else\n    {\n        if (parent)\n        {\n            parent.addChild(this);\n            this.z = parent.children.length;\n        }\n    }\n\n    /**\n    * Internal Phaser Type value.\n    * @property {integer} type\n    * @protected\n    */\n    this.type = Phaser.GROUP;\n\n    /**\n    * @property {number} physicsType - The const physics body type of this object.\n    * @readonly\n    */\n    this.physicsType = Phaser.GROUP;\n\n    /**\n    * The alive property is useful for Groups that are children of other Groups and need to be included/excluded in checks like forEachAlive.\n    * @property {boolean} alive\n    * @default\n    */\n    this.alive = true;\n\n    /**\n    * If exists is true the group is updated, otherwise it is skipped.\n    * @property {boolean} exists\n    * @default\n    */\n    this.exists = true;\n\n    /**\n    * A group with `ignoreDestroy` set to `true` ignores all calls to its `destroy` method.\n    * @property {boolean} ignoreDestroy\n    * @default\n    */\n    this.ignoreDestroy = false;\n\n    /**\n    * A Group is that has `pendingDestroy` set to `true` is flagged to have its destroy method\n    * called on the next logic update.\n    * You can set it directly to flag the Group to be destroyed on its next update.\n    *\n    * This is extremely useful if you wish to destroy a Group from within one of its own callbacks\n    * or a callback of one of its children.\n    *\n    * @property {boolean} pendingDestroy\n    */\n    this.pendingDestroy = false;\n\n    /**\n    * The type of objects that will be created when using {@link #create} or {@link #createMultiple}.\n    *\n    * Any object may be used but it should extend either Sprite or Image and accept the same constructor arguments:\n    * when a new object is created it is passed the following parameters to its constructor: `(game, x, y, key, frame)`.\n    *\n    * @property {object} classType\n    * @default {@link Phaser.Sprite}\n    */\n    this.classType = Phaser.Sprite;\n\n    /**\n    * The current display object that the group cursor is pointing to, if any. (Can be set manually.)\n    *\n    * The cursor is a way to iterate through the children in a Group using {@link #next} and {@link #previous}.\n    * @property {?DisplayObject} cursor\n    */\n    this.cursor = null;\n\n    /**\n    * A Group with `inputEnableChildren` set to `true` will automatically call `inputEnabled = true` \n    * on any children _added_ to, or _created by_, this Group.\n    * \n    * If there are children already in the Group at the time you set this property, they are not changed.\n    * \n    * @property {boolean} inputEnableChildren\n    * @default\n    */\n    this.inputEnableChildren = false;\n\n    /**\n    * This Signal is dispatched whenever a child of this Group emits an onInputDown signal as a result\n    * of having been interacted with by a Pointer. You can bind functions to this Signal instead of to\n    * every child Sprite.\n    * \n    * This Signal is sent 2 arguments: A reference to the Sprite that triggered the signal, and\n    * a reference to the Pointer that caused it.\n    * \n    * @property {Phaser.Signal} onChildInputDown\n    */\n    this.onChildInputDown = new Phaser.Signal();\n\n    /**\n    * This Signal is dispatched whenever a child of this Group emits an onInputUp signal as a result\n    * of having been interacted with by a Pointer. You can bind functions to this Signal instead of to\n    * every child Sprite.\n    * \n    * This Signal is sent 3 arguments: A reference to the Sprite that triggered the signal, \n    * a reference to the Pointer that caused it, and a boolean value `isOver` that tells you if the Pointer\n    * is still over the Sprite or not.\n    * \n    * @property {Phaser.Signal} onChildInputUp\n    */\n    this.onChildInputUp = new Phaser.Signal();\n\n    /**\n    * This Signal is dispatched whenever a child of this Group emits an onInputOver signal as a result\n    * of having been interacted with by a Pointer. You can bind functions to this Signal instead of to\n    * every child Sprite.\n    * \n    * This Signal is sent 2 arguments: A reference to the Sprite that triggered the signal, and\n    * a reference to the Pointer that caused it.\n    * \n    * @property {Phaser.Signal} onChildInputOver\n    */\n    this.onChildInputOver = new Phaser.Signal();\n\n    /**\n    * This Signal is dispatched whenever a child of this Group emits an onInputOut signal as a result\n    * of having been interacted with by a Pointer. You can bind functions to this Signal instead of to\n    * every child Sprite.\n    * \n    * This Signal is sent 2 arguments: A reference to the Sprite that triggered the signal, and\n    * a reference to the Pointer that caused it.\n    * \n    * @property {Phaser.Signal} onChildInputOut\n    */\n    this.onChildInputOut = new Phaser.Signal();\n\n    /**\n    * If true all Sprites created by, or added to this group, will have a physics body enabled on them.\n    *\n    * If there are children already in the Group at the time you set this property, they are not changed.\n    *\n    * The default body type is controlled with {@link #physicsBodyType}.\n    * @property {boolean} enableBody\n    */\n    this.enableBody = enableBody;\n\n    /**\n    * If true when a physics body is created (via {@link #enableBody}) it will create a physics debug object as well.\n    *\n    * This only works for P2 bodies.\n    * @property {boolean} enableBodyDebug\n    * @default\n    */\n    this.enableBodyDebug = false;\n\n    /**\n    * If {@link #enableBody} is true this is the type of physics body that is created on new Sprites.\n    *\n    * The valid values are {@link Phaser.Physics.ARCADE}, {@link Phaser.Physics.P2JS}, {@link Phaser.Physics.NINJA}, etc.\n    * @property {integer} physicsBodyType\n    */\n    this.physicsBodyType = physicsBodyType;\n\n    /**\n    * If this Group contains Arcade Physics Sprites you can set a custom sort direction via this property.\n    *\n    * It should be set to one of the Phaser.Physics.Arcade sort direction constants: \n    * \n    * Phaser.Physics.Arcade.SORT_NONE\n    * Phaser.Physics.Arcade.LEFT_RIGHT\n    * Phaser.Physics.Arcade.RIGHT_LEFT\n    * Phaser.Physics.Arcade.TOP_BOTTOM\n    * Phaser.Physics.Arcade.BOTTOM_TOP\n    *\n    * If set to `null` the Group will use whatever Phaser.Physics.Arcade.sortDirection is set to. This is the default behavior.\n    * \n    * @property {integer} physicsSortDirection\n    * @default\n    */\n    this.physicsSortDirection = null;\n\n    /**\n    * This signal is dispatched when the group is destroyed.\n    * @property {Phaser.Signal} onDestroy\n    */\n    this.onDestroy = new Phaser.Signal();\n\n    /**\n    * @property {integer} cursorIndex - The current index of the Group cursor. Advance it with Group.next.\n    * @readOnly\n    */\n    this.cursorIndex = 0;\n\n    /**\n    * A Group that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Group.cameraOffset.\n    * \n    * Note that the cameraOffset values are in addition to any parent in the display list.\n    * So if this Group was in a Group that has x: 200, then this will be added to the cameraOffset.x\n    * \n    * @property {boolean} fixedToCamera\n    */\n    this.fixedToCamera = false;\n\n    /**\n    * If this object is {@link #fixedToCamera} then this stores the x/y position offset relative to the top-left of the camera view.\n    * If the parent of this Group is also `fixedToCamera` then the offset here is in addition to that and should typically be disabled.\n    * @property {Phaser.Point} cameraOffset\n    */\n    this.cameraOffset = new Phaser.Point();\n\n    /**\n    * The hash array is an array belonging to this Group into which you can add any of its children via Group.addToHash and Group.removeFromHash.\n    * \n    * Only children of this Group can be added to and removed from the hash.\n    * \n    * This hash is used automatically by Phaser Arcade Physics in order to perform non z-index based destructive sorting.\n    * However if you don't use Arcade Physics, or this isn't a physics enabled Group, then you can use the hash to perform your own\n    * sorting and filtering of Group children without touching their z-index (and therefore display draw order)\n    * \n    * @property {array} hash\n    */\n    this.hash = [];\n\n    /**\n    * The property on which children are sorted.\n    * @property {string} _sortProperty\n    * @private\n    */\n    this._sortProperty = 'z';\n\n};\n\nPhaser.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPhaser.Group.prototype.constructor = Phaser.Group;\n\n/**\n* A returnType value, as specified in {@link #iterate} eg.\n* @constant\n* @type {integer}\n*/\nPhaser.Group.RETURN_NONE = 0;\n\n/**\n* A returnType value, as specified in {@link #iterate} eg.\n* @constant\n* @type {integer}\n*/\nPhaser.Group.RETURN_TOTAL = 1;\n\n/**\n* A returnType value, as specified in {@link #iterate} eg.\n* @constant\n* @type {integer}\n*/\nPhaser.Group.RETURN_CHILD = 2;\n\n/**\n* A returnType value, as specified in {@link #iterate} eg.\n* @constant\n* @type {integer}\n*/\nPhaser.Group.RETURN_ALL = 3;\n\n/**\n* A sort ordering value, as specified in {@link #sort} eg.\n* @constant\n* @type {integer}\n*/\nPhaser.Group.SORT_ASCENDING = -1;\n\n/**\n* A sort ordering value, as specified in {@link #sort} eg.\n* @constant\n* @type {integer}\n*/\nPhaser.Group.SORT_DESCENDING = 1;\n\n/**\n* Adds an existing object as the top child in this group.\n*\n* The child is automatically added to the top of the group, and is displayed above every previous child.\n*\n* Or if the _optional_ index is specified, the child is added at the location specified by the index value, \n* this allows you to control child ordering.\n*\n* If the child was already in this Group, it is simply returned, and nothing else happens to it.\n*\n* If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.\n*\n* If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.\n*\n* Use {@link #addAt} to control where a child is added. Use {@link #create} to create and add a new child.\n*\n* @method Phaser.Group#add\n* @param {DisplayObject} child - The display object to add as a child.\n* @param {boolean} [silent=false] - If true the child will not dispatch the `onAddedToGroup` event.\n* @param {integer} [index] - The index within the group to insert the child to. Where 0 is the bottom of the Group.\n* @return {DisplayObject} The child that was added to the group.\n*/\nPhaser.Group.prototype.add = function (child, silent, index) {\n\n    if (silent === undefined) { silent = false; }\n\n    if (child.parent === this)\n    {\n        return child;\n    }\n\n    if (child.body && child.parent && child.parent.hash)\n    {\n        child.parent.removeFromHash(child);\n    }\n\n    if (index === undefined)\n    {\n        child.z = this.children.length;\n\n        this.addChild(child);\n    }\n    else\n    {\n        this.addChildAt(child, index);\n\n        this.updateZ();\n    }\n\n    if (this.enableBody && child.hasOwnProperty('body') && child.body === null)\n    {\n        this.game.physics.enable(child, this.physicsBodyType);\n    }\n    else if (child.body)\n    {\n        this.addToHash(child);\n    }\n\n    if (this.inputEnableChildren && (!child.input || child.inputEnabled))\n    {\n        child.inputEnabled = true;\n    }\n\n    if (!silent && child.events)\n    {\n        child.events.onAddedToGroup$dispatch(child, this);\n    }\n\n    if (this.cursor === null)\n    {\n        this.cursor = child;\n    }\n\n    return child;\n\n};\n\n/**\n* Adds an existing object to this group.\n*\n* The child is added to the group at the location specified by the index value, this allows you to control child ordering.\n* \n* If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.\n*\n* If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.\n*\n* @method Phaser.Group#addAt\n* @param {DisplayObject} child - The display object to add as a child.\n* @param {integer} [index=0] - The index within the group to insert the child to.\n* @param {boolean} [silent=false] - If true the child will not dispatch the `onAddedToGroup` event.\n* @return {DisplayObject} The child that was added to the group.\n*/\nPhaser.Group.prototype.addAt = function (child, index, silent) {\n\n    this.add(child, silent, index);\n\n};\n\n/**\n* Adds a child of this Group into the hash array.\n* This call will return false if the child is not a child of this Group, or is already in the hash.\n*\n* @method Phaser.Group#addToHash\n* @param {DisplayObject} child - The display object to add to this Groups hash. Must be a member of this Group already and not present in the hash.\n* @return {boolean} True if the child was successfully added to the hash, otherwise false.\n*/\nPhaser.Group.prototype.addToHash = function (child) {\n\n    if (child.parent === this)\n    {\n        var index = this.hash.indexOf(child);\n\n        if (index === -1)\n        {\n            this.hash.push(child);\n            return true;\n        }\n    }\n\n    return false;\n\n};\n\n/**\n* Removes a child of this Group from the hash array.\n* This call will return false if the child is not in the hash.\n*\n* @method Phaser.Group#removeFromHash\n* @param {DisplayObject} child - The display object to remove from this Groups hash. Must be a member of this Group and in the hash.\n* @return {boolean} True if the child was successfully removed from the hash, otherwise false.\n*/\nPhaser.Group.prototype.removeFromHash = function (child) {\n\n    if (child)\n    {\n        var index = this.hash.indexOf(child);\n\n        if (index !== -1)\n        {\n            this.hash.splice(index, 1);\n            return true;\n        }\n    }\n\n    return false;\n\n};\n\n/**\n* Adds an array of existing Display Objects to this Group.\n*\n* The Display Objects are automatically added to the top of this Group, and will render on-top of everything already in this Group.\n*\n* As well as an array you can also pass another Group as the first argument. In this case all of the children from that\n* Group will be removed from it and added into this Group.\n* \n* If `Group.enableBody` is set, then a physics body will be created on the objects, so long as one does not already exist.\n*\n* If `Group.inputEnableChildren` is set, then an Input Handler will be created on the objects, so long as one does not already exist.\n*\n* @method Phaser.Group#addMultiple\n* @param {DisplayObject[]|Phaser.Group} children - An array of display objects or a Phaser.Group. If a Group is given then *all* children will be moved from it.\n* @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event.\n* @return {DisplayObject[]|Phaser.Group} The array of children or Group of children that were added to this Group.\n*/\nPhaser.Group.prototype.addMultiple = function (children, silent) {\n\n    if (children instanceof Phaser.Group)\n    {\n        children.moveAll(this, silent);\n    }\n    else if (Array.isArray(children))\n    {\n        for (var i = 0; i < children.length; i++)\n        {\n            this.add(children[i], silent);\n        }\n    }\n\n    return children;\n\n};\n\n/**\n* Returns the child found at the given index within this group.\n*\n* @method Phaser.Group#getAt\n* @param {integer} index - The index to return the child from.\n* @return {DisplayObject|integer} The child that was found at the given index, or -1 for an invalid index.\n*/\nPhaser.Group.prototype.getAt = function (index) {\n\n    if (index < 0 || index >= this.children.length)\n    {\n        return -1;\n    }\n    else\n    {\n        return this.getChildAt(index);\n    }\n\n};\n\n/**\n* Creates a new Phaser.Sprite object and adds it to the top of this group.\n*\n* Use {@link #classType} to change the type of object created.\n* \n* The child is automatically added to the top of the group, and is displayed above every previous child.\n*\n* Or if the _optional_ index is specified, the child is added at the location specified by the index value, \n* this allows you to control child ordering.\n* \n* If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.\n*\n* If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.\n*\n* @method Phaser.Group#create\n* @param {number} x - The x coordinate to display the newly created Sprite at. The value is in relation to the group.x point.\n* @param {number} y - The y coordinate to display the newly created Sprite at. The value is in relation to the group.y point.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache Image entry, or an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n* @param {string|number} [frame] - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n* @param {boolean} [exists=true] - The default exists state of the Sprite.\n* @param {integer} [index] - The index within the group to insert the child to. Where 0 is the bottom of the Group.\n* @return {DisplayObject} The child that was created: will be a {@link Phaser.Sprite} unless {@link #classType} has been changed.\n*/\nPhaser.Group.prototype.create = function (x, y, key, frame, exists, index) {\n\n    if (exists === undefined) { exists = true; }\n\n    var child = new this.classType(this.game, x, y, key, frame);\n\n    child.exists = exists;\n    child.visible = exists;\n    child.alive = exists;\n\n    return this.add(child, false, index);\n\n};\n\n/**\n* Creates multiple Phaser.Sprite objects and adds them to the top of this Group.\n* \n* This method is useful if you need to quickly generate a pool of sprites, such as bullets.\n*\n* Use {@link #classType} to change the type of object created.\n*\n* You can provide an array as the `key` and / or `frame` arguments. When you do this\n* it will create `quantity` Sprites for every key (and frame) in the arrays.\n* \n* For example:\n* \n* `createMultiple(25, ['ball', 'carrot'])`\n*\n* In the above code there are 2 keys (ball and carrot) which means that 50 sprites will be\n* created in total, 25 of each. You can also have the `frame` as an array:\n*\n* `createMultiple(5, 'bricks', [0, 1, 2, 3])`\n*\n* In the above there is one key (bricks), which is a sprite sheet. The frames array tells\n* this method to use frames 0, 1, 2 and 3. So in total it will create 20 sprites, because\n* the quantity was set to 5, so that is 5 brick sprites of frame 0, 5 brick sprites with\n* frame 1, and so on.\n*\n* If you set both the key and frame arguments to be arrays then understand it will create\n* a total quantity of sprites equal to the size of both arrays times each other. I.e.:\n*\n* `createMultiple(20, ['diamonds', 'balls'], [0, 1, 2])`\n*\n* The above will create 20 'diamonds' of frame 0, 20 with frame 1 and 20 with frame 2.\n* It will then create 20 'balls' of frame 0, 20 with frame 1 and 20 with frame 2.\n* In total it will have created 120 sprites.\n*\n* By default the Sprites will have their `exists` property set to `false`, and they will be \n* positioned at 0x0, relative to the `Group.x / y` values.\n* \n* If `Group.enableBody` is set, then a physics body will be created on the objects, so long as one does not already exist.\n*\n* If `Group.inputEnableChildren` is set, then an Input Handler will be created on the objects, so long as one does not already exist.\n*\n* @method Phaser.Group#createMultiple\n* @param {integer} quantity - The number of Sprites to create.\n* @param {string|array} key - The Cache key of the image that the Sprites will use. Or an Array of keys. See the description for details on how the quantity applies when arrays are used.\n* @param {integer|string|array} [frame=0] - If the Sprite image contains multiple frames you can specify which one to use here. Or an Array of frames. See the description for details on how the quantity applies when arrays are used.\n* @param {boolean} [exists=false] - The default exists state of the Sprite.\n* @return {array} An array containing all of the Sprites that were created.\n*/\nPhaser.Group.prototype.createMultiple = function (quantity, key, frame, exists) {\n\n    if (frame === undefined) { frame = 0; }\n    if (exists === undefined) { exists = false; }\n\n    if (!Array.isArray(key))\n    {\n        key = [ key ];\n    }\n\n    if (!Array.isArray(frame))\n    {\n        frame = [ frame ];\n    }\n\n    var _this = this;\n    var children = [];\n\n    key.forEach(function(singleKey) {\n\n        frame.forEach(function(singleFrame) {\n\n            for (var i = 0; i < quantity; i++)\n            {\n                children.push(_this.create(0, 0, singleKey, singleFrame, exists));\n            }\n\n        });\n\n    });\n\n    return children;\n\n};\n\n/**\n* Internal method that re-applies all of the children's Z values.\n*\n* This must be called whenever children ordering is altered so that their `z` indices are correctly updated.\n*\n* @method Phaser.Group#updateZ\n* @protected\n*/\nPhaser.Group.prototype.updateZ = function () {\n\n    var i = this.children.length;\n\n    while (i--)\n    {\n        this.children[i].z = i;\n    }\n\n};\n\n/**\n* This method iterates through all children in the Group (regardless if they are visible or exist)\n* and then changes their position so they are arranged in a Grid formation. Children must have\n* the `alignTo` method in order to be positioned by this call. All default Phaser Game Objects have\n* this.\n*\n* The grid dimensions are determined by the first four arguments. The `width` and `height` arguments\n* relate to the width and height of the grid respectively.\n*\n* For example if the Group had 100 children in it:\n*\n* `Group.align(10, 10, 32, 32)`\n*\n* This will align all of the children into a grid formation of 10x10, using 32 pixels per\n* grid cell. If you want a wider grid, you could do:\n* \n* `Group.align(25, 4, 32, 32)`\n*\n* This will align the children into a grid of 25x4, again using 32 pixels per grid cell.\n*\n* You can choose to set _either_ the `width` or `height` value to -1. Doing so tells the method\n* to keep on aligning children until there are no children left. For example if this Group had\n* 48 children in it, the following:\n*\n* `Group.align(-1, 8, 32, 32)`\n*\n* ... will align the children so that there are 8 children vertically (the second argument), \n* and each row will contain 6 sprites, except the last one, which will contain 5 (totaling 48)\n*\n* You can also do:\n* \n* `Group.align(10, -1, 32, 32)`\n*\n* In this case it will create a grid 10 wide, and as tall as it needs to be in order to fit\n* all of the children in.\n*\n* The `position` property allows you to control where in each grid cell the child is positioned.\n* This is a constant and can be one of `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, \n* `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, \n* `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.\n*\n* The final argument; `offset` lets you start the alignment from a specific child index.\n*\n* @method Phaser.Group#align\n* @param {integer} width - The width of the grid in items (not pixels). Set to -1 for a dynamic width. If -1 then you must set an explicit height value.\n* @param {integer} height - The height of the grid in items (not pixels). Set to -1 for a dynamic height. If -1 then you must set an explicit width value.\n* @param {integer} cellWidth - The width of each grid cell, in pixels.\n* @param {integer} cellHeight - The height of each grid cell, in pixels.\n* @param {integer} [position] - The position constant. One of `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.\n* @param {integer} [offset=0] - Optional index to start the alignment from. Defaults to zero, the first child in the Group, but can be set to any valid child index value.\n* @return {boolean} True if the Group children were aligned, otherwise false.\n*/\nPhaser.Group.prototype.align = function (width, height, cellWidth, cellHeight, position, offset) {\n\n    if (position === undefined) { position = Phaser.TOP_LEFT; }\n    if (offset === undefined) { offset = 0; }\n\n    if (this.children.length === 0 || offset > this.children.length || (width === -1 && height === -1))\n    {\n        return false;\n    }\n\n    var r = new Phaser.Rectangle(0, 0, cellWidth, cellHeight);\n    var w = (width * cellWidth);\n    var h = (height * cellHeight);\n\n    for (var i = offset; i < this.children.length; i++)\n    {\n        var child = this.children[i];\n\n        if (child['alignIn'])\n        {\n            child.alignIn(r, position);\n        }\n        else\n        {\n            continue;\n        }\n\n        if (width === -1)\n        {\n            //  We keep laying them out horizontally until we've done them all\n            r.y += cellHeight;\n\n            if (r.y === h)\n            {\n                r.x += cellWidth;\n                r.y = 0;\n            }\n        }\n        else if (height === -1)\n        {\n            //  We keep laying them out vertically until we've done them all\n            r.x += cellWidth;\n\n            if (r.x === w)\n            {\n                r.x = 0;\n                r.y += cellHeight;\n            }\n        }\n        else\n        {\n            //  We keep laying them out until we hit the column limit\n            r.x += cellWidth;\n\n            if (r.x === w)\n            {\n                r.x = 0;\n                r.y += cellHeight;\n\n                if (r.y === h)\n                {\n                    //  We've hit the column limit, so return, even if there are children left\n                    return true;\n                }\n            }\n        }\n    }\n\n    return true;\n\n};\n\n/**\n* Sets the group cursor to the first child in the group.\n*\n* If the optional index parameter is given it sets the cursor to the object at that index instead.\n*\n* @method Phaser.Group#resetCursor\n* @param {integer} [index=0] - Set the cursor to point to a specific index.\n* @return {any} The child the cursor now points to.\n*/\nPhaser.Group.prototype.resetCursor = function (index) {\n\n    if (index === undefined) { index = 0; }\n\n    if (index > this.children.length - 1)\n    {\n        index = 0;\n    }\n\n    if (this.cursor)\n    {\n        this.cursorIndex = index;\n        this.cursor = this.children[this.cursorIndex];\n        return this.cursor;\n    }\n\n};\n\n/**\n* Advances the group cursor to the next (higher) object in the group.\n*\n* If the cursor is at the end of the group (top child) it is moved the start of the group (bottom child).\n*\n* @method Phaser.Group#next\n* @return {any} The child the cursor now points to.\n*/\nPhaser.Group.prototype.next = function () {\n\n    if (this.cursor)\n    {\n        //  Wrap the cursor?\n        if (this.cursorIndex >= this.children.length - 1)\n        {\n            this.cursorIndex = 0;\n        }\n        else\n        {\n            this.cursorIndex++;\n        }\n\n        this.cursor = this.children[this.cursorIndex];\n\n        return this.cursor;\n    }\n\n};\n\n/**\n* Moves the group cursor to the previous (lower) child in the group.\n*\n* If the cursor is at the start of the group (bottom child) it is moved to the end (top child).\n*\n* @method Phaser.Group#previous\n* @return {any} The child the cursor now points to.\n*/\nPhaser.Group.prototype.previous = function () {\n\n    if (this.cursor)\n    {\n        //  Wrap the cursor?\n        if (this.cursorIndex === 0)\n        {\n            this.cursorIndex = this.children.length - 1;\n        }\n        else\n        {\n            this.cursorIndex--;\n        }\n\n        this.cursor = this.children[this.cursorIndex];\n\n        return this.cursor;\n    }\n\n};\n\n/**\n* Swaps the position of two children in this group.\n*\n* Both children must be in this group, a child cannot be swapped with itself, and unparented children cannot be swapped.\n*\n* @method Phaser.Group#swap\n* @param {any} child1 - The first child to swap.\n* @param {any} child2 - The second child to swap.\n*/\nPhaser.Group.prototype.swap = function (child1, child2) {\n\n    this.swapChildren(child1, child2);\n    this.updateZ();\n\n};\n\n/**\n* Brings the given child to the top of this group so it renders above all other children.\n*\n* @method Phaser.Group#bringToTop\n* @param {any} child - The child to bring to the top of this group.\n* @return {any} The child that was moved.\n*/\nPhaser.Group.prototype.bringToTop = function (child) {\n\n    if (child.parent === this && this.getIndex(child) < this.children.length)\n    {\n        this.remove(child, false, true);\n        this.add(child, true);\n    }\n\n    return child;\n\n};\n\n/**\n* Sends the given child to the bottom of this group so it renders below all other children.\n*\n* @method Phaser.Group#sendToBack\n* @param {any} child - The child to send to the bottom of this group.\n* @return {any} The child that was moved.\n*/\nPhaser.Group.prototype.sendToBack = function (child) {\n\n    if (child.parent === this && this.getIndex(child) > 0)\n    {\n        this.remove(child, false, true);\n        this.addAt(child, 0, true);\n    }\n\n    return child;\n\n};\n\n/**\n* Moves the given child up one place in this group unless it's already at the top.\n*\n* @method Phaser.Group#moveUp\n* @param {any} child - The child to move up in the group.\n* @return {any} The child that was moved.\n*/\nPhaser.Group.prototype.moveUp = function (child) {\n\n    if (child.parent === this && this.getIndex(child) < this.children.length - 1)\n    {\n        var a = this.getIndex(child);\n        var b = this.getAt(a + 1);\n\n        if (b)\n        {\n            this.swap(child, b);\n        }\n    }\n\n    return child;\n\n};\n\n/**\n* Moves the given child down one place in this group unless it's already at the bottom.\n*\n* @method Phaser.Group#moveDown\n* @param {any} child - The child to move down in the group.\n* @return {any} The child that was moved.\n*/\nPhaser.Group.prototype.moveDown = function (child) {\n\n    if (child.parent === this && this.getIndex(child) > 0)\n    {\n        var a = this.getIndex(child);\n        var b = this.getAt(a - 1);\n\n        if (b)\n        {\n            this.swap(child, b);\n        }\n    }\n\n    return child;\n\n};\n\n/**\n* Positions the child found at the given index within this group to the given x and y coordinates.\n*\n* @method Phaser.Group#xy\n* @param {integer} index - The index of the child in the group to set the position of.\n* @param {number} x - The new x position of the child.\n* @param {number} y - The new y position of the child.\n*/\nPhaser.Group.prototype.xy = function (index, x, y) {\n\n    if (index < 0 || index > this.children.length)\n    {\n        return -1;\n    }\n    else\n    {\n        this.getChildAt(index).x = x;\n        this.getChildAt(index).y = y;\n    }\n\n};\n\n/**\n* Reverses all children in this group.\n*\n* This operation applies only to immediate children and does not propagate to subgroups.\n*\n* @method Phaser.Group#reverse\n*/\nPhaser.Group.prototype.reverse = function () {\n\n    this.children.reverse();\n    this.updateZ();\n\n};\n\n/**\n* Get the index position of the given child in this group, which should match the child's `z` property.\n*\n* @method Phaser.Group#getIndex\n* @param {any} child - The child to get the index for.\n* @return {integer} The index of the child or -1 if it's not a member of this group.\n*/\nPhaser.Group.prototype.getIndex = function (child) {\n\n    return this.children.indexOf(child);\n\n};\n\n/**\n* Searches the Group for the first instance of a child with the `name`\n* property matching the given argument. Should more than one child have\n* the same name only the first instance is returned.\n*\n* @method Phaser.Group#getByName\n* @param {string} name - The name to search for.\n* @return {any} The first child with a matching name, or null if none were found.\n*/\nPhaser.Group.prototype.getByName = function (name) {\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        if (this.children[i].name === name)\n        {\n            return this.children[i];\n        }\n    }\n\n    return null;\n\n};\n\n/**\n* Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.\n*\n* If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.\n*\n* If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.\n*\n* @method Phaser.Group#replace\n* @param {any} oldChild - The child in this group that will be replaced.\n* @param {any} newChild - The child to be inserted into this group.\n* @return {any} Returns the oldChild that was replaced within this group.\n*/\nPhaser.Group.prototype.replace = function (oldChild, newChild) {\n\n    var index = this.getIndex(oldChild);\n\n    if (index !== -1)\n    {\n        if (newChild.parent)\n        {\n            if (newChild.parent instanceof Phaser.Group)\n            {\n                newChild.parent.remove(newChild);\n            }\n            else\n            {\n                newChild.parent.removeChild(newChild);\n            }\n        }\n\n        this.remove(oldChild);\n\n        this.addAt(newChild, index);\n\n        return oldChild;\n    }\n\n};\n\n/**\n* Checks if the child has the given property.\n*\n* Will scan up to 4 levels deep only.\n*\n* @method Phaser.Group#hasProperty\n* @param {any} child - The child to check for the existence of the property on.\n* @param {string[]} key - An array of strings that make up the property.\n* @return {boolean} True if the child has the property, otherwise false.\n*/\nPhaser.Group.prototype.hasProperty = function (child, key) {\n\n    var len = key.length;\n\n    if (len === 1 && key[0] in child)\n    {\n        return true;\n    }\n    else if (len === 2 && key[0] in child && key[1] in child[key[0]])\n    {\n        return true;\n    }\n    else if (len === 3 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]])\n    {\n        return true;\n    }\n    else if (len === 4 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]] && key[3] in child[key[0]][key[1]][key[2]])\n    {\n        return true;\n    }\n\n    return false;\n\n};\n\n/**\n* Sets a property to the given value on the child. The operation parameter controls how the value is set.\n*\n* The operations are:\n* - 0: set the existing value to the given value; if force is `true` a new property will be created if needed\n* - 1: will add the given value to the value already present.\n* - 2: will subtract the given value from the value already present.\n* - 3: will multiply the value already present by the given value.\n* - 4: will divide the value already present by the given value.\n*\n* @method Phaser.Group#setProperty\n* @param {any} child - The child to set the property value on.\n* @param {array} key - An array of strings that make up the property that will be set.\n* @param {any} value - The value that will be set.\n* @param {integer} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.\n* @param {boolean} [force=false] - If `force` is true then the property will be set on the child regardless if it already exists or not. If false and the property doesn't exist, nothing will be set.\n* @return {boolean} True if the property was set, false if not.\n*/\nPhaser.Group.prototype.setProperty = function (child, key, value, operation, force) {\n\n    if (force === undefined) { force = false; }\n\n    operation = operation || 0;\n\n    //  As ugly as this approach looks, and although it's limited to a depth of only 4, it's much faster than a for loop or object iteration.\n\n    //  0 = Equals\n    //  1 = Add\n    //  2 = Subtract\n    //  3 = Multiply\n    //  4 = Divide\n\n    //  We can't force a property in and the child doesn't have it, so abort.\n    //  Equally we can't add, subtract, multiply or divide a property value if it doesn't exist, so abort in those cases too.\n    if (!this.hasProperty(child, key) && (!force || operation > 0))\n    {\n        return false;\n    }\n\n    var len = key.length;\n\n    if (len === 1)\n    {\n        if (operation === 0) { child[key[0]] = value; }\n        else if (operation === 1) { child[key[0]] += value; }\n        else if (operation === 2) { child[key[0]] -= value; }\n        else if (operation === 3) { child[key[0]] *= value; }\n        else if (operation === 4) { child[key[0]] /= value; }\n    }\n    else if (len === 2)\n    {\n        if (operation === 0) { child[key[0]][key[1]] = value; }\n        else if (operation === 1) { child[key[0]][key[1]] += value; }\n        else if (operation === 2) { child[key[0]][key[1]] -= value; }\n        else if (operation === 3) { child[key[0]][key[1]] *= value; }\n        else if (operation === 4) { child[key[0]][key[1]] /= value; }\n    }\n    else if (len === 3)\n    {\n        if (operation === 0) { child[key[0]][key[1]][key[2]] = value; }\n        else if (operation === 1) { child[key[0]][key[1]][key[2]] += value; }\n        else if (operation === 2) { child[key[0]][key[1]][key[2]] -= value; }\n        else if (operation === 3) { child[key[0]][key[1]][key[2]] *= value; }\n        else if (operation === 4) { child[key[0]][key[1]][key[2]] /= value; }\n    }\n    else if (len === 4)\n    {\n        if (operation === 0) { child[key[0]][key[1]][key[2]][key[3]] = value; }\n        else if (operation === 1) { child[key[0]][key[1]][key[2]][key[3]] += value; }\n        else if (operation === 2) { child[key[0]][key[1]][key[2]][key[3]] -= value; }\n        else if (operation === 3) { child[key[0]][key[1]][key[2]][key[3]] *= value; }\n        else if (operation === 4) { child[key[0]][key[1]][key[2]][key[3]] /= value; }\n    }\n\n    return true;\n\n};\n\n/**\n* Checks a property for the given value on the child.\n*\n* @method Phaser.Group#checkProperty\n* @param {any} child - The child to check the property value on.\n* @param {array} key - An array of strings that make up the property that will be set.\n* @param {any} value - The value that will be checked.\n* @param {boolean} [force=false] - If `force` is true then the property will be checked on the child regardless if it already exists or not. If true and the property doesn't exist, false will be returned.\n* @return {boolean} True if the property was was equal to value, false if not.\n*/\nPhaser.Group.prototype.checkProperty = function (child, key, value, force) {\n\n    if (force === undefined) { force = false; }\n\n    //  We can't force a property in and the child doesn't have it, so abort.\n    if (!Phaser.Utils.getProperty(child, key) && force)\n    {\n        return false;\n    }\n\n    if (Phaser.Utils.getProperty(child, key) !== value)\n    {\n        return false;\n    }\n\n    return true;\n\n};\n\n/**\n* Quickly set a property on a single child of this group to a new value.\n*\n* The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.\n*\n* @method Phaser.Group#set\n* @param {Phaser.Sprite} child - The child to set the property on.\n* @param {string} key - The property, as a string, to be set. For example: 'body.velocity.x'\n* @param {any} value - The value that will be set.\n* @param {boolean} [checkAlive=false] - If set then the child will only be updated if alive=true.\n* @param {boolean} [checkVisible=false] - If set then the child will only be updated if visible=true.\n* @param {integer} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.\n* @param {boolean} [force=false] - If `force` is true then the property will be set on the child regardless if it already exists or not. If false and the property doesn't exist, nothing will be set.\n* @return {boolean} True if the property was set, false if not.\n*/\nPhaser.Group.prototype.set = function (child, key, value, checkAlive, checkVisible, operation, force) {\n\n    if (force === undefined) { force = false; }\n\n    key = key.split('.');\n\n    if (checkAlive === undefined) { checkAlive = false; }\n    if (checkVisible === undefined) { checkVisible = false; }\n\n    if ((checkAlive === false || (checkAlive && child.alive)) && (checkVisible === false || (checkVisible && child.visible)))\n    {\n        return this.setProperty(child, key, value, operation, force);\n    }\n\n};\n\n/**\n* Quickly set the same property across all children of this group to a new value.\n*\n* This call doesn't descend down children, so if you have a Group inside of this group, the property will be set on the group but not its children.\n* If you need that ability please see `Group.setAllChildren`.\n*\n* The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.\n*\n* @method Phaser.Group#setAll\n* @param {string} key - The property, as a string, to be set. For example: 'body.velocity.x'\n* @param {any} value - The value that will be set.\n* @param {boolean} [checkAlive=false] - If set then only children with alive=true will be updated. This includes any Groups that are children.\n* @param {boolean} [checkVisible=false] - If set then only children with visible=true will be updated. This includes any Groups that are children.\n* @param {integer} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.\n* @param {boolean} [force=false] - If `force` is true then the property will be set on the child regardless if it already exists or not. If false and the property doesn't exist, nothing will be set.\n*/\nPhaser.Group.prototype.setAll = function (key, value, checkAlive, checkVisible, operation, force) {\n\n    if (checkAlive === undefined) { checkAlive = false; }\n    if (checkVisible === undefined) { checkVisible = false; }\n    if (force === undefined) { force = false; }\n\n    key = key.split('.');\n    operation = operation || 0;\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        if ((!checkAlive || (checkAlive && this.children[i].alive)) && (!checkVisible || (checkVisible && this.children[i].visible)))\n        {\n            this.setProperty(this.children[i], key, value, operation, force);\n        }\n    }\n\n};\n\n/**\n* Quickly set the same property across all children of this group, and any child Groups, to a new value.\n*\n* If this group contains other Groups then the same property is set across their children as well, iterating down until it reaches the bottom.\n* Unlike with `setAll` the property is NOT set on child Groups itself.\n*\n* The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.\n*\n* @method Phaser.Group#setAllChildren\n* @param {string} key - The property, as a string, to be set. For example: 'body.velocity.x'\n* @param {any} value - The value that will be set.\n* @param {boolean} [checkAlive=false] - If set then only children with alive=true will be updated. This includes any Groups that are children.\n* @param {boolean} [checkVisible=false] - If set then only children with visible=true will be updated. This includes any Groups that are children.\n* @param {integer} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.\n* @param {boolean} [force=false] - If `force` is true then the property will be set on the child regardless if it already exists or not. If false and the property doesn't exist, nothing will be set.\n*/\nPhaser.Group.prototype.setAllChildren = function (key, value, checkAlive, checkVisible, operation, force) {\n\n    if (checkAlive === undefined) { checkAlive = false; }\n    if (checkVisible === undefined) { checkVisible = false; }\n    if (force === undefined) { force = false; }\n\n    operation = operation || 0;\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        if ((!checkAlive || (checkAlive && this.children[i].alive)) && (!checkVisible || (checkVisible && this.children[i].visible)))\n        {\n            if (this.children[i] instanceof Phaser.Group)\n            {\n                this.children[i].setAllChildren(key, value, checkAlive, checkVisible, operation, force);\n            }\n            else\n            {\n                this.setProperty(this.children[i], key.split('.'), value, operation, force);\n            }\n        }\n    }\n\n};\n\n/**\n* Quickly check that the same property across all children of this group is equal to the given value.\n*\n* This call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.\n*\n* @method Phaser.Group#checkAll\n* @param {string} key - The property, as a string, to be set. For example: 'body.velocity.x'\n* @param {any} value - The value that will be checked.\n* @param {boolean} [checkAlive=false] - If set then only children with alive=true will be checked. This includes any Groups that are children.\n* @param {boolean} [checkVisible=false] - If set then only children with visible=true will be checked. This includes any Groups that are children.\n* @param {boolean} [force=false] - If `force` is true then the property will be checked on the child regardless if it already exists or not. If true and the property doesn't exist, false will be returned.\n*/\nPhaser.Group.prototype.checkAll = function (key, value, checkAlive, checkVisible, force) {\n\n    if (checkAlive === undefined) { checkAlive = false; }\n    if (checkVisible === undefined) { checkVisible = false; }\n    if (force === undefined) { force = false; }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        if ((!checkAlive || (checkAlive && this.children[i].alive)) && (!checkVisible || (checkVisible && this.children[i].visible)))\n        {\n            if (!this.checkProperty(this.children[i], key, value, force))\n            {\n                return false;\n            }\n        }\n    }\n\n    return true;\n\n};\n\n/**\n* Adds the amount to the given property on all children in this group.\n*\n* `Group.addAll('x', 10)` will add 10 to the child.x value for each child.\n*\n* @method Phaser.Group#addAll\n* @param {string} property - The property to increment, for example 'body.velocity.x' or 'angle'.\n* @param {number} amount - The amount to increment the property by. If child.x = 10 then addAll('x', 40) would make child.x = 50.\n* @param {boolean} checkAlive - If true the property will only be changed if the child is alive.\n* @param {boolean} checkVisible - If true the property will only be changed if the child is visible.\n*/\nPhaser.Group.prototype.addAll = function (property, amount, checkAlive, checkVisible) {\n\n    this.setAll(property, amount, checkAlive, checkVisible, 1);\n\n};\n\n/**\n* Subtracts the amount from the given property on all children in this group.\n*\n* `Group.subAll('x', 10)` will minus 10 from the child.x value for each child.\n*\n* @method Phaser.Group#subAll\n* @param {string} property - The property to decrement, for example 'body.velocity.x' or 'angle'.\n* @param {number} amount - The amount to subtract from the property. If child.x = 50 then subAll('x', 40) would make child.x = 10.\n* @param {boolean} checkAlive - If true the property will only be changed if the child is alive.\n* @param {boolean} checkVisible - If true the property will only be changed if the child is visible.\n*/\nPhaser.Group.prototype.subAll = function (property, amount, checkAlive, checkVisible) {\n\n    this.setAll(property, amount, checkAlive, checkVisible, 2);\n\n};\n\n/**\n* Multiplies the given property by the amount on all children in this group.\n*\n* `Group.multiplyAll('x', 2)` will x2 the child.x value for each child.\n*\n* @method Phaser.Group#multiplyAll\n* @param {string} property - The property to multiply, for example 'body.velocity.x' or 'angle'.\n* @param {number} amount - The amount to multiply the property by. If child.x = 10 then multiplyAll('x', 2) would make child.x = 20.\n* @param {boolean} checkAlive - If true the property will only be changed if the child is alive.\n* @param {boolean} checkVisible - If true the property will only be changed if the child is visible.\n*/\nPhaser.Group.prototype.multiplyAll = function (property, amount, checkAlive, checkVisible) {\n\n    this.setAll(property, amount, checkAlive, checkVisible, 3);\n\n};\n\n/**\n* Divides the given property by the amount on all children in this group.\n*\n* `Group.divideAll('x', 2)` will half the child.x value for each child.\n*\n* @method Phaser.Group#divideAll\n* @param {string} property - The property to divide, for example 'body.velocity.x' or 'angle'.\n* @param {number} amount - The amount to divide the property by. If child.x = 100 then divideAll('x', 2) would make child.x = 50.\n* @param {boolean} checkAlive - If true the property will only be changed if the child is alive.\n* @param {boolean} checkVisible - If true the property will only be changed if the child is visible.\n*/\nPhaser.Group.prototype.divideAll = function (property, amount, checkAlive, checkVisible) {\n\n    this.setAll(property, amount, checkAlive, checkVisible, 4);\n\n};\n\n/**\n* Calls a function, specified by name, on all children in the group who exist (or do not exist).\n*\n* After the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.\n*\n* @method Phaser.Group#callAllExists\n* @param {string} callback - Name of the function on the children to call.\n* @param {boolean} existsValue - Only children with exists=existsValue will be called.\n* @param {...any} parameter - Additional parameters that will be passed to the callback.\n*/\nPhaser.Group.prototype.callAllExists = function (callback, existsValue) {\n\n    var args;\n\n    if (arguments.length > 2)\n    {\n        args = [];\n\n        for (var i = 2; i < arguments.length; i++)\n        {\n            args.push(arguments[i]);\n        }\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        if (this.children[i].exists === existsValue && this.children[i][callback])\n        {\n            this.children[i][callback].apply(this.children[i], args);\n        }\n    }\n\n};\n\n/**\n* Returns a reference to a function that exists on a child of the group based on the given callback array.\n*\n* @method Phaser.Group#callbackFromArray\n* @param {object} child - The object to inspect.\n* @param {array} callback - The array of function names.\n* @param {integer} length - The size of the array (pre-calculated in callAll).\n* @protected\n*/\nPhaser.Group.prototype.callbackFromArray = function (child, callback, length) {\n\n    //  Kinda looks like a Christmas tree\n\n    if (length === 1)\n    {\n        if (child[callback[0]])\n        {\n            return child[callback[0]];\n        }\n    }\n    else if (length === 2)\n    {\n        if (child[callback[0]][callback[1]])\n        {\n            return child[callback[0]][callback[1]];\n        }\n    }\n    else if (length === 3)\n    {\n        if (child[callback[0]][callback[1]][callback[2]])\n        {\n            return child[callback[0]][callback[1]][callback[2]];\n        }\n    }\n    else if (length === 4)\n    {\n        if (child[callback[0]][callback[1]][callback[2]][callback[3]])\n        {\n            return child[callback[0]][callback[1]][callback[2]][callback[3]];\n        }\n    }\n    else if (child[callback])\n    {\n        return child[callback];\n    }\n\n    return false;\n\n};\n\n/**\n* Calls a function, specified by name, on all on children.\n*\n* The function is called for all children regardless if they are dead or alive (see callAllExists for different options).\n* After the method parameter and context you can add as many extra parameters as you like, which will all be passed to the child.\n*\n* @method Phaser.Group#callAll\n* @param {string} method - Name of the function on the child to call. Deep property lookup is supported.\n* @param {string} [context=null] - A string containing the context under which the method will be executed. Set to null to default to the child.\n* @param {...any} args - Additional parameters that will be passed to the method.\n*/\nPhaser.Group.prototype.callAll = function (method, context) {\n\n    if (method === undefined)\n    {\n        return;\n    }\n\n    //  Extract the method into an array\n    method = method.split('.');\n\n    var methodLength = method.length;\n\n    if (context === undefined || context === null || context === '')\n    {\n        context = null;\n    }\n    else\n    {\n        //  Extract the context into an array\n        if (typeof context === 'string')\n        {\n            context = context.split('.');\n            var contextLength = context.length;\n        }\n    }\n\n    var args;\n\n    if (arguments.length > 2)\n    {\n        args = [];\n\n        for (var i = 2; i < arguments.length; i++)\n        {\n            args.push(arguments[i]);\n        }\n    }\n\n    var callback = null;\n    var callbackContext = null;\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        callback = this.callbackFromArray(this.children[i], method, methodLength);\n\n        if (context && callback)\n        {\n            callbackContext = this.callbackFromArray(this.children[i], context, contextLength);\n\n            if (callback)\n            {\n                callback.apply(callbackContext, args);\n            }\n        }\n        else if (callback)\n        {\n            callback.apply(this.children[i], args);\n        }\n    }\n\n};\n\n/**\n* The core preUpdate - as called by World.\n* @method Phaser.Group#preUpdate\n* @protected\n*/\nPhaser.Group.prototype.preUpdate = function () {\n\n    if (this.pendingDestroy)\n    {\n        this.destroy();\n        return false;\n    }\n\n    if (!this.exists || !this.parent.exists)\n    {\n        this.renderOrderID = -1;\n        return false;\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].preUpdate();\n    }\n\n    return true;\n\n};\n\n/**\n* The core update - as called by World.\n* @method Phaser.Group#update\n* @protected\n*/\nPhaser.Group.prototype.update = function () {\n\n    //  Goes in reverse, because it's highly likely the child will destroy itself in `update`\n    var i = this.children.length;\n\n    while (i--)\n    {\n        this.children[i].update();\n    }\n\n};\n\n/**\n* The core postUpdate - as called by World.\n* @method Phaser.Group#postUpdate\n* @protected\n*/\nPhaser.Group.prototype.postUpdate = function () {\n\n    //  Fixed to Camera?\n    if (this.fixedToCamera)\n    {\n        this.x = this.game.camera.view.x + this.cameraOffset.x;\n        this.y = this.game.camera.view.y + this.cameraOffset.y;\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].postUpdate();\n    }\n\n};\n\n/**\n* Find children matching a certain predicate.\n*\n* For example:\n*\n*     var healthyList = Group.filter(function(child, index, children) {\n*         return child.health > 10 ? true : false;\n*     }, true);\n*     healthyList.callAll('attack');\n*\n* Note: Currently this will skip any children which are Groups themselves.\n*\n* @method Phaser.Group#filter\n* @param {function} predicate - The function that each child will be evaluated against. Each child of the group will be passed to it as its first parameter, the index as the second, and the entire child array as the third\n* @param {boolean} [checkExists=false] - If true, only existing can be selected; otherwise all children can be selected and will be passed to the predicate.\n* @return {Phaser.ArraySet} Returns an array list containing all the children that the predicate returned true for\n*/\nPhaser.Group.prototype.filter = function (predicate, checkExists) {\n\n    var index = -1;\n    var length = this.children.length;\n    var results = [];\n\n    while (++index < length)\n    {\n        var child = this.children[index];\n\n        if (!checkExists || (checkExists && child.exists))\n        {\n            if (predicate(child, index, this.children))\n            {\n                results.push(child);\n            }\n        }\n    }\n\n    return new Phaser.ArraySet(results);\n\n};\n\n/**\n* Call a function on each child in this group.\n*\n* Additional arguments for the callback can be specified after the `checkExists` parameter. For example,\n*\n*     Group.forEach(awardBonusGold, this, true, 100, 500)\n*\n* would invoke `awardBonusGold` function with the parameters `(child, 100, 500)`.\n*\n* Note: This check will skip any children which are Groups themselves.\n*\n* @method Phaser.Group#forEach\n* @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.\n* @param {object} callbackContext - The context in which the function should be called (usually 'this').\n* @param {boolean} [checkExists=false] - If set only children matching for which `exists` is true will be passed to the callback, otherwise all children will be passed.\n* @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\n*/\nPhaser.Group.prototype.forEach = function (callback, callbackContext, checkExists) {\n\n    if (checkExists === undefined) { checkExists = false; }\n\n    if (arguments.length <= 3)\n    {\n        for (var i = 0; i < this.children.length; i++)\n        {\n            if (!checkExists || (checkExists && this.children[i].exists))\n            {\n                callback.call(callbackContext, this.children[i]);\n            }\n        }\n    }\n    else\n    {\n        // Assigning to arguments properties causes Extreme Deoptimization in Chrome, FF, and IE.\n        // Using an array and pushing each element (not a slice!) is _significantly_ faster.\n        var args = [null];\n\n        for (var i = 3; i < arguments.length; i++)\n        {\n            args.push(arguments[i]);\n        }\n\n        for (var i = 0; i < this.children.length; i++)\n        {\n            if (!checkExists || (checkExists && this.children[i].exists))\n            {\n                args[0] = this.children[i];\n                callback.apply(callbackContext, args);\n            }\n        }\n    }\n\n};\n\n/**\n* Call a function on each existing child in this group.\n*\n* See {@link Phaser.Group#forEach forEach} for details.\n*\n* @method Phaser.Group#forEachExists\n* @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.\n* @param {object} callbackContext - The context in which the function should be called (usually 'this').\n* @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\n*/\nPhaser.Group.prototype.forEachExists = function (callback, callbackContext) {\n\n    var args;\n\n    if (arguments.length > 2)\n    {\n        args = [null];\n\n        for (var i = 2; i < arguments.length; i++)\n        {\n            args.push(arguments[i]);\n        }\n    }\n\n    this.iterate('exists', true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);\n\n};\n\n/**\n* Call a function on each alive child in this group.\n*\n* See {@link Phaser.Group#forEach forEach} for details.\n*\n* @method Phaser.Group#forEachAlive\n* @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.\n* @param {object} callbackContext - The context in which the function should be called (usually 'this').\n* @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\n*/\nPhaser.Group.prototype.forEachAlive = function (callback, callbackContext) {\n\n    var args;\n\n    if (arguments.length > 2)\n    {\n        args = [null];\n\n        for (var i = 2; i < arguments.length; i++)\n        {\n            args.push(arguments[i]);\n        }\n    }\n\n    this.iterate('alive', true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);\n\n};\n\n/**\n* Call a function on each dead child in this group.\n*\n* See {@link Phaser.Group#forEach forEach} for details.\n*\n* @method Phaser.Group#forEachDead\n* @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.\n* @param {object} callbackContext - The context in which the function should be called (usually 'this').\n* @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\n*/\nPhaser.Group.prototype.forEachDead = function (callback, callbackContext) {\n\n    var args;\n\n    if (arguments.length > 2)\n    {\n        args = [null];\n\n        for (var i = 2; i < arguments.length; i++)\n        {\n            args.push(arguments[i]);\n        }\n    }\n\n    this.iterate('alive', false, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);\n\n};\n\n/**\n* Sort the children in the group according to a particular key and ordering.\n*\n* Call this function to sort the group according to a particular key value and order.\n* \n* For example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.\n*\n* Internally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including\n* alphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.\n*\n* @method Phaser.Group#sort\n* @param {string} [key='z'] - The name of the property to sort on. Defaults to the objects z-depth value.\n* @param {integer} [order=Phaser.Group.SORT_ASCENDING] - Order ascending ({@link Phaser.Group.SORT_ASCENDING SORT_ASCENDING}) or descending ({@link Phaser.Group.SORT_DESCENDING SORT_DESCENDING}).\n*/\nPhaser.Group.prototype.sort = function (key, order) {\n\n    if (this.children.length < 2)\n    {\n        //  Nothing to swap\n        return;\n    }\n\n    if (key === undefined) { key = 'z'; }\n    if (order === undefined) { order = Phaser.Group.SORT_ASCENDING; }\n\n    this._sortProperty = key;\n\n    if (order === Phaser.Group.SORT_ASCENDING)\n    {\n        this.children.sort(this.ascendingSortHandler.bind(this));\n    }\n    else\n    {\n        this.children.sort(this.descendingSortHandler.bind(this));\n    }\n\n    this.updateZ();\n\n};\n\n/**\n* Sort the children in the group according to custom sort function.\n*\n* The `sortHandler` is provided the two parameters: the two children involved in the comparison (a and b).\n* It should return -1 if `a > b`, 1 if `a < b` or 0 if `a === b`.\n*\n* @method Phaser.Group#customSort\n* @param {function} sortHandler - The custom sort function.\n* @param {object} [context=undefined] - The context in which the sortHandler is called.\n*/\nPhaser.Group.prototype.customSort = function (sortHandler, context) {\n\n    if (this.children.length < 2)\n    {\n        //  Nothing to swap\n        return;\n    }\n\n    this.children.sort(sortHandler.bind(context));\n\n    this.updateZ();\n\n};\n\n/**\n* An internal helper function for the sort process.\n*\n* @method Phaser.Group#ascendingSortHandler\n* @protected\n* @param {object} a - The first object being sorted.\n* @param {object} b - The second object being sorted.\n*/\nPhaser.Group.prototype.ascendingSortHandler = function (a, b) {\n\n    if (a[this._sortProperty] < b[this._sortProperty])\n    {\n        return -1;\n    }\n    else if (a[this._sortProperty] > b[this._sortProperty])\n    {\n        return 1;\n    }\n    else\n    {\n        if (a.z < b.z)\n        {\n            return -1;\n        }\n        else\n        {\n            return 1;\n        }\n    }\n\n};\n\n/**\n* An internal helper function for the sort process.\n*\n* @method Phaser.Group#descendingSortHandler\n* @protected\n* @param {object} a - The first object being sorted.\n* @param {object} b - The second object being sorted.\n*/\nPhaser.Group.prototype.descendingSortHandler = function (a, b) {\n\n    if (a[this._sortProperty] < b[this._sortProperty])\n    {\n        return 1;\n    }\n    else if (a[this._sortProperty] > b[this._sortProperty])\n    {\n        return -1;\n    }\n    else\n    {\n        return 0;\n    }\n\n};\n\n/**\n* Iterates over the children of the group performing one of several actions for matched children.\n*\n* A child is considered a match when it has a property, named `key`, whose value is equal to `value`\n* according to a strict equality comparison.\n*\n* The result depends on the `returnType`:\n*\n* - {@link Phaser.Group.RETURN_TOTAL RETURN_TOTAL}:\n*     The callback, if any, is applied to all matching children. The number of matched children is returned.\n* - {@link Phaser.Group.RETURN_NONE RETURN_NONE}:\n*     The callback, if any, is applied to all matching children. No value is returned.\n* - {@link Phaser.Group.RETURN_CHILD RETURN_CHILD}:\n*     The callback, if any, is applied to the *first* matching child and the *first* matched child is returned.\n*     If there is no matching child then null is returned.\n*\n* If `args` is specified it must be an array. The matched child will be assigned to the first\n* element and the entire array will be applied to the callback function.\n*\n* @method Phaser.Group#iterate\n* @param {string} key - The child property to check, i.e. 'exists', 'alive', 'health'\n* @param {any} value - A child matches if `child[key] === value` is true.\n* @param {integer} returnType - How to iterate the children and what to return.\n* @param {function} [callback=null] - Optional function that will be called on each matching child. The matched child is supplied as the first argument.\n* @param {object} [callbackContext] - The context in which the function should be called (usually 'this').\n* @param {any[]} [args=(none)] - The arguments supplied to to the callback; the first array index (argument) will be replaced with the matched child.\n* @return {any} Returns either an integer (for RETURN_TOTAL), the first matched child (for RETURN_CHILD), or null.\n*/\nPhaser.Group.prototype.iterate = function (key, value, returnType, callback, callbackContext, args) {\n\n    if (this.children.length === 0)\n    {\n        if (returnType === Phaser.Group.RETURN_TOTAL)\n        {\n            return 0;\n        }\n        else if (returnType === Phaser.Group.RETURN_ALL)\n        {\n            return [];\n        }\n    }\n\n    var total = 0;\n\n    if (returnType === Phaser.Group.RETURN_ALL)\n    {\n        var output = [];\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        if (this.children[i][key] === value)\n        {\n            total++;\n\n            if (callback)\n            {\n                if (args)\n                {\n                    args[0] = this.children[i];\n                    callback.apply(callbackContext, args);\n                }\n                else\n                {\n                    callback.call(callbackContext, this.children[i]);\n                }\n            }\n\n            if (returnType === Phaser.Group.RETURN_CHILD)\n            {\n                return this.children[i];\n            }\n            else if (returnType === Phaser.Group.RETURN_ALL)\n            {\n                output.push(this.children[i]);\n            }\n        }\n    }\n\n    if (returnType === Phaser.Group.RETURN_TOTAL)\n    {\n        return total;\n    }\n    else if (returnType === Phaser.Group.RETURN_ALL)\n    {\n        return output;\n    }\n    else\n    {\n        //  RETURN_CHILD or RETURN_NONE\n        return null;\n    }\n\n};\n\n/**\n* Get the first display object that exists, or doesn't exist.\n* \n* You can use the optional argument `createIfNull` to create a new Game Object if none matching your exists argument were found in this Group.\n*\n* It works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n*\n* If a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\n* will be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.\n*\n* @method Phaser.Group#getFirstExists\n* @param {boolean} [exists=true] - If true, find the first existing child; otherwise find the first non-existing child.\n* @param {boolean} [createIfNull=false] - If `true` and no alive children are found a new one is created.\n* @param {number} [x] - The x coordinate to reset the child to. The value is in relation to the group.x point.\n* @param {number} [y] - The y coordinate to reset the child to. The value is in relation to the group.y point.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache Image entry, or an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n* @param {string|number} [frame] - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n* @return {DisplayObject} The first child, or `null` if none found and `createIfNull` was false.\n*/\nPhaser.Group.prototype.getFirstExists = function (exists, createIfNull, x, y, key, frame) {\n\n    if (createIfNull === undefined) { createIfNull = false; }\n\n    if (typeof exists !== 'boolean')\n    {\n        exists = true;\n    }\n\n    var child = this.iterate('exists', exists, Phaser.Group.RETURN_CHILD);\n\n    return (child === null && createIfNull) ? this.create(x, y, key, frame) : this.resetChild(child, x, y, key, frame);\n\n};\n\n/**\n* Get the first child that is alive (`child.alive === true`).\n*\n* This is handy for choosing a squad leader, etc.\n*\n* You can use the optional argument `createIfNull` to create a new Game Object if no alive ones were found in this Group.\n*\n* It works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n*\n* If a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\n* will be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.\n*\n* @method Phaser.Group#getFirstAlive\n* @param {boolean} [createIfNull=false] - If `true` and no alive children are found a new one is created.\n* @param {number} [x] - The x coordinate to reset the child to. The value is in relation to the group.x point.\n* @param {number} [y] - The y coordinate to reset the child to. The value is in relation to the group.y point.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache Image entry, or an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n* @param {string|number} [frame] - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n* @return {DisplayObject} The alive dead child, or `null` if none found and `createIfNull` was false.\n*/\nPhaser.Group.prototype.getFirstAlive = function (createIfNull, x, y, key, frame) {\n\n    if (createIfNull === undefined) { createIfNull = false; }\n\n    var child = this.iterate('alive', true, Phaser.Group.RETURN_CHILD);\n\n    return (child === null && createIfNull) ? this.create(x, y, key, frame) : this.resetChild(child, x, y, key, frame);\n\n};\n\n/**\n* Get the first child that is dead (`child.alive === false`).\n*\n* This is handy for checking if everything has been wiped out and adding to the pool as needed.\n*\n* You can use the optional argument `createIfNull` to create a new Game Object if no dead ones were found in this Group.\n*\n* It works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n*\n* If a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\n* will be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.\n*\n* @method Phaser.Group#getFirstDead\n* @param {boolean} [createIfNull=false] - If `true` and no dead children are found a new one is created.\n* @param {number} [x] - The x coordinate to reset the child to. The value is in relation to the group.x point.\n* @param {number} [y] - The y coordinate to reset the child to. The value is in relation to the group.y point.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache Image entry, or an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n* @param {string|number} [frame] - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n* @return {DisplayObject} The first dead child, or `null` if none found and `createIfNull` was false.\n*/\nPhaser.Group.prototype.getFirstDead = function (createIfNull, x, y, key, frame) {\n\n    if (createIfNull === undefined) { createIfNull = false; }\n\n    var child = this.iterate('alive', false, Phaser.Group.RETURN_CHILD);\n\n    return (child === null && createIfNull) ? this.create(x, y, key, frame) : this.resetChild(child, x, y, key, frame);\n\n};\n\n/**\n* Takes a child and if the `x` and `y` arguments are given it calls `child.reset(x, y)` on it.\n*\n* If the `key` and optionally the `frame` arguments are given, it calls `child.loadTexture(key, frame)` on it.\n*\n* The two operations are separate. For example if you just wish to load a new texture then pass `null` as the x and y values.\n*\n* @method Phaser.Group#resetChild\n* @param {DisplayObject} child - The child to reset and/or load the texture on.\n* @param {number} [x] - The x coordinate to reset the child to. The value is in relation to the group.x point.\n* @param {number} [y] - The y coordinate to reset the child to. The value is in relation to the group.y point.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache Image entry, or an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n* @param {string|number} [frame] - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n* @return {DisplayObject} The child that was reset: usually a {@link Phaser.Sprite}.\n*/\nPhaser.Group.prototype.resetChild = function (child, x, y, key, frame) {\n\n    if (child === null)\n    {\n        return null;\n    }\n\n    if (x === undefined) { x = null; }\n    if (y === undefined) { y = null; }\n\n    if (x !== null && y !== null)\n    {\n        child.reset(x, y);\n    }\n\n    if (key !== undefined)\n    {\n        child.loadTexture(key, frame);\n    }\n\n    return child;\n\n};\n\n/**\n* Return the child at the top of this group.\n*\n* The top child is the child displayed (rendered) above every other child.\n*\n* @method Phaser.Group#getTop\n* @return {any} The child at the top of the Group.\n*/\nPhaser.Group.prototype.getTop = function () {\n\n    if (this.children.length > 0)\n    {\n        return this.children[this.children.length - 1];\n    }\n\n};\n\n/**\n* Returns the child at the bottom of this group.\n*\n* The bottom child the child being displayed (rendered) below every other child.\n*\n* @method Phaser.Group#getBottom\n* @return {any} The child at the bottom of the Group.\n*/\nPhaser.Group.prototype.getBottom = function () {\n\n    if (this.children.length > 0)\n    {\n        return this.children[0];\n    }\n\n};\n\n/**\n* Get the closest child to given Object, with optional callback to filter children.\n*\n* This can be a Sprite, Group, Image or any object with public x and y properties.\n*\n* 'close' is determined by the distance from the objects `x` and `y` properties compared to the childs `x` and `y` properties.\n*\n* You can use the optional `callback` argument to apply your own filter to the distance checks.\n* If the child is closer then the previous child, it will be sent to `callback` as the first argument,\n* with the distance as the second. The callback should return `true` if it passes your \n* filtering criteria, otherwise it should return `false`.\n*\n* @method Phaser.Group#getClosestTo\n* @param {any} object - The object used to determine the distance. This can be a Sprite, Group, Image or any object with public x and y properties.\n* @param {function} [callback] - The function that each child will be evaluated against. Each child of the group will be passed to it as its first parameter, with the distance as the second. It should return `true` if the child passes the matching criteria.\n* @param {object} [callbackContext] - The context in which the function should be called (usually 'this').\n* @return {any} The child closest to given object, or `null` if no child was found.\n*/\nPhaser.Group.prototype.getClosestTo = function (object, callback, callbackContext) {\n\n    var distance = Number.MAX_VALUE;\n    var tempDistance = 0;\n    var result = null;\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        var child = this.children[i];\n\n        if (child.exists)\n        {\n            tempDistance = Math.abs(Phaser.Point.distance(object, child));\n\n            if (tempDistance < distance && (!callback || callback.call(callbackContext, child, tempDistance)))\n            {\n                distance = tempDistance;\n                result = child;\n            }\n        }\n    }\n\n    return result;\n\n};\n\n/**\n* Get the child furthest away from the given Object, with optional callback to filter children.\n*\n* This can be a Sprite, Group, Image or any object with public x and y properties.\n*\n* 'furthest away' is determined by the distance from the objects `x` and `y` properties compared to the childs `x` and `y` properties.\n*\n* You can use the optional `callback` argument to apply your own filter to the distance checks.\n* If the child is closer then the previous child, it will be sent to `callback` as the first argument,\n* with the distance as the second. The callback should return `true` if it passes your \n* filtering criteria, otherwise it should return `false`.\n*\n* @method Phaser.Group#getFurthestFrom\n* @param {any} object - The object used to determine the distance. This can be a Sprite, Group, Image or any object with public x and y properties.\n* @param {function} [callback] - The function that each child will be evaluated against. Each child of the group will be passed to it as its first parameter, with the distance as the second. It should return `true` if the child passes the matching criteria.\n* @param {object} [callbackContext] - The context in which the function should be called (usually 'this').\n* @return {any} The child furthest from the given object, or `null` if no child was found.\n*/\nPhaser.Group.prototype.getFurthestFrom = function (object, callback, callbackContext) {\n\n    var distance = 0;\n    var tempDistance = 0;\n    var result = null;\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        var child = this.children[i];\n\n        if (child.exists)\n        {\n            tempDistance = Math.abs(Phaser.Point.distance(object, child));\n\n            if (tempDistance > distance && (!callback || callback.call(callbackContext, child, tempDistance)))\n            {\n                distance = tempDistance;\n                result = child;\n            }\n        }\n    }\n\n    return result;\n\n};\n\n/**\n* Get the number of living children in this group.\n*\n* @method Phaser.Group#countLiving\n* @return {integer} The number of children flagged as alive.\n*/\nPhaser.Group.prototype.countLiving = function () {\n\n    return this.iterate('alive', true, Phaser.Group.RETURN_TOTAL);\n\n};\n\n/**\n* Get the number of dead children in this group.\n*\n* @method Phaser.Group#countDead\n* @return {integer} The number of children flagged as dead.\n*/\nPhaser.Group.prototype.countDead = function () {\n\n    return this.iterate('alive', false, Phaser.Group.RETURN_TOTAL);\n\n};\n\n/**\n* Returns a random child from the group.\n*\n* @method Phaser.Group#getRandom\n* @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).\n* @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.\n* @return {any} A random child of this Group.\n*/\nPhaser.Group.prototype.getRandom = function (startIndex, length) {\n\n    if (startIndex === undefined) { startIndex = 0; }\n    if (length === undefined) { length = this.children.length; }\n\n    if (length === 0)\n    {\n        return null;\n    }\n\n    return Phaser.ArrayUtils.getRandomItem(this.children, startIndex, length);\n\n};\n\n/**\n* Returns a random child from the Group that has `exists` set to `true`.\n*\n* Optionally you can specify a start and end index. For example if this Group had 100 children,\n* and you set `startIndex` to 0 and `endIndex` to 50, it would return a random child from only\n* the first 50 children in the Group.\n*\n* @method Phaser.Group#getRandomExists\n* @param {integer} [startIndex=0] - The first child index to start the search from.\n* @param {integer} [endIndex] - The last child index to search up to.\n* @return {any} A random child of this Group that exists.\n*/\nPhaser.Group.prototype.getRandomExists = function (startIndex, endIndex) {\n\n    var list = this.getAll('exists', true, startIndex, endIndex);\n\n    return this.game.rnd.pick(list);\n\n};\n\n/**\n* Returns all children in this Group.\n*\n* You can optionally specify a matching criteria using the `property` and `value` arguments.\n*\n* For example: `getAll('exists', true)` would return only children that have their exists property set.\n*\n* Optionally you can specify a start and end index. For example if this Group had 100 children,\n* and you set `startIndex` to 0 and `endIndex` to 50, it would return a random child from only\n* the first 50 children in the Group.\n*\n* @method Phaser.Group#getAll\n* @param {string} [property] - An optional property to test against the value argument.\n* @param {any} [value] - If property is set then Child.property must strictly equal this value to be included in the results.\n* @param {integer} [startIndex=0] - The first child index to start the search from.\n* @param {integer} [endIndex] - The last child index to search up until.\n* @return {any} A random existing child of this Group.\n*/\nPhaser.Group.prototype.getAll = function (property, value, startIndex, endIndex) {\n\n    if (startIndex === undefined) { startIndex = 0; }\n    if (endIndex === undefined) { endIndex = this.children.length; }\n\n    var output = [];\n\n    for (var i = startIndex; i < endIndex; i++)\n    {\n        var child = this.children[i];\n\n        if (property && child[property] === value)\n        {\n            output.push(child);\n        }\n    }\n\n    return output;\n\n};\n\n/**\n* Removes the given child from this group.\n*\n* This will dispatch an `onRemovedFromGroup` event from the child (if it has one), and optionally destroy the child.\n*\n* If the group cursor was referring to the removed child it is updated to refer to the next child.\n*\n* @method Phaser.Group#remove\n* @param {any} child - The child to remove.\n* @param {boolean} [destroy=false] - If true `destroy` will be invoked on the removed child.\n* @param {boolean} [silent=false] - If true the the child will not dispatch the `onRemovedFromGroup` event.\n* @return {boolean} true if the child was removed from this group, otherwise false.\n*/\nPhaser.Group.prototype.remove = function (child, destroy, silent) {\n\n    if (destroy === undefined) { destroy = false; }\n    if (silent === undefined) { silent = false; }\n\n    if (this.children.length === 0 || this.children.indexOf(child) === -1)\n    {\n        return false;\n    }\n\n    if (!silent && child.events && !child.destroyPhase)\n    {\n        child.events.onRemovedFromGroup$dispatch(child, this);\n    }\n\n    var removed = this.removeChild(child);\n\n    this.removeFromHash(child);\n\n    this.updateZ();\n\n    if (this.cursor === child)\n    {\n        this.next();\n    }\n\n    if (destroy && removed)\n    {\n        removed.destroy(true);\n    }\n\n    return true;\n\n};\n\n/**\n* Moves all children from this Group to the Group given.\n*\n* @method Phaser.Group#moveAll\n* @param {Phaser.Group} group - The new Group to which the children will be moved to.\n* @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event for the new Group.\n* @return {Phaser.Group} The Group to which all the children were moved.\n*/\nPhaser.Group.prototype.moveAll = function (group, silent) {\n\n    if (silent === undefined) { silent = false; }\n\n    if (this.children.length > 0 && group instanceof Phaser.Group)\n    {\n        do\n        {\n            group.add(this.children[0], silent);\n        }\n        while (this.children.length > 0);\n\n        this.hash = [];\n\n        this.cursor = null;\n    }\n\n    return group;\n\n};\n\n/**\n* Removes all children from this Group, but does not remove the group from its parent.\n*\n* The children can be optionally destroyed as they are removed.\n* \n* You can also optionally also destroy the BaseTexture the Child is using. Be careful if you've\n* more than one Game Object sharing the same BaseTexture.\n*\n* @method Phaser.Group#removeAll\n* @param {boolean} [destroy=false] - If true `destroy` will be invoked on each removed child.\n* @param {boolean} [silent=false] - If true the children will not dispatch their `onRemovedFromGroup` events.\n* @param {boolean} [destroyTexture=false] - If true, and if the `destroy` argument is also true, the BaseTexture belonging to the Child is also destroyed. Note that if another Game Object is sharing the same BaseTexture it will invalidate it.\n*/\nPhaser.Group.prototype.removeAll = function (destroy, silent, destroyTexture) {\n\n    if (destroy === undefined) { destroy = false; }\n    if (silent === undefined) { silent = false; }\n    if (destroyTexture === undefined) { destroyTexture = false; }\n\n    if (this.children.length === 0)\n    {\n        return;\n    }\n\n    do\n    {\n        if (!silent && this.children[0].events)\n        {\n            this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);\n        }\n\n        var removed = this.removeChild(this.children[0]);\n\n        this.removeFromHash(removed);\n\n        if (destroy && removed)\n        {\n            removed.destroy(true, destroyTexture);\n        }\n    }\n    while (this.children.length > 0);\n\n    this.hash = [];\n\n    this.cursor = null;\n\n};\n\n/**\n* Removes all children from this group whose index falls beteen the given startIndex and endIndex values.\n*\n* @method Phaser.Group#removeBetween\n* @param {integer} startIndex - The index to start removing children from.\n* @param {integer} [endIndex] - The index to stop removing children at. Must be higher than startIndex. If undefined this method will remove all children between startIndex and the end of the group.\n* @param {boolean} [destroy=false] - If true `destroy` will be invoked on each removed child.\n* @param {boolean} [silent=false] - If true the children will not dispatch their `onRemovedFromGroup` events.\n*/\nPhaser.Group.prototype.removeBetween = function (startIndex, endIndex, destroy, silent) {\n\n    if (endIndex === undefined) { endIndex = this.children.length - 1; }\n    if (destroy === undefined) { destroy = false; }\n    if (silent === undefined) { silent = false; }\n\n    if (this.children.length === 0)\n    {\n        return;\n    }\n\n    if (startIndex > endIndex || startIndex < 0 || endIndex > this.children.length)\n    {\n        return false;\n    }\n\n    var i = endIndex;\n\n    while (i >= startIndex)\n    {\n        if (!silent && this.children[i].events)\n        {\n            this.children[i].events.onRemovedFromGroup$dispatch(this.children[i], this);\n        }\n\n        var removed = this.removeChild(this.children[i]);\n\n        this.removeFromHash(removed);\n\n        if (destroy && removed)\n        {\n            removed.destroy(true);\n        }\n\n        if (this.cursor === this.children[i])\n        {\n            this.cursor = null;\n        }\n\n        i--;\n    }\n\n    this.updateZ();\n\n};\n\n/**\n* Destroys this group.\n*\n* Removes all children, then removes this group from its parent and nulls references.\n*\n* @method Phaser.Group#destroy\n* @param {boolean} [destroyChildren=true] - If true `destroy` will be invoked on each removed child.\n* @param {boolean} [soft=false] - A 'soft destroy' (set to true) doesn't remove this group from its parent or null the game reference. Set to false and it does.\n*/\nPhaser.Group.prototype.destroy = function (destroyChildren, soft) {\n\n    if (this.game === null || this.ignoreDestroy) { return; }\n\n    if (destroyChildren === undefined) { destroyChildren = true; }\n    if (soft === undefined) { soft = false; }\n\n    this.onDestroy.dispatch(this, destroyChildren, soft);\n\n    this.removeAll(destroyChildren);\n\n    this.cursor = null;\n    this.filters = null;\n    this.pendingDestroy = false;\n\n    if (!soft)\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n\n        this.game = null;\n        this.exists = false;\n    }\n\n};\n\n/**\n* Total number of existing children in the group.\n*\n* @name Phaser.Group#total\n* @property {integer} total\n* @readonly\n*/\nObject.defineProperty(Phaser.Group.prototype, \"total\", {\n\n    get: function () {\n\n        return this.iterate('exists', true, Phaser.Group.RETURN_TOTAL);\n\n    }\n\n});\n\n/**\n* Total number of children in this group, regardless of exists/alive status.\n*\n* @name Phaser.Group#length\n* @property {integer} length \n* @readonly\n*/\nObject.defineProperty(Phaser.Group.prototype, \"length\", {\n\n    get: function () {\n\n        return this.children.length;\n\n    }\n\n});\n\n/**\n* The angle of rotation of the group container, in degrees.\n*\n* This adjusts the group itself by modifying its local rotation transform.\n*\n* This has no impact on the rotation/angle properties of the children, but it will update their worldTransform\n* and on-screen orientation and position.\n*\n* @name Phaser.Group#angle\n* @property {number} angle\n*/\nObject.defineProperty(Phaser.Group.prototype, \"angle\", {\n\n    get: function() {\n        return Phaser.Math.radToDeg(this.rotation);\n    },\n\n    set: function(value) {\n        this.rotation = Phaser.Math.degToRad(value);\n    }\n\n});\n\n/**\n* The center x coordinate of this Group.\n*\n* It is derived by calling `getBounds`, calculating the Groups dimensions based on its\n* visible children.\n* \n* @name Phaser.Group#centerX\n* @property {number} centerX\n*/\nObject.defineProperty(Phaser.Group.prototype, \"centerX\", {\n\n    get: function () {\n\n        return this.getBounds(this.parent).centerX;\n\n    },\n\n    set: function (value) {\n\n        var r = this.getBounds(this.parent);\n        var offset = this.x - r.x;\n\n        this.x = (value + offset) - r.halfWidth;\n\n    }\n\n});\n\n/**\n* The center y coordinate of this Group.\n*\n* It is derived by calling `getBounds`, calculating the Groups dimensions based on its\n* visible children.\n* \n* @name Phaser.Group#centerY\n* @property {number} centerY\n*/\nObject.defineProperty(Phaser.Group.prototype, \"centerY\", {\n\n    get: function () {\n\n        return this.getBounds(this.parent).centerY;\n\n    },\n\n    set: function (value) {\n\n        var r = this.getBounds(this.parent);\n        var offset = this.y - r.y;\n\n        this.y = (value + offset) - r.halfHeight;\n\n    }\n\n});\n\n/**\n* The left coordinate of this Group.\n*\n* It is derived by calling `getBounds`, calculating the Groups dimensions based on its\n* visible children.\n* \n* @name Phaser.Group#left\n* @property {number} left\n*/\nObject.defineProperty(Phaser.Group.prototype, \"left\", {\n\n    get: function () {\n\n        return this.getBounds(this.parent).left;\n\n    },\n\n    set: function (value) {\n\n        var r = this.getBounds(this.parent);\n        var offset = this.x - r.x;\n\n        this.x = value + offset;\n\n    }\n\n});\n\n/**\n* The right coordinate of this Group.\n*\n* It is derived by calling `getBounds`, calculating the Groups dimensions based on its\n* visible children.\n*\n* @name Phaser.Group#right\n* @property {number} right\n*/\nObject.defineProperty(Phaser.Group.prototype, \"right\", {\n\n    get: function () {\n\n        return this.getBounds(this.parent).right;\n\n    },\n\n    set: function (value) {\n\n        var r = this.getBounds(this.parent);\n        var offset = this.x - r.x;\n\n        this.x = (value + offset) - r.width;\n\n    }\n\n});\n\n/**\n* The top coordinate of this Group.\n*\n* It is derived by calling `getBounds`, calculating the Groups dimensions based on its\n* visible children.\n*\n* @name Phaser.Group#top\n* @property {number} top\n*/\nObject.defineProperty(Phaser.Group.prototype, \"top\", {\n\n    get: function () {\n\n        return this.getBounds(this.parent).top;\n\n    },\n\n    set: function (value) {\n\n        var r = this.getBounds(this.parent);\n        var offset = this.y - r.y;\n\n        this.y = (value + offset);\n\n    }\n\n});\n\n/**\n* The bottom coordinate of this Group.\n*\n* It is derived by calling `getBounds`, calculating the Groups dimensions based on its\n* visible children.\n* \n* @name Phaser.Group#bottom\n* @property {number} bottom\n*/\nObject.defineProperty(Phaser.Group.prototype, \"bottom\", {\n\n    get: function () {\n\n        return this.getBounds(this.parent).bottom;\n\n    },\n\n    set: function (value) {\n\n        var r = this.getBounds(this.parent);\n        var offset = this.y - r.y;\n\n        this.y = (value + offset) - r.height;\n\n    }\n\n});\n\n/**\n* Aligns this Group within another Game Object, or Rectangle, known as the\n* 'container', to one of 9 possible positions.\n*\n* The container must be a Game Object, or Phaser.Rectangle object. This can include properties\n* such as `World.bounds` or `Camera.view`, for aligning Groups within the world \n* and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,\n* TileSprites or Buttons.\n*\n* Please note that aligning a Group to another Game Object does **not** make it a child of\n* the container. It simply modifies its position coordinates so it aligns with it.\n* \n* The position constants you can use are:\n* \n* `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, \n* `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`, \n* `Phaser.BOTTOM_CENTER` and `Phaser.BOTTOM_RIGHT`.\n*\n* Groups are placed in such a way that their _bounds_ align with the\n* container, taking into consideration rotation and scale of its children.\n* This allows you to neatly align Groups, irrespective of their position value.\n*\n* The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final\n* aligned position of the Group. For example:\n*\n* `group.alignIn(background, Phaser.BOTTOM_RIGHT, -20, -20)`\n*\n* Would align the `group` to the bottom-right, but moved 20 pixels in from the corner.\n* Think of the offsets as applying an adjustment to the containers bounds before the alignment takes place.\n* So providing a negative offset will 'shrink' the container bounds by that amount, and providing a positive\n* one expands it.\n*\n* @method Phaser.Group#alignIn\n* @param {Phaser.Rectangle|Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText|Phaser.Button|Phaser.Graphics|Phaser.TileSprite} container - The Game Object or Rectangle with which to align this Group to. Can also include properties such as `World.bounds` or `Camera.view`.\n* @param {integer} [position] - The position constant. One of `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.\n* @param {integer} [offsetX=0] - A horizontal adjustment of the Containers bounds, applied to the aligned position of the Game Object. Use a negative value to shrink the bounds, positive to increase it.\n* @param {integer} [offsetY=0] - A vertical adjustment of the Containers bounds, applied to the aligned position of the Game Object. Use a negative value to shrink the bounds, positive to increase it.\n* @return {Phaser.Group} This Group.\n*/\n\n//  This function is set at the bottom of src/gameobjects/components/Bounds.js\n\n/**\n* Aligns this Group to the side of another Game Object, or Rectangle, known as the\n* 'parent', in one of 11 possible positions.\n*\n* The parent must be a Game Object, or Phaser.Rectangle object. This can include properties\n* such as `World.bounds` or `Camera.view`, for aligning Groups within the world \n* and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,\n* TileSprites or Buttons.\n*\n* Please note that aligning a Group to another Game Object does **not** make it a child of\n* the parent. It simply modifies its position coordinates so it aligns with it.\n* \n* The position constants you can use are:\n* \n* `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`, \n* `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`, \n* `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` \n* and `Phaser.BOTTOM_RIGHT`.\n*\n* Groups are placed in such a way that their _bounds_ align with the\n* parent, taking into consideration rotation and scale of the children.\n* This allows you to neatly align Groups, irrespective of their position value.\n*\n* The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final\n* aligned position of the Group. For example:\n*\n* `group.alignTo(background, Phaser.BOTTOM_RIGHT, -20, -20)`\n*\n* Would align the `group` to the bottom-right, but moved 20 pixels in from the corner.\n* Think of the offsets as applying an adjustment to the parents bounds before the alignment takes place.\n* So providing a negative offset will 'shrink' the parent bounds by that amount, and providing a positive\n* one expands it.\n*\n* @method Phaser.Group#alignTo\n* @param {Phaser.Rectangle|Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText|Phaser.Button|Phaser.Graphics|Phaser.TileSprite} parent - The Game Object or Rectangle with which to align this Group to. Can also include properties such as `World.bounds` or `Camera.view`.\n* @param {integer} [position] - The position constant. One of `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`, `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`, `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.\n* @param {integer} [offsetX=0] - A horizontal adjustment of the Containers bounds, applied to the aligned position of the Game Object. Use a negative value to shrink the bounds, positive to increase it.\n* @param {integer} [offsetY=0] - A vertical adjustment of the Containers bounds, applied to the aligned position of the Game Object. Use a negative value to shrink the bounds, positive to increase it.\n* @return {Phaser.Group} This Group.\n*/\n\n//  This function is set at the bottom of src/gameobjects/components/Bounds.js\n\n/**\n* A display object is any object that can be rendered in the Phaser/pixi.js scene graph.\n*\n* This includes {@link Phaser.Group} (groups are display objects!),\n* {@link Phaser.Sprite}, {@link Phaser.Button}, {@link Phaser.Text}\n* as well as {@link PIXI.DisplayObject} and all derived types.\n*\n* @typedef {object} DisplayObject\n*/\n// Documentation stub for linking.\n\n/**\n* The x coordinate of the group container.\n*\n* You can adjust the group container itself by modifying its coordinates.\n* This will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.\n* @name Phaser.Group#x\n* @property {number} x\n*/\n\n/**\n* The y coordinate of the group container.\n*\n* You can adjust the group container itself by modifying its coordinates.\n* This will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.\n* @name Phaser.Group#y\n* @property {number} y\n*/\n\n/**\n* The angle of rotation of the group container, in radians.\n*\n* This will adjust the group container itself by modifying its rotation.\n* This will have no impact on the rotation value of its children, but it will update their worldTransform and on-screen position.\n* @name Phaser.Group#rotation\n* @property {number} rotation\n*/\n\n/**\n* The visible state of the group. Non-visible Groups and all of their children are not rendered.\n*\n* @name Phaser.Group#visible\n* @property {boolean} visible\n*/\n\n/**\n* The alpha value of the group container.\n*\n* @name Phaser.Group#alpha\n* @property {number} alpha\n*/\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* \"This world is but a canvas to our imagination.\" - Henry David Thoreau\n*\n* A game has only one world. The world is an abstract place in which all game objects live. It is not bound\n* by stage limits and can be any size. You look into the world via cameras. All game objects live within\n* the world at world-based coordinates. By default a world is created the same size as your Stage.\n*\n* @class Phaser.World\n* @extends Phaser.Group\n* @constructor\n* @param {Phaser.Game} game - Reference to the current game instance.\n*/\nPhaser.World = function (game) {\n\n    Phaser.Group.call(this, game, null, '__world', false);\n\n    /**\n    * The World has no fixed size, but it does have a bounds outside of which objects are no longer considered as being \"in world\" and you should use this to clean-up the display list and purge dead objects.\n    * By default we set the Bounds to be from 0,0 to Game.width,Game.height. I.e. it will match the size given to the game constructor with 0,0 representing the top-left of the display.\n    * However 0,0 is actually the center of the world, and if you rotate or scale the world all of that will happen from 0,0.\n    * So if you want to make a game in which the world itself will rotate you should adjust the bounds so that 0,0 is the center point, i.e. set them to -1000,-1000,2000,2000 for a 2000x2000 sized world centered around 0,0.\n    * @property {Phaser.Rectangle} bounds - Bound of this world that objects can not escape from.\n    */\n    this.bounds = new Phaser.Rectangle(0, 0, game.width, game.height);\n\n    /**\n    * @property {Phaser.Camera} camera - Camera instance.\n    */\n    this.camera = null;\n\n    /**\n    * @property {boolean} _definedSize - True if the World has been given a specifically defined size (i.e. from a Tilemap or direct in code) or false if it's just matched to the Game dimensions.\n    * @readonly\n    */\n    this._definedSize = false;\n\n    /**\n    * @property {number} width - The defined width of the World. Sometimes the bounds needs to grow larger than this (if you resize the game) but this retains the original requested dimension.\n    */\n    this._width = game.width;\n\n    /**\n    * @property {number} height - The defined height of the World. Sometimes the bounds needs to grow larger than this (if you resize the game) but this retains the original requested dimension.\n    */\n    this._height = game.height;\n\n    this.game.state.onStateChange.add(this.stateChange, this);\n\n};\n\nPhaser.World.prototype = Object.create(Phaser.Group.prototype);\nPhaser.World.prototype.constructor = Phaser.World;\n\n/**\n* Initialises the game world.\n*\n* @method Phaser.World#boot\n* @protected\n*/\nPhaser.World.prototype.boot = function () {\n\n    this.camera = new Phaser.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);\n\n    this.game.stage.addChild(this);\n\n    this.camera.boot();\n\n};\n\n/**\n* Called whenever the State changes or resets.\n* \n* It resets the world.x and world.y coordinates back to zero,\n* then resets the Camera.\n*\n* @method Phaser.World#stateChange\n* @protected\n*/\nPhaser.World.prototype.stateChange = function () {\n\n    this.x = 0;\n    this.y = 0;\n\n    this.camera.reset();\n\n};\n\n/**\n* Updates the size of this world and sets World.x/y to the given values\n* The Camera bounds and Physics bounds (if set) are also updated to match the new World bounds.\n*\n* @method Phaser.World#setBounds\n* @param {number} x - Top left most corner of the world.\n* @param {number} y - Top left most corner of the world.\n* @param {number} width - New width of the game world in pixels.\n* @param {number} height - New height of the game world in pixels.\n*/\nPhaser.World.prototype.setBounds = function (x, y, width, height) {\n\n    this._definedSize = true;\n    this._width = width;\n    this._height = height;\n\n    this.bounds.setTo(x, y, width, height);\n\n    this.x = x;\n    this.y = y;\n\n    if (this.camera.bounds)\n    {\n        //  The Camera can never be smaller than the game size\n        this.camera.bounds.setTo(x, y, Math.max(width, this.game.width), Math.max(height, this.game.height));\n    }\n\n    this.game.physics.setBoundsToWorld();\n\n};\n\n/**\n* Updates the size of this world. Note that this doesn't modify the world x/y coordinates, just the width and height.\n*\n* @method Phaser.World#resize\n* @param {number} width - New width of the game world in pixels.\n* @param {number} height - New height of the game world in pixels.\n*/\nPhaser.World.prototype.resize = function (width, height) {\n\n    //  Don't ever scale the World bounds lower than the original requested dimensions if it's a defined world size\n\n    if (this._definedSize)\n    {\n        if (width < this._width)\n        {\n            width = this._width;\n        }\n\n        if (height < this._height)\n        {\n            height = this._height;\n        }\n    }\n\n    this.bounds.width = width;\n    this.bounds.height = height;\n\n    this.game.camera.setBoundsToWorld();\n\n    this.game.physics.setBoundsToWorld();\n\n};\n\n/**\n* Destroyer of worlds.\n*\n* @method Phaser.World#shutdown\n*/\nPhaser.World.prototype.shutdown = function () {\n\n    //  World is a Group, so run a soft destruction on this and all children.\n    this.destroy(true, true);\n\n};\n\n/**\n* This will take the given game object and check if its x/y coordinates fall outside of the world bounds.\n* If they do it will reposition the object to the opposite side of the world, creating a wrap-around effect.\n* If sprite has a P2 body then the body (sprite.body) should be passed as first parameter to the function.\n*\n* Please understand there are limitations to this method. For example if you have scaled the World\n* then objects won't always be re-positioned correctly, and you'll need to employ your own wrapping function.\n*\n* @method Phaser.World#wrap\n* @param {Phaser.Sprite|Phaser.Image|Phaser.TileSprite|Phaser.Text} sprite - The object you wish to wrap around the world bounds.\n* @param {number} [padding=0] - Extra padding added equally to the sprite.x and y coordinates before checking if within the world bounds. Ignored if useBounds is true.\n* @param {boolean} [useBounds=false] - If useBounds is false wrap checks the object.x/y coordinates. If true it does a more accurate bounds check, which is more expensive.\n* @param {boolean} [horizontal=true] - If horizontal is false, wrap will not wrap the object.x coordinates horizontally.\n* @param {boolean} [vertical=true] - If vertical is false, wrap will not wrap the object.y coordinates vertically.\n*/\nPhaser.World.prototype.wrap = function (sprite, padding, useBounds, horizontal, vertical) {\n\n    if (padding === undefined) { padding = 0; }\n    if (useBounds === undefined) { useBounds = false; }\n    if (horizontal === undefined) { horizontal = true; }\n    if (vertical === undefined) { vertical = true; }\n\n    if (!useBounds)\n    {\n        if (horizontal && sprite.x + padding < this.bounds.x)\n        {\n            sprite.x = this.bounds.right + padding;\n        }\n        else if (horizontal && sprite.x - padding > this.bounds.right)\n        {\n            sprite.x = this.bounds.left - padding;\n        }\n\n        if (vertical && sprite.y + padding < this.bounds.top)\n        {\n            sprite.y = this.bounds.bottom + padding;\n        }\n        else if (vertical && sprite.y - padding > this.bounds.bottom)\n        {\n            sprite.y = this.bounds.top - padding;\n        }\n    }\n    else\n    {\n        sprite.getBounds();\n\n        if (horizontal)\n        {\n            if ((sprite.x + sprite._currentBounds.width) < this.bounds.x)\n            {\n                sprite.x = this.bounds.right;\n            }\n            else if (sprite.x > this.bounds.right)\n            {\n                sprite.x = this.bounds.left;\n            }\n        }\n\n        if (vertical)\n        {\n            if ((sprite.y + sprite._currentBounds.height) < this.bounds.top)\n            {\n                sprite.y = this.bounds.bottom;\n            }\n            else if (sprite.y > this.bounds.bottom)\n            {\n                sprite.y = this.bounds.top;\n            }\n        }\n    }\n\n};\n\n/**\n* @name Phaser.World#width\n* @property {number} width - Gets or sets the current width of the game world. The world can never be smaller than the game (canvas) dimensions.\n*/\nObject.defineProperty(Phaser.World.prototype, \"width\", {\n\n    get: function () {\n        return this.bounds.width;\n    },\n\n    set: function (value) {\n\n        if (value < this.game.width)\n        {\n            value = this.game.width;\n        }\n\n        this.bounds.width = value;\n        this._width = value;\n        this._definedSize = true;\n\n    }\n\n});\n\n/**\n* @name Phaser.World#height\n* @property {number} height - Gets or sets the current height of the game world. The world can never be smaller than the game (canvas) dimensions.\n*/\nObject.defineProperty(Phaser.World.prototype, \"height\", {\n\n    get: function () {\n        return this.bounds.height;\n    },\n\n    set: function (value) {\n\n        if (value < this.game.height)\n        {\n            value = this.game.height;\n        }\n\n        this.bounds.height = value;\n        this._height = value;\n        this._definedSize = true;\n\n    }\n\n});\n\n/**\n* @name Phaser.World#centerX\n* @property {number} centerX - Gets the X position corresponding to the center point of the world.\n* @readonly\n*/\nObject.defineProperty(Phaser.World.prototype, \"centerX\", {\n\n    get: function () {\n        return this.bounds.halfWidth + this.bounds.x;\n    }\n\n});\n\n/**\n* @name Phaser.World#centerY\n* @property {number} centerY - Gets the Y position corresponding to the center point of the world.\n* @readonly\n*/\nObject.defineProperty(Phaser.World.prototype, \"centerY\", {\n\n    get: function () {\n        return this.bounds.halfHeight + this.bounds.y;\n    }\n\n});\n\n/**\n* @name Phaser.World#randomX\n* @property {number} randomX - Gets a random integer which is lesser than or equal to the current width of the game world.\n* @readonly\n*/\nObject.defineProperty(Phaser.World.prototype, \"randomX\", {\n\n    get: function () {\n\n        if (this.bounds.x < 0)\n        {\n            return this.game.rnd.between(this.bounds.x, (this.bounds.width - Math.abs(this.bounds.x)));\n        }\n        else\n        {\n            return this.game.rnd.between(this.bounds.x, this.bounds.width);\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.World#randomY\n* @property {number} randomY - Gets a random integer which is lesser than or equal to the current height of the game world.\n* @readonly\n*/\nObject.defineProperty(Phaser.World.prototype, \"randomY\", {\n\n    get: function () {\n\n        if (this.bounds.y < 0)\n        {\n            return this.game.rnd.between(this.bounds.y, (this.bounds.height - Math.abs(this.bounds.y)));\n        }\n        else\n        {\n            return this.game.rnd.between(this.bounds.y, this.bounds.height);\n        }\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* This is where the magic happens. The Game object is the heart of your game,\n* providing quick access to common functions and handling the boot process.\n* \n* \"Hell, there are no rules here - we're trying to accomplish something.\"\n*                                                       Thomas A. Edison\n*\n* @class Phaser.Game\n* @constructor\n* @param {number|string} [width=800] - The width of your game in game pixels. If given as a string the value must be between 0 and 100 and will be used as the percentage width of the parent container, or the browser window if no parent is given.\n* @param {number|string} [height=600] - The height of your game in game pixels. If given as a string the value must be between 0 and 100 and will be used as the percentage height of the parent container, or the browser window if no parent is given.\n* @param {number} [renderer=Phaser.AUTO] - Which renderer to use: Phaser.AUTO will auto-detect, Phaser.WEBGL, Phaser.CANVAS or Phaser.HEADLESS (no rendering at all).\n* @param {string|HTMLElement} [parent=''] - The DOM element into which this games canvas will be injected. Either a DOM ID (string) or the element itself.\n* @param {object} [state=null] - The default state object. A object consisting of Phaser.State functions (preload, create, update, render) or null.\n* @param {boolean} [transparent=false] - Use a transparent canvas background or not.\n* @param {boolean} [antialias=true] - Draw all image textures anti-aliased or not. The default is for smooth textures, but disable if your game features pixel art.\n* @param {object} [physicsConfig=null] - A physics configuration object to pass to the Physics world on creation.\n*/\nPhaser.Game = function (width, height, renderer, parent, state, transparent, antialias, physicsConfig) {\n\n    /**\n    * @property {number} id - Phaser Game ID (for when Pixi supports multiple instances).\n    * @readonly\n    */\n    this.id = Phaser.GAMES.push(this) - 1;\n\n    /**\n    * @property {object} config - The Phaser.Game configuration object.\n    */\n    this.config = null;\n\n    /**\n    * @property {object} physicsConfig - The Phaser.Physics.World configuration object.\n    */\n    this.physicsConfig = physicsConfig;\n\n    /**\n    * @property {string|HTMLElement} parent - The Games DOM parent.\n    * @default\n    */\n    this.parent = '';\n\n    /**\n    * The current Game Width in pixels.\n    *\n    * _Do not modify this property directly:_ use {@link Phaser.ScaleManager#setGameSize} - eg. `game.scale.setGameSize(width, height)` - instead.\n    *\n    * @property {integer} width\n    * @readonly\n    * @default\n    */\n    this.width = 800;\n\n    /**\n    * The current Game Height in pixels.\n    *\n    * _Do not modify this property directly:_ use {@link Phaser.ScaleManager#setGameSize} - eg. `game.scale.setGameSize(width, height)` - instead.\n    *\n    * @property {integer} height\n    * @readonly\n    * @default\n    */\n    this.height = 600;\n\n    /**\n    * The resolution of your game. This value is read only, but can be changed at start time it via a game configuration object.\n    *\n    * @property {integer} resolution\n    * @readonly\n    * @default\n    */\n    this.resolution = 1;\n\n    /**\n    * @property {integer} _width - Private internal var.\n    * @private\n    */\n    this._width = 800;\n\n    /**\n    * @property {integer} _height - Private internal var.\n    * @private\n    */\n    this._height = 600;\n\n    /**\n    * @property {boolean} transparent - Use a transparent canvas background or not.\n    * @default\n    */\n    this.transparent = false;\n\n    /**\n    * @property {boolean} antialias - Anti-alias graphics. By default scaled images are smoothed in Canvas and WebGL, set anti-alias to false to disable this globally.\n    * @default\n    */\n    this.antialias = true;\n\n    /**\n    * @property {boolean} preserveDrawingBuffer - The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.\n    * @default\n    */\n    this.preserveDrawingBuffer = false;\n\n    /**\n    * Clear the Canvas each frame before rendering the display list.\n    * You can set this to `false` to gain some performance if your game always contains a background that completely fills the display.\n    * @property {boolean} clearBeforeRender\n    * @default\n    */\n    this.clearBeforeRender = true;\n\n    /**\n    * @property {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - The Pixi Renderer.\n    * @protected\n    */\n    this.renderer = null;\n\n    /**\n    * @property {number} renderType - The Renderer this game will use. Either Phaser.AUTO, Phaser.CANVAS, Phaser.WEBGL, or Phaser.HEADLESS.\n    * @readonly\n    */\n    this.renderType = Phaser.AUTO;\n\n    /**\n    * @property {Phaser.StateManager} state - The StateManager.\n    */\n    this.state = null;\n\n    /**\n    * @property {boolean} isBooted - Whether the game engine is booted, aka available.\n    * @readonly\n    */\n    this.isBooted = false;\n\n    /**\n    * @property {boolean} isRunning - Is game running or paused?\n    * @readonly\n    */\n    this.isRunning = false;\n\n    /**\n    * @property {Phaser.RequestAnimationFrame} raf - Automatically handles the core game loop via requestAnimationFrame or setTimeout\n    * @protected\n    */\n    this.raf = null;\n\n    /**\n    * @property {Phaser.GameObjectFactory} add - Reference to the Phaser.GameObjectFactory.\n    */\n    this.add = null;\n\n    /**\n    * @property {Phaser.GameObjectCreator} make - Reference to the GameObject Creator.\n    */\n    this.make = null;\n\n    /**\n    * @property {Phaser.Cache} cache - Reference to the assets cache.\n    */\n    this.cache = null;\n\n    /**\n    * @property {Phaser.Input} input - Reference to the input manager\n    */\n    this.input = null;\n\n    /**\n    * @property {Phaser.Loader} load - Reference to the assets loader.\n    */\n    this.load = null;\n\n    /**\n    * @property {Phaser.Math} math - Reference to the math helper.\n    */\n    this.math = null;\n\n    /**\n    * @property {Phaser.Net} net - Reference to the network class.\n    */\n    this.net = null;\n\n    /**\n    * @property {Phaser.ScaleManager} scale - The game scale manager.\n    */\n    this.scale = null;\n\n    /**\n    * @property {Phaser.SoundManager} sound - Reference to the sound manager.\n    */\n    this.sound = null;\n\n    /**\n    * @property {Phaser.Stage} stage - Reference to the stage.\n    */\n    this.stage = null;\n\n    /**\n    * @property {Phaser.Time} time - Reference to the core game clock.\n    */\n    this.time = null;\n\n    /**\n    * @property {Phaser.TweenManager} tweens - Reference to the tween manager.\n    */\n    this.tweens = null;\n\n    /**\n    * @property {Phaser.World} world - Reference to the world.\n    */\n    this.world = null;\n\n    /**\n    * @property {Phaser.Physics} physics - Reference to the physics manager.\n    */\n    this.physics = null;\n    \n    /**\n    * @property {Phaser.PluginManager} plugins - Reference to the plugin manager.\n    */\n    this.plugins = null;\n\n    /**\n    * @property {Phaser.RandomDataGenerator} rnd - Instance of repeatable random data generator helper.\n    */\n    this.rnd = null;\n\n    /**\n    * @property {Phaser.Device} device - Contains device information and capabilities.\n    */\n    this.device = Phaser.Device;\n\n    /**\n    * @property {Phaser.Camera} camera - A handy reference to world.camera.\n    */\n    this.camera = null;\n\n    /**\n    * @property {HTMLCanvasElement} canvas - A handy reference to renderer.view, the canvas that the game is being rendered in to.\n    */\n    this.canvas = null;\n\n    /**\n    * @property {CanvasRenderingContext2D} context - A handy reference to renderer.context (only set for CANVAS games, not WebGL)\n    */\n    this.context = null;\n\n    /**\n    * @property {Phaser.Utils.Debug} debug - A set of useful debug utilities.\n    */\n    this.debug = null;\n\n    /**\n    * @property {Phaser.Particles} particles - The Particle Manager.\n    */\n    this.particles = null;\n\n    /**\n    * @property {Phaser.Create} create - The Asset Generator.\n    */\n    this.create = null;\n\n    /**\n    * If `false` Phaser will automatically render the display list every update. If `true` the render loop will be skipped.\n    * You can toggle this value at run-time to gain exact control over when Phaser renders. This can be useful in certain types of game or application.\n    * Please note that if you don't render the display list then none of the game object transforms will be updated, so use this value carefully.\n    * @property {boolean} lockRender\n    * @default\n    */\n    this.lockRender = false;\n\n    /**\n    * @property {boolean} stepping - Enable core loop stepping with Game.enableStep().\n    * @default\n    * @readonly\n    */\n    this.stepping = false;\n\n    /**\n    * @property {boolean} pendingStep - An internal property used by enableStep, but also useful to query from your own game objects.\n    * @default\n    * @readonly\n    */\n    this.pendingStep = false;\n\n    /**\n    * @property {number} stepCount - When stepping is enabled this contains the current step cycle.\n    * @default\n    * @readonly\n    */\n    this.stepCount = 0;\n\n    /**\n    * @property {Phaser.Signal} onPause - This event is fired when the game pauses.\n    */\n    this.onPause = null;\n\n    /**\n    * @property {Phaser.Signal} onResume - This event is fired when the game resumes from a paused state.\n    */\n    this.onResume = null;\n\n    /**\n    * @property {Phaser.Signal} onBlur - This event is fired when the game no longer has focus (typically on page hide).\n    */\n    this.onBlur = null;\n\n    /**\n    * @property {Phaser.Signal} onFocus - This event is fired when the game has focus (typically on page show).\n    */\n    this.onFocus = null;\n\n    /**\n    * @property {boolean} _paused - Is game paused?\n    * @private\n    */\n    this._paused = false;\n\n    /**\n    * @property {boolean} _codePaused - Was the game paused via code or a visibility change?\n    * @private\n    */\n    this._codePaused = false;\n\n    /**\n    * The ID of the current/last logic update applied this render frame, starting from 0.\n    * The first update is `currentUpdateID === 0` and the last update is `currentUpdateID === updatesThisFrame.`\n    * @property {integer} currentUpdateID\n    * @protected\n    */\n    this.currentUpdateID = 0;\n\n    /**\n    * Number of logic updates expected to occur this render frame; will be 1 unless there are catch-ups required (and allowed).\n    * @property {integer} updatesThisFrame\n    * @protected\n    */\n    this.updatesThisFrame = 1;\n\n    /**\n    * @property {number} _deltaTime - Accumulate elapsed time until a logic update is due.\n    * @private\n    */\n    this._deltaTime = 0;\n\n    /**\n    * @property {number} _lastCount - Remember how many 'catch-up' iterations were used on the logicUpdate last frame.\n    * @private\n    */\n    this._lastCount = 0;\n\n    /**\n    * @property {number} _spiraling - If the 'catch-up' iterations are spiraling out of control, this counter is incremented.\n    * @private\n    */\n    this._spiraling = 0;\n\n    /**\n    * @property {boolean} _kickstart - Force a logic update + render by default (always set on Boot and State swap)\n    * @private\n    */\n    this._kickstart = true;\n\n    /**\n    * If the game is struggling to maintain the desired FPS, this signal will be dispatched.\n    * The desired/chosen FPS should probably be closer to the {@link Phaser.Time#suggestedFps} value.\n    * @property {Phaser.Signal} fpsProblemNotifier\n    * @public\n    */\n    this.fpsProblemNotifier = new Phaser.Signal();\n\n    /**\n    * @property {boolean} forceSingleUpdate - Should the game loop force a logic update, regardless of the delta timer? Set to true if you know you need this. You can toggle it on the fly.\n    */\n    this.forceSingleUpdate = true;\n\n    /**\n    * @property {number} _nextNotification - The soonest game.time.time value that the next fpsProblemNotifier can be dispatched.\n    * @private\n    */\n    this._nextFpsNotification = 0;\n\n    //  Parse the configuration object (if any)\n    if (arguments.length === 1 && typeof arguments[0] === 'object')\n    {\n        this.parseConfig(arguments[0]);\n    }\n    else\n    {\n        this.config = { enableDebug: true };\n\n        if (typeof width !== 'undefined')\n        {\n            this._width = width;\n        }\n\n        if (typeof height !== 'undefined')\n        {\n            this._height = height;\n        }\n\n        if (typeof renderer !== 'undefined')\n        {\n            this.renderType = renderer;\n        }\n\n        if (typeof parent !== 'undefined')\n        {\n            this.parent = parent;\n        }\n\n        if (typeof transparent !== 'undefined')\n        {\n            this.transparent = transparent;\n        }\n\n        if (typeof antialias !== 'undefined')\n        {\n            this.antialias = antialias;\n        }\n\n        this.rnd = new Phaser.RandomDataGenerator([(Date.now() * Math.random()).toString()]);\n\n        this.state = new Phaser.StateManager(this, state);\n    }\n\n    this.device.whenReady(this.boot, this);\n\n    return this;\n\n};\n\nPhaser.Game.prototype = {\n\n    /**\n    * Parses a Game configuration object.\n    *\n    * @method Phaser.Game#parseConfig\n    * @protected\n    */\n    parseConfig: function (config) {\n\n        this.config = config;\n\n        if (config['enableDebug'] === undefined)\n        {\n            this.config.enableDebug = true;\n        }\n\n        if (config['width'])\n        {\n            this._width = config['width'];\n        }\n\n        if (config['height'])\n        {\n            this._height = config['height'];\n        }\n\n        if (config['renderer'])\n        {\n            this.renderType = config['renderer'];\n        }\n\n        if (config['parent'])\n        {\n            this.parent = config['parent'];\n        }\n\n        if (config['transparent'] !== undefined)\n        {\n            this.transparent = config['transparent'];\n        }\n\n        if (config['antialias'] !== undefined)\n        {\n            this.antialias = config['antialias'];\n        }\n\n        if (config['resolution'])\n        {\n            this.resolution = config['resolution'];\n        }\n\n        if (config['preserveDrawingBuffer'] !== undefined)\n        {\n            this.preserveDrawingBuffer = config['preserveDrawingBuffer'];\n        }\n\n        if (config['physicsConfig'])\n        {\n            this.physicsConfig = config['physicsConfig'];\n        }\n\n        var seed = [(Date.now() * Math.random()).toString()];\n\n        if (config['seed'])\n        {\n            seed = config['seed'];\n        }\n\n        this.rnd = new Phaser.RandomDataGenerator(seed);\n\n        var state = null;\n\n        if (config['state'])\n        {\n            state = config['state'];\n        }\n\n        this.state = new Phaser.StateManager(this, state);\n\n    },\n\n    /**\n    * Initialize engine sub modules and start the game.\n    *\n    * @method Phaser.Game#boot\n    * @protected\n    */\n    boot: function () {\n\n        if (this.isBooted)\n        {\n            return;\n        }\n\n        this.onPause = new Phaser.Signal();\n        this.onResume = new Phaser.Signal();\n        this.onBlur = new Phaser.Signal();\n        this.onFocus = new Phaser.Signal();\n\n        this.isBooted = true;\n\n        PIXI.game = this;\n\n        this.math = Phaser.Math;\n\n        this.scale = new Phaser.ScaleManager(this, this._width, this._height);\n        this.stage = new Phaser.Stage(this);\n\n        this.setUpRenderer();\n\n        this.world = new Phaser.World(this);\n        this.add = new Phaser.GameObjectFactory(this);\n        this.make = new Phaser.GameObjectCreator(this);\n        this.cache = new Phaser.Cache(this);\n        this.load = new Phaser.Loader(this);\n        this.time = new Phaser.Time(this);\n        this.tweens = new Phaser.TweenManager(this);\n        this.input = new Phaser.Input(this);\n        this.sound = new Phaser.SoundManager(this);\n        this.physics = new Phaser.Physics(this, this.physicsConfig);\n        this.particles = new Phaser.Particles(this);\n        this.create = new Phaser.Create(this);\n        this.plugins = new Phaser.PluginManager(this);\n        this.net = new Phaser.Net(this);\n\n        this.time.boot();\n        this.stage.boot();\n        this.world.boot();\n        this.scale.boot();\n        this.input.boot();\n        this.sound.boot();\n        this.state.boot();\n\n        if (this.config['enableDebug'])\n        {\n            this.debug = new Phaser.Utils.Debug(this);\n            this.debug.boot();\n        }\n        else\n        {\n            this.debug = { preUpdate: function () {}, update: function () {}, reset: function () {} };\n        }\n\n        this.showDebugHeader();\n\n        this.isRunning = true;\n\n        if (this.config && this.config['forceSetTimeOut'])\n        {\n            this.raf = new Phaser.RequestAnimationFrame(this, this.config['forceSetTimeOut']);\n        }\n        else\n        {\n            this.raf = new Phaser.RequestAnimationFrame(this, false);\n        }\n\n        this._kickstart = true;\n\n        if (window['focus'])\n        {\n            if (!window['PhaserGlobal'] || (window['PhaserGlobal'] && !window['PhaserGlobal'].stopFocus))\n            {\n                window.focus();\n            }\n        }\n\n        this.raf.start();\n\n    },\n\n    /**\n    * Displays a Phaser version debug header in the console.\n    *\n    * @method Phaser.Game#showDebugHeader\n    * @protected\n    */\n    showDebugHeader: function () {\n\n        if (window['PhaserGlobal'] && window['PhaserGlobal'].hideBanner)\n        {\n            return;\n        }\n\n        var v = Phaser.VERSION;\n        var r = 'Canvas';\n        var a = 'HTML Audio';\n        var c = 1;\n\n        if (this.renderType === Phaser.WEBGL)\n        {\n            r = 'WebGL';\n            c++;\n        }\n        else if (this.renderType === Phaser.HEADLESS)\n        {\n            r = 'Headless';\n        }\n\n        if (this.device.webAudio)\n        {\n            a = 'WebAudio';\n            c++;\n        }\n\n        if (this.device.chrome)\n        {\n            var args = [\n                '%c %c %c Phaser v' + v + ' | Pixi.js | ' + r + ' | ' + a + '  %c %c ' + '%c http://phaser.io %c\\u2665%c\\u2665%c\\u2665',\n                'background: #fb8cb3',\n                'background: #d44a52',\n                'color: #ffffff; background: #871905;',\n                'background: #d44a52',\n                'background: #fb8cb3',\n                'background: #ffffff'\n            ];\n\n            for (var i = 0; i < 3; i++)\n            {\n                if (i < c)\n                {\n                    args.push('color: #ff2424; background: #fff');\n                }\n                else\n                {\n                    args.push('color: #959595; background: #fff');\n                }\n            }\n\n            console.log.apply(console, args);\n        }\n        else if (window['console'])\n        {\n            console.log('Phaser v' + v + ' | Pixi.js ' + PIXI.VERSION + ' | ' + r + ' | ' + a + ' | http://phaser.io');\n        }\n\n    },\n\n    /**\n    * Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.\n    *\n    * @method Phaser.Game#setUpRenderer\n    * @protected\n    */\n    setUpRenderer: function () {\n\n        if (this.config['canvas'])\n        {\n            this.canvas = this.config['canvas'];\n        }\n        else\n        {\n            this.canvas = Phaser.Canvas.create(this, this.width, this.height, this.config['canvasID'], true);\n        }\n\n        if (this.config['canvasStyle'])\n        {\n            this.canvas.style = this.config['canvasStyle'];\n        }\n        else\n        {\n            this.canvas.style['-webkit-full-screen'] = 'width: 100%; height: 100%';\n        }\n\n        if (this.renderType === Phaser.HEADLESS || this.renderType === Phaser.CANVAS || (this.renderType === Phaser.AUTO && !this.device.webGL))\n        {\n            if (this.device.canvas)\n            {\n                //  They requested Canvas and their browser supports it\n                this.renderType = Phaser.CANVAS;\n\n                this.renderer = new PIXI.CanvasRenderer(this);\n\n                this.context = this.renderer.context;\n            }\n            else\n            {\n                throw new Error('Phaser.Game - Cannot create Canvas or WebGL context, aborting.');\n            }\n        }\n        else\n        {\n            //  They requested WebGL and their browser supports it\n            this.renderType = Phaser.WEBGL;\n\n            this.renderer = new PIXI.WebGLRenderer(this);\n\n            this.context = null;\n\n            this.canvas.addEventListener('webglcontextlost', this.contextLost.bind(this), false);\n            this.canvas.addEventListener('webglcontextrestored', this.contextRestored.bind(this), false);\n        }\n\n        if (this.device.cocoonJS)\n        {\n            this.canvas.screencanvas = (this.renderType === Phaser.CANVAS) ? true : false;\n        }\n\n        if (this.renderType !== Phaser.HEADLESS)\n        {\n            this.stage.smoothed = this.antialias;\n            \n            Phaser.Canvas.addToDOM(this.canvas, this.parent, false);\n            Phaser.Canvas.setTouchAction(this.canvas);\n        }\n\n    },\n\n    /**\n    * Handles WebGL context loss.\n    *\n    * @method Phaser.Game#contextLost\n    * @private\n    * @param {Event} event - The webglcontextlost event.\n    */\n    contextLost: function (event) {\n\n        event.preventDefault();\n\n        this.renderer.contextLost = true;\n\n    },\n\n    /**\n    * Handles WebGL context restoration.\n    *\n    * @method Phaser.Game#contextRestored\n    * @private\n    */\n    contextRestored: function () {\n\n        this.renderer.initContext();\n\n        this.cache.clearGLTextures();\n\n        this.renderer.contextLost = false;\n\n    },\n\n    /**\n    * The core game loop.\n    *\n    * @method Phaser.Game#update\n    * @protected\n    * @param {number} time - The current time as provided by RequestAnimationFrame.\n    */\n    update: function (time) {\n\n        this.time.update(time);\n\n        if (this._kickstart)\n        {\n            this.updateLogic(this.time.desiredFpsMult);\n\n            // call the game render update exactly once every frame\n            this.updateRender(this.time.slowMotion * this.time.desiredFps);\n\n            this._kickstart = false;\n\n            return;\n        }\n\n        // if the logic time is spiraling upwards, skip a frame entirely\n        if (this._spiraling > 1 && !this.forceSingleUpdate)\n        {\n            // cause an event to warn the program that this CPU can't keep up with the current desiredFps rate\n            if (this.time.time > this._nextFpsNotification)\n            {\n                // only permit one fps notification per 10 seconds\n                this._nextFpsNotification = this.time.time + 10000;\n\n                // dispatch the notification signal\n                this.fpsProblemNotifier.dispatch();\n            }\n\n            // reset the _deltaTime accumulator which will cause all pending dropped frames to be permanently skipped\n            this._deltaTime = 0;\n            this._spiraling = 0;\n\n            // call the game render update exactly once every frame\n            this.updateRender(this.time.slowMotion * this.time.desiredFps);\n        }\n        else\n        {\n            // step size taking into account the slow motion speed\n            var slowStep = this.time.slowMotion * 1000.0 / this.time.desiredFps;\n\n            // accumulate time until the slowStep threshold is met or exceeded... up to a limit of 3 catch-up frames at slowStep intervals\n            this._deltaTime += Math.max(Math.min(slowStep * 3, this.time.elapsed), 0);\n\n            // call the game update logic multiple times if necessary to \"catch up\" with dropped frames\n            // unless forceSingleUpdate is true\n            var count = 0;\n\n            this.updatesThisFrame = Math.floor(this._deltaTime / slowStep);\n\n            if (this.forceSingleUpdate)\n            {\n                this.updatesThisFrame = Math.min(1, this.updatesThisFrame);\n            }\n\n            while (this._deltaTime >= slowStep)\n            {\n                this._deltaTime -= slowStep;\n                this.currentUpdateID = count;\n\n                this.updateLogic(this.time.desiredFpsMult);\n\n                count++;\n\n                if (this.forceSingleUpdate && count === 1)\n                {\n                    break;\n                }\n                else\n                {\n                    this.time.refresh();\n                }\n            }\n\n            // detect spiraling (if the catch-up loop isn't fast enough, the number of iterations will increase constantly)\n            if (count > this._lastCount)\n            {\n                this._spiraling++;\n            }\n            else if (count < this._lastCount)\n            {\n                // looks like it caught up successfully, reset the spiral alert counter\n                this._spiraling = 0;\n            }\n\n            this._lastCount = count;\n\n            // call the game render update exactly once every frame unless we're playing catch-up from a spiral condition\n            this.updateRender(this._deltaTime / slowStep);\n        }\n\n    },\n\n    /**\n    * Updates all logic subsystems in Phaser. Called automatically by Game.update.\n    *\n    * @method Phaser.Game#updateLogic\n    * @protected\n    * @param {number} timeStep - The current timeStep value as determined by Game.update.\n    */\n    updateLogic: function (timeStep) {\n\n        if (!this._paused && !this.pendingStep)\n        {\n            if (this.stepping)\n            {\n                this.pendingStep = true;\n            }\n\n            this.scale.preUpdate();\n            this.debug.preUpdate();\n            this.camera.preUpdate();\n            this.physics.preUpdate();\n            this.state.preUpdate(timeStep);\n            this.plugins.preUpdate(timeStep);\n            this.stage.preUpdate();\n\n            this.state.update();\n            this.stage.update();\n            this.tweens.update();\n            this.sound.update();\n            this.input.update();\n            this.physics.update();\n            this.particles.update();\n            this.plugins.update();\n\n            this.stage.postUpdate();\n            this.plugins.postUpdate();\n        }\n        else\n        {\n            // Scaling and device orientation changes are still reflected when paused.\n            this.scale.pauseUpdate();\n            this.state.pauseUpdate();\n            this.debug.preUpdate();\n        }\n\n        this.stage.updateTransform();\n\n    },\n\n    /**\n    * Runs the Render cycle.\n    * It starts by calling State.preRender. In here you can do any last minute adjustments of display objects as required.\n    * It then calls the renderer, which renders the entire display list, starting from the Stage object and working down.\n    * It then calls plugin.render on any loaded plugins, in the order in which they were enabled.\n    * After this State.render is called. Any rendering that happens here will take place on-top of the display list.\n    * Finally plugin.postRender is called on any loaded plugins, in the order in which they were enabled.\n    * This method is called automatically by Game.update, you don't need to call it directly.\n    * Should you wish to have fine-grained control over when Phaser renders then use the `Game.lockRender` boolean.\n    * Phaser will only render when this boolean is `false`.\n    *\n    * @method Phaser.Game#updateRender\n    * @protected\n    * @param {number} elapsedTime - The time elapsed since the last update.\n    */\n    updateRender: function (elapsedTime) {\n\n        if (this.lockRender)\n        {\n            return;\n        }\n\n        this.state.preRender(elapsedTime);\n\n        if (this.renderType !== Phaser.HEADLESS)\n        {\n            this.renderer.render(this.stage);\n\n            this.plugins.render(elapsedTime);\n\n            this.state.render(elapsedTime);\n        }\n\n        this.plugins.postRender(elapsedTime);\n\n    },\n\n    /**\n    * Enable core game loop stepping. When enabled you must call game.step() directly (perhaps via a DOM button?)\n    * Calling step will advance the game loop by one frame. This is extremely useful for hard to track down errors!\n    *\n    * @method Phaser.Game#enableStep\n    */\n    enableStep: function () {\n\n        this.stepping = true;\n        this.pendingStep = false;\n        this.stepCount = 0;\n\n    },\n\n    /**\n    * Disables core game loop stepping.\n    *\n    * @method Phaser.Game#disableStep\n    */\n    disableStep: function () {\n\n        this.stepping = false;\n        this.pendingStep = false;\n\n    },\n\n    /**\n    * When stepping is enabled you must call this function directly (perhaps via a DOM button?) to advance the game loop by one frame.\n    * This is extremely useful to hard to track down errors! Use the internal stepCount property to monitor progress.\n    *\n    * @method Phaser.Game#step\n    */\n    step: function () {\n\n        this.pendingStep = false;\n        this.stepCount++;\n\n    },\n\n    /**\n    * Nukes the entire game from orbit.\n    *\n    * Calls destroy on Game.state, Game.sound, Game.scale, Game.stage, Game.input, Game.physics and Game.plugins.\n    *\n    * Then sets all of those local handlers to null, destroys the renderer, removes the canvas from the DOM\n    * and resets the PIXI default renderer.\n    *\n    * @method Phaser.Game#destroy\n    */\n    destroy: function () {\n\n        this.raf.stop();\n\n        this.state.destroy();\n        this.sound.destroy();\n        this.scale.destroy();\n        this.stage.destroy();\n        this.input.destroy();\n        this.physics.destroy();\n        this.plugins.destroy();\n\n        this.state = null;\n        this.sound = null;\n        this.scale = null;\n        this.stage = null;\n        this.input = null;\n        this.physics = null;\n        this.plugins = null;\n\n        this.cache = null;\n        this.load = null;\n        this.time = null;\n        this.world = null;\n\n        this.isBooted = false;\n\n        this.renderer.destroy(false);\n\n        Phaser.Canvas.removeFromDOM(this.canvas);\n\n        PIXI.defaultRenderer = null;\n\n        Phaser.GAMES[this.id] = null;\n\n    },\n\n    /**\n    * Called by the Stage visibility handler.\n    *\n    * @method Phaser.Game#gamePaused\n    * @param {object} event - The DOM event that caused the game to pause, if any.\n    * @protected\n    */\n    gamePaused: function (event) {\n\n        //   If the game is already paused it was done via game code, so don't re-pause it\n        if (!this._paused)\n        {\n            this._paused = true;\n\n            this.time.gamePaused();\n\n            if (this.sound.muteOnPause)\n            {\n                this.sound.setMute();\n            }\n\n            this.onPause.dispatch(event);\n\n            //  Avoids Cordova iOS crash event: https://github.com/photonstorm/phaser/issues/1800\n            if (this.device.cordova && this.device.iOS)\n            {\n                this.lockRender = true;\n            }\n        }\n\n    },\n\n    /**\n    * Called by the Stage visibility handler.\n    *\n    * @method Phaser.Game#gameResumed\n    * @param {object} event - The DOM event that caused the game to pause, if any.\n    * @protected\n    */\n    gameResumed: function (event) {\n\n        //  Game is paused, but wasn't paused via code, so resume it\n        if (this._paused && !this._codePaused)\n        {\n            this._paused = false;\n\n            this.time.gameResumed();\n\n            this.input.reset();\n\n            if (this.sound.muteOnPause)\n            {\n                this.sound.unsetMute();\n            }\n\n            this.onResume.dispatch(event);\n\n            //  Avoids Cordova iOS crash event: https://github.com/photonstorm/phaser/issues/1800\n            if (this.device.cordova && this.device.iOS)\n            {\n                this.lockRender = false;\n            }\n        }\n\n    },\n\n    /**\n    * Called by the Stage visibility handler.\n    *\n    * @method Phaser.Game#focusLoss\n    * @param {object} event - The DOM event that caused the game to pause, if any.\n    * @protected\n    */\n    focusLoss: function (event) {\n\n        this.onBlur.dispatch(event);\n\n        if (!this.stage.disableVisibilityChange)\n        {\n            this.gamePaused(event);\n        }\n\n    },\n\n    /**\n    * Called by the Stage visibility handler.\n    *\n    * @method Phaser.Game#focusGain\n    * @param {object} event - The DOM event that caused the game to pause, if any.\n    * @protected\n    */\n    focusGain: function (event) {\n\n        this.onFocus.dispatch(event);\n\n        if (!this.stage.disableVisibilityChange)\n        {\n            this.gameResumed(event);\n        }\n\n    }\n\n};\n\nPhaser.Game.prototype.constructor = Phaser.Game;\n\n/**\n* The paused state of the Game. A paused game doesn't update any of its subsystems.\n* When a game is paused the onPause event is dispatched. When it is resumed the onResume event is dispatched.\n* @name Phaser.Game#paused\n* @property {boolean} paused - Gets and sets the paused state of the Game.\n*/\nObject.defineProperty(Phaser.Game.prototype, \"paused\", {\n\n    get: function () {\n        return this._paused;\n    },\n\n    set: function (value) {\n\n        if (value === true)\n        {\n            if (this._paused === false)\n            {\n                this._paused = true;\n                this.sound.setMute();\n                this.time.gamePaused();\n                this.onPause.dispatch(this);\n            }\n            this._codePaused = true;\n        }\n        else\n        {\n            if (this._paused)\n            {\n                this._paused = false;\n                this.input.reset();\n                this.sound.unsetMute();\n                this.time.gameResumed();\n                this.onResume.dispatch(this);\n            }\n            this._codePaused = false;\n        }\n\n    }\n\n});\n\n/**\n * \n * \"Deleted code is debugged code.\" - Jeff Sickel\n *\n * ヽ(〃＾▽＾〃)ﾉ\n * \n*/\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Input is the Input Manager for all types of Input across Phaser, including mouse, keyboard, touch and MSPointer.\n* The Input manager is updated automatically by the core game loop.\n*\n* @class Phaser.Input\n* @constructor\n* @param {Phaser.Game} game - Current game instance.\n*/\nPhaser.Input = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {HTMLCanvasElement} hitCanvas - The canvas to which single pixels are drawn in order to perform pixel-perfect hit detection.\n    * @default\n    */\n    this.hitCanvas = null;\n\n    /**\n    * @property {CanvasRenderingContext2D} hitContext - The context of the pixel perfect hit canvas.\n    * @default\n    */\n    this.hitContext = null;\n\n    /**\n    * An array of callbacks that will be fired every time the activePointer receives a move event from the DOM.\n    * To add a callback to this array please use `Input.addMoveCallback`.\n    * @property {array} moveCallbacks\n    * @protected\n    */\n    this.moveCallbacks = [];\n\n    /**\n    * @property {function} customCandidateHandler - See Input.setInteractiveCandidateHandler.\n    * @private\n    */\n    this.customCandidateHandler = null;\n\n    /**\n    * @property {object} customCandidateHandlerContext - See Input.setInteractiveCandidateHandler.\n    * @private\n    */\n    this.customCandidateHandlerContext = null;\n\n    /**\n    * @property {number} pollRate - How often should the input pointers be checked for updates? A value of 0 means every single frame (60fps); a value of 1 means every other frame (30fps) and so on.\n    * @default\n    */\n    this.pollRate = 0;\n\n    /**\n    * When enabled, input (eg. Keyboard, Mouse, Touch) will be processed - as long as the individual sources are enabled themselves.\n    *\n    * When not enabled, _all_ input sources are ignored. To disable just one type of input; for example, the Mouse, use `input.mouse.enabled = false`.\n    * @property {boolean} enabled\n    * @default\n    */\n    this.enabled = true;\n\n    /**\n    * @property {number} multiInputOverride - Controls the expected behavior when using a mouse and touch together on a multi-input device.\n    * @default\n    */\n    this.multiInputOverride = Phaser.Input.MOUSE_TOUCH_COMBINE;\n\n    /**\n    * @property {Phaser.Point} position - A point object representing the current position of the Pointer.\n    * @default\n    */\n    this.position = null;\n\n    /**\n    * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.\n    */\n    this.speed = null;\n\n    /**\n    * A Circle object centered on the x/y screen coordinates of the Input.\n    * Default size of 44px (Apples recommended \"finger tip\" size) but can be changed to anything.\n    * @property {Phaser.Circle} circle\n    */\n    this.circle = null;\n\n    /**\n    * @property {Phaser.Point} scale - The scale by which all input coordinates are multiplied; calculated by the ScaleManager. In an un-scaled game the values will be x = 1 and y = 1.\n    */\n    this.scale = null;\n\n    /**\n    * @property {integer} maxPointers - The maximum number of Pointers allowed to be active at any one time. A value of -1 is only limited by the total number of pointers. For lots of games it's useful to set this to 1.\n    * @default -1 (Limited by total pointers.)\n    */\n    this.maxPointers = -1;\n\n    /**\n    * @property {number} tapRate - The number of milliseconds that the Pointer has to be pressed down and then released to be considered a tap or click.\n    * @default\n    */\n    this.tapRate = 200;\n\n    /**\n    * @property {number} doubleTapRate - The number of milliseconds between taps of the same Pointer for it to be considered a double tap / click.\n    * @default\n    */\n    this.doubleTapRate = 300;\n\n    /**\n    * @property {number} holdRate - The number of milliseconds that the Pointer has to be pressed down for it to fire a onHold event.\n    * @default\n    */\n    this.holdRate = 2000;\n\n    /**\n    * @property {number} justPressedRate - The number of milliseconds below which the Pointer is considered justPressed.\n    * @default\n    */\n    this.justPressedRate = 200;\n\n    /**\n    * @property {number} justReleasedRate - The number of milliseconds below which the Pointer is considered justReleased .\n    * @default\n    */\n    this.justReleasedRate = 200;\n\n    /**\n    * Sets if the Pointer objects should record a history of x/y coordinates they have passed through.\n    * The history is cleared each time the Pointer is pressed down.\n    * The history is updated at the rate specified in Input.pollRate\n    * @property {boolean} recordPointerHistory\n    * @default\n    */\n    this.recordPointerHistory = false;\n\n    /**\n    * @property {number} recordRate - The rate in milliseconds at which the Pointer objects should update their tracking history.\n    * @default\n    */\n    this.recordRate = 100;\n\n    /**\n    * The total number of entries that can be recorded into the Pointer objects tracking history.\n    * If the Pointer is tracking one event every 100ms; then a trackLimit of 100 would store the last 10 seconds worth of history.\n    * @property {number} recordLimit\n    * @default\n    */\n    this.recordLimit = 100;\n\n    /**\n    * @property {Phaser.Pointer} pointer1 - A Pointer object.\n    */\n    this.pointer1 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer2 - A Pointer object.\n    */\n    this.pointer2 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer3 - A Pointer object.\n    */\n    this.pointer3 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer4 - A Pointer object.\n    */\n    this.pointer4 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer5 - A Pointer object.\n    */\n    this.pointer5 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer6 - A Pointer object.\n    */\n    this.pointer6 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer7 - A Pointer object.\n    */\n    this.pointer7 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer8 - A Pointer object.\n    */\n    this.pointer8 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer9 - A Pointer object.\n    */\n    this.pointer9 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer10 - A Pointer object.\n    */\n    this.pointer10 = null;\n\n    /**\n    * An array of non-mouse pointers that have been added to the game.\n    * The properties `pointer1..N` are aliases for `pointers[0..N-1]`.\n    * @property {Phaser.Pointer[]} pointers\n    * @public\n    * @readonly\n    */\n    this.pointers = [];\n\n    /**\n    * The most recently active Pointer object.\n    * \n    * When you've limited max pointers to 1 this will accurately be either the first finger touched or mouse.\n    * \n    * @property {Phaser.Pointer} activePointer\n    */\n    this.activePointer = null;\n\n    /**\n    * The mouse has its own unique Phaser.Pointer object which you can use if making a desktop specific game.\n    * \n    * @property {Pointer} mousePointer\n    */\n    this.mousePointer = null;\n\n    /**\n    * The Mouse Input manager.\n    * \n    * You should not usually access this manager directly, but instead use Input.mousePointer or Input.activePointer \n    * which normalizes all the input values for you, regardless of browser.\n    * \n    * @property {Phaser.Mouse} mouse\n    */\n    this.mouse = null;\n\n    /**\n    * The Keyboard Input manager.\n    * \n    * @property {Phaser.Keyboard} keyboard\n    */\n    this.keyboard = null;\n\n    /**\n    * The Touch Input manager.\n    * \n    * You should not usually access this manager directly, but instead use Input.activePointer \n    * which normalizes all the input values for you, regardless of browser.\n    * \n    * @property {Phaser.Touch} touch\n    */\n    this.touch = null;\n\n    /**\n    * The MSPointer Input manager.\n    * \n    * You should not usually access this manager directly, but instead use Input.activePointer \n    * which normalizes all the input values for you, regardless of browser.\n    * \n    * @property {Phaser.MSPointer} mspointer\n    */\n    this.mspointer = null;\n\n    /**\n    * The Gamepad Input manager.\n    * \n    * @property {Phaser.Gamepad} gamepad\n    */\n    this.gamepad = null;\n\n    /**\n    * If the Input Manager has been reset locked then all calls made to InputManager.reset, \n    * such as from a State change, are ignored.\n    * @property {boolean} resetLocked\n    * @default\n    */\n    this.resetLocked = false;\n\n    /**\n    * A Signal that is dispatched each time a pointer is pressed down.\n    * @property {Phaser.Signal} onDown\n    */\n    this.onDown = null;\n\n    /**\n    * A Signal that is dispatched each time a pointer is released.\n    * @property {Phaser.Signal} onUp\n    */\n    this.onUp = null;\n\n    /**\n    * A Signal that is dispatched each time a pointer is tapped.\n    * @property {Phaser.Signal} onTap\n    */\n    this.onTap = null;\n\n    /**\n    * A Signal that is dispatched each time a pointer is held down.\n    * @property {Phaser.Signal} onHold\n    */\n    this.onHold = null;\n\n    /**\n    * You can tell all Pointers to ignore any Game Object with a `priorityID` lower than this value.\n    * This is useful when stacking UI layers. Set to zero to disable.\n    * @property {number} minPriorityID\n    * @default\n    */\n    this.minPriorityID = 0;\n\n    /**\n    * A list of interactive objects. The InputHandler components add and remove themselves from this list.\n    * @property {Phaser.ArraySet} interactiveItems\n    */\n    this.interactiveItems = new Phaser.ArraySet();\n\n    /**\n    * @property {Phaser.Point} _localPoint - Internal cache var.\n    * @private\n    */\n    this._localPoint = new Phaser.Point();\n\n    /**\n    * @property {number} _pollCounter - Internal var holding the current poll counter.\n    * @private\n    */\n    this._pollCounter = 0;\n\n    /**\n    * @property {Phaser.Point} _oldPosition - A point object representing the previous position of the Pointer.\n    * @private\n    */\n    this._oldPosition = null;\n\n    /**\n    * @property {number} _x - x coordinate of the most recent Pointer event\n    * @private\n    */\n    this._x = 0;\n\n    /**\n    * @property {number} _y - Y coordinate of the most recent Pointer event\n    * @private\n    */\n    this._y = 0;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Input.MOUSE_OVERRIDES_TOUCH = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Input.TOUCH_OVERRIDES_MOUSE = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Input.MOUSE_TOUCH_COMBINE = 2;\n\n/**\n* The maximum number of pointers that can be added. This excludes the mouse pointer.\n* @constant\n* @type {integer}\n*/\nPhaser.Input.MAX_POINTERS = 10;\n\nPhaser.Input.prototype = {\n\n    /**\n    * Starts the Input Manager running.\n    *\n    * @method Phaser.Input#boot\n    * @protected\n    */\n    boot: function () {\n\n        this.mousePointer = new Phaser.Pointer(this.game, 0, Phaser.PointerMode.CURSOR);\n        this.addPointer();\n        this.addPointer();\n\n        this.mouse = new Phaser.Mouse(this.game);\n        this.touch = new Phaser.Touch(this.game);\n        this.mspointer = new Phaser.MSPointer(this.game);\n\n        if (Phaser.Keyboard)\n        {\n            this.keyboard = new Phaser.Keyboard(this.game);\n        }\n\n        if (Phaser.Gamepad)\n        {\n            this.gamepad = new Phaser.Gamepad(this.game);\n        }\n\n        this.onDown = new Phaser.Signal();\n        this.onUp = new Phaser.Signal();\n        this.onTap = new Phaser.Signal();\n        this.onHold = new Phaser.Signal();\n\n        this.scale = new Phaser.Point(1, 1);\n        this.speed = new Phaser.Point();\n        this.position = new Phaser.Point();\n        this._oldPosition = new Phaser.Point();\n\n        this.circle = new Phaser.Circle(0, 0, 44);\n\n        this.activePointer = this.mousePointer;\n\n        this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1);\n        this.hitContext = this.hitCanvas.getContext('2d');\n\n        this.mouse.start();\n        this.touch.start();\n        this.mspointer.start();\n        this.mousePointer.active = true;\n\n        if (this.keyboard)\n        {\n            this.keyboard.start();\n        }\n\n        var _this = this;\n\n        this._onClickTrampoline = function (event) {\n            _this.onClickTrampoline(event);\n        };\n\n        this.game.canvas.addEventListener('click', this._onClickTrampoline, false);\n\n    },\n\n    /**\n    * Stops all of the Input Managers from running.\n    *\n    * @method Phaser.Input#destroy\n    */\n    destroy: function () {\n\n        this.mouse.stop();\n        this.touch.stop();\n        this.mspointer.stop();\n\n        if (this.keyboard)\n        {\n            this.keyboard.stop();\n        }\n\n        if (this.gamepad)\n        {\n            this.gamepad.stop();\n        }\n\n        this.moveCallbacks = [];\n\n        PIXI.CanvasPool.remove(this);\n\n        this.game.canvas.removeEventListener('click', this._onClickTrampoline);\n\n    },\n\n    /**\n    * Adds a callback that is fired every time `Pointer.processInteractiveObjects` is called.\n    * The purpose of `processInteractiveObjects` is to work out which Game Object the Pointer is going to\n    * interact with. It works by polling all of the valid game objects, and then slowly discounting those\n    * that don't meet the criteria (i.e. they aren't under the Pointer, are disabled, invisible, etc).\n    *\n    * Eventually a short-list of 'candidates' is created. These are all of the Game Objects which are valid\n    * for input and overlap with the Pointer. If you need fine-grained control over which of the items is\n    * selected then you can use this callback to do so.\n    *\n    * The callback will be sent 3 parameters:\n    * \n    * 1) A reference to the Phaser.Pointer object that is processing the Items.\n    * 2) An array containing all potential interactive candidates. This is an array of `InputHandler` objects, not Sprites.\n    * 3) The current 'favorite' candidate, based on its priorityID and position in the display list.\n    *\n    * Your callback MUST return one of the candidates sent to it.\n    * \n    * @method Phaser.Input#setInteractiveCandidateHandler\n    * @param {function} callback - The callback that will be called each time `Pointer.processInteractiveObjects` is called. Set to `null` to disable.\n    * @param {object} context - The context in which the callback will be called.\n    */\n    setInteractiveCandidateHandler: function (callback, context) {\n\n        this.customCandidateHandler = callback;\n        this.customCandidateHandlerContext = context;\n\n    },\n\n    /**\n    * Adds a callback that is fired every time the activePointer receives a DOM move event such as a mousemove or touchmove.\n    *\n    * The callback will be sent 4 parameters:\n    * \n    * A reference to the Phaser.Pointer object that moved,\n    * The x position of the pointer,\n    * The y position,\n    * A boolean indicating if the movement was the result of a 'click' event (such as a mouse click or touch down).\n    * \n    * It will be called every time the activePointer moves, which in a multi-touch game can be a lot of times, so this is best\n    * to only use if you've limited input to a single pointer (i.e. mouse or touch).\n    * \n    * The callback is added to the Phaser.Input.moveCallbacks array and should be removed with Phaser.Input.deleteMoveCallback.\n    * \n    * @method Phaser.Input#addMoveCallback\n    * @param {function} callback - The callback that will be called each time the activePointer receives a DOM move event.\n    * @param {object} context - The context in which the callback will be called.\n    */\n    addMoveCallback: function (callback, context) {\n\n        this.moveCallbacks.push({ callback: callback, context: context });\n\n    },\n\n    /**\n    * Removes the callback from the Phaser.Input.moveCallbacks array.\n    * \n    * @method Phaser.Input#deleteMoveCallback\n    * @param {function} callback - The callback to be removed.\n    * @param {object} context - The context in which the callback exists.\n    */\n    deleteMoveCallback: function (callback, context) {\n\n        var i = this.moveCallbacks.length;\n\n        while (i--)\n        {\n            if (this.moveCallbacks[i].callback === callback && this.moveCallbacks[i].context === context)\n            {\n                this.moveCallbacks.splice(i, 1);\n                return;\n            }\n        }\n\n    },\n\n    /**\n    * Add a new Pointer object to the Input Manager.\n    * By default Input creates 3 pointer objects: `mousePointer` (not include in part of general pointer pool), `pointer1` and `pointer2`.\n    * This method adds an additional pointer, up to a maximum of Phaser.Input.MAX_POINTERS (default of 10).\n    *\n    * @method Phaser.Input#addPointer\n    * @return {Phaser.Pointer|null} The new Pointer object that was created; null if a new pointer could not be added.\n    */\n    addPointer: function () {\n\n        if (this.pointers.length >= Phaser.Input.MAX_POINTERS)\n        {\n            console.warn(\"Phaser.Input.addPointer: Maximum limit of \" + Phaser.Input.MAX_POINTERS + \" pointers reached.\");\n            return null;\n        }\n\n        var id = this.pointers.length + 1;\n        var pointer = new Phaser.Pointer(this.game, id, Phaser.PointerMode.TOUCH);\n\n        this.pointers.push(pointer);\n        this['pointer' + id] = pointer;\n\n        return pointer;\n\n    },\n\n    /**\n    * Updates the Input Manager. Called by the core Game loop.\n    * \n    * @method Phaser.Input#update\n    * @protected\n    */\n    update: function () {\n\n        if (this.keyboard)\n        {\n            this.keyboard.update();\n        }\n\n        if (this.pollRate > 0 && this._pollCounter < this.pollRate)\n        {\n            this._pollCounter++;\n            return;\n        }\n\n        this.speed.x = this.position.x - this._oldPosition.x;\n        this.speed.y = this.position.y - this._oldPosition.y;\n\n        this._oldPosition.copyFrom(this.position);\n        this.mousePointer.update();\n\n        if (this.gamepad && this.gamepad.active)\n        {\n            this.gamepad.update();\n        }\n\n        for (var i = 0; i < this.pointers.length; i++)\n        {\n            this.pointers[i].update();\n        }\n\n        this._pollCounter = 0;\n\n    },\n\n    /**\n    * Reset all of the Pointers and Input states.\n    *\n    * The optional `hard` parameter will reset any events or callbacks that may be bound.\n    * Input.reset is called automatically during a State change or if a game loses focus / visibility.\n    * To control control the reset manually set {@link Phaser.InputManager.resetLocked} to `true`.\n    *\n    * @method Phaser.Input#reset\n    * @public\n    * @param {boolean} [hard=false] - A soft reset won't reset any events or callbacks that are bound. A hard reset will.\n    */\n    reset: function (hard) {\n\n        if (!this.game.isBooted || this.resetLocked)\n        {\n            return;\n        }\n\n        if (hard === undefined) { hard = false; }\n\n        this.mousePointer.reset();\n\n        if (this.keyboard)\n        {\n            this.keyboard.reset(hard);\n        }\n\n        if (this.gamepad)\n        {\n            this.gamepad.reset();\n        }\n\n        for (var i = 0; i < this.pointers.length; i++)\n        {\n            this.pointers[i].reset();\n        }\n\n        if (this.game.canvas.style.cursor !== 'none')\n        {\n            this.game.canvas.style.cursor = 'inherit';\n        }\n\n        if (hard)\n        {\n            this.onDown.dispose();\n            this.onUp.dispose();\n            this.onTap.dispose();\n            this.onHold.dispose();\n            this.onDown = new Phaser.Signal();\n            this.onUp = new Phaser.Signal();\n            this.onTap = new Phaser.Signal();\n            this.onHold = new Phaser.Signal();\n            this.moveCallbacks = [];\n        }\n\n        this._pollCounter = 0;\n\n    },\n\n    /**\n    * Resets the speed and old position properties.\n    *\n    * @method Phaser.Input#resetSpeed\n    * @param {number} x - Sets the oldPosition.x value.\n    * @param {number} y - Sets the oldPosition.y value.\n    */\n    resetSpeed: function (x, y) {\n\n        this._oldPosition.setTo(x, y);\n        this.speed.setTo(0, 0);\n\n    },\n\n    /**\n    * Find the first free Pointer object and start it, passing in the event data.\n    * This is called automatically by Phaser.Touch and Phaser.MSPointer.\n    *\n    * @method Phaser.Input#startPointer\n    * @protected\n    * @param {any} event - The event data from the Touch event.\n    * @return {Phaser.Pointer} The Pointer object that was started or null if no Pointer object is available.\n    */\n    startPointer: function (event) {\n\n        if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers)\n        {\n            return null;\n        }\n\n        if (!this.pointer1.active)\n        {\n            return this.pointer1.start(event);\n        }\n\n        if (!this.pointer2.active)\n        {\n            return this.pointer2.start(event);\n        }\n\n        for (var i = 2; i < this.pointers.length; i++)\n        {\n            var pointer = this.pointers[i];\n\n            if (!pointer.active)\n            {\n                return pointer.start(event);\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Updates the matching Pointer object, passing in the event data.\n    * This is called automatically and should not normally need to be invoked.\n    *\n    * @method Phaser.Input#updatePointer\n    * @protected\n    * @param {any} event - The event data from the Touch event.\n    * @return {Phaser.Pointer} The Pointer object that was updated; null if no pointer was updated.\n    */\n    updatePointer: function (event) {\n\n        if (this.pointer1.active && this.pointer1.identifier === event.identifier)\n        {\n            return this.pointer1.move(event);\n        }\n\n        if (this.pointer2.active && this.pointer2.identifier === event.identifier)\n        {\n            return this.pointer2.move(event);\n        }\n\n        for (var i = 2; i < this.pointers.length; i++)\n        {\n            var pointer = this.pointers[i];\n\n            if (pointer.active && pointer.identifier === event.identifier)\n            {\n                return pointer.move(event);\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Stops the matching Pointer object, passing in the event data.\n    *\n    * @method Phaser.Input#stopPointer\n    * @protected\n    * @param {any} event - The event data from the Touch event.\n    * @return {Phaser.Pointer} The Pointer object that was stopped or null if no Pointer object is available.\n    */\n    stopPointer: function (event) {\n\n        if (this.pointer1.active && this.pointer1.identifier === event.identifier)\n        {\n            return this.pointer1.stop(event);\n        }\n\n        if (this.pointer2.active && this.pointer2.identifier === event.identifier)\n        {\n            return this.pointer2.stop(event);\n        }\n\n        for (var i = 2; i < this.pointers.length; i++)\n        {\n            var pointer = this.pointers[i];\n\n            if (pointer.active && pointer.identifier === event.identifier)\n            {\n                return pointer.stop(event);\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Returns the total number of active pointers, not exceeding the specified limit\n    *\n    * @name Phaser.Input#countActivePointers\n    * @private\n    * @property {integer} [limit=(max pointers)] - Stop counting after this.\n    * @return {integer} The number of active pointers, or limit - whichever is less.\n    */\n    countActivePointers: function (limit) {\n\n        if (limit === undefined) { limit = this.pointers.length; }\n\n        var count = limit;\n\n        for (var i = 0; i < this.pointers.length && count > 0; i++)\n        {\n            var pointer = this.pointers[i];\n\n            if (pointer.active)\n            {\n                count--;\n            }\n        }\n\n        return (limit - count);\n\n    },\n\n    /**\n    * Get the first Pointer with the given active state.\n    *\n    * @method Phaser.Input#getPointer\n    * @param {boolean} [isActive=false] - The state the Pointer should be in - active or inactive?\n    * @return {Phaser.Pointer} A Pointer object or null if no Pointer object matches the requested state.\n    */\n    getPointer: function (isActive) {\n\n        if (isActive === undefined) { isActive = false; }\n\n        for (var i = 0; i < this.pointers.length; i++)\n        {\n            var pointer = this.pointers[i];\n\n            if (pointer.active === isActive)\n            {\n                return pointer;\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Get the Pointer object whos `identifier` property matches the given identifier value.\n    *\n    * The identifier property is not set until the Pointer has been used at least once, as its populated by the DOM event.\n    * Also it can change every time you press the pointer down, and is not fixed once set.\n    * Note: Not all browsers set the identifier property and it's not part of the W3C spec, so you may need getPointerFromId instead.\n    *\n    * @method Phaser.Input#getPointerFromIdentifier\n    * @param {number} identifier - The Pointer.identifier value to search for.\n    * @return {Phaser.Pointer} A Pointer object or null if no Pointer object matches the requested identifier.\n    */\n    getPointerFromIdentifier: function (identifier) {\n\n        for (var i = 0; i < this.pointers.length; i++)\n        {\n            var pointer = this.pointers[i];\n\n            if (pointer.identifier === identifier)\n            {\n                return pointer;\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Get the Pointer object whos `pointerId` property matches the given value.\n    *\n    * The pointerId property is not set until the Pointer has been used at least once, as its populated by the DOM event.\n    * Also it can change every time you press the pointer down if the browser recycles it.\n    *\n    * @method Phaser.Input#getPointerFromId\n    * @param {number} pointerId - The `pointerId` (not 'id') value to search for.\n    * @return {Phaser.Pointer} A Pointer object or null if no Pointer object matches the requested identifier.\n    */\n    getPointerFromId: function (pointerId) {\n\n        for (var i = 0; i < this.pointers.length; i++)\n        {\n            var pointer = this.pointers[i];\n\n            if (pointer.pointerId === pointerId)\n            {\n                return pointer;\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * This will return the local coordinates of the specified displayObject based on the given Pointer.\n    *\n    * @method Phaser.Input#getLocalPosition\n    * @param {Phaser.Sprite|Phaser.Image} displayObject - The DisplayObject to get the local coordinates for.\n    * @param {Phaser.Pointer} pointer - The Pointer to use in the check against the displayObject.\n    * @return {Phaser.Point} A point containing the coordinates of the Pointer position relative to the DisplayObject.\n    */\n    getLocalPosition: function (displayObject, pointer, output) {\n\n        if (output === undefined) { output = new Phaser.Point(); }\n\n        var wt = displayObject.worldTransform;\n        var id = 1 / (wt.a * wt.d + wt.c * -wt.b);\n\n        return output.setTo(\n            wt.d * id * pointer.x + -wt.c * id * pointer.y + (wt.ty * wt.c - wt.tx * wt.d) * id,\n            wt.a * id * pointer.y + -wt.b * id * pointer.x + (-wt.ty * wt.a + wt.tx * wt.b) * id\n        );\n\n    },\n\n    /**\n    * Tests if the pointer hits the given object.\n    *\n    * @method Phaser.Input#hitTest\n    * @param {DisplayObject} displayObject - The displayObject to test for a hit.\n    * @param {Phaser.Pointer} pointer - The pointer to use for the test.\n    * @param {Phaser.Point} localPoint - The local translated point.\n    */\n    hitTest: function (displayObject, pointer, localPoint) {\n\n        if (!displayObject.worldVisible)\n        {\n            return false;\n        }\n\n        this.getLocalPosition(displayObject, pointer, this._localPoint);\n\n        localPoint.copyFrom(this._localPoint);\n\n        if (displayObject.hitArea && displayObject.hitArea.contains)\n        {\n            return (displayObject.hitArea.contains(this._localPoint.x, this._localPoint.y));\n        }\n        else if (displayObject instanceof Phaser.TileSprite)\n        {\n            var width = displayObject.width;\n            var height = displayObject.height;\n            var x1 = -width * displayObject.anchor.x;\n\n            if (this._localPoint.x >= x1 && this._localPoint.x < x1 + width)\n            {\n                var y1 = -height * displayObject.anchor.y;\n\n                if (this._localPoint.y >= y1 && this._localPoint.y < y1 + height)\n                {\n                    return true;\n                }\n            }\n        }\n        else if (displayObject instanceof PIXI.Sprite)\n        {\n            var width = displayObject.texture.frame.width;\n            var height = displayObject.texture.frame.height;\n            var x1 = -width * displayObject.anchor.x;\n\n            if (this._localPoint.x >= x1 && this._localPoint.x < x1 + width)\n            {\n                var y1 = -height * displayObject.anchor.y;\n\n                if (this._localPoint.y >= y1 && this._localPoint.y < y1 + height)\n                {\n                    return true;\n                }\n            }\n        }\n        else if (displayObject instanceof Phaser.Graphics)\n        {\n            for (var i = 0; i < displayObject.graphicsData.length; i++)\n            {\n                var data = displayObject.graphicsData[i];\n\n                if (!data.fill)\n                {\n                    continue;\n                }\n\n                //  Only deal with fills..\n                if (data.shape && data.shape.contains(this._localPoint.x, this._localPoint.y))\n                {\n                    return true;\n                }\n            }\n        }\n\n        //  Didn't hit the parent, does it have any children?\n\n        for (var i = 0; i < displayObject.children.length; i++)\n        {\n            if (this.hitTest(displayObject.children[i], pointer, localPoint))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    /**\n    * Used for click trampolines. See {@link Phaser.Pointer.addClickTrampoline}.\n    *\n    * @method Phaser.Input#onClickTrampoline\n    * @private\n    */\n    onClickTrampoline: function () {\n\n        // It might not always be the active pointer, but this does work on\n        // Desktop browsers (read: IE) with Mouse or MSPointer input.\n        this.activePointer.processClickTrampolines();\n\n    }\n\n};\n\nPhaser.Input.prototype.constructor = Phaser.Input;\n\n/**\n* The X coordinate of the most recently active pointer.\n* This value takes game scaling into account automatically. See Pointer.screenX/clientX for source values.\n* @name Phaser.Input#x\n* @property {number} x\n*/\nObject.defineProperty(Phaser.Input.prototype, \"x\", {\n\n    get: function () {\n        return this._x;\n    },\n\n    set: function (value) {\n        this._x = Math.floor(value);\n    }\n\n});\n\n/**\n* The Y coordinate of the most recently active pointer.\n* This value takes game scaling into account automatically. See Pointer.screenY/clientY for source values.\n* @name Phaser.Input#y\n* @property {number} y\n*/\nObject.defineProperty(Phaser.Input.prototype, \"y\", {\n\n    get: function () {\n        return this._y;\n    },\n\n    set: function (value) {\n        this._y = Math.floor(value);\n    }\n\n});\n\n/**\n* True if the Input is currently poll rate locked.\n* @name Phaser.Input#pollLocked\n* @property {boolean} pollLocked\n* @readonly\n*/\nObject.defineProperty(Phaser.Input.prototype, \"pollLocked\", {\n\n    get: function () {\n        return (this.pollRate > 0 && this._pollCounter < this.pollRate);\n    }\n\n});\n\n/**\n* The total number of inactive Pointers.\n* @name Phaser.Input#totalInactivePointers\n* @property {number} totalInactivePointers\n* @readonly\n*/\nObject.defineProperty(Phaser.Input.prototype, \"totalInactivePointers\", {\n\n    get: function () {\n        return this.pointers.length - this.countActivePointers();\n    }\n\n});\n\n/**\n* The total number of active Pointers, not counting the mouse pointer.\n* @name Phaser.Input#totalActivePointers\n* @property {integers} totalActivePointers\n* @readonly\n*/\nObject.defineProperty(Phaser.Input.prototype, \"totalActivePointers\", {\n\n    get: function () {\n        return this.countActivePointers();\n    }\n\n});\n\n/**\n* The world X coordinate of the most recently active pointer.\n* @name Phaser.Input#worldX\n* @property {number} worldX - The world X coordinate of the most recently active pointer.\n* @readonly\n*/\nObject.defineProperty(Phaser.Input.prototype, \"worldX\", {\n\n    get: function () {\n        return this.game.camera.view.x + this.x;\n    }\n\n});\n\n/**\n* The world Y coordinate of the most recently active pointer.\n* @name Phaser.Input#worldY\n* @property {number} worldY - The world Y coordinate of the most recently active pointer.\n* @readonly\n*/\nObject.defineProperty(Phaser.Input.prototype, \"worldY\", {\n\n    get: function () {\n        return this.game.camera.view.y + this.y;\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Mouse class is responsible for handling all aspects of mouse interaction with the browser.\n*\n* It captures and processes mouse events that happen on the game canvas object.\n* It also adds a single `mouseup` listener to `window` which is used to capture the mouse being released\n* when not over the game.\n*\n* You should not normally access this class directly, but instead use a Phaser.Pointer object\n* which normalises all game input for you, including accurate button handling.\n*\n* @class Phaser.Mouse\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Mouse = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Input} input - A reference to the Phaser Input Manager.\n    * @protected\n    */\n    this.input = game.input;\n\n    /**\n    * @property {object} callbackContext - The context under which callbacks are called.\n    */\n    this.callbackContext = this.game;\n\n    /**\n    * @property {function} mouseDownCallback - A callback that can be fired when the mouse is pressed down.\n    */\n    this.mouseDownCallback = null;\n\n    /**\n    * @property {function} mouseUpCallback - A callback that can be fired when the mouse is released from a pressed down state.\n    */\n    this.mouseUpCallback = null;\n\n    /**\n    * @property {function} mouseOutCallback - A callback that can be fired when the mouse is no longer over the game canvas.\n    */\n    this.mouseOutCallback = null;\n\n    /**\n    * @property {function} mouseOverCallback - A callback that can be fired when the mouse enters the game canvas (usually after a mouseout).\n    */\n    this.mouseOverCallback = null;\n\n    /**\n     * @property {function} mouseWheelCallback - A callback that can be fired when the mousewheel is used.\n     */\n    this.mouseWheelCallback = null;\n\n    /**\n    * @property {boolean} capture - If true the DOM mouse events will have event.preventDefault applied to them, if false they will propagate fully.\n    */\n    this.capture = false;\n\n    /**\n    * This property was removed in Phaser 2.4 and should no longer be used.\n    * Instead please see the Pointer button properties such as `Pointer.leftButton`, `Pointer.rightButton` and so on.\n    * Or Pointer.button holds the DOM event button value if you require that.\n    * @property {number} button\n    * @default\n    */\n    this.button = -1;\n\n    /**\n     * The direction of the _last_ mousewheel usage 1 for up -1 for down.\n     * @property {number} wheelDelta\n     */\n    this.wheelDelta = 0;\n\n    /**\n    * Mouse input will only be processed if enabled.\n    * @property {boolean} enabled\n    * @default\n    */\n    this.enabled = true;\n\n    /**\n    * @property {boolean} locked - If the mouse has been Pointer Locked successfully this will be set to true.\n    * @default\n    */\n    this.locked = false;\n\n    /**\n    * @property {boolean} stopOnGameOut - If true Pointer.stop will be called if the mouse leaves the game canvas.\n    * @default\n    */\n    this.stopOnGameOut = false;\n\n    /**\n    * @property {Phaser.Signal} pointerLock - This event is dispatched when the browser enters or leaves pointer lock state.\n    * @default\n    */\n    this.pointerLock = new Phaser.Signal();\n\n    /**\n    * The browser mouse DOM event. Will be null if no mouse event has ever been received.\n    * Access this property only inside a Mouse event handler and do not keep references to it.\n    * @property {MouseEvent|null} event\n    * @default\n    */\n    this.event = null;\n\n    /**\n    * @property {function} _onMouseDown - Internal event handler reference.\n    * @private\n    */\n    this._onMouseDown = null;\n\n    /**\n    * @property {function} _onMouseMove - Internal event handler reference.\n    * @private\n    */\n    this._onMouseMove = null;\n\n    /**\n    * @property {function} _onMouseUp - Internal event handler reference.\n    * @private\n    */\n    this._onMouseUp = null;\n\n    /**\n    * @property {function} _onMouseOut - Internal event handler reference.\n    * @private\n    */\n    this._onMouseOut = null;\n\n    /**\n    * @property {function} _onMouseOver - Internal event handler reference.\n    * @private\n    */\n    this._onMouseOver = null;\n\n    /**\n    * @property {function} _onMouseWheel - Internal event handler reference.\n    * @private\n    */\n    this._onMouseWheel = null;\n\n    /**\n    * Wheel proxy event object, if required. Shared for all wheel events for this mouse.\n    * @property {Phaser.Mouse~WheelEventProxy} _wheelEvent\n    * @private\n    */\n    this._wheelEvent = null;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.NO_BUTTON = -1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.LEFT_BUTTON = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.MIDDLE_BUTTON = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.RIGHT_BUTTON = 2;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.BACK_BUTTON = 3;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.FORWARD_BUTTON = 4;\n\n/**\n * @constant\n * @type {number}\n */\nPhaser.Mouse.WHEEL_UP = 1;\n\n/**\n * @constant\n * @type {number}\n */\nPhaser.Mouse.WHEEL_DOWN = -1;\n\nPhaser.Mouse.prototype = {\n\n    /**\n    * Starts the event listeners running.\n    * @method Phaser.Mouse#start\n    */\n    start: function () {\n\n        if (this.game.device.android && this.game.device.chrome === false)\n        {\n            //  Android stock browser fires mouse events even if you preventDefault on the touchStart, so ...\n            return;\n        }\n\n        if (this._onMouseDown !== null)\n        {\n            //  Avoid setting multiple listeners\n            return;\n        }\n\n        var _this = this;\n\n        this._onMouseDown = function (event) {\n            return _this.onMouseDown(event);\n        };\n\n        this._onMouseMove = function (event) {\n            return _this.onMouseMove(event);\n        };\n\n        this._onMouseUp = function (event) {\n            return _this.onMouseUp(event);\n        };\n\n        this._onMouseUpGlobal = function (event) {\n            return _this.onMouseUpGlobal(event);\n        };\n\n        this._onMouseOutGlobal = function (event) {\n            return _this.onMouseOutGlobal(event);\n        };\n\n        this._onMouseOut = function (event) {\n            return _this.onMouseOut(event);\n        };\n\n        this._onMouseOver = function (event) {\n            return _this.onMouseOver(event);\n        };\n\n        this._onMouseWheel = function (event) {\n            return _this.onMouseWheel(event);\n        };\n\n        var canvas = this.game.canvas;\n\n        canvas.addEventListener('mousedown', this._onMouseDown, true);\n        canvas.addEventListener('mousemove', this._onMouseMove, true);\n        canvas.addEventListener('mouseup', this._onMouseUp, true);\n\n        if (!this.game.device.cocoonJS)\n        {\n            window.addEventListener('mouseup', this._onMouseUpGlobal, true);\n            window.addEventListener('mouseout', this._onMouseOutGlobal, true);\n            canvas.addEventListener('mouseover', this._onMouseOver, true);\n            canvas.addEventListener('mouseout', this._onMouseOut, true);\n        }\n\n        var wheelEvent = this.game.device.wheelEvent;\n\n        if (wheelEvent)\n        {\n            canvas.addEventListener(wheelEvent, this._onMouseWheel, true);\n\n            if (wheelEvent === 'mousewheel')\n            {\n                this._wheelEvent = new WheelEventProxy(-1/40, 1);\n            }\n            else if (wheelEvent === 'DOMMouseScroll')\n            {\n                this._wheelEvent = new WheelEventProxy(1, 1);\n            }\n        }\n\n    },\n\n    /**\n    * The internal method that handles the mouse down event from the browser.\n    * @method Phaser.Mouse#onMouseDown\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseDown: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        if (this.mouseDownCallback)\n        {\n            this.mouseDownCallback.call(this.callbackContext, event);\n        }\n\n        if (!this.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        event['identifier'] = 0;\n\n        this.input.mousePointer.start(event);\n\n    },\n\n    /**\n    * The internal method that handles the mouse move event from the browser.\n    * @method Phaser.Mouse#onMouseMove\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseMove: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        if (this.mouseMoveCallback)\n        {\n            this.mouseMoveCallback.call(this.callbackContext, event);\n        }\n\n        if (!this.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        event['identifier'] = 0;\n\n        this.input.mousePointer.move(event);\n\n    },\n\n    /**\n    * The internal method that handles the mouse up event from the browser.\n    * @method Phaser.Mouse#onMouseUp\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseUp: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        if (this.mouseUpCallback)\n        {\n            this.mouseUpCallback.call(this.callbackContext, event);\n        }\n\n        if (!this.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        event['identifier'] = 0;\n\n        this.input.mousePointer.stop(event);\n\n    },\n\n    /**\n    * The internal method that handles the mouse up event from the window.\n    *\n    * @method Phaser.Mouse#onMouseUpGlobal\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseUpGlobal: function (event) {\n\n        if (!this.input.mousePointer.withinGame)\n        {\n            if (this.mouseUpCallback)\n            {\n                this.mouseUpCallback.call(this.callbackContext, event);\n            }\n\n            event['identifier'] = 0;\n\n            this.input.mousePointer.stop(event);\n        }\n\n    },\n\n    /**\n    * The internal method that handles the mouse out event from the window.\n    *\n    * @method Phaser.Mouse#onMouseOutGlobal\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseOutGlobal: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        this.input.mousePointer.withinGame = false;\n\n        if (!this.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        //  If we get a mouseout event from the window then basically\n        //  something serious has gone down, usually along the lines of\n        //  the browser opening a context-menu or similar.\n        //  On OS X Chrome especially this is bad news, as it blocks\n        //  us then getting a mouseup event, so we need to force that through.\n        //\n        //  No matter what, we must cancel the left and right buttons\n\n        this.input.mousePointer.stop(event);\n        this.input.mousePointer.leftButton.stop(event);\n        this.input.mousePointer.rightButton.stop(event);\n\n    },\n\n    /**\n    * The internal method that handles the mouse out event from the browser.\n    *\n    * @method Phaser.Mouse#onMouseOut\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseOut: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        this.input.mousePointer.withinGame = false;\n\n        if (this.mouseOutCallback)\n        {\n            this.mouseOutCallback.call(this.callbackContext, event);\n        }\n\n        if (!this.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        if (this.stopOnGameOut)\n        {\n            event['identifier'] = 0;\n\n            this.input.mousePointer.stop(event);\n        }\n\n    },\n\n    /**\n    * The internal method that handles the mouse over event from the browser.\n    *\n    * @method Phaser.Mouse#onMouseOver\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseOver: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        this.input.mousePointer.withinGame = true;\n\n        if (this.mouseOverCallback)\n        {\n            this.mouseOverCallback.call(this.callbackContext, event);\n        }\n\n    },\n\n    /**\n     * The internal method that handles the mouse wheel event from the browser.\n     *\n     * @method Phaser.Mouse#onMouseWheel\n     * @param {MouseEvent} event - The native event from the browser.\n     */\n    onMouseWheel: function (event) {\n\n        if (this._wheelEvent) {\n            event = this._wheelEvent.bindEvent(event);\n        }\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        // reverse detail for firefox\n        this.wheelDelta = Phaser.Math.clamp(-event.deltaY, -1, 1);\n\n        if (this.mouseWheelCallback)\n        {\n            this.mouseWheelCallback.call(this.callbackContext, event);\n        }\n\n    },\n\n    /**\n    * If the browser supports it you can request that the pointer be locked to the browser window.\n    * This is classically known as 'FPS controls', where the pointer can't leave the browser until the user presses an exit key.\n    * If the browser successfully enters a locked state the event Phaser.Mouse.pointerLock will be dispatched and the first parameter will be 'true'.\n    * @method Phaser.Mouse#requestPointerLock\n    */\n    requestPointerLock: function () {\n\n        if (this.game.device.pointerLock)\n        {\n            var element = this.game.canvas;\n\n            element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;\n\n            element.requestPointerLock();\n\n            var _this = this;\n\n            this._pointerLockChange = function (event) {\n                return _this.pointerLockChange(event);\n            };\n\n            document.addEventListener('pointerlockchange', this._pointerLockChange, true);\n            document.addEventListener('mozpointerlockchange', this._pointerLockChange, true);\n            document.addEventListener('webkitpointerlockchange', this._pointerLockChange, true);\n        }\n\n    },\n\n    /**\n    * Internal pointerLockChange handler.\n    *\n    * @method Phaser.Mouse#pointerLockChange\n    * @param {Event} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    pointerLockChange: function (event) {\n\n        var element = this.game.canvas;\n\n        if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element)\n        {\n            //  Pointer was successfully locked\n            this.locked = true;\n            this.pointerLock.dispatch(true, event);\n        }\n        else\n        {\n            //  Pointer was unlocked\n            this.locked = false;\n            this.pointerLock.dispatch(false, event);\n        }\n\n    },\n\n    /**\n    * Internal release pointer lock handler.\n    * @method Phaser.Mouse#releasePointerLock\n    */\n    releasePointerLock: function () {\n\n        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;\n\n        document.exitPointerLock();\n\n        document.removeEventListener('pointerlockchange', this._pointerLockChange, true);\n        document.removeEventListener('mozpointerlockchange', this._pointerLockChange, true);\n        document.removeEventListener('webkitpointerlockchange', this._pointerLockChange, true);\n\n    },\n\n    /**\n    * Stop the event listeners.\n    * @method Phaser.Mouse#stop\n    */\n    stop: function () {\n\n        var canvas = this.game.canvas;\n\n        canvas.removeEventListener('mousedown', this._onMouseDown, true);\n        canvas.removeEventListener('mousemove', this._onMouseMove, true);\n        canvas.removeEventListener('mouseup', this._onMouseUp, true);\n        canvas.removeEventListener('mouseover', this._onMouseOver, true);\n        canvas.removeEventListener('mouseout', this._onMouseOut, true);\n\n        var wheelEvent = this.game.device.wheelEvent;\n\n        if (wheelEvent)\n        {\n            canvas.removeEventListener(wheelEvent, this._onMouseWheel, true);\n        }\n\n        window.removeEventListener('mouseup', this._onMouseUpGlobal, true);\n        window.removeEventListener('mouseout', this._onMouseOutGlobal, true);\n\n        document.removeEventListener('pointerlockchange', this._pointerLockChange, true);\n        document.removeEventListener('mozpointerlockchange', this._pointerLockChange, true);\n        document.removeEventListener('webkitpointerlockchange', this._pointerLockChange, true);\n\n    }\n\n};\n\nPhaser.Mouse.prototype.constructor = Phaser.Mouse;\n\n/* jshint latedef:nofunc */\n/**\n* A purely internal event support class to proxy 'wheelscroll' and 'DOMMouseWheel'\n* events to 'wheel'-like events.\n*\n* See https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel for choosing a scale and delta mode.\n*\n* @method Phaser.Mouse#WheelEventProxy\n* @private\n* @param {number} scaleFactor - Scale factor as applied to wheelDelta/wheelDeltaX or details.\n* @param {integer} deltaMode - The reported delta mode.\n*/\nfunction WheelEventProxy (scaleFactor, deltaMode) {\n\n    /**\n    * @property {number} _scaleFactor - Scale factor as applied to wheelDelta/wheelDeltaX or details.\n    * @private\n    */\n    this._scaleFactor = scaleFactor;\n\n    /**\n    * @property {number} _deltaMode - The reported delta mode.\n    * @private\n    */\n    this._deltaMode = deltaMode;\n\n    /**\n    * @property {any} originalEvent - The original event _currently_ being proxied; the getters will follow suit.\n    * @private\n    */\n    this.originalEvent = null;\n\n}\n\nWheelEventProxy.prototype = {};\nWheelEventProxy.prototype.constructor = WheelEventProxy;\n\nWheelEventProxy.prototype.bindEvent = function (event) {\n\n    // Generate stubs automatically\n    if (!WheelEventProxy._stubsGenerated && event)\n    {\n        var makeBinder = function (name) {\n\n            return function () {\n                var v = this.originalEvent[name];\n                return typeof v !== 'function' ? v : v.bind(this.originalEvent);\n            };\n\n        };\n\n        for (var prop in event)\n        {\n            if (!(prop in WheelEventProxy.prototype))\n            {\n                Object.defineProperty(WheelEventProxy.prototype, prop, {\n                    get: makeBinder(prop)\n                });\n            }\n        }\n        WheelEventProxy._stubsGenerated = true;\n    }\n\n    this.originalEvent = event;\n    return this;\n\n};\n\nObject.defineProperties(WheelEventProxy.prototype, {\n    \"type\": { value: \"wheel\" },\n    \"deltaMode\": { get: function () { return this._deltaMode; } },\n    \"deltaY\": {\n        get: function () {\n            return (this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail)) || 0;\n        }\n    },\n    \"deltaX\": {\n        get: function () {\n            return (this._scaleFactor * this.originalEvent.wheelDeltaX) || 0;\n        }\n    },\n    \"deltaZ\": { value: 0 }\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The MSPointer class handles Microsoft touch interactions with the game and the resulting Pointer objects.\n*\n* It will work only in Internet Explorer 10+ and Windows Store or Windows Phone 8 apps using JavaScript.\n* http://msdn.microsoft.com/en-us/library/ie/hh673557(v=vs.85).aspx\n*\n* You should not normally access this class directly, but instead use a Phaser.Pointer object which \n* normalises all game input for you including accurate button handling.\n*\n* Please note that at the current time of writing Phaser does not yet support chorded button interactions:\n* http://www.w3.org/TR/pointerevents/#chorded-button-interactions\n*\n* @class Phaser.MSPointer\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.MSPointer = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Input} input - A reference to the Phaser Input Manager.\n    * @protected\n    */\n    this.input = game.input;\n\n    /**\n    * @property {object} callbackContext - The context under which callbacks are called (defaults to game).\n    */\n    this.callbackContext = this.game;\n\n    /**\n    * @property {function} pointerDownCallback - A callback that can be fired on a MSPointerDown event.\n    */\n    this.pointerDownCallback = null;\n\n    /**\n    * @property {function} pointerMoveCallback - A callback that can be fired on a MSPointerMove event.\n    */\n    this.pointerMoveCallback = null;\n\n    /**\n    * @property {function} pointerUpCallback - A callback that can be fired on a MSPointerUp event.\n    */\n    this.pointerUpCallback = null;\n\n    /**\n    * @property {boolean} capture - If true the Pointer events will have event.preventDefault applied to them, if false they will propagate fully.\n    */\n    this.capture = true;\n\n    /**\n    * This property was removed in Phaser 2.4 and should no longer be used.\n    * Instead please see the Pointer button properties such as `Pointer.leftButton`, `Pointer.rightButton` and so on.\n    * Or Pointer.button holds the DOM event button value if you require that.\n    * @property {number} button\n    */\n    this.button = -1;\n\n    /**\n    * The browser MSPointer DOM event. Will be null if no event has ever been received.\n    * Access this property only inside a Pointer event handler and do not keep references to it.\n    * @property {MSPointerEvent|null} event\n    * @default\n    */\n    this.event = null;\n\n    /**\n    * MSPointer input will only be processed if enabled.\n    * @property {boolean} enabled\n    * @default\n    */\n    this.enabled = true;\n\n    /**\n    * @property {function} _onMSPointerDown - Internal function to handle MSPointer events.\n    * @private\n    */\n    this._onMSPointerDown = null;\n\n    /**\n    * @property {function} _onMSPointerMove - Internal function to handle MSPointer events.\n    * @private\n    */\n    this._onMSPointerMove = null;\n\n    /**\n    * @property {function} _onMSPointerUp - Internal function to handle MSPointer events.\n    * @private\n    */\n    this._onMSPointerUp = null;\n\n    /**\n    * @property {function} _onMSPointerUpGlobal - Internal function to handle MSPointer events.\n    * @private\n    */\n    this._onMSPointerUpGlobal = null;\n\n    /**\n    * @property {function} _onMSPointerOut - Internal function to handle MSPointer events.\n    * @private\n    */\n    this._onMSPointerOut = null;\n\n    /**\n    * @property {function} _onMSPointerOver - Internal function to handle MSPointer events.\n    * @private\n    */\n    this._onMSPointerOver = null;\n\n};\n\nPhaser.MSPointer.prototype = {\n\n    /**\n    * Starts the event listeners running.\n    * @method Phaser.MSPointer#start\n    */\n    start: function () {\n\n        if (this._onMSPointerDown !== null)\n        {\n            //  Avoid setting multiple listeners\n            return;\n        }\n\n        var _this = this;\n\n        if (this.game.device.mspointer)\n        {\n            this._onMSPointerDown = function (event) {\n                return _this.onPointerDown(event);\n            };\n\n            this._onMSPointerMove = function (event) {\n                return _this.onPointerMove(event);\n            };\n\n            this._onMSPointerUp = function (event) {\n                return _this.onPointerUp(event);\n            };\n\n            this._onMSPointerUpGlobal = function (event) {\n                return _this.onPointerUpGlobal(event);\n            };\n\n            this._onMSPointerOut = function (event) {\n                return _this.onPointerOut(event);\n            };\n\n            this._onMSPointerOver = function (event) {\n                return _this.onPointerOver(event);\n            };\n\n            var canvas = this.game.canvas;\n\n            canvas.addEventListener('MSPointerDown', this._onMSPointerDown, false);\n            canvas.addEventListener('MSPointerMove', this._onMSPointerMove, false);\n            canvas.addEventListener('MSPointerUp', this._onMSPointerUp, false);\n\n            //  IE11+ uses non-prefix events\n            canvas.addEventListener('pointerdown', this._onMSPointerDown, false);\n            canvas.addEventListener('pointermove', this._onMSPointerMove, false);\n            canvas.addEventListener('pointerup', this._onMSPointerUp, false);\n\n            canvas.style['-ms-content-zooming'] = 'none';\n            canvas.style['-ms-touch-action'] = 'none';\n\n            if (!this.game.device.cocoonJS)\n            {\n                window.addEventListener('MSPointerUp', this._onMSPointerUpGlobal, true);\n                canvas.addEventListener('MSPointerOver', this._onMSPointerOver, true);\n                canvas.addEventListener('MSPointerOut', this._onMSPointerOut, true);\n\n                //  IE11+ uses non-prefix events\n                window.addEventListener('pointerup', this._onMSPointerUpGlobal, true);\n                canvas.addEventListener('pointerover', this._onMSPointerOver, true);\n                canvas.addEventListener('pointerout', this._onMSPointerOut, true);\n            }\n        }\n\n    },\n\n    /**\n    * The function that handles the PointerDown event.\n    * \n    * @method Phaser.MSPointer#onPointerDown\n    * @param {PointerEvent} event - The native DOM event.\n    */\n    onPointerDown: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        if (this.pointerDownCallback)\n        {\n            this.pointerDownCallback.call(this.callbackContext, event);\n        }\n\n        if (!this.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        event.identifier = event.pointerId;\n\n        if (event.pointerType === 'mouse' || event.pointerType === 0x00000004)\n        {\n            this.input.mousePointer.start(event);\n        }\n        else\n        {\n            this.input.startPointer(event);\n        }\n\n    },\n\n    /**\n    * The function that handles the PointerMove event.\n    * @method Phaser.MSPointer#onPointerMove\n    * @param {PointerEvent} event - The native DOM event.\n    */\n    onPointerMove: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        if (this.pointerMoveCallback)\n        {\n            this.pointerMoveCallback.call(this.callbackContext, event);\n        }\n\n        if (!this.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        event.identifier = event.pointerId;\n\n        if (event.pointerType === 'mouse' || event.pointerType === 0x00000004)\n        {\n            this.input.mousePointer.move(event);\n        }\n        else\n        {\n            this.input.updatePointer(event);\n        }\n\n    },\n\n    /**\n    * The function that handles the PointerUp event.\n    * @method Phaser.MSPointer#onPointerUp\n    * @param {PointerEvent} event - The native DOM event.\n    */\n    onPointerUp: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        if (this.pointerUpCallback)\n        {\n            this.pointerUpCallback.call(this.callbackContext, event);\n        }\n\n        if (!this.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        event.identifier = event.pointerId;\n\n        if (event.pointerType === 'mouse' || event.pointerType === 0x00000004)\n        {\n            this.input.mousePointer.stop(event);\n        }\n        else\n        {\n            this.input.stopPointer(event);\n        }\n\n    },\n\n    /**\n    * The internal method that handles the mouse up event from the window.\n    * \n    * @method Phaser.MSPointer#onPointerUpGlobal\n    * @param {PointerEvent} event - The native event from the browser. This gets stored in MSPointer.event.\n    */\n    onPointerUpGlobal: function (event) {\n\n        if ((event.pointerType === 'mouse' || event.pointerType === 0x00000004) && !this.input.mousePointer.withinGame)\n        {\n            this.onPointerUp(event);\n        }\n        else\n        {\n            var pointer = this.input.getPointerFromIdentifier(event.identifier);\n\n            if (pointer && pointer.withinGame)\n            {\n                this.onPointerUp(event);\n            }\n        }\n\n    },\n\n    /**\n    * The internal method that handles the pointer out event from the browser.\n    *\n    * @method Phaser.MSPointer#onPointerOut\n    * @param {PointerEvent} event - The native event from the browser. This gets stored in MSPointer.event.\n    */\n    onPointerOut: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        if (event.pointerType === 'mouse' || event.pointerType === 0x00000004)\n        {\n            this.input.mousePointer.withinGame = false;\n        }\n        else\n        {\n            var pointer = this.input.getPointerFromIdentifier(event.identifier);\n\n            if (pointer)\n            {\n                pointer.withinGame = false;\n            }\n        }\n\n        if (this.input.mouse.mouseOutCallback)\n        {\n            this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, event);\n        }\n\n        if (!this.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        if (this.input.mouse.stopOnGameOut)\n        {\n            event['identifier'] = 0;\n\n            if (pointer)\n            {\n                pointer.stop(event);\n            }\n            else\n            {\n                this.input.mousePointer.stop(event);\n            }\n        }\n\n    },\n\n    /**\n    * The internal method that handles the pointer out event from the browser.\n    *\n    * @method Phaser.MSPointer#onPointerOut\n    * @param {PointerEvent} event - The native event from the browser. This gets stored in MSPointer.event.\n    */\n    onPointerOver: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        if (event.pointerType === 'mouse' || event.pointerType === 0x00000004)\n        {\n            this.input.mousePointer.withinGame = true;\n        }\n        else\n        {\n            var pointer = this.input.getPointerFromIdentifier(event.identifier);\n\n            if (pointer)\n            {\n                pointer.withinGame = true;\n            }\n        }\n\n        if (this.input.mouse.mouseOverCallback)\n        {\n            this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, event);\n        }\n\n    },\n\n    /**\n    * Stop the event listeners.\n    * @method Phaser.MSPointer#stop\n    */\n    stop: function () {\n\n        var canvas = this.game.canvas;\n\n        canvas.removeEventListener('MSPointerDown', this._onMSPointerDown, false);\n        canvas.removeEventListener('MSPointerMove', this._onMSPointerMove, false);\n        canvas.removeEventListener('MSPointerUp', this._onMSPointerUp, false);\n\n        //  IE11+ uses non-prefix events\n        canvas.removeEventListener('pointerdown', this._onMSPointerDown, false);\n        canvas.removeEventListener('pointermove', this._onMSPointerMove, false);\n        canvas.removeEventListener('pointerup', this._onMSPointerUp, false);\n\n        window.removeEventListener('MSPointerUp', this._onMSPointerUpGlobal, true);\n        canvas.removeEventListener('MSPointerOver', this._onMSPointerOver, true);\n        canvas.removeEventListener('MSPointerOut', this._onMSPointerOut, true);\n\n        //  IE11+ uses non-prefix events\n        window.removeEventListener('pointerup', this._onMSPointerUpGlobal, true);\n        canvas.removeEventListener('pointerover', this._onMSPointerOver, true);\n        canvas.removeEventListener('pointerout', this._onMSPointerOut, true);\n\n    }\n\n};\n\nPhaser.MSPointer.prototype.constructor = Phaser.MSPointer;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @author       @karlmacklin <tacklemcclean@gmail.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* DeviceButtons belong to both `Phaser.Pointer` and `Phaser.SinglePad` (Gamepad) instances.\n*\n* For Pointers they represent the various buttons that can exist on mice and pens, such as the left button, right button,\n* middle button and advanced buttons like back and forward.\n*\n* Access them via `Pointer.leftbutton`, `Pointer.rightButton` and so on.\n*\n* On Gamepads they represent all buttons on the pad: from shoulder buttons to action buttons.\n*\n* At the time of writing this there are device limitations you should be aware of:\n*\n* - On Windows, if you install a mouse driver, and its utility software allows you to customize button actions \n*   (e.g., IntelliPoint and SetPoint), the middle (wheel) button, the 4th button, and the 5th button might not be set, \n*   even when they are pressed.\n* - On Linux (GTK), the 4th button and the 5th button are not supported.\n* - On Mac OS X 10.5 there is no platform API for implementing any advanced buttons.\n* \n* @class Phaser.DeviceButton\n* @constructor\n* @param {Phaser.Pointer|Phaser.SinglePad} parent - A reference to the parent of this button. Either a Pointer or a Gamepad.\n* @param {number} buttonCode - The button code this DeviceButton is responsible for.\n*/\nPhaser.DeviceButton = function (parent, buttonCode) {\n\n    /**\n    * @property {Phaser.Pointer|Phaser.SinglePad} parent - A reference to the Pointer or Gamepad that owns this button.\n    */\n    this.parent = parent;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = parent.game;\n\n    /**\n    * @property {object} event - The DOM event that caused the change in button state.\n    * @default\n    */\n    this.event = null;\n\n    /**\n    * @property {boolean} isDown - The \"down\" state of the button.\n    * @default\n    */\n    this.isDown = false;\n\n    /**\n    * @property {boolean} isUp - The \"up\" state of the button.\n    * @default\n    */\n    this.isUp = true;\n\n    /**\n    * @property {number} timeDown - The timestamp when the button was last pressed down.\n    * @default\n    */\n    this.timeDown = 0;\n\n    /**\n    * @property {number} timeUp - The timestamp when the button was last released.\n    * @default\n    */\n    this.timeUp = 0;\n\n    /**\n    * Gamepad only.\n    * If a button is held down this holds down the number of times the button has 'repeated'.\n    * @property {number} repeats\n    * @default\n    */\n    this.repeats = 0;\n\n    /**\n    * True if the alt key was held down when this button was last pressed or released.\n    * Not supported on Gamepads.\n    * @property {boolean} altKey\n    * @default\n    */\n    this.altKey = false;\n\n    /**\n    * True if the shift key was held down when this button was last pressed or released.\n    * Not supported on Gamepads.\n    * @property {boolean} shiftKey\n    * @default\n    */\n    this.shiftKey = false;\n\n    /**\n    * True if the control key was held down when this button was last pressed or released.\n    * Not supported on Gamepads.\n    * @property {boolean} ctrlKey\n    * @default\n    */\n    this.ctrlKey = false;\n\n    /**\n    * @property {number} value - Button value. Mainly useful for checking analog buttons (like shoulder triggers) on Gamepads.\n    * @default\n    */\n    this.value = 0;\n\n    /**\n    * @property {number} buttonCode - The buttoncode of this button if a Gamepad, or the DOM button event value if a Pointer.\n    */\n    this.buttonCode = buttonCode;\n\n    /**\n    * This Signal is dispatched every time this DeviceButton is pressed down.\n    * It is only dispatched once (until the button is released again).\n    * When dispatched it sends 2 arguments: A reference to this DeviceButton and the value of the button.\n    * @property {Phaser.Signal} onDown\n    */\n    this.onDown = new Phaser.Signal();\n\n    /**\n    * This Signal is dispatched every time this DeviceButton is released from a down state.\n    * It is only dispatched once (until the button is pressed again).\n    * When dispatched it sends 2 arguments: A reference to this DeviceButton and the value of the button.\n    * @property {Phaser.Signal} onUp\n    */\n    this.onUp = new Phaser.Signal();\n\n    /**\n    * Gamepad only.\n    * This Signal is dispatched every time this DeviceButton changes floating value (between, but not exactly, 0 and 1).\n    * When dispatched it sends 2 arguments: A reference to this DeviceButton and the value of the button.\n    * @property {Phaser.Signal} onFloat\n    */\n    this.onFloat = new Phaser.Signal();\n\n};\n\nPhaser.DeviceButton.prototype = {\n\n    /**\n    * Called automatically by Phaser.Pointer and Phaser.SinglePad.\n    * Handles the button down state.\n    * \n    * @method Phaser.DeviceButton#start\n    * @protected\n    * @param {object} [event] - The DOM event that triggered the button change.\n    * @param {number} [value] - The button value. Only get for Gamepads.\n    */\n    start: function (event, value) {\n\n        if (this.isDown)\n        {\n            return;\n        }\n\n        this.isDown = true;\n        this.isUp = false;\n        this.timeDown = this.game.time.time;\n        this.repeats = 0;\n\n        this.event = event;\n        this.value = value;\n\n        if (event)\n        {\n            this.altKey = event.altKey;\n            this.shiftKey = event.shiftKey;\n            this.ctrlKey = event.ctrlKey;\n        }\n\n        this.onDown.dispatch(this, value);\n\n    },\n\n    /**\n    * Called automatically by Phaser.Pointer and Phaser.SinglePad.\n    * Handles the button up state.\n    * \n    * @method Phaser.DeviceButton#stop\n    * @protected\n    * @param {object} [event] - The DOM event that triggered the button change.\n    * @param {number} [value] - The button value. Only get for Gamepads.\n    */\n    stop: function (event, value) {\n\n        if (this.isUp)\n        {\n            return;\n        }\n\n        this.isDown = false;\n        this.isUp = true;\n        this.timeUp = this.game.time.time;\n\n        this.event = event;\n        this.value = value;\n\n        if (event)\n        {\n            this.altKey = event.altKey;\n            this.shiftKey = event.shiftKey;\n            this.ctrlKey = event.ctrlKey;\n        }\n\n        this.onUp.dispatch(this, value);\n\n    },\n\n    /**\n    * Called automatically by Phaser.SinglePad.\n    * \n    * @method Phaser.DeviceButton#padFloat\n    * @protected\n    * @param {number} value - Button value\n    */\n    padFloat: function (value) {\n\n        this.value = value;\n\n        this.onFloat.dispatch(this, value);\n\n    },\n\n    /**\n    * Returns the \"just pressed\" state of this button.\n    * Just pressed is considered true if the button was pressed down within the duration given (default 250ms).\n    * \n    * @method Phaser.DeviceButton#justPressed\n    * @param {number} [duration=250] - The duration in ms below which the button is considered as being just pressed.\n    * @return {boolean} True if the button is just pressed otherwise false.\n    */\n    justPressed: function (duration) {\n\n        duration = duration || 250;\n\n        return (this.isDown && (this.timeDown + duration) > this.game.time.time);\n\n    },\n\n    /**\n    * Returns the \"just released\" state of this button.\n    * Just released is considered as being true if the button was released within the duration given (default 250ms).\n    * \n    * @method Phaser.DeviceButton#justReleased\n    * @param {number} [duration=250] - The duration in ms below which the button is considered as being just released.\n    * @return {boolean} True if the button is just released otherwise false.\n    */\n    justReleased: function (duration) {\n\n        duration = duration || 250;\n\n        return (this.isUp && (this.timeUp + duration) > this.game.time.time);\n\n    },\n\n    /**\n    * Resets this DeviceButton, changing it to an isUp state and resetting the duration and repeats counters.\n    * \n    * @method Phaser.DeviceButton#reset\n    */\n    reset: function () {\n\n        this.isDown = false;\n        this.isUp = true;\n\n        this.timeDown = this.game.time.time;\n        this.repeats = 0;\n\n        this.altKey = false;\n        this.shiftKey = false;\n        this.ctrlKey = false;\n\n    },\n\n    /**\n    * Destroys this DeviceButton, this disposes of the onDown, onUp and onFloat signals \n    * and clears the parent and game references.\n    * \n    * @method Phaser.DeviceButton#destroy\n    */\n    destroy: function () {\n\n        this.onDown.dispose();\n        this.onUp.dispose();\n        this.onFloat.dispose();\n\n        this.parent = null;\n        this.game = null;\n\n    }\n\n};\n\nPhaser.DeviceButton.prototype.constructor = Phaser.DeviceButton;\n\n/**\n* How long the button has been held down for in milliseconds.\n* If not currently down it returns -1.\n* \n* @name Phaser.DeviceButton#duration\n* @property {number} duration\n* @readonly\n*/\nObject.defineProperty(Phaser.DeviceButton.prototype, \"duration\", {\n\n    get: function () {\n\n        if (this.isUp)\n        {\n            return -1;\n        }\n\n        return this.game.time.time - this.timeDown;\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Pointer object is used by the Mouse, Touch and MSPoint managers and represents a single finger on the touch screen.\n*\n* @class Phaser.Pointer\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} id - The ID of the Pointer object within the game. Each game can have up to 10 active pointers.\n* @param {Phaser.PointerMode} pointerMode=(CURSOR|CONTACT) - The operational mode of this pointer, eg. CURSOR or TOUCH.\n*/\nPhaser.Pointer = function (game, id, pointerMode) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {number} id - The ID of the Pointer object within the game. Each game can have up to 10 active pointers.\n    */\n    this.id = id;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.POINTER;\n\n    /**\n    * @property {boolean} exists - A Pointer object that exists is allowed to be checked for physics collisions and overlaps.\n    * @default\n    */\n    this.exists = true;\n\n    /**\n    * @property {number} identifier - The identifier property of the Pointer as set by the DOM event when this Pointer is started.\n    * @default\n    */\n    this.identifier = 0;\n\n    /**\n    * @property {number} pointerId - The pointerId property of the Pointer as set by the DOM event when this Pointer is started. The browser can and will recycle this value.\n    * @default\n    */\n    this.pointerId = null;\n\n    /**\n    * @property {Phaser.PointerMode} pointerMode - The operational mode of this pointer.\n    */\n    this.pointerMode = pointerMode || (Phaser.PointerMode.CURSOR | Phaser.PointerMode.CONTACT);\n\n    /**\n    * @property {any} target - The target property of the Pointer as set by the DOM event when this Pointer is started.\n    * @default\n    */\n    this.target = null;\n\n    /**\n    * The button property of the most recent DOM event when this Pointer is started.\n    * You should not rely on this value for accurate button detection, instead use the Pointer properties\n    * `leftButton`, `rightButton`, `middleButton` and so on.\n    * @property {any} button\n    * @default\n    */\n    this.button = null;\n\n    /**\n    * If this Pointer is a Mouse or Pen / Stylus then you can access its left button directly through this property.\n    * \n    * The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\n    * button control.\n    * \n    * @property {Phaser.DeviceButton} leftButton\n    * @default\n    */\n    this.leftButton = new Phaser.DeviceButton(this, Phaser.Pointer.LEFT_BUTTON);\n\n    /**\n    * If this Pointer is a Mouse or Pen / Stylus then you can access its middle button directly through this property.\n    * \n    * The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\n    * button control.\n    *\n    * Please see the DeviceButton docs for details on browser button limitations.\n    * \n    * @property {Phaser.DeviceButton} middleButton\n    * @default\n    */\n    this.middleButton = new Phaser.DeviceButton(this, Phaser.Pointer.MIDDLE_BUTTON);\n\n    /**\n    * If this Pointer is a Mouse or Pen / Stylus then you can access its right button directly through this property.\n    * \n    * The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\n    * button control.\n    *\n    * Please see the DeviceButton docs for details on browser button limitations.\n    * \n    * @property {Phaser.DeviceButton} rightButton\n    * @default\n    */\n    this.rightButton = new Phaser.DeviceButton(this, Phaser.Pointer.RIGHT_BUTTON);\n\n    /**\n    * If this Pointer is a Mouse or Pen / Stylus then you can access its X1 (back) button directly through this property.\n    * \n    * The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\n    * button control.\n    *\n    * Please see the DeviceButton docs for details on browser button limitations.\n    * \n    * @property {Phaser.DeviceButton} backButton\n    * @default\n    */\n    this.backButton = new Phaser.DeviceButton(this, Phaser.Pointer.BACK_BUTTON);\n\n    /**\n    * If this Pointer is a Mouse or Pen / Stylus then you can access its X2 (forward) button directly through this property.\n    * \n    * The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\n    * button control.\n    *\n    * Please see the DeviceButton docs for details on browser button limitations.\n    * \n    * @property {Phaser.DeviceButton} forwardButton\n    * @default\n    */\n    this.forwardButton = new Phaser.DeviceButton(this, Phaser.Pointer.FORWARD_BUTTON);\n\n    /**\n    * If this Pointer is a Pen / Stylus then you can access its eraser button directly through this property.\n    * \n    * The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\n    * button control.\n    *\n    * Please see the DeviceButton docs for details on browser button limitations.\n    * \n    * @property {Phaser.DeviceButton} eraserButton\n    * @default\n    */\n    this.eraserButton = new Phaser.DeviceButton(this, Phaser.Pointer.ERASER_BUTTON);\n\n    /**\n    * @property {boolean} _holdSent - Local private variable to store the status of dispatching a hold event.\n    * @private\n    * @default\n    */\n    this._holdSent = false;\n\n    /**\n    * @property {array} _history - Local private variable storing the short-term history of pointer movements.\n    * @private\n    */\n    this._history = [];\n\n    /**\n    * @property {number} _nextDrop - Local private variable storing the time at which the next history drop should occur.\n    * @private\n    */\n    this._nextDrop = 0;\n\n    /**\n    * @property {boolean} _stateReset - Monitor events outside of a state reset loop.\n    * @private\n    */\n    this._stateReset = false;\n\n    /**\n    * @property {boolean} withinGame - true if the Pointer is over the game canvas, otherwise false.\n    */\n    this.withinGame = false;\n\n    /**\n    * @property {number} clientX - The horizontal coordinate of the Pointer within the application's client area at which the event occurred (as opposed to the coordinates within the page).\n    */\n    this.clientX = -1;\n\n    /**\n    * @property {number} clientY - The vertical coordinate of the Pointer within the application's client area at which the event occurred (as opposed to the coordinates within the page).\n    */\n    this.clientY = -1;\n\n    /**\n    * @property {number} pageX - The horizontal coordinate of the Pointer relative to whole document.\n    */\n    this.pageX = -1;\n\n    /**\n    * @property {number} pageY - The vertical coordinate of the Pointer relative to whole document.\n    */\n    this.pageY = -1;\n\n    /**\n    * @property {number} screenX - The horizontal coordinate of the Pointer relative to the screen.\n    */\n    this.screenX = -1;\n\n    /**\n    * @property {number} screenY - The vertical coordinate of the Pointer relative to the screen.\n    */\n    this.screenY = -1;\n\n    /**\n    * @property {number} rawMovementX - The horizontal raw relative movement of the Pointer in pixels since last event.\n    * @default\n    */\n    this.rawMovementX = 0;\n\n    /**\n    * @property {number} rawMovementY - The vertical raw relative movement of the Pointer in pixels since last event.\n    * @default\n    */\n    this.rawMovementY = 0;\n\n    /**\n    * @property {number} movementX - The horizontal processed relative movement of the Pointer in pixels since last event.\n    * @default\n    */\n    this.movementX = 0;\n\n    /**\n    * @property {number} movementY - The vertical processed relative movement of the Pointer in pixels since last event.\n    * @default\n    */\n    this.movementY = 0;\n\n    /**\n    * @property {number} x - The horizontal coordinate of the Pointer. This value is automatically scaled based on the game scale.\n    * @default\n    */\n    this.x = -1;\n\n    /**\n    * @property {number} y - The vertical coordinate of the Pointer. This value is automatically scaled based on the game scale.\n    * @default\n    */\n    this.y = -1;\n\n    /**\n    * @property {boolean} isMouse - If the Pointer is a mouse or pen / stylus this is true, otherwise false.\n    */\n    this.isMouse = (id === 0);\n\n    /**\n    * If the Pointer is touching the touchscreen, or *any* mouse or pen button is held down, isDown is set to true.\n    * If you need to check a specific mouse or pen button then use the button properties, i.e. Pointer.rightButton.isDown.\n    * @property {boolean} isDown\n    * @default\n    */\n    this.isDown = false;\n\n    /**\n    * If the Pointer is not touching the touchscreen, or *all* mouse or pen buttons are up, isUp is set to true.\n    * If you need to check a specific mouse or pen button then use the button properties, i.e. Pointer.rightButton.isUp.\n    * @property {boolean} isUp\n    * @default\n    */\n    this.isUp = true;\n\n    /**\n    * @property {number} timeDown - A timestamp representing when the Pointer first touched the touchscreen.\n    * @default\n    */\n    this.timeDown = 0;\n\n    /**\n    * @property {number} timeUp - A timestamp representing when the Pointer left the touchscreen.\n    * @default\n    */\n    this.timeUp = 0;\n\n    /**\n    * @property {number} previousTapTime - A timestamp representing when the Pointer was last tapped or clicked.\n    * @default\n    */\n    this.previousTapTime = 0;\n\n    /**\n    * @property {number} totalTouches - The total number of times this Pointer has been touched to the touchscreen.\n    * @default\n    */\n    this.totalTouches = 0;\n\n    /**\n    * @property {number} msSinceLastClick - The number of milliseconds since the last click or touch event.\n    * @default\n    */\n    this.msSinceLastClick = Number.MAX_VALUE;\n\n    /**\n    * @property {any} targetObject - The Game Object this Pointer is currently over / touching / dragging.\n    * @default\n    */\n    this.targetObject = null;\n\n    /**\n    * This array is erased and re-populated every time this Pointer is updated. It contains references to all\n    * of the Game Objects that were considered as being valid for processing by this Pointer, this frame. To be\n    * valid they must have suitable a `priorityID`, be Input enabled, visible and actually have the Pointer over\n    * them. You can check the contents of this array in events such as `onInputDown`, but beware it is reset\n    * every frame.\n    * @property {array} interactiveCandidates\n    * @default\n    */\n    this.interactiveCandidates = [];\n\n    /**\n    * @property {boolean} active - An active pointer is one that is currently pressed down on the display. A Mouse is always active.\n    * @default\n    */\n    this.active = false;\n\n    /**\n    * @property {boolean} dirty - A dirty pointer needs to re-poll any interactive objects it may have been over, regardless if it has moved or not.\n    * @default\n    */\n    this.dirty = false;\n\n    /**\n    * @property {Phaser.Point} position - A Phaser.Point object containing the current x/y values of the pointer on the display.\n    */\n    this.position = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} positionDown - A Phaser.Point object containing the x/y values of the pointer when it was last in a down state on the display.\n    */\n    this.positionDown = new Phaser.Point();\n    \n    /**\n    * @property {Phaser.Point} positionUp - A Phaser.Point object containing the x/y values of the pointer when it was last released.\n    */\n    this.positionUp = new Phaser.Point();\n\n    /**\n    * A Phaser.Circle that is centered on the x/y coordinates of this pointer, useful for hit detection.\n    * The Circle size is 44px (Apples recommended \"finger tip\" size).\n    * @property {Phaser.Circle} circle\n    */\n    this.circle = new Phaser.Circle(0, 0, 44);\n\n    /**\n    * Click trampolines associated with this pointer. See `addClickTrampoline`.\n    * @property {object[]|null} _clickTrampolines\n    * @private\n    */\n    this._clickTrampolines = null;\n\n    /**\n    * When the Pointer has click trampolines the last target object is stored here\n    * so it can be used to check for validity of the trampoline in a post-Up/'stop'.\n    * @property {object} _trampolineTargetObject\n    * @private\n    */\n    this._trampolineTargetObject = null;\n\n};\n\n/**\n* No buttons at all.\n* @constant\n* @type {number}\n*/\nPhaser.Pointer.NO_BUTTON = 0;\n\n/**\n* The Left Mouse button, or in PointerEvent devices a Touch contact or Pen contact.\n* @constant\n* @type {number}\n*/\nPhaser.Pointer.LEFT_BUTTON = 1;\n\n/**\n* The Right Mouse button, or in PointerEvent devices a Pen contact with a barrel button.\n* @constant\n* @type {number}\n*/\nPhaser.Pointer.RIGHT_BUTTON = 2;\n\n/**\n* The Middle Mouse button.\n* @constant\n* @type {number}\n*/\nPhaser.Pointer.MIDDLE_BUTTON = 4;\n\n/**\n* The X1 button. This is typically the mouse Back button, but is often reconfigured.\n* On Linux (GTK) this is unsupported. On Windows if advanced pointer software (such as IntelliPoint) is installed this doesn't register.\n* @constant\n* @type {number}\n*/\nPhaser.Pointer.BACK_BUTTON = 8;\n\n/**\n* The X2 button. This is typically the mouse Forward button, but is often reconfigured.\n* On Linux (GTK) this is unsupported. On Windows if advanced pointer software (such as IntelliPoint) is installed this doesn't register.\n* @constant\n* @type {number}\n*/\nPhaser.Pointer.FORWARD_BUTTON = 16;\n\n/**\n* The Eraser pen button on PointerEvent supported devices only.\n* @constant\n* @type {number}\n*/\nPhaser.Pointer.ERASER_BUTTON = 32;\n\nPhaser.Pointer.prototype = {\n\n    /**\n    * Resets the states of all the button booleans.\n    * \n    * @method Phaser.Pointer#resetButtons\n    * @protected\n    */\n    resetButtons: function () {\n\n        this.isDown = false;\n        this.isUp = true;\n\n        if (this.isMouse)\n        {\n            this.leftButton.reset();\n            this.middleButton.reset();\n            this.rightButton.reset();\n            this.backButton.reset();\n            this.forwardButton.reset();\n            this.eraserButton.reset();\n        }\n\n    },\n\n    /**\n    * Called by updateButtons.\n    * \n    * @method Phaser.Pointer#processButtonsDown\n    * @private\n    * @param {integer} buttons - The DOM event.buttons property.\n    * @param {MouseEvent} event - The DOM event.\n    */\n    processButtonsDown: function (buttons, event) {\n\n        //  Note: These are bitwise checks, not booleans\n\n        if (Phaser.Pointer.LEFT_BUTTON & buttons)\n        {\n            this.leftButton.start(event);\n        }\n\n        if (Phaser.Pointer.RIGHT_BUTTON & buttons)\n        {\n            this.rightButton.start(event);\n        }\n                \n        if (Phaser.Pointer.MIDDLE_BUTTON & buttons)\n        {\n            this.middleButton.start(event);\n        }\n\n        if (Phaser.Pointer.BACK_BUTTON & buttons)\n        {\n            this.backButton.start(event);\n        }\n\n        if (Phaser.Pointer.FORWARD_BUTTON & buttons)\n        {\n            this.forwardButton.start(event);\n        }\n\n        if (Phaser.Pointer.ERASER_BUTTON & buttons)\n        {\n            this.eraserButton.start(event);\n        }\n\n    },\n\n    /**\n    * Called by updateButtons.\n    * \n    * @method Phaser.Pointer#processButtonsUp\n    * @private\n    * @param {integer} buttons - The DOM event.buttons property.\n    * @param {MouseEvent} event - The DOM event.\n    */\n    processButtonsUp: function (button, event) {\n\n        //  Note: These are bitwise checks, not booleans\n\n        if (button === Phaser.Mouse.LEFT_BUTTON)\n        {\n            this.leftButton.stop(event);\n        }\n\n        if (button === Phaser.Mouse.RIGHT_BUTTON)\n        {\n            this.rightButton.stop(event);\n        }\n                \n        if (button === Phaser.Mouse.MIDDLE_BUTTON)\n        {\n            this.middleButton.stop(event);\n        }\n\n        if (button === Phaser.Mouse.BACK_BUTTON)\n        {\n            this.backButton.stop(event);\n        }\n\n        if (button === Phaser.Mouse.FORWARD_BUTTON)\n        {\n            this.forwardButton.stop(event);\n        }\n\n        if (button === 5)\n        {\n            this.eraserButton.stop(event);\n        }\n\n    },\n\n    /**\n    * Called when the event.buttons property changes from zero.\n    * Contains a button bitmask.\n    * \n    * @method Phaser.Pointer#updateButtons\n    * @protected\n    * @param {MouseEvent} event - The DOM event.\n    */\n    updateButtons: function (event) {\n\n        this.button = event.button;\n\n        var down = (event.type.toLowerCase().substr(-4) === 'down');\n\n        if (event.buttons !== undefined)\n        {\n            if (down)\n            {\n                this.processButtonsDown(event.buttons, event);\n            }\n            else\n            {\n                this.processButtonsUp(event.button, event);\n            }\n        }\n        else\n        {\n            //  No buttons property (like Safari on OSX when using a trackpad)\n            if (down)\n            {\n                this.leftButton.start(event);\n            }\n            else\n            {\n                this.leftButton.stop(event);\n                this.rightButton.stop(event);\n            }\n        }\n\n        //  On OS X (and other devices with trackpads) you have to press CTRL + the pad\n        //  to initiate a right-click event, so we'll check for that here ONLY if\n        //  event.buttons = 1 (i.e. they only have a 1 button mouse or trackpad)\n\n        if (event.buttons === 1 && event.ctrlKey && this.leftButton.isDown)\n        {\n            this.leftButton.stop(event);\n            this.rightButton.start(event);\n        }\n\n        this.isUp = true;\n        this.isDown = false;\n\n        if (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown)\n        {\n            this.isUp = false;\n            this.isDown = true;\n        }\n\n    },\n\n    /**\n    * Called when the Pointer is pressed onto the touchscreen.\n    * @method Phaser.Pointer#start\n    * @param {any} event - The DOM event from the browser.\n    */\n    start: function (event) {\n\n        var input = this.game.input;\n\n        if (event['pointerId'])\n        {\n            this.pointerId = event.pointerId;\n        }\n\n        this.identifier = event.identifier;\n        this.target = event.target;\n\n        if (this.isMouse)\n        {\n            this.updateButtons(event);\n        }\n        else\n        {\n            this.isDown = true;\n            this.isUp = false;\n        }\n\n        this.active = true;\n        this.withinGame = true;\n        this.dirty = false;\n\n        this._history = [];\n        this._clickTrampolines = null;\n        this._trampolineTargetObject = null;\n\n        //  Work out how long it has been since the last click\n        this.msSinceLastClick = this.game.time.time - this.timeDown;\n        this.timeDown = this.game.time.time;\n        this._holdSent = false;\n\n        //  This sets the x/y and other local values\n        this.move(event, true);\n\n        // x and y are the old values here?\n        this.positionDown.setTo(this.x, this.y);\n\n        if (input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH ||\n            input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE ||\n            (input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && input.totalActivePointers === 0))\n        {\n            input.x = this.x;\n            input.y = this.y;\n            input.position.setTo(this.x, this.y);\n            input.onDown.dispatch(this, event);\n            input.resetSpeed(this.x, this.y);\n        }\n\n        this._stateReset = false;\n\n        this.totalTouches++;\n\n        if (this.targetObject !== null)\n        {\n            this.targetObject._touchedHandler(this);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Called by the Input Manager.\n    * @method Phaser.Pointer#update\n    */\n    update: function () {\n\n        var input = this.game.input;\n\n        if (this.active)\n        {\n            //  Force a check?\n            if (this.dirty)\n            {\n                if (input.interactiveItems.total > 0)\n                {\n                    this.processInteractiveObjects(false);\n                }\n\n                this.dirty = false;\n            }\n\n            if (this._holdSent === false && this.duration >= input.holdRate)\n            {\n                if (input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH ||\n                    input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE ||\n                    (input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && input.totalActivePointers === 0))\n                {\n                    input.onHold.dispatch(this);\n                }\n\n                this._holdSent = true;\n            }\n\n            //  Update the droppings history\n            if (input.recordPointerHistory && this.game.time.time >= this._nextDrop)\n            {\n                this._nextDrop = this.game.time.time + input.recordRate;\n\n                this._history.push({\n                    x: this.position.x,\n                    y: this.position.y\n                });\n\n                if (this._history.length > input.recordLimit)\n                {\n                    this._history.shift();\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Called when the Pointer is moved.\n    * \n    * @method Phaser.Pointer#move\n    * @param {MouseEvent|PointerEvent|TouchEvent} event - The event passed up from the input handler.\n    * @param {boolean} [fromClick=false] - Was this called from the click event?\n    */\n    move: function (event, fromClick) {\n\n        var input = this.game.input;\n\n        if (input.pollLocked)\n        {\n            return;\n        }\n\n        if (fromClick === undefined) { fromClick = false; }\n\n        if (event.button !== undefined)\n        {\n            this.button = event.button;\n        }\n\n        if (fromClick && this.isMouse)\n        {\n            this.updateButtons(event);\n        }\n\n        this.clientX = event.clientX;\n        this.clientY = event.clientY;\n\n        this.pageX = event.pageX;\n        this.pageY = event.pageY;\n\n        this.screenX = event.screenX;\n        this.screenY = event.screenY;\n\n        if (this.isMouse && input.mouse.locked && !fromClick)\n        {\n            this.rawMovementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\n            this.rawMovementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\n\n            this.movementX += this.rawMovementX;\n            this.movementY += this.rawMovementY;\n        }\n\n        this.x = (this.pageX - this.game.scale.offset.x) * input.scale.x;\n        this.y = (this.pageY - this.game.scale.offset.y) * input.scale.y;\n\n        this.position.setTo(this.x, this.y);\n        this.circle.x = this.x;\n        this.circle.y = this.y;\n\n        if (input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH ||\n            input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE ||\n            (input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && input.totalActivePointers === 0))\n        {\n            input.activePointer = this;\n            input.x = this.x;\n            input.y = this.y;\n            input.position.setTo(input.x, input.y);\n            input.circle.x = input.x;\n            input.circle.y = input.y;\n        }\n\n        this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);\n\n        //  If the game is paused we don't process any target objects or callbacks\n        if (this.game.paused)\n        {\n            return this;\n        }\n\n        var i = input.moveCallbacks.length;\n\n        while (i--)\n        {\n            input.moveCallbacks[i].callback.call(input.moveCallbacks[i].context, this, this.x, this.y, fromClick);\n        }\n\n        //  Easy out if we're dragging something and it still exists\n        if (this.targetObject !== null && this.targetObject.isDragged === true)\n        {\n            if (this.targetObject.update(this) === false)\n            {\n                this.targetObject = null;\n            }\n        }\n        else if (input.interactiveItems.total > 0)\n        {\n            this.processInteractiveObjects(fromClick);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Process all interactive objects to find out which ones were updated in the recent Pointer move.\n    * \n    * @method Phaser.Pointer#processInteractiveObjects\n    * @protected\n    * @param {boolean} [fromClick=false] - Was this called from the click event?\n    * @return {boolean} True if this method processes an object (i.e. a Sprite becomes the Pointers currentTarget), otherwise false.\n    */\n    processInteractiveObjects: function (fromClick) {\n\n        //  Work out which object is on the top\n        var highestRenderOrderID = 0;\n        var highestInputPriorityID = -1;\n        var candidateTarget = null;\n\n        //  First pass gets all objects that the pointer is over that DON'T use pixelPerfect checks and get the highest ID\n        //  We know they'll be valid for input detection but not which is the top just yet\n\n        var currentNode = this.game.input.interactiveItems.first;\n\n        this.interactiveCandidates = [];\n\n        while (currentNode)\n        {\n            //  Reset checked status\n            currentNode.checked = false;\n\n            if (currentNode.validForInput(highestInputPriorityID, highestRenderOrderID, false))\n            {\n                //  Flag it as checked so we don't re-scan it on the next phase\n                currentNode.checked = true;\n\n                if ((fromClick && currentNode.checkPointerDown(this, true)) ||\n                    (!fromClick && currentNode.checkPointerOver(this, true)))\n                {\n                    highestRenderOrderID = currentNode.sprite.renderOrderID;\n                    highestInputPriorityID = currentNode.priorityID;\n                    candidateTarget = currentNode;\n                    this.interactiveCandidates.push(currentNode);\n                }\n            }\n\n            currentNode = this.game.input.interactiveItems.next;\n        }\n\n        //  Then in the second sweep we process ONLY the pixel perfect ones that are checked and who have a higher ID\n        //  because if their ID is lower anyway then we can just automatically discount them\n        //  (A node that was previously checked did not request a pixel-perfect check.)\n\n        currentNode = this.game.input.interactiveItems.first;\n\n        while (currentNode)\n        {\n            if (!currentNode.checked &&\n                currentNode.validForInput(highestInputPriorityID, highestRenderOrderID, true))\n            {\n                if ((fromClick && currentNode.checkPointerDown(this, false)) ||\n                    (!fromClick && currentNode.checkPointerOver(this, false)))\n                {\n                    highestRenderOrderID = currentNode.sprite.renderOrderID;\n                    highestInputPriorityID = currentNode.priorityID;\n                    candidateTarget = currentNode;\n                    this.interactiveCandidates.push(currentNode);\n                }\n            }\n\n            currentNode = this.game.input.interactiveItems.next;\n        }\n\n        if (this.game.input.customCandidateHandler)\n        {\n            candidateTarget = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, candidateTarget);\n        }\n\n        this.swapTarget(candidateTarget, false);\n\n        return (this.targetObject !== null);\n\n    },\n\n    /**\n    * This will change the `Pointer.targetObject` object to be the one provided.\n    * \n    * This allows you to have fine-grained control over which object the Pointer is targeting.\n    *\n    * Note that even if you set a new Target here, it is still able to be replaced by any other valid\n    * target during the next Pointer update.\n    *\n    * @method Phaser.Pointer#swapTarget\n    * @param {Phaser.InputHandler} newTarget - The new target for this Pointer. Note this is an `InputHandler`, so don't pass a Sprite, instead pass `sprite.input` to it.\n    * @param {boolean} [silent=false] - If true the new target AND the old one will NOT dispatch their `onInputOver` or `onInputOut` events.\n    */\n    swapTarget: function (newTarget, silent) {\n\n        if (silent === undefined) { silent = false; }\n\n        //  Now we know the top-most item (if any) we can process it\n        if (newTarget === null)\n        {\n            //  The pointer isn't currently over anything, check if we've got a lingering previous target\n            if (this.targetObject)\n            {\n                this.targetObject._pointerOutHandler(this, silent);\n                this.targetObject = null;\n            }\n        }\n        else\n        {\n            if (this.targetObject === null)\n            {\n                //  And now set the new one\n                this.targetObject = newTarget;\n                newTarget._pointerOverHandler(this, silent);\n            }\n            else\n            {\n                //  We've got a target from the last update\n                if (this.targetObject === newTarget)\n                {\n                    //  Same target as before, so update it\n                    if (newTarget.update(this) === false)\n                    {\n                        this.targetObject = null;\n                    }\n                }\n                else\n                {\n                    //  The target has changed, so tell the old one we've left it\n                    this.targetObject._pointerOutHandler(this, silent);\n\n                    //  And now set the new one\n                    this.targetObject = newTarget;\n                    this.targetObject._pointerOverHandler(this, silent);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Called when the Pointer leaves the target area.\n    *\n    * @method Phaser.Pointer#leave\n    * @param {MouseEvent|PointerEvent|TouchEvent} event - The event passed up from the input handler.\n    */\n    leave: function (event) {\n\n        this.withinGame = false;\n        this.move(event, false);\n\n    },\n\n    /**\n    * Called when the Pointer leaves the touchscreen.\n    *\n    * @method Phaser.Pointer#stop\n    * @param {MouseEvent|PointerEvent|TouchEvent} event - The event passed up from the input handler.\n    */\n    stop: function (event) {\n\n        var input = this.game.input;\n\n        if (this._stateReset && this.withinGame)\n        {\n            event.preventDefault();\n            return;\n        }\n\n        this.timeUp = this.game.time.time;\n\n        if (input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH ||\n            input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE ||\n            (input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && input.totalActivePointers === 0))\n        {\n            input.onUp.dispatch(this, event);\n\n            //  Was it a tap?\n            if (this.duration >= 0 && this.duration <= input.tapRate)\n            {\n                //  Was it a double-tap?\n                if (this.timeUp - this.previousTapTime < input.doubleTapRate)\n                {\n                    //  Yes, let's dispatch the signal then with the 2nd parameter set to true\n                    input.onTap.dispatch(this, true);\n                }\n                else\n                {\n                    //  Wasn't a double-tap, so dispatch a single tap signal\n                    input.onTap.dispatch(this, false);\n                }\n\n                this.previousTapTime = this.timeUp;\n            }\n        }\n\n        if (this.isMouse)\n        {\n            this.updateButtons(event);\n        }\n        else\n        {\n            this.isDown = false;\n            this.isUp = true;\n        }\n\n        //  Mouse is always active\n        if (this.id > 0)\n        {\n            this.active = false;\n        }\n\n        this.withinGame = this.game.scale.bounds.contains(event.pageX, event.pageY);\n        this.pointerId = null;\n        this.identifier = null;\n        \n        this.positionUp.setTo(this.x, this.y);\n        \n        if (this.isMouse === false)\n        {\n            input.currentPointers--;\n        }\n\n        input.interactiveItems.callAll('_releasedHandler', this);\n\n        if (this._clickTrampolines)\n        {\n            this._trampolineTargetObject = this.targetObject;\n        }\n\n        this.targetObject = null;\n\n        return this;\n\n    },\n\n    /**\n    * The Pointer is considered justPressed if the time it was pressed onto the touchscreen or clicked is less than justPressedRate.\n    * Note that calling justPressed doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.\n    * If you wish to check if the Pointer was pressed down just once then see the Sprite.events.onInputDown event.\n    * @method Phaser.Pointer#justPressed\n    * @param {number} [duration] - The time to check against. If none given it will use InputManager.justPressedRate.\n    * @return {boolean} true if the Pointer was pressed down within the duration given.\n    */\n    justPressed: function (duration) {\n\n        duration = duration || this.game.input.justPressedRate;\n\n        return (this.isDown === true && (this.timeDown + duration) > this.game.time.time);\n\n    },\n\n    /**\n    * The Pointer is considered justReleased if the time it left the touchscreen is less than justReleasedRate.\n    * Note that calling justReleased doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.\n    * If you wish to check if the Pointer was released just once then see the Sprite.events.onInputUp event.\n    * @method Phaser.Pointer#justReleased\n    * @param {number} [duration] - The time to check against. If none given it will use InputManager.justReleasedRate.\n    * @return {boolean} true if the Pointer was released within the duration given.\n    */\n    justReleased: function (duration) {\n\n        duration = duration || this.game.input.justReleasedRate;\n\n        return (this.isUp && (this.timeUp + duration) > this.game.time.time);\n\n    },\n\n    /**\n    * Add a click trampoline to this pointer.\n    *\n    * A click trampoline is a callback that is run on the DOM 'click' event; this is primarily\n    * needed with certain browsers (ie. IE11) which restrict some actions like requestFullscreen\n    * to the DOM 'click' event and rejects it for 'pointer*' and 'mouse*' events.\n    *\n    * This is used internally by the ScaleManager; click trampoline usage is uncommon.\n    * Click trampolines can only be added to pointers that are currently down.\n    *\n    * @method Phaser.Pointer#addClickTrampoline\n    * @protected\n    * @param {string} name - The name of the trampoline; must be unique among active trampolines in this pointer.\n    * @param {function} callback - Callback to run/trampoline.\n    * @param {object} callbackContext - Context of the callback.\n    * @param {object[]|null} callbackArgs - Additional callback args, if any. Supplied as an array.\n    */\n    addClickTrampoline: function (name, callback, callbackContext, callbackArgs) {\n\n        if (!this.isDown)\n        {\n            return;\n        }\n\n        var trampolines = (this._clickTrampolines = this._clickTrampolines || []);\n\n        for (var i = 0; i < trampolines.length; i++)\n        {\n            if (trampolines[i].name === name)\n            {\n                trampolines.splice(i, 1);\n                break;\n            }\n        }\n\n        trampolines.push({\n            name: name,\n            targetObject: this.targetObject,\n            callback: callback,\n            callbackContext: callbackContext,\n            callbackArgs: callbackArgs\n        });\n\n    },\n\n    /**\n    * Fire all click trampolines for which the pointers are still referring to the registered object.\n    * @method Phaser.Pointer#processClickTrampolines\n    * @private\n    */\n    processClickTrampolines: function () {\n\n        var trampolines = this._clickTrampolines;\n\n        if (!trampolines)\n        {\n            return;\n        }\n\n        for (var i = 0; i < trampolines.length; i++)\n        {\n            var trampoline = trampolines[i];\n\n            if (trampoline.targetObject === this._trampolineTargetObject)\n            {\n                trampoline.callback.apply(trampoline.callbackContext, trampoline.callbackArgs);\n            }\n        }\n\n        this._clickTrampolines = null;\n        this._trampolineTargetObject = null;\n\n    },\n\n    /**\n    * Resets the Pointer properties. Called by InputManager.reset when you perform a State change.\n    * @method Phaser.Pointer#reset\n    */\n    reset: function () {\n\n        if (this.isMouse === false)\n        {\n            this.active = false;\n        }\n\n        this.pointerId = null;\n        this.identifier = null;\n        this.dirty = false;\n        this.totalTouches = 0;\n        this._holdSent = false;\n        this._history.length = 0;\n        this._stateReset = true;\n\n        this.resetButtons();\n\n        if (this.targetObject)\n        {\n            this.targetObject._releasedHandler(this);\n        }\n\n        this.targetObject = null;\n\n    },\n\n    /**\n     * Resets the movementX and movementY properties. Use in your update handler after retrieving the values.\n     * @method Phaser.Pointer#resetMovement\n     */\n    resetMovement: function() {\n\n        this.movementX = 0;\n        this.movementY = 0;\n\n    }\n\n};\n\nPhaser.Pointer.prototype.constructor = Phaser.Pointer;\n\n/**\n* How long the Pointer has been depressed on the touchscreen or *any* of the mouse buttons have been held down.\n* If not currently down it returns -1.\n* If you need to test a specific mouse or pen button then access the buttons directly, i.e. `Pointer.rightButton.duration`.\n* \n* @name Phaser.Pointer#duration\n* @property {number} duration\n* @readonly\n*/\nObject.defineProperty(Phaser.Pointer.prototype, \"duration\", {\n\n    get: function () {\n\n        if (this.isUp)\n        {\n            return -1;\n        }\n\n        return this.game.time.time - this.timeDown;\n\n    }\n\n});\n\n/**\n* Gets the X value of this Pointer in world coordinates based on the world camera.\n* @name Phaser.Pointer#worldX\n* @property {number} worldX - The X value of this Pointer in world coordinates based on the world camera.\n* @readonly\n*/\nObject.defineProperty(Phaser.Pointer.prototype, \"worldX\", {\n\n    get: function () {\n\n        return this.game.world.camera.x + this.x;\n\n    }\n\n});\n\n/**\n* Gets the Y value of this Pointer in world coordinates based on the world camera.\n* @name Phaser.Pointer#worldY\n* @property {number} worldY - The Y value of this Pointer in world coordinates based on the world camera.\n* @readonly\n*/\nObject.defineProperty(Phaser.Pointer.prototype, \"worldY\", {\n\n    get: function () {\n\n        return this.game.world.camera.y + this.y;\n\n    }\n\n});\n\n/**\n* Enumeration categorizing operational modes of pointers.\n*\n* PointerType values represent valid bitmasks.\n* For example, a value representing both Mouse and Touch devices\n* can be expressed as `PointerMode.CURSOR | PointerMode.CONTACT`.\n*\n* Values may be added for future mode categorizations.\n* @class Phaser.PointerMode\n*/\nPhaser.PointerMode = {\n\n    /**\n    * A 'CURSOR' is a pointer with a *passive cursor* such as a mouse, touchpad, watcom stylus, or even TV-control arrow-pad.\n    *\n    * It has the property that a cursor is passively moved without activating the input.\n    * This currently corresponds with {@link Phaser.Pointer#isMouse} property.\n    * @constant\n    */\n    CURSOR: 1 << 0,\n\n    /**\n    * A 'CONTACT' pointer has an *active cursor* that only tracks movement when actived; notably this is a touch-style input.\n    * @constant\n    */\n    CONTACT: 1 << 1\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Touch handles touch events with your game. Note: Android 2.x only supports 1 touch event at once, no multi-touch.\n*\n* You should not normally access this class directly, but instead use a Phaser.Pointer object which normalises all game input for you.\n*\n* @class Phaser.Touch\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Touch = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * Touch events will only be processed if enabled.\n    * @property {boolean} enabled\n    * @default\n    */\n    this.enabled = true;\n\n    /**\n    * An array of callbacks that will be fired every time a native touch start or touch end event is received from the browser.\n    * This is used internally to handle audio and video unlocking on mobile devices.\n    * To add a callback to this array please use `Touch.addTouchLockCallback`.\n    * @property {array} touchLockCallbacks\n    * @protected\n    */\n    this.touchLockCallbacks = [];\n\n    /**\n    * @property {object} callbackContext - The context under which callbacks are called.\n    */\n    this.callbackContext = this.game;\n\n    /**\n    * @property {function} touchStartCallback - A callback that can be fired on a touchStart event.\n    */\n    this.touchStartCallback = null;\n\n    /**\n    * @property {function} touchMoveCallback - A callback that can be fired on a touchMove event.\n    */\n    this.touchMoveCallback = null;\n\n    /**\n    * @property {function} touchEndCallback - A callback that can be fired on a touchEnd event.\n    */\n    this.touchEndCallback = null;\n\n    /**\n    * @property {function} touchEnterCallback - A callback that can be fired on a touchEnter event.\n    */\n    this.touchEnterCallback = null;\n\n    /**\n    * @property {function} touchLeaveCallback - A callback that can be fired on a touchLeave event.\n    */\n    this.touchLeaveCallback = null;\n\n    /**\n    * @property {function} touchCancelCallback - A callback that can be fired on a touchCancel event.\n    */\n    this.touchCancelCallback = null;\n\n    /**\n    * @property {boolean} preventDefault - If true the TouchEvent will have prevent.default called on it.\n    * @default\n    */\n    this.preventDefault = true;\n\n    /**\n    * @property {TouchEvent} event - The browser touch DOM event. Will be set to null if no touch event has ever been received.\n    * @default\n    */\n    this.event = null;\n\n    /**\n    * @property {function} _onTouchStart - Internal event handler reference.\n    * @private\n    */\n    this._onTouchStart = null;\n\n    /**\n    * @property {function} _onTouchMove - Internal event handler reference.\n    * @private\n    */\n    this._onTouchMove = null;\n\n    /**\n    * @property {function} _onTouchEnd - Internal event handler reference.\n    * @private\n    */\n    this._onTouchEnd = null;\n\n    /**\n    * @property {function} _onTouchEnter - Internal event handler reference.\n    * @private\n    */\n    this._onTouchEnter = null;\n\n    /**\n    * @property {function} _onTouchLeave - Internal event handler reference.\n    * @private\n    */\n    this._onTouchLeave = null;\n\n    /**\n    * @property {function} _onTouchCancel - Internal event handler reference.\n    * @private\n    */\n    this._onTouchCancel = null;\n\n    /**\n    * @property {function} _onTouchMove - Internal event handler reference.\n    * @private\n    */\n    this._onTouchMove = null;\n\n};\n\nPhaser.Touch.prototype = {\n\n    /**\n    * Starts the event listeners running.\n    * @method Phaser.Touch#start\n    */\n    start: function () {\n\n        if (this._onTouchStart !== null)\n        {\n            //  Avoid setting multiple listeners\n            return;\n        }\n\n        var _this = this;\n\n        if (this.game.device.touch)\n        {\n            this._onTouchStart = function (event) {\n                return _this.onTouchStart(event);\n            };\n\n            this._onTouchMove = function (event) {\n                return _this.onTouchMove(event);\n            };\n\n            this._onTouchEnd = function (event) {\n                return _this.onTouchEnd(event);\n            };\n\n            this._onTouchEnter = function (event) {\n                return _this.onTouchEnter(event);\n            };\n\n            this._onTouchLeave = function (event) {\n                return _this.onTouchLeave(event);\n            };\n\n            this._onTouchCancel = function (event) {\n                return _this.onTouchCancel(event);\n            };\n\n            this.game.canvas.addEventListener('touchstart', this._onTouchStart, false);\n            this.game.canvas.addEventListener('touchmove', this._onTouchMove, false);\n            this.game.canvas.addEventListener('touchend', this._onTouchEnd, false);\n            this.game.canvas.addEventListener('touchcancel', this._onTouchCancel, false);\n\n            if (!this.game.device.cocoonJS)\n            {\n                this.game.canvas.addEventListener('touchenter', this._onTouchEnter, false);\n                this.game.canvas.addEventListener('touchleave', this._onTouchLeave, false);\n            }\n        }\n\n    },\n\n    /**\n    * Consumes all touchmove events on the document (only enable this if you know you need it!).\n    * @method Phaser.Touch#consumeTouchMove\n    */\n    consumeDocumentTouches: function () {\n\n        this._documentTouchMove = function (event) {\n            event.preventDefault();\n        };\n\n        document.addEventListener('touchmove', this._documentTouchMove, false);\n\n    },\n\n    /**\n    * Adds a callback that is fired when a browser touchstart or touchend event is received.\n    *\n    * This is used internally to handle audio and video unlocking on mobile devices.\n    *\n    * If the callback returns 'true' then the callback is automatically deleted once invoked.\n    *\n    * The callback is added to the Phaser.Touch.touchLockCallbacks array and should be removed with Phaser.Touch.removeTouchLockCallback.\n    * \n    * @method Phaser.Touch#addTouchLockCallback\n    * @param {function} callback - The callback that will be called when a touchstart event is received.\n    * @param {object} context - The context in which the callback will be called.\n    * @param {boolean} [onEnd=false] - Will the callback fire on a touchstart (default) or touchend event?\n    */\n    addTouchLockCallback: function (callback, context, onEnd) {\n\n        if (onEnd === undefined) { onEnd = false; }\n\n        this.touchLockCallbacks.push({ callback: callback, context: context, onEnd: onEnd });\n\n    },\n\n    /**\n    * Removes the callback at the defined index from the Phaser.Touch.touchLockCallbacks array\n    * \n    * @method Phaser.Touch#removeTouchLockCallback\n    * @param {function} callback - The callback to be removed.\n    * @param {object} context - The context in which the callback exists.\n    * @return {boolean} True if the callback was deleted, otherwise false.\n    */\n    removeTouchLockCallback: function (callback, context) {\n\n        var i = this.touchLockCallbacks.length;\n\n        while (i--)\n        {\n            if (this.touchLockCallbacks[i].callback === callback && this.touchLockCallbacks[i].context === context)\n            {\n                this.touchLockCallbacks.splice(i, 1);\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * The internal method that handles the touchstart event from the browser.\n    * @method Phaser.Touch#onTouchStart\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchStart: function (event) {\n\n        var i = this.touchLockCallbacks.length;\n\n        while (i--)\n        {\n            var cb = this.touchLockCallbacks[i];\n\n            if (!cb.onEnd && cb.callback.call(cb.context, this, event))\n            {\n                this.touchLockCallbacks.splice(i, 1);\n            }\n        }\n\n        this.event = event;\n\n        if (!this.game.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        if (this.touchStartCallback)\n        {\n            this.touchStartCallback.call(this.callbackContext, event);\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n        //  event.targetTouches = list of all touches on the TARGET ELEMENT (i.e. game dom element)\n        //  event.touches = list of all touches on the ENTIRE DOCUMENT, not just the target element\n        //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\n        for (var i = 0; i < event.changedTouches.length; i++)\n        {\n            this.game.input.startPointer(event.changedTouches[i]);\n        }\n\n    },\n\n    /**\n    * Touch cancel - touches that were disrupted (perhaps by moving into a plugin or browser chrome).\n    * Occurs for example on iOS when you put down 4 fingers and the app selector UI appears.\n    * @method Phaser.Touch#onTouchCancel\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchCancel: function (event) {\n\n        this.event = event;\n\n        if (this.touchCancelCallback)\n        {\n            this.touchCancelCallback.call(this.callbackContext, event);\n        }\n\n        if (!this.game.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n        //  Touch cancel - touches that were disrupted (perhaps by moving into a plugin or browser chrome)\n        //  http://www.w3.org/TR/touch-events/#dfn-touchcancel\n        for (var i = 0; i < event.changedTouches.length; i++)\n        {\n            this.game.input.stopPointer(event.changedTouches[i]);\n        }\n\n    },\n\n    /**\n    * For touch enter and leave its a list of the touch points that have entered or left the target.\n    * Doesn't appear to be supported by most browsers on a canvas element yet.\n    * @method Phaser.Touch#onTouchEnter\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchEnter: function (event) {\n\n        this.event = event;\n\n        if (this.touchEnterCallback)\n        {\n            this.touchEnterCallback.call(this.callbackContext, event);\n        }\n\n        if (!this.game.input.enabled || !this.enabled)\n        {\n            return;\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n    },\n\n    /**\n    * For touch enter and leave its a list of the touch points that have entered or left the target.\n    * Doesn't appear to be supported by most browsers on a canvas element yet.\n    * @method Phaser.Touch#onTouchLeave\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchLeave: function (event) {\n\n        this.event = event;\n\n        if (this.touchLeaveCallback)\n        {\n            this.touchLeaveCallback.call(this.callbackContext, event);\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n    },\n\n    /**\n    * The handler for the touchmove events.\n    * @method Phaser.Touch#onTouchMove\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchMove: function (event) {\n\n        this.event = event;\n\n        if (this.touchMoveCallback)\n        {\n            this.touchMoveCallback.call(this.callbackContext, event);\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n        for (var i = 0; i < event.changedTouches.length; i++)\n        {\n            this.game.input.updatePointer(event.changedTouches[i]);\n        }\n\n    },\n\n    /**\n    * The handler for the touchend events.\n    * @method Phaser.Touch#onTouchEnd\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchEnd: function (event) {\n\n        var i = this.touchLockCallbacks.length;\n\n        while (i--)\n        {\n            var cb = this.touchLockCallbacks[i];\n\n            if (cb.onEnd && cb.callback.call(cb.context, this, event))\n            {\n                this.touchLockCallbacks.splice(i, 1);\n            }\n        }\n\n        this.event = event;\n\n        if (this.touchEndCallback)\n        {\n            this.touchEndCallback.call(this.callbackContext, event);\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n        //  For touch end its a list of the touch points that have been removed from the surface\n        //  https://developer.mozilla.org/en-US/docs/DOM/TouchList\n        //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\n        for (var i = 0; i < event.changedTouches.length; i++)\n        {\n            this.game.input.stopPointer(event.changedTouches[i]);\n        }\n\n    },\n\n    /**\n    * Stop the event listeners.\n    * @method Phaser.Touch#stop\n    */\n    stop: function () {\n\n        if (this.game.device.touch)\n        {\n            this.game.canvas.removeEventListener('touchstart', this._onTouchStart);\n            this.game.canvas.removeEventListener('touchmove', this._onTouchMove);\n            this.game.canvas.removeEventListener('touchend', this._onTouchEnd);\n            this.game.canvas.removeEventListener('touchenter', this._onTouchEnter);\n            this.game.canvas.removeEventListener('touchleave', this._onTouchLeave);\n            this.game.canvas.removeEventListener('touchcancel', this._onTouchCancel);\n        }\n\n    }\n\n};\n\nPhaser.Touch.prototype.constructor = Phaser.Touch;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Input Handler is bound to a specific Sprite and is responsible for managing all Input events on that Sprite.\n*\n* @class Phaser.InputHandler\n* @constructor\n* @param {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.\n*/\nPhaser.InputHandler = function (sprite) {\n\n    /**\n    * @property {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.\n    */\n    this.sprite = sprite;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = sprite.game;\n\n    /**\n    * @property {boolean} enabled - If enabled the Input Handler will process input requests and monitor pointer activity.\n    * @default\n    */\n    this.enabled = false;\n\n    /**\n    * @property {boolean} checked - A disposable flag used by the Pointer class when performing priority checks.\n    * @protected\n    */\n    this.checked = false;\n\n    /**\n    * The priorityID is used to determine which game objects should get priority when input events occur. For example if you have\n    * several Sprites that overlap, by default the one at the top of the display list is given priority for input events. You can\n    * stop this from happening by controlling the priorityID value. The higher the value, the more important they are considered to the Input events.\n    * @property {number} priorityID\n    * @default\n    */\n    this.priorityID = 0;\n\n    /**\n    * @property {boolean} useHandCursor - On a desktop browser you can set the 'hand' cursor to appear when moving over the Sprite.\n    * @default\n    */\n    this.useHandCursor = false;\n\n    /**\n    * @property {boolean} _setHandCursor - Did this Sprite trigger the hand cursor?\n    * @private\n    */\n    this._setHandCursor = false;\n\n    /**\n    * @property {boolean} isDragged - true if the Sprite is being currently dragged.\n    * @default\n    */\n    this.isDragged = false;\n\n    /**\n    * @property {boolean} allowHorizontalDrag - Controls if the Sprite is allowed to be dragged horizontally.\n    * @default\n    */\n    this.allowHorizontalDrag = true;\n\n    /**\n    * @property {boolean} allowVerticalDrag - Controls if the Sprite is allowed to be dragged vertically.\n    * @default\n    */\n    this.allowVerticalDrag = true;\n\n    /**\n    * @property {boolean} bringToTop - If true when this Sprite is clicked or dragged it will automatically be bought to the top of the Group it is within.\n    * @default\n    */\n    this.bringToTop = false;\n\n    /**\n    * @property {Phaser.Point} snapOffset - A Point object that contains by how far the Sprite snap is offset.\n    * @default\n    */\n    this.snapOffset = null;\n\n    /**\n    * @property {boolean} snapOnDrag - When the Sprite is dragged this controls if the center of the Sprite will snap to the pointer on drag or not.\n    * @default\n    */\n    this.snapOnDrag = false;\n\n    /**\n    * @property {boolean} snapOnRelease - When the Sprite is dragged this controls if the Sprite will be snapped on release.\n    * @default\n    */\n    this.snapOnRelease = false;\n\n    /**\n    * @property {number} snapX - When a Sprite has snapping enabled this holds the width of the snap grid.\n    * @default\n    */\n    this.snapX = 0;\n\n    /**\n    * @property {number} snapY - When a Sprite has snapping enabled this holds the height of the snap grid.\n    * @default\n    */\n    this.snapY = 0;\n\n    /**\n    * @property {number} snapOffsetX - This defines the top-left X coordinate of the snap grid.\n    * @default\n    */\n    this.snapOffsetX = 0;\n\n    /**\n    * @property {number} snapOffsetY - This defines the top-left Y coordinate of the snap grid..\n    * @default\n    */\n    this.snapOffsetY = 0;\n\n    /**\n    * Set to true to use pixel perfect hit detection when checking if the pointer is over this Sprite.\n    * The x/y coordinates of the pointer are tested against the image in combination with the InputHandler.pixelPerfectAlpha value.\n    * This feature only works for display objects with image based textures such as Sprites. It won't work on BitmapText or Rope.\n    * Warning: This is expensive, especially on mobile (where it's not even needed!) so only enable if required. Also see the less-expensive InputHandler.pixelPerfectClick.\n    * @property {boolean} pixelPerfectOver - Use a pixel perfect check when testing for pointer over.\n    * @default\n    */\n    this.pixelPerfectOver = false;\n\n    /**\n    * Set to true to use pixel perfect hit detection when checking if the pointer is over this Sprite when it's clicked or touched.\n    * The x/y coordinates of the pointer are tested against the image in combination with the InputHandler.pixelPerfectAlpha value.\n    * This feature only works for display objects with image based textures such as Sprites. It won't work on BitmapText or Rope.\n    * Warning: This is expensive so only enable if you really need it.\n    * @property {boolean} pixelPerfectClick - Use a pixel perfect check when testing for clicks or touches on the Sprite.\n    * @default\n    */\n    this.pixelPerfectClick = false;\n\n    /**\n    * @property {number} pixelPerfectAlpha - The alpha tolerance threshold. If the alpha value of the pixel matches or is above this value, it's considered a hit.\n    * @default\n    */\n    this.pixelPerfectAlpha = 255;\n\n    /**\n    * @property {boolean} draggable - Is this sprite allowed to be dragged by the mouse? true = yes, false = no\n    * @default\n    */\n    this.draggable = false;\n\n    /**\n    * @property {Phaser.Rectangle} boundsRect - A region of the game world within which the sprite is restricted during drag.\n    * @default\n    */\n    this.boundsRect = null;\n\n    /**\n    * @property {Phaser.Sprite} boundsSprite - A Sprite the bounds of which this sprite is restricted during drag.\n    * @default\n    */\n    this.boundsSprite = null;\n\n    /**\n    * @property {boolean} scaleLayer - EXPERIMENTAL: Please do not use this property unless you know what it does. Likely to change in the future.\n    */\n    this.scaleLayer = false;\n\n    /**\n    * @property {Phaser.Point} dragOffset - The offset from the Sprites position that dragging takes place from.\n    */\n    this.dragOffset = new Phaser.Point();\n\n    /**\n    * @property {boolean} dragFromCenter - Is the Sprite dragged from its center, or the point at which the Pointer was pressed down upon it?\n    */\n    this.dragFromCenter = false;\n\n    /**\n    * @property {boolean} dragStopBlocksInputUp - If enabled, when the Sprite stops being dragged, it will only dispatch the `onDragStop` event, and not the `onInputUp` event. If set to `false` it will dispatch both events.\n    */\n    this.dragStopBlocksInputUp = false;\n\n    /**\n    * @property {Phaser.Point} dragStartPoint - The Point from which the most recent drag started from. Useful if you need to return an object to its starting position.\n    */\n    this.dragStartPoint = new Phaser.Point();\n\n    /**\n    * @property {integer} dragDistanceThreshold - The distance, in pixels, the pointer has to move while being held down, before the Sprite thinks it is being dragged.\n    */\n    this.dragDistanceThreshold = 0;\n\n    /**\n    * @property {integer} dragTimeThreshold - The amount of time, in ms, the pointer has to be held down over the Sprite before it thinks it is being dragged.\n    */\n    this.dragTimeThreshold = 0;\n\n    /**\n    * @property {Phaser.Point} downPoint - A Point object containing the coordinates of the Pointer when it was first pressed down onto this Sprite.\n    */\n    this.downPoint = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} snapPoint - If the sprite is set to snap while dragging this holds the point of the most recent 'snap' event.\n    */\n    this.snapPoint = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} _dragPoint - Internal cache var.\n    * @private\n    */\n    this._dragPoint = new Phaser.Point();\n\n    /**\n    * @property {boolean} _dragPhase - Internal cache var.\n    * @private\n    */\n    this._dragPhase = false;\n\n    /**\n    * @property {boolean} _pendingDrag - Internal cache var.\n    * @private\n    */\n    this._pendingDrag = false;\n\n    /**\n    * @property {boolean} _dragTimePass - Internal cache var.\n    * @private\n    */\n    this._dragTimePass = false;\n\n    /**\n    * @property {boolean} _dragDistancePass - Internal cache var.\n    * @private\n    */\n    this._dragDistancePass = false;\n\n    /**\n    * @property {boolean} _wasEnabled - Internal cache var.\n    * @private\n    */\n    this._wasEnabled = false;\n\n    /**\n    * @property {Phaser.Point} _tempPoint - Internal cache var.\n    * @private\n    */\n    this._tempPoint = new Phaser.Point();\n\n    /**\n    * @property {array} _pointerData - Internal cache var.\n    * @private\n    */\n    this._pointerData = [];\n\n    this._pointerData.push({\n        id: 0,\n        x: 0,\n        y: 0,\n        camX: 0,\n        camY: 0,\n        isDown: false,\n        isUp: false,\n        isOver: false,\n        isOut: false,\n        timeOver: 0,\n        timeOut: 0,\n        timeDown: 0,\n        timeUp: 0,\n        downDuration: 0,\n        isDragged: false\n    });\n\n};\n\nPhaser.InputHandler.prototype = {\n\n    /**\n    * Starts the Input Handler running. This is called automatically when you enable input on a Sprite, or can be called directly if you need to set a specific priority.\n    * \n    * @method Phaser.InputHandler#start\n    * @param {number} [priority=0] - Higher priority sprites take click priority over low-priority sprites when they are stacked on-top of each other.\n    * @param {boolean} [useHandCursor=false] - If true the Sprite will show the hand cursor on mouse-over (doesn't apply to mobile browsers)\n    * @return {Phaser.Sprite} The Sprite object to which the Input Handler is bound.\n    */\n    start: function (priority, useHandCursor) {\n\n        priority = priority || 0;\n        if (useHandCursor === undefined) { useHandCursor = false; }\n\n        //  Turning on\n        if (this.enabled === false)\n        {\n            //  Register, etc\n            this.game.input.interactiveItems.add(this);\n            this.useHandCursor = useHandCursor;\n            this.priorityID = priority;\n\n            for (var i = 0; i < 10; i++)\n            {\n                this._pointerData[i] = {\n                    id: i,\n                    x: 0,\n                    y: 0,\n                    isDown: false,\n                    isUp: false,\n                    isOver: false,\n                    isOut: false,\n                    timeOver: 0,\n                    timeOut: 0,\n                    timeDown: 0,\n                    timeUp: 0,\n                    downDuration: 0,\n                    isDragged: false\n                };\n            }\n\n            this.snapOffset = new Phaser.Point();\n            this.enabled = true;\n            this._wasEnabled = true;\n\n        }\n\n        this.sprite.events.onAddedToGroup.add(this.addedToGroup, this);\n        this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this);\n\n        return this.sprite;\n\n    },\n\n    /**\n    * Handles when the parent Sprite is added to a new Group.\n    *\n    * @method Phaser.InputHandler#addedToGroup\n    * @private\n    */\n    addedToGroup: function () {\n\n        if (this._dragPhase)\n        {\n            return;\n        }\n\n        if (this._wasEnabled && !this.enabled)\n        {\n            this.start();\n        }\n\n    },\n\n    /**\n    * Handles when the parent Sprite is removed from a Group.\n    *\n    * @method Phaser.InputHandler#removedFromGroup\n    * @private\n    */\n    removedFromGroup: function () {\n\n        if (this._dragPhase)\n        {\n            return;\n        }\n\n        if (this.enabled)\n        {\n            this._wasEnabled = true;\n            this.stop();\n        }\n        else\n        {\n            this._wasEnabled = false;\n        }\n\n    },\n\n    /**\n    * Resets the Input Handler and disables it.\n    * @method Phaser.InputHandler#reset\n    */\n    reset: function () {\n\n        this.enabled = false;\n\n        for (var i = 0; i < 10; i++)\n        {\n            this._pointerData[i] = {\n                id: i,\n                x: 0,\n                y: 0,\n                isDown: false,\n                isUp: false,\n                isOver: false,\n                isOut: false,\n                timeOver: 0,\n                timeOut: 0,\n                timeDown: 0,\n                timeUp: 0,\n                downDuration: 0,\n                isDragged: false\n            };\n        }\n    },\n\n    /**\n    * Stops the Input Handler from running.\n    * @method Phaser.InputHandler#stop\n    */\n    stop: function () {\n\n        //  Turning off\n        if (this.enabled === false)\n        {\n            return;\n        }\n        else\n        {\n            //  De-register, etc\n            this.enabled = false;\n            this.game.input.interactiveItems.remove(this);\n        }\n\n    },\n\n    /**\n    * Clean up memory.\n    * @method Phaser.InputHandler#destroy\n    */\n    destroy: function () {\n\n        if (this.sprite)\n        {\n            if (this._setHandCursor)\n            {\n                this.game.canvas.style.cursor = \"default\";\n                this._setHandCursor = false;\n            }\n\n            this.enabled = false;\n\n            this.game.input.interactiveItems.remove(this);\n\n            this._pointerData.length = 0;\n            this.boundsRect = null;\n            this.boundsSprite = null;\n            this.sprite = null;\n        }\n\n    },\n\n    /**\n    * Checks if the object this InputHandler is bound to is valid for consideration in the Pointer move event.\n    * This is called by Phaser.Pointer and shouldn't typically be called directly.\n    *\n    * @method Phaser.InputHandler#validForInput\n    * @protected\n    * @param {number} highestID - The highest ID currently processed by the Pointer.\n    * @param {number} highestRenderID - The highest Render Order ID currently processed by the Pointer.\n    * @param {boolean} [includePixelPerfect=true] - If this object has `pixelPerfectClick` or `pixelPerfectOver` set should it be considered as valid?\n    * @return {boolean} True if the object this InputHandler is bound to should be considered as valid for input detection.\n    */\n    validForInput: function (highestID, highestRenderID, includePixelPerfect) {\n\n        if (includePixelPerfect === undefined) { includePixelPerfect = true; }\n\n        if (!this.enabled ||\n            this.sprite.scale.x === 0 ||\n            this.sprite.scale.y === 0 ||\n            this.priorityID < this.game.input.minPriorityID ||\n            (this.sprite.parent && this.sprite.parent.ignoreChildInput))\n        {\n            return false;\n        }\n\n        //   If we're trying to specifically IGNORE pixel perfect objects, then set includePixelPerfect to false and skip it\n        if (!includePixelPerfect && (this.pixelPerfectClick || this.pixelPerfectOver))\n        {\n            return false;\n        }\n\n        if (this.priorityID > highestID || (this.priorityID === highestID && this.sprite.renderOrderID > highestRenderID))\n        {\n            return true;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Is this object using pixel perfect checking?\n    *\n    * @method Phaser.InputHandler#isPixelPerfect\n    * @return {boolean} True if the this InputHandler has either `pixelPerfectClick` or `pixelPerfectOver` set to `true`.\n    */\n    isPixelPerfect: function () {\n\n        return (this.pixelPerfectClick || this.pixelPerfectOver);\n\n    },\n\n    /**\n    * The x coordinate of the Input pointer, relative to the top-left of the parent Sprite.\n    * This value is only set when the pointer is over this Sprite.\n    *\n    * @method Phaser.InputHandler#pointerX\n    * @param {integer} [pointerId=0]\n    * @return {number} The x coordinate of the Input pointer.\n    */\n    pointerX: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        return this._pointerData[pointerId].x;\n\n    },\n\n    /**\n    * The y coordinate of the Input pointer, relative to the top-left of the parent Sprite\n    * This value is only set when the pointer is over this Sprite.\n    *\n    * @method Phaser.InputHandler#pointerY\n    * @param {integer} [pointerId=0]\n    * @return {number} The y coordinate of the Input pointer.\n    */\n    pointerY: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        return this._pointerData[pointerId].y;\n\n    },\n\n    /**\n    * If the Pointer is down this returns true.\n    * This *only* checks if the Pointer is down, not if it's down over any specific Sprite.\n    *\n    * @method Phaser.InputHandler#pointerDown\n    * @param {integer} [pointerId=0]\n    * @return {boolean} - True if the given pointer is down, otherwise false.\n    */\n    pointerDown: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        return this._pointerData[pointerId].isDown;\n\n    },\n\n    /**\n    * If the Pointer is up this returns true.\n    * This *only* checks if the Pointer is up, not if it's up over any specific Sprite.\n    *\n    * @method Phaser.InputHandler#pointerUp\n    * @param {integer} [pointerId=0]\n    * @return {boolean} - True if the given pointer is up, otherwise false.\n    */\n    pointerUp: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        return this._pointerData[pointerId].isUp;\n\n    },\n\n    /**\n    * A timestamp representing when the Pointer first touched the touchscreen.\n    *\n    * @method Phaser.InputHandler#pointerTimeDown\n    * @param {integer} [pointerId=(check all)]\n    * @return {number}\n    */\n    pointerTimeDown: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        return this._pointerData[pointerId].timeDown;\n\n    },\n\n    /**\n    * A timestamp representing when the Pointer left the touchscreen.\n    *\n    * @method Phaser.InputHandler#pointerTimeUp\n    * @param {integer} [pointerId=0]\n    * @return {number}\n    */\n    pointerTimeUp: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        return this._pointerData[pointerId].timeUp;\n\n    },\n\n    /**\n    * Is the Pointer over this Sprite?\n    *\n    * @method Phaser.InputHandler#pointerOver\n    * @param {integer} [pointerId=(check all)] The ID number of a Pointer to check. If you don't provide a number it will check all Pointers.\n    * @return {boolean} - True if the given pointer (if a index was given, or any pointer if not) is over this object.\n    */\n    pointerOver: function (pointerId) {\n\n        if (!this.enabled)\n        {\n            return false;\n        }\n\n        if (pointerId === undefined)\n        {\n            for (var i = 0; i < 10; i++)\n            {\n                if (this._pointerData[i].isOver)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n        else\n        {\n            return this._pointerData[pointerId].isOver;\n        }\n\n    },\n\n    /**\n    * Is the Pointer outside of this Sprite?\n    *\n    * @method Phaser.InputHandler#pointerOut\n    * @param {integer} [pointerId=(check all)] The ID number of a Pointer to check. If you don't provide a number it will check all Pointers.\n    * @return {boolean} True if the given pointer (if a index was given, or any pointer if not) is out of this object.\n    */\n    pointerOut: function (pointerId) {\n\n        if (!this.enabled)\n        {\n            return false;\n        }\n\n        if (pointerId === undefined)\n        {\n            for (var i = 0; i < 10; i++)\n            {\n                if (this._pointerData[i].isOut)\n                {\n                    return true;\n                }\n            }\n        }\n        else\n        {\n            return this._pointerData[pointerId].isOut;\n        }\n\n    },\n\n    /**\n    * A timestamp representing when the Pointer first touched the touchscreen.\n    *\n    * @method Phaser.InputHandler#pointerTimeOver\n    * @param {integer} [pointerId=0]\n    * @return {number}\n    */\n    pointerTimeOver: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        return this._pointerData[pointerId].timeOver;\n\n    },\n\n    /**\n    * A timestamp representing when the Pointer left the touchscreen.\n    *\n    * @method Phaser.InputHandler#pointerTimeOut\n    * @param {integer} [pointerId=0]\n    * @return {number}\n    */\n    pointerTimeOut: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        return this._pointerData[pointerId].timeOut;\n\n    },\n\n    /**\n    * Is this sprite being dragged by the mouse or not?\n    *\n    * @method Phaser.InputHandler#pointerDragged\n    * @param {integer} [pointerId=0]\n    * @return {boolean} True if the pointer is dragging an object, otherwise false.\n    */\n    pointerDragged: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        return this._pointerData[pointerId].isDragged;\n\n    },\n\n    /**\n    * Checks if the given pointer is both down and over the Sprite this InputHandler belongs to.\n    * Use the `fastTest` flag is to quickly check just the bounding hit area even if `InputHandler.pixelPerfectOver` is `true`.\n    *\n    * @method Phaser.InputHandler#checkPointerDown\n    * @param {Phaser.Pointer} pointer\n    * @param {boolean} [fastTest=false] - Force a simple hit area check even if `pixelPerfectOver` is true for this object?\n    * @return {boolean} True if the pointer is down, otherwise false.\n    */\n    checkPointerDown: function (pointer, fastTest) {\n\n        if (!pointer.isDown ||\n            !this.enabled ||\n            !this.sprite ||\n            !this.sprite.parent ||\n            !this.sprite.visible ||\n            !this.sprite.parent.visible ||\n            this.sprite.worldScale.x === 0 ||\n            this.sprite.worldScale.y === 0)\n        {\n            return false;\n        }\n\n        //  Need to pass it a temp point, in case we need it again for the pixel check\n        if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint))\n        {\n            if (fastTest === undefined)\n            {\n                fastTest = false;\n            }\n\n            if (!fastTest && this.pixelPerfectClick)\n            {\n                return this.checkPixel(this._tempPoint.x, this._tempPoint.y);\n            }\n            else\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Checks if the given pointer is over the Sprite this InputHandler belongs to.\n    * Use the `fastTest` flag is to quickly check just the bounding hit area even if `InputHandler.pixelPerfectOver` is `true`.\n    *\n    * @method Phaser.InputHandler#checkPointerOver\n    * @param {Phaser.Pointer} pointer\n    * @param {boolean} [fastTest=false] - Force a simple hit area check even if `pixelPerfectOver` is true for this object?\n    * @return {boolean}\n    */\n    checkPointerOver: function (pointer, fastTest) {\n\n        if (!this.enabled ||\n            !this.sprite ||\n            !this.sprite.parent ||\n            !this.sprite.visible ||\n            !this.sprite.parent.visible ||\n            this.sprite.worldScale.x === 0 ||\n            this.sprite.worldScale.y === 0)\n        {\n            return false;\n        }\n\n        //  Need to pass it a temp point, in case we need it again for the pixel check\n        if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint))\n        {\n            if (fastTest === undefined)\n            {\n                fastTest = false;\n            }\n\n            if (!fastTest && this.pixelPerfectOver)\n            {\n                return this.checkPixel(this._tempPoint.x, this._tempPoint.y);\n            }\n            else\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Runs a pixel perfect check against the given x/y coordinates of the Sprite this InputHandler is bound to.\n    * It compares the alpha value of the pixel and if >= InputHandler.pixelPerfectAlpha it returns true.\n    *\n    * @method Phaser.InputHandler#checkPixel\n    * @param {number} x - The x coordinate to check.\n    * @param {number} y - The y coordinate to check.\n    * @param {Phaser.Pointer} [pointer] - The pointer to get the x/y coordinate from if not passed as the first two parameters.\n    * @return {boolean} true if there is the alpha of the pixel is >= InputHandler.pixelPerfectAlpha\n    */\n    checkPixel: function (x, y, pointer) {\n\n        //  Grab a pixel from our image into the hitCanvas and then test it\n        if (this.sprite.texture.baseTexture.source)\n        {\n            if (x === null && y === null)\n            {\n                //  Use the pointer parameter\n                this.game.input.getLocalPosition(this.sprite, pointer, this._tempPoint);\n\n                var x = this._tempPoint.x;\n                var y = this._tempPoint.y;\n            }\n\n            if (this.sprite.anchor.x !== 0)\n            {\n                x -= -this.sprite.texture.frame.width * this.sprite.anchor.x;\n            }\n\n            if (this.sprite.anchor.y !== 0)\n            {\n                y -= -this.sprite.texture.frame.height * this.sprite.anchor.y;\n            }\n\n            x += this.sprite.texture.frame.x;\n            y += this.sprite.texture.frame.y;\n\n            if (this.sprite.texture.trim)\n            {\n                x -= this.sprite.texture.trim.x;\n                y -= this.sprite.texture.trim.y;\n\n                //  If the coordinates are outside the trim area we return false immediately, to save doing a draw call\n                if (x < this.sprite.texture.crop.x || x > this.sprite.texture.crop.right || y < this.sprite.texture.crop.y || y > this.sprite.texture.crop.bottom)\n                {\n                    this._dx = x;\n                    this._dy = y;\n                    return false;\n                }\n            }\n\n            this._dx = x;\n            this._dy = y;\n\n            this.game.input.hitContext.clearRect(0, 0, 1, 1);\n            this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, x, y, 1, 1, 0, 0, 1, 1);\n\n            var rgb = this.game.input.hitContext.getImageData(0, 0, 1, 1);\n\n            if (rgb.data[3] >= this.pixelPerfectAlpha)\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Internal Update method. This is called automatically and handles the Pointer\n    * and drag update loops.\n    * \n    * @method Phaser.InputHandler#update\n    * @protected\n    * @param {Phaser.Pointer} pointer\n    * @return {boolean} True if the pointer is still active, otherwise false.\n    */\n    update: function (pointer) {\n\n        if (this.sprite === null || this.sprite.parent === undefined)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        if (!this.enabled || !this.sprite.visible || !this.sprite.parent.visible)\n        {\n            this._pointerOutHandler(pointer);\n            return false;\n        }\n\n        if (this._pendingDrag)\n        {\n            if (!this._dragDistancePass)\n            {\n                this._dragDistancePass = (Phaser.Math.distance(pointer.x, pointer.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold);\n            }\n\n            if (this._dragDistancePass && this._dragTimePass)\n            {\n                this.startDrag(pointer);\n            }\n\n            return true;\n        }\n        else if (this.draggable && this._draggedPointerID === pointer.id)\n        {\n            return this.updateDrag(pointer, false);\n        }\n        else if (this._pointerData[pointer.id].isOver)\n        {\n            if (this.checkPointerOver(pointer))\n            {\n                this._pointerData[pointer.id].x = pointer.x - this.sprite.x;\n                this._pointerData[pointer.id].y = pointer.y - this.sprite.y;\n                return true;\n            }\n            else\n            {\n                this._pointerOutHandler(pointer);\n                return false;\n            }\n        }\n    },\n\n    /**\n    * Internal method handling the pointer over event.\n    * \n    * @method Phaser.InputHandler#_pointerOverHandler\n    * @private\n    * @param {Phaser.Pointer} pointer - The pointer that triggered the event\n    * @param {boolean} [silent=false] - If silent is `true` then this method will not dispatch any Signals from the parent Sprite.\n    */\n    _pointerOverHandler: function (pointer, silent) {\n\n        if (this.sprite === null)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        var data = this._pointerData[pointer.id];\n\n        if (data.isOver === false || pointer.dirty)\n        {\n            var sendEvent = (data.isOver === false);\n\n            data.isOver = true;\n            data.isOut = false;\n            data.timeOver = this.game.time.time;\n            data.x = pointer.x - this.sprite.x;\n            data.y = pointer.y - this.sprite.y;\n\n            if (this.useHandCursor && data.isDragged === false)\n            {\n                this.game.canvas.style.cursor = \"pointer\";\n                this._setHandCursor = true;\n            }\n\n            if (!silent && sendEvent && this.sprite && this.sprite.events)\n            {\n                this.sprite.events.onInputOver$dispatch(this.sprite, pointer);\n            }\n\n            if (this.sprite.parent && this.sprite.parent.type === Phaser.GROUP)\n            {\n                this.sprite.parent.onChildInputOver.dispatch(this.sprite, pointer);\n            }\n        }\n\n    },\n\n    /**\n    * Internal method handling the pointer out event.\n    * \n    * @method Phaser.InputHandler#_pointerOutHandler\n    * @private\n    * @param {Phaser.Pointer} pointer - The pointer that triggered the event.\n    * @param {boolean} [silent=false] - If silent is `true` then this method will not dispatch any Signals from the parent Sprite.\n    */\n    _pointerOutHandler: function (pointer, silent) {\n\n        if (this.sprite === null)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        var data = this._pointerData[pointer.id];\n\n        data.isOver = false;\n        data.isOut = true;\n        data.timeOut = this.game.time.time;\n\n        if (this.useHandCursor && data.isDragged === false)\n        {\n            this.game.canvas.style.cursor = \"default\";\n            this._setHandCursor = false;\n        }\n\n        if (!silent && this.sprite && this.sprite.events)\n        {\n            this.sprite.events.onInputOut$dispatch(this.sprite, pointer);\n\n            if (this.sprite && this.sprite.parent && this.sprite.parent.type === Phaser.GROUP)\n            {\n                this.sprite.parent.onChildInputOut.dispatch(this.sprite, pointer);\n            }\n        }\n\n    },\n\n    /**\n    * Internal method handling the touched / clicked event.\n    * \n    * @method Phaser.InputHandler#_touchedHandler\n    * @private\n    * @param {Phaser.Pointer} pointer - The pointer that triggered the event.\n    */\n    _touchedHandler: function (pointer) {\n\n        if (this.sprite === null)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        var data = this._pointerData[pointer.id];\n\n        if (!data.isDown && data.isOver)\n        {\n            if (this.pixelPerfectClick && !this.checkPixel(null, null, pointer))\n            {\n                return;\n            }\n\n            data.isDown = true;\n            data.isUp = false;\n            data.timeDown = this.game.time.time;\n\n            this.downPoint.set(pointer.x, pointer.y);\n\n            //  It's possible the onInputDown event creates a new Sprite that is on-top of this one, so we ought to force a Pointer update\n            pointer.dirty = true;\n\n            if (this.sprite && this.sprite.events)\n            {\n                this.sprite.events.onInputDown$dispatch(this.sprite, pointer);\n\n                //  The event above might have destroyed this sprite.\n                if (this.sprite && this.sprite.parent && this.sprite.parent.type === Phaser.GROUP)\n                {\n                    this.sprite.parent.onChildInputDown.dispatch(this.sprite, pointer);\n                }\n\n                //  The events might have destroyed this sprite.\n                if (this.sprite === null)\n                {\n                    return;\n                }\n            }\n\n            //  Start drag\n            if (this.draggable && this.isDragged === false)\n            {\n                if (this.dragTimeThreshold === 0 && this.dragDistanceThreshold === 0)\n                {\n                    this.startDrag(pointer);\n                }\n                else\n                {\n                    this._pendingDrag = true;\n\n                    this._dragDistancePass = (this.dragDistanceThreshold === 0);\n\n                    if (this.dragTimeThreshold > 0)\n                    {\n                        this._dragTimePass = false;\n                        this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, pointer);\n                    }\n                    else\n                    {\n                        this._dragTimePass = true;\n                    }\n                }\n            }\n\n            if (this.bringToTop)\n            {\n                this.sprite.bringToTop();\n            }\n        }\n\n    },\n\n    /**\n    * Internal method handling the drag threshold timer.\n    * \n    * @method Phaser.InputHandler#dragTimeElapsed\n    * @private\n    * @param {Phaser.Pointer} pointer\n    */\n    dragTimeElapsed: function (pointer) {\n\n        this._dragTimePass = true;\n\n        if (this._pendingDrag && this.sprite)\n        {\n            if (this._dragDistancePass)\n            {\n                this.startDrag(pointer);\n            }\n        }\n\n    },\n\n    /**\n    * Internal method handling the pointer released event.\n    * @method Phaser.InputHandler#_releasedHandler\n    * @private\n    * @param {Phaser.Pointer} pointer\n    */\n    _releasedHandler: function (pointer) {\n\n        if (this.sprite === null)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        var data = this._pointerData[pointer.id];\n\n        //  If was previously touched by this Pointer, check if still is AND still over this item\n        if (data.isDown && pointer.isUp)\n        {\n            data.isDown = false;\n            data.isUp = true;\n            data.timeUp = this.game.time.time;\n            data.downDuration = data.timeUp - data.timeDown;\n\n            //  Only release the InputUp signal if the pointer is still over this sprite\n            var isOver = this.checkPointerOver(pointer);\n\n            if (this.sprite && this.sprite.events)\n            {\n                if (!this.dragStopBlocksInputUp ||\n                    this.dragStopBlocksInputUp && !(this.draggable && this.isDragged && this._draggedPointerID === pointer.id))\n                {\n                    this.sprite.events.onInputUp$dispatch(this.sprite, pointer, isOver);\n                }\n\n                if (this.sprite && this.sprite.parent && this.sprite.parent.type === Phaser.GROUP)\n                {\n                    this.sprite.parent.onChildInputUp.dispatch(this.sprite, pointer, isOver);\n                }\n\n                //  The onInputUp event may have changed the sprite so that checkPointerOver is no longer true, so update it.\n                if (isOver)\n                {\n                    isOver = this.checkPointerOver(pointer);\n                }\n            }\n            \n            data.isOver = isOver;\n\n            if (!isOver && this.useHandCursor)\n            {\n                this.game.canvas.style.cursor = \"default\";\n                this._setHandCursor = false;\n            }\n\n            //  It's possible the onInputUp event created a new Sprite that is on-top of this one, so force a Pointer update\n            pointer.dirty = true;\n\n            this._pendingDrag = false;\n\n            //  Stop drag\n            if (this.draggable && this.isDragged && this._draggedPointerID === pointer.id)\n            {\n                this.stopDrag(pointer);\n            }\n        }\n\n    },\n\n    /**\n    * Called as a Pointer actively drags this Game Object.\n    * \n    * @method Phaser.InputHandler#updateDrag\n    * @private\n    * @param {Phaser.Pointer} pointer - The Pointer causing the drag update.\n    * @param {boolean} fromStart - True if this is the first update, immediately after the drag has started.\n    * @return {boolean}\n    */\n    updateDrag: function (pointer, fromStart) {\n\n        if (fromStart === undefined) { fromStart = false; }\n\n        if (pointer.isUp)\n        {\n            this.stopDrag(pointer);\n            return false;\n        }\n\n        var px = this.globalToLocalX(pointer.x) + this._dragPoint.x + this.dragOffset.x;\n        var py = this.globalToLocalY(pointer.y) + this._dragPoint.y + this.dragOffset.y;\n\n        if (this.sprite.fixedToCamera)\n        {\n            if (this.allowHorizontalDrag)\n            {\n                this.sprite.cameraOffset.x = px;\n            }\n\n            if (this.allowVerticalDrag)\n            {\n                this.sprite.cameraOffset.y = py;\n            }\n\n            if (this.boundsRect)\n            {\n                this.checkBoundsRect();\n            }\n\n            if (this.boundsSprite)\n            {\n                this.checkBoundsSprite();\n            }\n\n            if (this.snapOnDrag)\n            {\n                this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX);\n                this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY);\n                this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y);\n            }\n        }\n        else\n        {\n            var cx = this.game.camera.x - this._pointerData[pointer.id].camX;\n            var cy = this.game.camera.y - this._pointerData[pointer.id].camY;\n\n            if (this.allowHorizontalDrag)\n            {\n                this.sprite.x = px + cx;\n            }\n\n            if (this.allowVerticalDrag)\n            {\n                this.sprite.y = py + cy;\n            }\n\n            if (this.boundsRect)\n            {\n                this.checkBoundsRect();\n            }\n\n            if (this.boundsSprite)\n            {\n                this.checkBoundsSprite();\n            }\n\n            if (this.snapOnDrag)\n            {\n                this.sprite.x = Math.round((this.sprite.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX);\n                this.sprite.y = Math.round((this.sprite.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY);\n                this.snapPoint.set(this.sprite.x, this.sprite.y);\n            }\n        }\n\n        this.sprite.events.onDragUpdate.dispatch(this.sprite, pointer, px, py, this.snapPoint, fromStart);\n\n        return true;\n\n    },\n\n    /**\n    * Returns true if the pointer has entered the Sprite within the specified delay time (defaults to 500ms, half a second)\n    *\n    * @method Phaser.InputHandler#justOver\n    * @param {integer} [pointerId=0]\n    * @param {number} delay - The time below which the pointer is considered as just over.\n    * @return {boolean}\n    */\n    justOver: function (pointerId, delay) {\n\n        pointerId = pointerId || 0;\n        delay = delay || 500;\n\n        return (this._pointerData[pointerId].isOver && this.overDuration(pointerId) < delay);\n\n    },\n\n    /**\n    * Returns true if the pointer has left the Sprite within the specified delay time (defaults to 500ms, half a second)\n    *\n    * @method Phaser.InputHandler#justOut\n    * @param {integer} [pointerId=0]\n    * @param {number} delay - The time below which the pointer is considered as just out.\n    * @return {boolean}\n    */\n    justOut: function (pointerId, delay) {\n\n        pointerId = pointerId || 0;\n        delay = delay || 500;\n\n        return (this._pointerData[pointerId].isOut && (this.game.time.time - this._pointerData[pointerId].timeOut < delay));\n\n    },\n\n    /**\n    * Returns true if the pointer has touched or clicked on the Sprite within the specified delay time (defaults to 500ms, half a second)\n    *\n    * @method Phaser.InputHandler#justPressed\n    * @param {integer} [pointerId=0]\n    * @param {number} delay - The time below which the pointer is considered as just over.\n    * @return {boolean}\n    */\n    justPressed: function (pointerId, delay) {\n\n        pointerId = pointerId || 0;\n        delay = delay || 500;\n\n        return (this._pointerData[pointerId].isDown && this.downDuration(pointerId) < delay);\n\n    },\n\n    /**\n    * Returns true if the pointer was touching this Sprite, but has been released within the specified delay time (defaults to 500ms, half a second)\n    *\n    * @method Phaser.InputHandler#justReleased\n    * @param {integer} [pointerId=0]\n    * @param {number} delay - The time below which the pointer is considered as just out.\n    * @return {boolean}\n    */\n    justReleased: function (pointerId, delay) {\n\n        pointerId = pointerId || 0;\n        delay = delay || 500;\n\n        return (this._pointerData[pointerId].isUp && (this.game.time.time - this._pointerData[pointerId].timeUp < delay));\n\n    },\n\n    /**\n    * If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.\n    *\n    * @method Phaser.InputHandler#overDuration\n    * @param {integer} [pointerId=0]\n    * @return {number} The number of milliseconds the pointer has been over the Sprite, or -1 if not over.\n    */\n    overDuration: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        if (this._pointerData[pointerId].isOver)\n        {\n            return this.game.time.time - this._pointerData[pointerId].timeOver;\n        }\n\n        return -1;\n\n    },\n\n    /**\n    * If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.\n    *\n    * @method Phaser.InputHandler#downDuration\n    * @param {integer} [pointerId=0]\n    * @return {number} The number of milliseconds the pointer has been pressed down on the Sprite, or -1 if not over.\n    */\n    downDuration: function (pointerId) {\n\n        pointerId = pointerId || 0;\n\n        if (this._pointerData[pointerId].isDown)\n        {\n            return this.game.time.time - this._pointerData[pointerId].timeDown;\n        }\n\n        return -1;\n\n    },\n\n    /**\n    * Allow this Sprite to be dragged by any valid pointer.\n    *\n    * When the drag begins the Sprite.events.onDragStart event will be dispatched.\n    * \n    * When the drag completes by way of the user letting go of the pointer that was dragging the sprite, the Sprite.events.onDragStop event is dispatched.\n    *\n    * You can control the thresholds over when a drag starts via the properties:\n    * \n    * `Pointer.dragDistanceThreshold` the distance, in pixels, that the pointer has to move\n    * before the drag will start.\n    *\n    * `Pointer.dragTimeThreshold` the time, in ms, that the pointer must be held down on\n    * the Sprite before the drag will start.\n    *\n    * You can set either (or both) of these properties after enabling a Sprite for drag.\n    *\n    * For the duration of the drag the Sprite.events.onDragUpdate event is dispatched. This event is only dispatched when the pointer actually\n    * changes position and moves. The event sends 5 parameters: `sprite`, `pointer`, `dragX`, `dragY` and `snapPoint`.\n    * \n    * @method Phaser.InputHandler#enableDrag\n    * @param {boolean} [lockCenter=false] - If false the Sprite will drag from where you click it minus the dragOffset. If true it will center itself to the tip of the mouse pointer.\n    * @param {boolean} [bringToTop=false] - If true the Sprite will be bought to the top of the rendering list in its current Group.\n    * @param {boolean} [pixelPerfect=false] - If true it will use a pixel perfect test to see if you clicked the Sprite. False uses the bounding box.\n    * @param {boolean} [alphaThreshold=255] - If using pixel perfect collision this specifies the alpha level from 0 to 255 above which a collision is processed.\n    * @param {Phaser.Rectangle} [boundsRect=null] - If you want to restrict the drag of this sprite to a specific Rectangle, pass the Phaser.Rectangle here, otherwise it's free to drag anywhere.\n    * @param {Phaser.Sprite} [boundsSprite=null] - If you want to restrict the drag of this sprite to within the bounding box of another sprite, pass it here.\n    */\n    enableDrag: function (lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, boundsSprite) {\n\n        if (lockCenter === undefined) { lockCenter = false; }\n        if (bringToTop === undefined) { bringToTop = false; }\n        if (pixelPerfect === undefined) { pixelPerfect = false; }\n        if (alphaThreshold === undefined) { alphaThreshold = 255; }\n        if (boundsRect === undefined) { boundsRect = null; }\n        if (boundsSprite === undefined) { boundsSprite = null; }\n\n        this._dragPoint = new Phaser.Point();\n        this.draggable = true;\n        this.bringToTop = bringToTop;\n        this.dragOffset = new Phaser.Point();\n        this.dragFromCenter = lockCenter;\n\n        this.pixelPerfectClick = pixelPerfect;\n        this.pixelPerfectAlpha = alphaThreshold;\n\n        if (boundsRect)\n        {\n            this.boundsRect = boundsRect;\n        }\n\n        if (boundsSprite)\n        {\n            this.boundsSprite = boundsSprite;\n        }\n\n    },\n\n    /**\n    * Stops this sprite from being able to be dragged.\n    * If it is currently the target of an active drag it will be stopped immediately; also disables any set callbacks.\n    *\n    * @method Phaser.InputHandler#disableDrag\n    */\n    disableDrag: function () {\n\n        if (this._pointerData)\n        {\n            for (var i = 0; i < 10; i++)\n            {\n                this._pointerData[i].isDragged = false;\n            }\n        }\n\n        this.draggable = false;\n        this.isDragged = false;\n        this._draggedPointerID = -1;\n        this._pendingDrag = false;\n\n    },\n\n    /**\n    * Called by Pointer when drag starts on this Sprite. Should not usually be called directly.\n    *\n    * @method Phaser.InputHandler#startDrag\n    * @param {Phaser.Pointer} pointer\n    */\n    startDrag: function (pointer) {\n\n        var x = this.sprite.x;\n        var y = this.sprite.y;\n\n        this.isDragged = true;\n        this._draggedPointerID = pointer.id;\n\n        this._pointerData[pointer.id].camX = this.game.camera.x;\n        this._pointerData[pointer.id].camY = this.game.camera.y;\n\n        this._pointerData[pointer.id].isDragged = true;\n\n        if (this.sprite.fixedToCamera)\n        {\n            if (this.dragFromCenter)\n            {\n                var bounds = this.sprite.getBounds();\n\n                this.sprite.cameraOffset.x = this.globalToLocalX(pointer.x) + (this.sprite.cameraOffset.x - bounds.centerX);\n                this.sprite.cameraOffset.y = this.globalToLocalY(pointer.y) + (this.sprite.cameraOffset.y - bounds.centerY);\n            }\n\n            this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y);\n        }\n        else\n        {\n            if (this.dragFromCenter)\n            {\n                var bounds = this.sprite.getBounds();\n\n                this.sprite.x = this.globalToLocalX(pointer.x) + (this.sprite.x - bounds.centerX);\n                this.sprite.y = this.globalToLocalY(pointer.y) + (this.sprite.y - bounds.centerY);\n            }\n\n            this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(pointer.x), this.sprite.y - this.globalToLocalY(pointer.y));\n        }\n\n        this.updateDrag(pointer, true);\n\n        if (this.bringToTop)\n        {\n            this._dragPhase = true;\n            this.sprite.bringToTop();\n        }\n\n        this.dragStartPoint.set(x, y);\n\n        this.sprite.events.onDragStart$dispatch(this.sprite, pointer, x, y);\n\n        this._pendingDrag = false;\n\n    },\n\n    /**\n    * Warning: EXPERIMENTAL\n    *\n    * @method Phaser.InputHandler#globalToLocalX\n    * @param {number} x\n    */\n    globalToLocalX: function (x) {\n\n        if (this.scaleLayer)\n        {\n            x -= this.game.scale.grid.boundsFluid.x;\n            x *= this.game.scale.grid.scaleFluidInversed.x;\n        }\n\n        return x;\n\n    },\n\n    /**\n    * Warning: EXPERIMENTAL\n    *\n    * @method Phaser.InputHandler#globalToLocalY\n    * @param {number} y\n    */\n    globalToLocalY: function (y) {\n\n        if (this.scaleLayer)\n        {\n            y -= this.game.scale.grid.boundsFluid.y;\n            y *= this.game.scale.grid.scaleFluidInversed.y;\n        }\n\n        return y;\n\n    },\n\n    /**\n    * Called by Pointer when drag is stopped on this Sprite. Should not usually be called directly.\n    *\n    * @method Phaser.InputHandler#stopDrag\n    * @param {Phaser.Pointer} pointer\n    */\n    stopDrag: function (pointer) {\n\n        this.isDragged = false;\n        this._draggedPointerID = -1;\n        this._pointerData[pointer.id].isDragged = false;\n        this._dragPhase = false;\n        this._pendingDrag = false;\n\n        if (this.snapOnRelease)\n        {\n            if (this.sprite.fixedToCamera)\n            {\n                this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX);\n                this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY);\n            }\n            else\n            {\n                this.sprite.x = Math.round((this.sprite.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX);\n                this.sprite.y = Math.round((this.sprite.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY);\n            }\n        }\n\n        this.sprite.events.onDragStop$dispatch(this.sprite, pointer);\n\n        if (this.checkPointerOver(pointer) === false)\n        {\n            this._pointerOutHandler(pointer);\n        }\n\n    },\n\n    /**\n    * Restricts this sprite to drag movement only on the given axis. Note: If both are set to false the sprite will never move!\n    *\n    * @method Phaser.InputHandler#setDragLock\n    * @param {boolean} [allowHorizontal=true] - To enable the sprite to be dragged horizontally set to true, otherwise false.\n    * @param {boolean} [allowVertical=true] - To enable the sprite to be dragged vertically set to true, otherwise false.\n    */\n    setDragLock: function (allowHorizontal, allowVertical) {\n\n        if (allowHorizontal === undefined) { allowHorizontal = true; }\n        if (allowVertical === undefined) { allowVertical = true; }\n\n        this.allowHorizontalDrag = allowHorizontal;\n        this.allowVerticalDrag = allowVertical;\n\n    },\n\n    /**\n    * Make this Sprite snap to the given grid either during drag or when it's released.\n    * For example 16x16 as the snapX and snapY would make the sprite snap to every 16 pixels.\n    *\n    * @method Phaser.InputHandler#enableSnap\n    * @param {number} snapX - The width of the grid cell to snap to.\n    * @param {number} snapY - The height of the grid cell to snap to.\n    * @param {boolean} [onDrag=true] - If true the sprite will snap to the grid while being dragged.\n    * @param {boolean} [onRelease=false] - If true the sprite will snap to the grid when released.\n    * @param {number} [snapOffsetX=0] - Used to offset the top-left starting point of the snap grid.\n    * @param {number} [snapOffsetY=0] - Used to offset the top-left starting point of the snap grid.\n    */\n    enableSnap: function (snapX, snapY, onDrag, onRelease, snapOffsetX, snapOffsetY) {\n\n        if (onDrag === undefined) { onDrag = true; }\n        if (onRelease === undefined) { onRelease = false; }\n        if (snapOffsetX === undefined) { snapOffsetX = 0; }\n        if (snapOffsetY === undefined) { snapOffsetY = 0; }\n\n        this.snapX = snapX;\n        this.snapY = snapY;\n        this.snapOffsetX = snapOffsetX;\n        this.snapOffsetY = snapOffsetY;\n        this.snapOnDrag = onDrag;\n        this.snapOnRelease = onRelease;\n\n    },\n\n    /**\n    * Stops the sprite from snapping to a grid during drag or release.\n    *\n    * @method Phaser.InputHandler#disableSnap\n    */\n    disableSnap: function () {\n\n        this.snapOnDrag = false;\n        this.snapOnRelease = false;\n\n    },\n\n    /**\n    * Bounds Rect check for the sprite drag\n    *\n    * @method Phaser.InputHandler#checkBoundsRect\n    */\n    checkBoundsRect: function () {\n\n        if (this.sprite.fixedToCamera)\n        {\n            if (this.sprite.cameraOffset.x < this.boundsRect.left)\n            {\n                this.sprite.cameraOffset.x = this.boundsRect.left;\n            }\n            else if ((this.sprite.cameraOffset.x + this.sprite.width) > this.boundsRect.right)\n            {\n                this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width;\n            }\n\n            if (this.sprite.cameraOffset.y < this.boundsRect.top)\n            {\n                this.sprite.cameraOffset.y = this.boundsRect.top;\n            }\n            else if ((this.sprite.cameraOffset.y + this.sprite.height) > this.boundsRect.bottom)\n            {\n                this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height;\n            }\n        }\n        else\n        {\n            if (this.sprite.left < this.boundsRect.left)\n            {\n                this.sprite.x = this.boundsRect.x + this.sprite.offsetX;\n            }\n            else if (this.sprite.right > this.boundsRect.right)\n            {\n                this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX);\n            }\n\n            if (this.sprite.top < this.boundsRect.top)\n            {\n                this.sprite.y = this.boundsRect.top + this.sprite.offsetY;\n            }\n            else if (this.sprite.bottom > this.boundsRect.bottom)\n            {\n                this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY);\n            }\n        }\n\n    },\n\n    /**\n    * Parent Sprite Bounds check for the sprite drag.\n    *\n    * @method Phaser.InputHandler#checkBoundsSprite\n    */\n    checkBoundsSprite: function () {\n\n        if (this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera)\n        {\n            if (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x)\n            {\n                this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x;\n            }\n            else if ((this.sprite.cameraOffset.x + this.sprite.width) > (this.boundsSprite.cameraOffset.x + this.boundsSprite.width))\n            {\n                this.sprite.cameraOffset.x = (this.boundsSprite.cameraOffset.x + this.boundsSprite.width) - this.sprite.width;\n            }\n\n            if (this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y)\n            {\n                this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y;\n            }\n            else if ((this.sprite.cameraOffset.y + this.sprite.height) > (this.boundsSprite.cameraOffset.y + this.boundsSprite.height))\n            {\n                this.sprite.cameraOffset.y = (this.boundsSprite.cameraOffset.y + this.boundsSprite.height) - this.sprite.height;\n            }\n        }\n        else\n        {\n            if (this.sprite.left < this.boundsSprite.left)\n            {\n                this.sprite.x = this.boundsSprite.left + this.sprite.offsetX;\n            }\n            else if (this.sprite.right > this.boundsSprite.right)\n            {\n                this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX);\n            }\n\n            if (this.sprite.top < this.boundsSprite.top)\n            {\n                this.sprite.y = this.boundsSprite.top + this.sprite.offsetY;\n            }\n            else if (this.sprite.bottom > this.boundsSprite.bottom)\n            {\n                this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY);\n            }\n        }\n\n    }\n\n};\n\nPhaser.InputHandler.prototype.constructor = Phaser.InputHandler;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\nPhaser.Component = function () {};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Angle Component provides access to an `angle` property; the rotation of a Game Object in degrees.\n*\n* @class\n*/\nPhaser.Component.Angle = function () {};\n\nPhaser.Component.Angle.prototype = {\n\n    /**\n    * The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n    * \n    * Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n    * \n    * Values outside this range are added to or subtracted from 360 to obtain a value within the range. \n    * For example, the statement player.angle = 450 is the same as player.angle = 90.\n    * \n    * If you wish to work in radians instead of degrees you can use the property `rotation` instead. \n    * Working in radians is slightly faster as it doesn't have to perform any calculations.\n    *\n    * @property {number} angle\n    */\n    angle: {\n\n        get: function() {\n\n            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));\n\n        },\n\n        set: function(value) {\n\n            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));\n\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Animation Component provides a `play` method, which is a proxy to the `AnimationManager.play` method.\n*\n* @class\n*/\nPhaser.Component.Animation = function () {};\n\nPhaser.Component.Animation.prototype = {\n\n    /**\n    * Plays an Animation.\n    * \n    * The animation should have previously been created via `animations.add`.\n    * \n    * If the animation is already playing calling this again won't do anything.\n    * If you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.\n    *\n    * @method\n    * @param {string} name - The name of the animation to be played, e.g. \"fire\", \"walk\", \"jump\". Must have been previously created via 'AnimationManager.add'.\n    * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.\n    * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.\n    * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.\n    * @return {Phaser.Animation} A reference to playing Animation.\n    */\n    play: function (name, frameRate, loop, killOnComplete) {\n\n        if (this.animations)\n        {\n            return this.animations.play(name, frameRate, loop, killOnComplete);\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The AutoCull Component is responsible for providing methods that check if a Game Object is within the bounds of the World Camera.\n* It is used by the InWorld component.\n*\n* @class\n*/\nPhaser.Component.AutoCull = function () {};\n\nPhaser.Component.AutoCull.prototype = {\n\n    /**\n    * A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\n    * If it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\n    * This keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n    * \n    * This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\n    * or you have tested performance and find it acceptable.\n    *\n    * @property {boolean} autoCull\n    * @default\n    */\n    autoCull: false,\n\n    /**\n    * Checks if the Game Objects bounds intersect with the Game Camera bounds.\n    * Returns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.\n    *\n    * @property {boolean} inCamera\n    * @readonly\n    */\n    inCamera: {\n\n        get: function() {\n\n            if (!this.autoCull && !this.checkWorldBounds)\n            {\n                this._bounds.copyFrom(this.getBounds());\n                this._bounds.x += this.game.camera.view.x;\n                this._bounds.y += this.game.camera.view.y;\n            }\n\n            return this.game.world.camera.view.intersects(this._bounds);\n\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Bounds component contains properties related to the bounds of the Game Object.\n*\n* @class\n*/\nPhaser.Component.Bounds = function () {};\n\nPhaser.Component.Bounds.prototype = {\n\n    /**\n    * The amount the Game Object is visually offset from its x coordinate.\n    * This is the same as `width * anchor.x`.\n    * It will only be > 0 if anchor.x is not equal to zero.\n    *\n    * @property {number} offsetX\n    * @readOnly\n    */\n    offsetX: {\n\n        get: function () {\n\n            return this.anchor.x * this.width;\n\n        }\n\n    },\n\n    /**\n    * The amount the Game Object is visually offset from its y coordinate.\n    * This is the same as `height * anchor.y`.\n    * It will only be > 0 if anchor.y is not equal to zero.\n    *\n    * @property {number} offsetY\n    * @readOnly\n    */\n    offsetY: {\n\n        get: function () {\n\n            return this.anchor.y * this.height;\n\n        }\n\n    },\n\n    /**\n    * The center x coordinate of the Game Object.\n    * This is the same as `(x - offsetX) + (width / 2)`.\n    *\n    * @property {number} centerX\n    */\n    centerX: {\n\n        get: function () {\n\n            return (this.x - this.offsetX) + (this.width * 0.5);\n\n        },\n\n        set: function (value) {\n\n            this.x = (value + this.offsetX) - (this.width * 0.5);\n\n        }\n\n    },\n\n    /**\n    * The center y coordinate of the Game Object.\n    * This is the same as `(y - offsetY) + (height / 2)`.\n    *\n    * @property {number} centerY\n    */\n    centerY: {\n\n        get: function () {\n\n            return (this.y - this.offsetY) + (this.height * 0.5);\n\n        },\n\n        set: function (value) {\n\n            this.y = (value + this.offsetY) - (this.height * 0.5);\n\n        }\n\n    },\n\n    /**\n    * The left coordinate of the Game Object.\n    * This is the same as `x - offsetX`.\n    *\n    * @property {number} left\n    */\n    left: {\n\n        get: function () {\n\n            return this.x - this.offsetX;\n\n        },\n\n        set: function (value) {\n\n            this.x = value + this.offsetX;\n\n        }\n\n    },\n\n    /**\n    * The right coordinate of the Game Object.\n    * This is the same as `x + width - offsetX`.\n    *\n    * @property {number} right\n    */\n    right: {\n\n        get: function () {\n\n            return (this.x + this.width) - this.offsetX;\n\n        },\n\n        set: function (value) {\n\n            this.x = value - (this.width) + this.offsetX;\n\n        }\n\n    },\n\n    /**\n    * The y coordinate of the Game Object.\n    * This is the same as `y - offsetY`.\n    *\n    * @property {number} top\n    */\n    top: {\n\n        get: function () {\n\n            return this.y - this.offsetY;\n\n        },\n\n        set: function (value) {\n\n            this.y = value + this.offsetY;\n\n        }\n\n    },\n\n    /**\n    * The sum of the y and height properties.\n    * This is the same as `y + height - offsetY`.\n    *\n    * @property {number} bottom\n    */\n    bottom: {\n\n        get: function () {\n\n            return (this.y + this.height) - this.offsetY;\n\n        },\n\n        set: function (value) {\n\n            this.y = value - (this.height) + this.offsetY;\n\n        }\n\n    },\n\n    /**\n    * Aligns this Game Object within another Game Object, or Rectangle, known as the\n    * 'container', to one of 9 possible positions.\n    *\n    * The container must be a Game Object, or Phaser.Rectangle object. This can include properties\n    * such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world \n    * and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,\n    * TileSprites or Buttons.\n    *\n    * Please note that aligning a Sprite to another Game Object does **not** make it a child of\n    * the container. It simply modifies its position coordinates so it aligns with it.\n    * \n    * The position constants you can use are:\n    * \n    * `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, \n    * `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`, \n    * `Phaser.BOTTOM_CENTER` and `Phaser.BOTTOM_RIGHT`.\n    *\n    * The Game Objects are placed in such a way that their _bounds_ align with the\n    * container, taking into consideration rotation, scale and the anchor property.\n    * This allows you to neatly align Game Objects, irrespective of their position value.\n    *\n    * The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final\n    * aligned position of the Game Object. For example:\n    *\n    * `sprite.alignIn(background, Phaser.BOTTOM_RIGHT, -20, -20)`\n    *\n    * Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.\n    * Think of the offsets as applying an adjustment to the containers bounds before the alignment takes place.\n    * So providing a negative offset will 'shrink' the container bounds by that amount, and providing a positive\n    * one expands it.\n    *\n    * @method\n    * @param {Phaser.Rectangle|Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText|Phaser.Button|Phaser.Graphics|Phaser.TileSprite} container - The Game Object or Rectangle with which to align this Game Object to. Can also include properties such as `World.bounds` or `Camera.view`.\n    * @param {integer} [position] - The position constant. One of `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.\n    * @param {integer} [offsetX=0] - A horizontal adjustment of the Containers bounds, applied to the aligned position of the Game Object. Use a negative value to shrink the bounds, positive to increase it.\n    * @param {integer} [offsetY=0] - A vertical adjustment of the Containers bounds, applied to the aligned position of the Game Object. Use a negative value to shrink the bounds, positive to increase it.\n    * @return {Object} This Game Object.\n    */\n    alignIn: function (container, position, offsetX, offsetY) {\n\n        if (offsetX === undefined) { offsetX = 0; }\n        if (offsetY === undefined) { offsetY = 0; }\n\n        switch (position)\n        {\n            default:\n            case Phaser.TOP_LEFT:\n                this.left = container.left - offsetX;\n                this.top = container.top - offsetY;\n                break;\n\n            case Phaser.TOP_CENTER:\n                this.centerX = container.centerX + offsetX;\n                this.top = container.top - offsetY;\n                break;\n\n            case Phaser.TOP_RIGHT:\n                this.right = container.right + offsetX;\n                this.top = container.top - offsetY;\n                break;\n\n            case Phaser.LEFT_CENTER:\n                this.left = container.left - offsetX;\n                this.centerY = container.centerY + offsetY;\n                break;\n\n            case Phaser.CENTER:\n                this.centerX = container.centerX + offsetX;\n                this.centerY = container.centerY + offsetY;\n                break;\n\n            case Phaser.RIGHT_CENTER:\n                this.right = container.right + offsetX;\n                this.centerY = container.centerY + offsetY;\n                break;\n\n            case Phaser.BOTTOM_LEFT:\n                this.left = container.left - offsetX;\n                this.bottom = container.bottom + offsetY;\n                break;\n\n            case Phaser.BOTTOM_CENTER:\n                this.centerX = container.centerX + offsetX;\n                this.bottom = container.bottom + offsetY;\n                break;\n\n            case Phaser.BOTTOM_RIGHT:\n                this.right = container.right + offsetX;\n                this.bottom = container.bottom + offsetY;\n                break;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Aligns this Game Object to the side of another Game Object, or Rectangle, known as the\n    * 'parent', in one of 11 possible positions.\n    *\n    * The parent must be a Game Object, or Phaser.Rectangle object. This can include properties\n    * such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world \n    * and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,\n    * TileSprites or Buttons.\n    *\n    * Please note that aligning a Sprite to another Game Object does **not** make it a child of\n    * the parent. It simply modifies its position coordinates so it aligns with it.\n    * \n    * The position constants you can use are:\n    * \n    * `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`, \n    * `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`, \n    * `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` \n    * and `Phaser.BOTTOM_RIGHT`.\n    *\n    * The Game Objects are placed in such a way that their _bounds_ align with the\n    * parent, taking into consideration rotation, scale and the anchor property.\n    * This allows you to neatly align Game Objects, irrespective of their position value.\n    *\n    * The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final\n    * aligned position of the Game Object. For example:\n    *\n    * `sprite.alignTo(background, Phaser.BOTTOM_RIGHT, -20, -20)`\n    *\n    * Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.\n    * Think of the offsets as applying an adjustment to the parents bounds before the alignment takes place.\n    * So providing a negative offset will 'shrink' the parent bounds by that amount, and providing a positive\n    * one expands it.\n    *\n    * @method\n    * @param {Phaser.Rectangle|Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText|Phaser.Button|Phaser.Graphics|Phaser.TileSprite} parent - The Game Object or Rectangle with which to align this Game Object to. Can also include properties such as `World.bounds` or `Camera.view`.\n    * @param {integer} [position] - The position constant. One of `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`, `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`, `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.\n    * @param {integer} [offsetX=0] - A horizontal adjustment of the Containers bounds, applied to the aligned position of the Game Object. Use a negative value to shrink the bounds, positive to increase it.\n    * @param {integer} [offsetY=0] - A vertical adjustment of the Containers bounds, applied to the aligned position of the Game Object. Use a negative value to shrink the bounds, positive to increase it.\n    * @return {Object} This Game Object.\n    */\n    alignTo: function (parent, position, offsetX, offsetY) {\n\n        if (offsetX === undefined) { offsetX = 0; }\n        if (offsetY === undefined) { offsetY = 0; }\n\n        switch (position)\n        {\n            default:\n            case Phaser.TOP_LEFT:\n                this.left = parent.left - offsetX;\n                this.bottom = parent.top - offsetY;\n                break;\n\n            case Phaser.TOP_CENTER:\n                this.centerX = parent.centerX + offsetX;\n                this.bottom = parent.top - offsetY;\n                break;\n\n            case Phaser.TOP_RIGHT:\n                this.right = parent.right + offsetX;\n                this.bottom = parent.top - offsetY;\n                break;\n\n            case Phaser.LEFT_TOP:\n                this.right = parent.left - offsetX;\n                this.top = parent.top - offsetY;\n                break;\n\n            case Phaser.LEFT_CENTER:\n                this.right = parent.left - offsetX;\n                this.centerY = parent.centerY + offsetY;\n                break;\n\n            case Phaser.LEFT_BOTTOM:\n                this.right = parent.left - offsetX;\n                this.bottom = parent.bottom + offsetY;\n                break;\n\n            case Phaser.RIGHT_TOP:\n                this.left = parent.right + offsetX;\n                this.top = parent.top - offsetY;\n                break;\n\n            case Phaser.RIGHT_CENTER:\n                this.left = parent.right + offsetX;\n                this.centerY = parent.centerY + offsetY;\n                break;\n\n            case Phaser.RIGHT_BOTTOM:\n                this.left = parent.right + offsetX;\n                this.bottom = parent.bottom + offsetY;\n                break;\n\n            case Phaser.BOTTOM_LEFT:\n                this.left = parent.left - offsetX;\n                this.top = parent.bottom + offsetY;\n                break;\n\n            case Phaser.BOTTOM_CENTER:\n                this.centerX = parent.centerX + offsetX;\n                this.top = parent.bottom + offsetY;\n                break;\n\n            case Phaser.BOTTOM_RIGHT:\n                this.right = parent.right + offsetX;\n                this.top = parent.bottom + offsetY;\n                break;\n        }\n\n        return this;\n\n    }\n\n};\n\n//  Phaser.Group extensions\n\nPhaser.Group.prototype.alignIn = Phaser.Component.Bounds.prototype.alignIn;\nPhaser.Group.prototype.alignTo = Phaser.Component.Bounds.prototype.alignTo;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The BringToTop Component features quick access to Group sorting related methods.\n*\n* @class\n*/\nPhaser.Component.BringToTop = function () {};\n\n/**\n* Brings this Game Object to the top of its parents display list.\n* Visually this means it will render over the top of any old child in the same Group.\n* \n* If this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \n* because the World is the root Group from which all Game Objects descend.\n*\n* @method\n* @return {PIXI.DisplayObject} This instance.\n*/\nPhaser.Component.BringToTop.prototype.bringToTop = function() {\n\n    if (this.parent)\n    {\n        this.parent.bringToTop(this);\n    }\n\n    return this;\n\n};\n\n/**\n* Sends this Game Object to the bottom of its parents display list.\n* Visually this means it will render below all other children in the same Group.\n* \n* If this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \n* because the World is the root Group from which all Game Objects descend.\n*\n* @method\n* @return {PIXI.DisplayObject} This instance.\n*/\nPhaser.Component.BringToTop.prototype.sendToBack = function() {\n\n    if (this.parent)\n    {\n        this.parent.sendToBack(this);\n    }\n\n    return this;\n\n};\n\n/**\n* Moves this Game Object up one place in its parents display list.\n* This call has no effect if the Game Object is already at the top of the display list.\n* \n* If this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \n* because the World is the root Group from which all Game Objects descend.\n*\n* @method\n* @return {PIXI.DisplayObject} This instance.\n*/\nPhaser.Component.BringToTop.prototype.moveUp = function () {\n\n    if (this.parent)\n    {\n        this.parent.moveUp(this);\n    }\n\n    return this;\n\n};\n\n/**\n* Moves this Game Object down one place in its parents display list.\n* This call has no effect if the Game Object is already at the bottom of the display list.\n* \n* If this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \n* because the World is the root Group from which all Game Objects descend.\n*\n* @method\n* @return {PIXI.DisplayObject} This instance.\n*/\nPhaser.Component.BringToTop.prototype.moveDown = function () {\n\n    if (this.parent)\n    {\n        this.parent.moveDown(this);\n    }\n\n    return this;\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Core Component Features.\n*\n* @class\n*/\nPhaser.Component.Core = function () {};\n\n/**\n* Installs / registers mixin components.\n*\n* The `this` context should be that of the applicable object instance or prototype.\n*\n* @method\n* @protected\n*/\nPhaser.Component.Core.install = function (components) {\n\n    // Always install 'Core' first\n    Phaser.Utils.mixinPrototype(this, Phaser.Component.Core.prototype);\n\n    this.components = {};\n\n    for (var i = 0; i < components.length; i++)\n    {\n        var id = components[i];\n        var replace = false;\n\n        if (id === 'Destroy')\n        {\n            replace = true;\n        }\n\n        Phaser.Utils.mixinPrototype(this, Phaser.Component[id].prototype, replace);\n\n        this.components[id] = true;\n    }\n\n};\n\n/**\n* Initializes the mixin components.\n*\n* The `this` context should be an instance of the component mixin target.\n*\n* @method\n* @protected\n*/\nPhaser.Component.Core.init = function (game, x, y, key, frame) {\n\n    this.game = game;\n\n    this.key = key;\n\n    this.data = {};\n\n    this.position.set(x, y);\n    this.world = new Phaser.Point(x, y);\n    this.previousPosition = new Phaser.Point(x, y);\n\n    this.events = new Phaser.Events(this);\n\n    this._bounds = new Phaser.Rectangle();\n\n    if (this.components.PhysicsBody)\n    {\n        // Enable-body checks for hasOwnProperty; makes sure to lift property from prototype.\n        this.body = this.body;\n    }\n\n    if (this.components.Animation)\n    {\n        this.animations = new Phaser.AnimationManager(this);\n    }\n\n    if (this.components.LoadTexture && key !== null)\n    {\n        this.loadTexture(key, frame);\n    }\n\n    if (this.components.FixedToCamera)\n    {\n        this.cameraOffset = new Phaser.Point(x, y);\n    }\n\n};\n\nPhaser.Component.Core.preUpdate = function () {\n\n    if (this.pendingDestroy)\n    {\n        this.destroy();\n        return;\n    }\n\n    this.previousPosition.set(this.world.x, this.world.y);\n    this.previousRotation = this.rotation;\n\n    if (!this.exists || !this.parent.exists)\n    {\n        this.renderOrderID = -1;\n        return false;\n    }\n\n    this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);\n\n    if (this.visible)\n    {\n        this.renderOrderID = this.game.stage.currentRenderOrderID++;\n    }\n\n    if (this.animations)\n    {\n        this.animations.update();\n    }\n\n    if (this.body)\n    {\n        this.body.preUpdate();\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].preUpdate();\n    }\n\n    return true;\n\n};\n\nPhaser.Component.Core.prototype = {\n\n    /**\n    * A reference to the currently running Game.\n    * @property {Phaser.Game} game\n    */\n    game: null,\n\n    /**\n    * A user defined name given to this Game Object.\n    * This value isn't ever used internally by Phaser, it is meant as a game level property.\n    * @property {string} name\n    * @default\n    */\n    name: '',\n\n    /**\n    * An empty Object that belongs to this Game Object.\n    * This value isn't ever used internally by Phaser, but may be used by your own code, or\n    * by Phaser Plugins, to store data that needs to be associated with the Game Object,\n    * without polluting the Game Object directly.\n    * @property {Object} data\n    * @default\n    */\n    data: {},\n\n    /**\n    * The components this Game Object has installed.\n    * @property {object} components\n    * @protected\n    */\n    components: {},\n\n    /**\n    * The z depth of this Game Object within its parent Group.\n    * No two objects in a Group can have the same z value.\n    * This value is adjusted automatically whenever the Group hierarchy changes.\n    * If you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.\n    * @property {number} z\n    * @readOnly\n    */\n    z: 0,\n\n    /**\n    * All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\n    * Game Object, or any of its components.\n    * @see Phaser.Events\n    * @property {Phaser.Events} events\n    */\n    events: undefined,\n\n    /**\n    * If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\n    * Through it you can create, play, pause and stop animations.\n    * @see Phaser.AnimationManager\n    * @property {Phaser.AnimationManager} animations\n    */\n    animations: undefined,\n\n    /**\n    * The key of the image or texture used by this Game Object during rendering.\n    * If it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\n    * It can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n    * If a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\n    * If a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.\n    * @property {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} key\n    */\n    key: '',\n\n    /**\n    * The world coordinates of this Game Object in pixels.\n    * Depending on where in the display list this Game Object is placed this value can differ from `position`, \n    * which contains the x/y coordinates relative to the Game Objects parent.\n    * @property {Phaser.Point} world\n    */\n    world: null,\n\n    /**\n    * A debug flag designed for use with `Game.enableStep`.\n    * @property {boolean} debug\n    * @default\n    */\n    debug: false,\n\n    /**\n    * The position the Game Object was located in the previous frame.\n    * @property {Phaser.Point} previousPosition\n    * @readOnly\n    */\n    previousPosition: null,\n\n    /**\n    * The rotation the Game Object was in set to in the previous frame. Value is in radians.\n    * @property {number} previousRotation\n    * @readOnly\n    */\n    previousRotation: 0,\n\n    /**\n    * The render order ID is used internally by the renderer and Input Manager and should not be modified.\n    * This property is mostly used internally by the renderers, but is exposed for the use of plugins.\n    * @property {number} renderOrderID\n    * @readOnly\n    */\n    renderOrderID: 0,\n\n    /**\n    * A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\n    * This property is mostly used internally by the physics systems, but is exposed for the use of plugins.\n    * @property {boolean} fresh\n    * @readOnly\n    */\n    fresh: true,\n\n    /**\n    * A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\n    * You can set it directly to allow you to flag an object to be destroyed on its next update.\n    * \n    * This is extremely useful if you wish to destroy an object from within one of its own callbacks \n    * such as with Buttons or other Input events.\n    * \n    * @property {boolean} pendingDestroy\n    */\n    pendingDestroy: false,\n\n    /**\n    * @property {Phaser.Rectangle} _bounds - Internal cache var.\n    * @private\n    */\n    _bounds: null,\n\n    /**\n    * @property {boolean} _exists - Internal cache var.\n    * @private\n    */\n    _exists: true,\n\n    /**\n    * Controls if this Game Object is processed by the core game loop.\n    * If this Game Object has a physics body it also controls if its physics body is updated or not.\n    * When `exists` is set to `false` it will remove its physics body from the physics world if it has one.\n    * It also toggles the `visible` property to false as well.\n    *\n    * Setting `exists` to true will add its physics body back in to the physics world, if it has one.\n    * It will also set the `visible` property to `true`.\n    *\n    * @property {boolean} exists\n    */\n    exists: {\n\n        get: function () {\n\n            return this._exists;\n\n        },\n\n        set: function (value) {\n\n            if (value)\n            {\n                this._exists = true;\n\n                if (this.body && this.body.type === Phaser.Physics.P2JS)\n                {\n                    this.body.addToWorld();\n                }\n\n                this.visible = true;\n            }\n            else\n            {\n                this._exists = false;\n\n                if (this.body && this.body.type === Phaser.Physics.P2JS)\n                {\n                    this.body.removeFromWorld();\n                }\n\n                this.visible = false;\n            }\n\n        }\n\n    },\n\n    /**\n    * Override this method in your own custom objects to handle any update requirements.\n    * It is called immediately after `preUpdate` and before `postUpdate`.\n    * Remember if this Game Object has any children you should call update on those too.\n    *\n    * @method\n    */\n    update: function() {\n\n    },\n\n    /**\n    * Internal method called by the World postUpdate cycle.\n    *\n    * @method\n    * @protected\n    */\n    postUpdate: function() {\n\n        if (this.customRender)\n        {\n            this.key.render();\n        }\n\n        if (this.components.PhysicsBody)\n        {\n            Phaser.Component.PhysicsBody.postUpdate.call(this);\n        }\n\n        if (this.components.FixedToCamera)\n        {\n            Phaser.Component.FixedToCamera.postUpdate.call(this);\n        }\n\n        for (var i = 0; i < this.children.length; i++)\n        {\n            this.children[i].postUpdate();\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Crop component provides the ability to crop a texture based Game Object to a defined rectangle, \n* which can be updated in real-time.\n*\n* @class\n*/\nPhaser.Component.Crop = function () {};\n\nPhaser.Component.Crop.prototype = {\n\n    /**\n    * The Rectangle used to crop the texture this Game Object uses.\n    * Set this property via `crop`. \n    * If you modify this property directly you must call `updateCrop` in order to have the change take effect.\n    * @property {Phaser.Rectangle} cropRect\n    * @default\n    */\n    cropRect: null,\n\n    /**\n    * @property {Phaser.Rectangle} _crop - Internal cache var.\n    * @private\n    */\n    _crop: null,\n\n    /**\n    * Crop allows you to crop the texture being used to display this Game Object.\n    * Setting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.\n    *\n    * Cropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,\n    * or by modifying `cropRect` property directly and then calling `updateCrop`.\n    *\n    * The rectangle object given to this method can be either a `Phaser.Rectangle` or any other object \n    * so long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.\n    * \n    * A reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`, \n    * in which case the values are duplicated to a local object.\n    *\n    * @method\n    * @param {Phaser.Rectangle} rect - The Rectangle used during cropping. Pass null or no parameters to clear a previously set crop rectangle.\n    * @param {boolean} [copy=false] - If false `cropRect` will be stored as a reference to the given rect. If true it will copy the rect values into a local Phaser Rectangle object stored in cropRect.\n    */\n    crop: function (rect, copy) {\n\n        if (copy === undefined) { copy = false; }\n\n        if (rect)\n        {\n            if (copy && this.cropRect !== null)\n            {\n                this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height);\n            }\n            else if (copy && this.cropRect === null)\n            {\n                this.cropRect = new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height);\n            }\n            else\n            {\n                this.cropRect = rect;\n            }\n\n            this.updateCrop();\n        }\n        else\n        {\n            this._crop = null;\n            this.cropRect = null;\n\n            this.resetFrame();\n        }\n\n    },\n\n    /**\n    * If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,\n    * or the rectangle it references, then you need to update the crop frame by calling this method.\n    *\n    * @method\n    */\n    updateCrop: function () {\n\n        if (!this.cropRect)\n        {\n            return;\n        }\n\n        var oldX = this.texture.crop.x;\n        var oldY = this.texture.crop.y;\n        var oldW = this.texture.crop.width;\n        var oldH = this.texture.crop.height;\n\n        this._crop = Phaser.Rectangle.clone(this.cropRect, this._crop);\n        this._crop.x += this._frame.x;\n        this._crop.y += this._frame.y;\n\n        var cx = Math.max(this._frame.x, this._crop.x);\n        var cy = Math.max(this._frame.y, this._crop.y);\n        var cw = Math.min(this._frame.right, this._crop.right) - cx;\n        var ch = Math.min(this._frame.bottom, this._crop.bottom) - cy;\n\n        this.texture.crop.x = cx;\n        this.texture.crop.y = cy;\n        this.texture.crop.width = cw;\n        this.texture.crop.height = ch;\n\n        this.texture.frame.width = Math.min(cw, this.cropRect.width);\n        this.texture.frame.height = Math.min(ch, this.cropRect.height);\n\n        this.texture.width = this.texture.frame.width;\n        this.texture.height = this.texture.frame.height;\n\n        this.texture._updateUvs();\n\n        if (this.tint !== 0xffffff && (oldX !== cx || oldY !== cy || oldW !== cw || oldH !== ch))\n        {\n            this.texture.requiresReTint = true;\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Delta component provides access to delta values between the Game Objects current and previous position.\n*\n* @class\n*/\nPhaser.Component.Delta = function () {};\n\nPhaser.Component.Delta.prototype = {\n\n    /**\n    * Returns the delta x value. The difference between world.x now and in the previous frame.\n    * \n    * The value will be positive if the Game Object has moved to the right or negative if to the left.\n    *\n    * @property {number} deltaX\n    * @readonly\n    */\n    deltaX: {\n\n        get: function() {\n\n            return this.world.x - this.previousPosition.x;\n\n        }\n\n    },\n\n    /**\n    * Returns the delta y value. The difference between world.y now and in the previous frame.\n    * \n    * The value will be positive if the Game Object has moved down or negative if up.\n    *\n    * @property {number} deltaY\n    * @readonly\n    */\n    deltaY: {\n\n        get: function() {\n\n            return this.world.y - this.previousPosition.y;\n\n        }\n\n    },\n\n    /**\n    * Returns the delta z value. The difference between rotation now and in the previous frame.\n    *\n    * @property {number} deltaZ - The delta value.\n    * @readonly\n    */\n    deltaZ: {\n\n        get: function() {\n\n            return this.rotation - this.previousRotation;\n\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Destroy component is responsible for destroying a Game Object.\n*\n* @class\n*/\nPhaser.Component.Destroy = function () {};\n\nPhaser.Component.Destroy.prototype = {\n\n    /**\n    * As a Game Object runs through its destroy method this flag is set to true, \n    * and can be checked in any sub-systems or plugins it is being destroyed from.\n    * @property {boolean} destroyPhase\n    * @readOnly\n    */\n    destroyPhase: false,\n\n    /**\n    * Destroys the Game Object. This removes it from its parent group, destroys the input, event and animation handlers if present\n    * and nulls its reference to `game`, freeing it up for garbage collection.\n    * \n    * If this Game Object has the Events component it will also dispatch the `onDestroy` event.\n    *\n    * You can optionally also destroy the BaseTexture this Game Object is using. Be careful if you've\n    * more than one Game Object sharing the same BaseTexture.\n    *\n    * @method\n    * @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called as well?\n    * @param {boolean} [destroyTexture=false] - Destroy the BaseTexture this Game Object is using? Note that if another Game Object is sharing the same BaseTexture it will invalidate it.\n    */\n    destroy: function (destroyChildren, destroyTexture) {\n\n        if (this.game === null || this.destroyPhase) { return; }\n\n        if (destroyChildren === undefined) { destroyChildren = true; }\n        if (destroyTexture === undefined) { destroyTexture = false; }\n\n        this.destroyPhase = true;\n\n        if (this.events)\n        {\n            this.events.onDestroy$dispatch(this);\n        }\n\n        if (this.parent)\n        {\n            if (this.parent instanceof Phaser.Group)\n            {\n                this.parent.remove(this);\n            }\n            else\n            {\n                this.parent.removeChild(this);\n            }\n        }\n\n        if (this.input)\n        {\n            this.input.destroy();\n        }\n\n        if (this.animations)\n        {\n            this.animations.destroy();\n        }\n\n        if (this.body)\n        {\n            this.body.destroy();\n        }\n\n        if (this.events)\n        {\n            this.events.destroy();\n        }\n\n        this.game.tweens.removeFrom(this);\n\n        var i = this.children.length;\n\n        if (destroyChildren)\n        {\n            while (i--)\n            {\n                this.children[i].destroy(destroyChildren);\n            }\n        }\n        else\n        {\n            while (i--)\n            {\n                this.removeChild(this.children[i]);\n            }\n        }\n\n        if (this._crop)\n        {\n            this._crop = null;\n            this.cropRect = null;\n        }\n\n        if (this._frame)\n        {\n            this._frame = null;\n        }\n\n        if (Phaser.Video && this.key instanceof Phaser.Video)\n        {\n            this.key.onChangeSource.remove(this.resizeFrame, this);\n        }\n\n        if (Phaser.BitmapText && this._glyphs)\n        {\n            this._glyphs = [];\n        }\n\n        this.alive = false;\n        this.exists = false;\n        this.visible = false;\n\n        this.filters = null;\n        this.mask = null;\n        this.game = null;\n\n        this.data = {};\n\n        //  In case Pixi is still going to try and render it even though destroyed\n        this.renderable = false;\n\n        if (this.transformCallback)\n        {\n            this.transformCallback = null;\n            this.transformCallbackContext = null;\n        }\n\n        //  Pixi level DisplayObject destroy\n        this.hitArea = null;\n        this.parent = null;\n        this.stage = null;\n        this.worldTransform = null;\n        this.filterArea = null;\n        this._bounds = null;\n        this._currentBounds = null;\n        this._mask = null;\n\n        this._destroyCachedSprite();\n\n        //  Texture?\n        if (destroyTexture)\n        {\n            this.texture.destroy(true);\n        }\n\n        this.destroyPhase = false;\n        this.pendingDestroy = false;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Events component is a collection of events fired by the parent Game Object.\n* \n* Phaser uses what are known as 'Signals' for all event handling. All of the events in\n* this class are signals you can subscribe to, much in the same way you'd \"listen\" for\n* an event.\n*\n* For example to tell when a Sprite has been added to a new group, you can bind a function\n* to the `onAddedToGroup` signal:\n*\n* `sprite.events.onAddedToGroup.add(yourFunction, this);`\n*\n* Where `yourFunction` is the function you want called when this event occurs.\n* \n* For more details about how signals work please see the Phaser.Signal class.\n*\n* The Input-related events will only be dispatched if the Sprite has had `inputEnabled` set to `true`\n* and the Animation-related events only apply to game objects with animations like {@link Phaser.Sprite}.\n*\n* @class Phaser.Events\n* @constructor\n* @param {Phaser.Sprite} sprite - A reference to the game object / Sprite that owns this Events object.\n*/\nPhaser.Events = function (sprite) {\n\n    /**\n    * @property {Phaser.Sprite} parent - The Sprite that owns these events.\n    */\n    this.parent = sprite;\n\n    // The signals are automatically added by the corresponding proxy properties\n\n};\n\nPhaser.Events.prototype = {\n\n    /**\n     * Removes all events.\n     *\n     * @method Phaser.Events#destroy\n     */\n    destroy: function () {\n\n        this._parent = null;\n\n        if (this._onDestroy)           { this._onDestroy.dispose(); }\n        if (this._onAddedToGroup)      { this._onAddedToGroup.dispose(); }\n        if (this._onRemovedFromGroup)  { this._onRemovedFromGroup.dispose(); }\n        if (this._onRemovedFromWorld)  { this._onRemovedFromWorld.dispose(); }\n        if (this._onKilled)            { this._onKilled.dispose(); }\n        if (this._onRevived)           { this._onRevived.dispose(); }\n        if (this._onEnterBounds)       { this._onEnterBounds.dispose(); }\n        if (this._onOutOfBounds)       { this._onOutOfBounds.dispose(); }\n\n        if (this._onInputOver)         { this._onInputOver.dispose(); }\n        if (this._onInputOut)          { this._onInputOut.dispose(); }\n        if (this._onInputDown)         { this._onInputDown.dispose(); }\n        if (this._onInputUp)           { this._onInputUp.dispose(); }\n        if (this._onDragStart)         { this._onDragStart.dispose(); }\n        if (this._onDragUpdate)        { this._onDragUpdate.dispose(); }\n        if (this._onDragStop)          { this._onDragStop.dispose(); }\n\n        if (this._onAnimationStart)    { this._onAnimationStart.dispose(); }\n        if (this._onAnimationComplete) { this._onAnimationComplete.dispose(); }\n        if (this._onAnimationLoop)     { this._onAnimationLoop.dispose(); }\n\n    },\n\n    // The following properties are sentinels that will be replaced with getters\n\n    /**\n    * This signal is dispatched when this Game Object is added to a new Group.\n    * It is sent two arguments:\n    * {any} The Game Object that was added to the Group.\n    * {Phaser.Group} The Group it was added to.\n    * @property {Phaser.Signal} onAddedToGroup\n    */\n    onAddedToGroup: null,\n\n    /**\n    * This signal is dispatched when the Game Object is removed from a Group.\n    * It is sent two arguments:\n    * {any} The Game Object that was removed from the Group.\n    * {Phaser.Group} The Group it was removed from.\n    * @property {Phaser.Signal} onRemovedFromGroup\n    */\n    onRemovedFromGroup: null,\n\n    /**\n    * This Signal is never used internally by Phaser and is now deprecated.\n    * @deprecated\n    * @property {Phaser.Signal} onRemovedFromWorld\n    */\n    onRemovedFromWorld: null,\n\n    /**\n    * This signal is dispatched when the Game Object is destroyed.\n    * This happens when `Sprite.destroy()` is called, or `Group.destroy()` with `destroyChildren` set to true.\n    * It is sent one argument:\n    * {any} The Game Object that was destroyed.\n    * @property {Phaser.Signal} onDestroy\n    */\n    onDestroy: null,\n\n    /**\n    * This signal is dispatched when the Game Object is killed.\n    * This happens when `Sprite.kill()` is called.\n    * Please understand the difference between `kill` and `destroy` by looking at their respective methods.\n    * It is sent one argument:\n    * {any} The Game Object that was killed.\n    * @property {Phaser.Signal} onKilled\n    */\n    onKilled: null,\n\n    /**\n    * This signal is dispatched when the Game Object is revived from a previously killed state.\n    * This happens when `Sprite.revive()` is called.\n    * It is sent one argument:\n    * {any} The Game Object that was revived.\n    * @property {Phaser.Signal} onRevived\n    */\n    onRevived: null,\n\n    /**\n    * This signal is dispatched when the Game Object leaves the Phaser.World bounds.\n    * This signal is only if `Sprite.checkWorldBounds` is set to `true`.\n    * It is sent one argument:\n    * {any} The Game Object that left the World bounds.\n    * @property {Phaser.Signal} onOutOfBounds\n    */\n    onOutOfBounds: null,\n\n    /**\n    * This signal is dispatched when the Game Object returns within the Phaser.World bounds, having previously been outside of them.\n    * This signal is only if `Sprite.checkWorldBounds` is set to `true`.\n    * It is sent one argument:\n    * {any} The Game Object that entered the World bounds.\n    * @property {Phaser.Signal} onEnterBounds\n    */\n    onEnterBounds: null,\n\n    /**\n    * This signal is dispatched if the Game Object has `inputEnabled` set to `true`, \n    * and receives an over event from a Phaser.Pointer.\n    * It is sent two arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Pointer} The Phaser.Pointer object that caused the event.\n    * @property {Phaser.Signal} onInputOver\n    */\n    onInputOver: null,\n\n    /**\n    * This signal is dispatched if the Game Object has `inputEnabled` set to `true`, \n    * and receives an out event from a Phaser.Pointer, which was previously over it.\n    * It is sent two arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Pointer} The Phaser.Pointer object that caused the event.\n    * @property {Phaser.Signal} onInputOut\n    */\n    onInputOut: null,\n\n    /**\n    * This signal is dispatched if the Game Object has `inputEnabled` set to `true`, \n    * and receives a down event from a Phaser.Pointer. This effectively means the Pointer has been\n    * pressed down (but not yet released) on the Game Object.\n    * It is sent two arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Pointer} The Phaser.Pointer object that caused the event.\n    * @property {Phaser.Signal} onInputDown\n    */\n    onInputDown: null,\n\n    /**\n    * This signal is dispatched if the Game Object has `inputEnabled` set to `true`, \n    * and receives an up event from a Phaser.Pointer. This effectively means the Pointer had been\n    * pressed down, and was then released on the Game Object.\n    * It is sent three arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Pointer} The Phaser.Pointer object that caused the event.\n    * {boolean} isOver - Is the Pointer still over the Game Object?\n    * @property {Phaser.Signal} onInputUp\n    */\n    onInputUp: null,\n\n    /**\n    * This signal is dispatched if the Game Object has been `inputEnabled` and `enableDrag` has been set.\n    * It is sent when a Phaser.Pointer starts to drag the Game Object, taking into consideration the various\n    * drag limitations that may be set.\n    * It is sent four arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Pointer} The Phaser.Pointer object that caused the event.\n    * {number} The x coordinate that the drag started from.\n    * {number} The y coordinate that the drag started from.\n    * @property {Phaser.Signal} onDragStart\n    */\n    onDragStart: null,\n\n    /**\n    * This signal is dispatched if the Game Object has been `inputEnabled` and `enableDrag` has been set.\n    * It is sent when a Phaser.Pointer is actively dragging the Game Object.\n    * Be warned: This is a high volume Signal. Be careful what you bind to it.\n    * It is sent six arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Pointer} The Phaser.Pointer object that caused the event.\n    * {number} The new x coordinate of the Game Object.\n    * {number} The new y coordinate of the Game Object.\n    * {Phaser.Point} A Point object that contains the point the Game Object was snapped to, if `snapOnDrag` has been enabled.\n    * {boolean} The `fromStart` boolean, indicates if this is the first update immediately after the drag has started.\n    * @property {Phaser.Signal} onDragUpdate\n    */\n    onDragUpdate: null,\n\n    /**\n    * This signal is dispatched if the Game Object has been `inputEnabled` and `enableDrag` has been set.\n    * It is sent when a Phaser.Pointer stops dragging the Game Object.\n    * It is sent two arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Pointer} The Phaser.Pointer object that caused the event.\n    * @property {Phaser.Signal} onDragStop\n    */\n    onDragStop: null,\n\n    /**\n    * This signal is dispatched if the Game Object has the AnimationManager component, \n    * and an Animation has been played.\n    * You can also listen to `Animation.onStart` rather than via the Game Objects events.\n    * It is sent two arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Animation} The Phaser.Animation that was started.\n    * @property {Phaser.Signal} onAnimationStart\n    */\n    onAnimationStart: null,\n\n    /**\n    * This signal is dispatched if the Game Object has the AnimationManager component, \n    * and an Animation has been stopped (via `animation.stop()` and the `dispatchComplete` argument has been set.\n    * You can also listen to `Animation.onComplete` rather than via the Game Objects events.\n    * It is sent two arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Animation} The Phaser.Animation that was stopped.\n    * @property {Phaser.Signal} onAnimationComplete\n    */\n    onAnimationComplete: null,\n\n    /**\n    * This signal is dispatched if the Game Object has the AnimationManager component, \n    * and an Animation has looped playback.\n    * You can also listen to `Animation.onLoop` rather than via the Game Objects events.\n    * It is sent two arguments:\n    * {any} The Game Object that received the event.\n    * {Phaser.Animation} The Phaser.Animation that looped.\n    * @property {Phaser.Signal} onAnimationLoop\n    */\n    onAnimationLoop: null\n\n};\n\nPhaser.Events.prototype.constructor = Phaser.Events;\n\n// Create an auto-create proxy getter and dispatch method for all events.\n// The backing property is the same as the event name, prefixed with '_'\n// and the dispatch method is the same as the event name postfixed with '$dispatch'.\nfor (var prop in Phaser.Events.prototype)\n{\n    if (!Phaser.Events.prototype.hasOwnProperty(prop) ||\n        prop.indexOf('on') !== 0 ||\n        Phaser.Events.prototype[prop] !== null)\n    {\n        continue;\n    }\n\n    (function (prop, backing) {\n        'use strict';\n\n        // The accessor creates a new Signal; and so it should only be used from user-code.\n        Object.defineProperty(Phaser.Events.prototype, prop, {\n            get: function () {\n                return this[backing] || (this[backing] = new Phaser.Signal());\n            }\n        });\n\n        // The dispatcher will only broadcast on an already-created signal; call this internally.\n        Phaser.Events.prototype[prop + '$dispatch'] = function () {\n            return this[backing] ? this[backing].dispatch.apply(this[backing], arguments) : null;\n        };\n\n    })(prop, '_' + prop);\n\n}\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The FixedToCamera component enables a Game Object to be rendered relative to the game camera coordinates, regardless \n* of where in the world the camera is. This is used for things like sticking game UI to the camera that scrolls as it moves around the world.\n*\n* @class\n*/\nPhaser.Component.FixedToCamera = function () {};\n\n/**\n * The FixedToCamera component postUpdate handler.\n * Called automatically by the Game Object.\n *\n * @method\n */\nPhaser.Component.FixedToCamera.postUpdate = function () {\n\n    if (this.fixedToCamera)\n    {\n        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;\n        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;\n    }\n\n};\n\nPhaser.Component.FixedToCamera.prototype = {\n\n    /**\n    * @property {boolean} _fixedToCamera\n    * @private\n    */\n    _fixedToCamera: false,\n\n    /**\n    * A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n    * \n    * The values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n    * \n    * The end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\n    * the camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \n    * regardless where in the world the camera is.\n    * \n    * The offsets are stored in the `cameraOffset` property.\n    * \n    * Note that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n    *\n    * Be careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.\n    *\n    * @property {boolean} fixedToCamera\n    */\n    fixedToCamera: {\n\n        get: function () {\n\n            return this._fixedToCamera;\n\n        },\n\n        set: function (value) {\n\n            if (value)\n            {\n                this._fixedToCamera = true;\n                this.cameraOffset.set(this.x, this.y);\n            }\n            else\n            {\n                this._fixedToCamera = false;\n            }\n\n        }\n\n    },\n\n    /**\n    * The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n    * \n    * The values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.\n    * @property {Phaser.Point} cameraOffset\n    */\n    cameraOffset: new Phaser.Point()\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Health component provides the ability for Game Objects to have a `health` property \n* that can be damaged and reset through game code.\n* Requires the LifeSpan component.\n*\n* @class\n*/\nPhaser.Component.Health = function () {};\n\nPhaser.Component.Health.prototype = {\n\n    /**\n    * The Game Objects health value. This is a handy property for setting and manipulating health on a Game Object.\n    * \n    * It can be used in combination with the `damage` method or modified directly.\n    * \n    * @property {number} health\n    * @default\n    */\n    health: 1,\n\n    /**\n    * The Game Objects maximum health value. This works in combination with the `heal` method to ensure\n    * the health value never exceeds the maximum.\n    * \n    * @property {number} maxHealth\n    * @default\n    */\n    maxHealth: 100,\n\n    /**\n    * Damages the Game Object. This removes the given amount of health from the `health` property.\n    * \n    * If health is taken below or is equal to zero then the `kill` method is called.\n    *\n    * @member\n    * @param {number} amount - The amount to subtract from the current `health` value.\n    * @return {Phaser.Sprite} This instance.\n    */\n    damage: function (amount) {\n\n        if (this.alive)\n        {\n            this.health -= amount;\n\n            if (this.health <= 0)\n            {\n                this.kill();\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Sets the health property of the Game Object to the given amount.\n    * Will never exceed the `maxHealth` value.\n    *\n    * @member\n    * @param {number} amount - The amount to set the `health` value to. The total will never exceed `maxHealth`.\n    * @return {Phaser.Sprite} This instance.\n    */\n    setHealth: function (amount) {\n\n        this.health = amount;\n\n        if (this.health > this.maxHealth)\n        {\n            this.health = this.maxHealth;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Heal the Game Object. This adds the given amount of health to the `health` property.\n    *\n    * @member\n    * @param {number} amount - The amount to add to the current `health` value. The total will never exceed `maxHealth`.\n    * @return {Phaser.Sprite} This instance.\n    */\n    heal: function (amount) {\n\n        if (this.alive)\n        {\n            this.health += amount;\n\n            if (this.health > this.maxHealth)\n            {\n                this.health = this.maxHealth;\n            }\n        }\n\n        return this;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The InCamera component checks if the Game Object intersects with the Game Camera.\n*\n* @class\n*/\nPhaser.Component.InCamera = function () {};\n\nPhaser.Component.InCamera.prototype = {\n\n    /**\n    * Checks if this Game Objects bounds intersects with the Game Cameras bounds.\n    * \n    * It will be `true` if they intersect, or `false` if the Game Object is fully outside of the Cameras bounds.\n    * \n    * An object outside the bounds can be considered for camera culling if it has the AutoCull component.\n    *\n    * @property {boolean} inCamera\n    * @readonly\n    */\n    inCamera: {\n\n        get: function() {\n\n            return this.game.world.camera.view.intersects(this._bounds);\n\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The InputEnabled component allows a Game Object to have its own InputHandler and process input related events.\n*\n* @class\n*/\nPhaser.Component.InputEnabled = function () {};\n\nPhaser.Component.InputEnabled.prototype = {\n\n    /**\n    * The Input Handler for this Game Object.\n    * \n    * By default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n    * \n    * After you have done this, this property will be a reference to the Phaser InputHandler.\n    * @property {Phaser.InputHandler|null} input \n    */\n    input: null,\n\n    /**\n    * By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\n    * for this Game Object and it will then start to process click / touch events and more.\n    * \n    * You can then access the Input Handler via `this.input`.\n    * \n    * Note that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n    * \n    * If you set this property to false it will stop the Input Handler from processing any more input events.\n    * \n    * If you want to _temporarily_ disable input for a Game Object, then it's better to set\n    * `input.enabled = false`, as it won't reset any of the Input Handlers internal properties.\n    * You can then toggle this back on as needed.\n    *\n    * @property {boolean} inputEnabled\n    */\n    inputEnabled: {\n\n        get: function () {\n\n            return (this.input && this.input.enabled);\n\n        },\n\n        set: function (value) {\n\n            if (value)\n            {\n                if (this.input === null)\n                {\n                    this.input = new Phaser.InputHandler(this);\n                    this.input.start();\n                }\n                else if (this.input && !this.input.enabled)\n                {\n                    this.input.start();\n                }\n            }\n            else\n            {\n                if (this.input && this.input.enabled)\n                {\n                    this.input.stop();\n                }\n            }\n\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The InWorld component checks if a Game Object is within the Game World Bounds.\n* An object is considered as being \"in bounds\" so long as its own bounds intersects at any point with the World bounds.\n* If the AutoCull component is enabled on the Game Object then it will check the Game Object against the Camera bounds as well.\n*\n* @class\n*/\nPhaser.Component.InWorld = function () {};\n\n/**\n * The InWorld component preUpdate handler.\n * Called automatically by the Game Object.\n *\n * @method\n */\nPhaser.Component.InWorld.preUpdate = function () {\n\n    //  Cache the bounds if we need it\n    if (this.autoCull || this.checkWorldBounds)\n    {\n        this._bounds.copyFrom(this.getBounds());\n\n        this._bounds.x += this.game.camera.view.x;\n        this._bounds.y += this.game.camera.view.y;\n\n        if (this.autoCull)\n        {\n            //  Won't get rendered but will still get its transform updated\n            if (this.game.world.camera.view.intersects(this._bounds))\n            {\n                this.renderable = true;\n                this.game.world.camera.totalInView++;\n            }\n            else\n            {\n                this.renderable = false;\n\n                if (this.outOfCameraBoundsKill)\n                {\n                    this.kill();\n                    return false;\n                }\n            }\n        }\n\n        if (this.checkWorldBounds)\n        {\n            //  The Sprite is already out of the world bounds, so let's check to see if it has come back again\n            if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds))\n            {\n                this._outOfBoundsFired = false;\n                this.events.onEnterBounds$dispatch(this);\n            }\n            else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds))\n            {\n                //  The Sprite WAS in the screen, but has now left.\n                this._outOfBoundsFired = true;\n                this.events.onOutOfBounds$dispatch(this);\n\n                if (this.outOfBoundsKill)\n                {\n                    this.kill();\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n\n};\n\nPhaser.Component.InWorld.prototype = {\n\n    /**\n    * If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n    * \n    * When it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n    * \n    * If it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n    * \n    * It also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n    * \n    * When `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n    * \n    * This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\n    * or you have tested performance and find it acceptable.\n    * \n    * @property {boolean} checkWorldBounds\n    * @default\n    */\n    checkWorldBounds: false,\n\n    /**\n    * If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.\n    * \n    * @property {boolean} outOfBoundsKill\n    * @default\n    */\n    outOfBoundsKill: false,\n\n    /**\n     * If this and the `autoCull` property are both set to `true`, then the `kill` method\n     * is called as soon as the Game Object leaves the camera bounds.\n     *\n     * @property {boolean} outOfCameraBoundsKill\n     * @default\n     */\n    outOfCameraBoundsKill: false,\n\n    /**\n    * @property {boolean} _outOfBoundsFired - Internal state var.\n    * @private\n    */\n    _outOfBoundsFired: false,\n\n    /**\n    * Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.\n    *\n    * @property {boolean} inWorld\n    * @readonly\n    */\n    inWorld: {\n\n        get: function () {\n\n            return this.game.world.bounds.intersects(this.getBounds());\n\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* LifeSpan Component Features.\n*\n* @class\n*/\nPhaser.Component.LifeSpan = function () {};\n\n/**\n * The LifeSpan component preUpdate handler.\n * Called automatically by the Game Object.\n *\n * @method\n */\nPhaser.Component.LifeSpan.preUpdate = function () {\n\n    if (this.lifespan > 0)\n    {\n        this.lifespan -= this.game.time.physicsElapsedMS;\n\n        if (this.lifespan <= 0)\n        {\n            this.kill();\n            return false;\n        }\n    }\n\n    return true;\n\n};\n\nPhaser.Component.LifeSpan.prototype = {\n\n    /**\n    * A useful flag to control if the Game Object is alive or dead.\n    *\n    * This is set automatically by the Health components `damage` method should the object run out of health.\n    * Or you can toggle it via your game code.\n    *\n    * This property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\n    * However you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.\n    * @property {boolean} alive\n    * @default\n    */\n    alive: true,\n\n    /**\n    * The lifespan allows you to give a Game Object a lifespan in milliseconds.\n    *\n    * Once the Game Object is 'born' you can set this to a positive value.\n    *\n    * It is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\n    * When it reaches zero it will call the `kill` method.\n    *\n    * Very handy for particles, bullets, collectibles, or any other short-lived entity.\n    *\n    * @property {number} lifespan\n    * @default\n    */\n    lifespan: 0,\n\n    /**\n    * Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n    *\n    * A resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n    *\n    * It will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.\n    *\n    * @method\n    * @param {number} [health=100] - The health to give the Game Object. Only set if the GameObject has the Health component.\n    * @return {PIXI.DisplayObject} This instance.\n    */\n    revive: function (health) {\n\n        if (health === undefined) { health = 100; }\n\n        this.alive = true;\n        this.exists = true;\n        this.visible = true;\n\n        if (typeof this.setHealth === 'function')\n        {\n            this.setHealth(health);\n        }\n\n        if (this.events)\n        {\n            this.events.onRevived$dispatch(this);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n    *\n    * It will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n    *\n    * Note that killing a Game Object is a way for you to quickly recycle it in an object pool,\n    * it doesn't destroy the object or free it up from memory.\n    *\n    * If you don't need this Game Object any more you should call `destroy` instead.\n    *\n    * @method\n    * @return {PIXI.DisplayObject} This instance.\n    */\n    kill: function () {\n\n        this.alive = false;\n        this.exists = false;\n        this.visible = false;\n\n        if (this.events)\n        {\n            this.events.onKilled$dispatch(this);\n        }\n\n        return this;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The LoadTexture component manages the loading of a texture into the Game Object and the changing of frames.\n*\n* @class\n*/\nPhaser.Component.LoadTexture = function () {};\n\nPhaser.Component.LoadTexture.prototype = {\n\n    /**\n    * @property {boolean} customRender - Does this texture require a custom render call? (as set by BitmapData, Video, etc)\n    * @private\n    */\n    customRender: false,\n\n    /**\n    * @property {Phaser.Rectangle} _frame - Internal cache var.\n    * @private\n    */\n    _frame: null,\n\n    /**\n    * Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n    * \n    * If your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n    * \n    * You should only use `loadTexture` if you want to replace the base texture entirely.\n    * \n    * Calling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n    *\n    * You can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \n    * Doing this then sets the key to be the `frame` argument (the frame is set to zero). \n    * \n    * This allows you to create sprites using `load.image` during development, and then change them \n    * to use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \n    * and swapping it to be the key of the atlas data.\n    *\n    * Note: You cannot use a RenderTexture as a texture for a TileSprite.\n    *\n    * @method\n    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache Image entry, or an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n    * @param {string|number} [frame] - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n    * @param {boolean} [stopAnimation=true] - If an animation is already playing on this Sprite you can choose to stop it or let it carry on playing.\n    */\n    loadTexture: function (key, frame, stopAnimation) {\n\n        if (key === Phaser.PENDING_ATLAS)\n        {\n            key = frame;\n            frame = 0;\n        }\n        else\n        {\n            frame = frame || 0;\n        }\n\n        if ((stopAnimation || stopAnimation === undefined) && this.animations)\n        {\n            this.animations.stop();\n        }\n\n        this.key = key;\n        this.customRender = false;\n        var cache = this.game.cache;\n\n        var setFrame = true;\n        var smoothed = !this.texture.baseTexture.scaleMode;\n\n        if (Phaser.RenderTexture && key instanceof Phaser.RenderTexture)\n        {\n            this.key = key.key;\n            this.setTexture(key);\n        }\n        else if (Phaser.BitmapData && key instanceof Phaser.BitmapData)\n        {\n            this.customRender = true;\n\n            this.setTexture(key.texture);\n\n            if (cache.hasFrameData(key.key, Phaser.Cache.BITMAPDATA))\n            {\n                setFrame = !this.animations.loadFrameData(cache.getFrameData(key.key, Phaser.Cache.BITMAPDATA), frame);\n            }\n            else\n            {\n                setFrame = !this.animations.loadFrameData(key.frameData, 0);\n            }\n        }\n        else if (Phaser.Video && key instanceof Phaser.Video)\n        {\n            this.customRender = true;\n\n            //  This works from a reference, which probably isn't what we need here\n            var valid = key.texture.valid;\n            this.setTexture(key.texture);\n            this.setFrame(key.texture.frame.clone());\n            key.onChangeSource.add(this.resizeFrame, this);\n            this.texture.valid = valid;\n        }\n        else if (Phaser.Tilemap && key instanceof Phaser.TilemapLayer)\n        {\n            // this.customRender = true;\n\n            this.setTexture(PIXI.Texture.fromCanvas(key.canvas));\n        }\n        else if (key instanceof PIXI.Texture)\n        {\n            this.setTexture(key);\n        }\n        else\n        {\n            var img = cache.getImage(key, true);\n\n            this.key = img.key;\n            this.setTexture(new PIXI.Texture(img.base));\n\n            if (key === '__default')\n            {\n                this.texture.baseTexture.skipRender = true;\n            }\n            else\n            {\n                this.texture.baseTexture.skipRender = false;\n            }\n\n            setFrame = !this.animations.loadFrameData(img.frameData, frame);\n        }\n        \n        if (setFrame)\n        {\n            this._frame = Phaser.Rectangle.clone(this.texture.frame);\n        }\n\n        if (!smoothed)\n        {\n            this.texture.baseTexture.scaleMode = 1;\n        }\n\n    },\n\n    /**\n    * Sets the texture frame the Game Object uses for rendering.\n    * \n    * This is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.\n    *\n    * @method\n    * @param {Phaser.Frame} frame - The Frame to be used by the texture.\n    */\n    setFrame: function (frame) {\n\n        this._frame = frame;\n\n        this.texture.frame.x = frame.x;\n        this.texture.frame.y = frame.y;\n        this.texture.frame.width = frame.width;\n        this.texture.frame.height = frame.height;\n\n        this.texture.crop.x = frame.x;\n        this.texture.crop.y = frame.y;\n        this.texture.crop.width = frame.width;\n        this.texture.crop.height = frame.height;\n\n        if (frame.trimmed)\n        {\n            if (this.texture.trim)\n            {\n                this.texture.trim.x = frame.spriteSourceSizeX;\n                this.texture.trim.y = frame.spriteSourceSizeY;\n                this.texture.trim.width = frame.sourceSizeW;\n                this.texture.trim.height = frame.sourceSizeH;\n            }\n            else\n            {\n                this.texture.trim = { x: frame.spriteSourceSizeX, y: frame.spriteSourceSizeY, width: frame.sourceSizeW, height: frame.sourceSizeH };\n            }\n\n            this.texture.width = frame.sourceSizeW;\n            this.texture.height = frame.sourceSizeH;\n            this.texture.frame.width = frame.sourceSizeW;\n            this.texture.frame.height = frame.sourceSizeH;\n        }\n        else if (!frame.trimmed && this.texture.trim)\n        {\n            this.texture.trim = null;\n        }\n\n        if (this.cropRect)\n        {\n            this.updateCrop();\n        }\n        \n        this.texture.requiresReTint = true;\n        \n        this.texture._updateUvs();\n\n        if (this.tilingTexture)\n        {\n            this.refreshTexture = true;\n        }\n\n    },\n\n    /**\n    * Resizes the Frame dimensions that the Game Object uses for rendering.\n    * \n    * You shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\n    * it can be useful to adjust the dimensions directly in this way.\n    *\n    * @method\n    * @param {object} parent - The parent texture object that caused the resize, i.e. a Phaser.Video object.\n    * @param {integer} width - The new width of the texture.\n    * @param {integer} height - The new height of the texture.\n    */\n    resizeFrame: function (parent, width, height) {\n\n        this.texture.frame.resize(width, height);\n        this.texture.setFrame(this.texture.frame);\n\n    },\n\n    /**\n    * Resets the texture frame dimensions that the Game Object uses for rendering.\n    *\n    * @method\n    */\n    resetFrame: function () {\n\n        if (this._frame)\n        {\n            this.setFrame(this._frame);\n        }\n\n    },\n\n    /**\n    * Gets or sets the current frame index of the texture being used to render this Game Object.\n    *\n    * To change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\n    * for example: `player.frame = 4`.\n    * \n    * If the frame index given doesn't exist it will revert to the first frame found in the texture.\n    * \n    * If you are using a texture atlas then you should use the `frameName` property instead.\n    * \n    * If you wish to fully replace the texture being used see `loadTexture`.\n    * @property {integer} frame\n    */\n    frame: {\n\n        get: function () {\n            return this.animations.frame;\n        },\n\n        set: function (value) {\n            this.animations.frame = value;\n        }\n\n    },\n\n    /**\n    * Gets or sets the current frame name of the texture being used to render this Game Object.\n    * \n    * To change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \n    * for example: `player.frameName = \"idle\"`.\n    *\n    * If the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n    * \n    * If you are using a sprite sheet then you should use the `frame` property instead.\n    * \n    * If you wish to fully replace the texture being used see `loadTexture`.\n    * @property {string} frameName\n    */\n    frameName: {\n\n        get: function () {\n            return this.animations.frameName;\n        },\n\n        set: function (value) {\n            this.animations.frameName = value;\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Overlap component allows a Game Object to check if it overlaps with the bounds of another Game Object.\n*\n* @class\n*/\nPhaser.Component.Overlap = function () {};\n\nPhaser.Component.Overlap.prototype = {\n\n    /**\n    * Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \n    * which can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n    * \n    * This check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n    * \n    * Therefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\n    * It should be fine for low-volume testing where physics isn't required.\n    *\n    * @method\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.TileSprite|Phaser.Button|PIXI.DisplayObject} displayObject - The display object to check against.\n    * @return {boolean} True if the bounds of this Game Object intersects at any point with the bounds of the given display object.\n    */\n    overlap: function (displayObject) {\n\n        return Phaser.Rectangle.intersects(this.getBounds(), displayObject.getBounds());\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The PhysicsBody component manages the Game Objects physics body and physics enabling.\n* It also overrides the x and y properties, ensuring that any manual adjustment of them is reflected in the physics body itself.\n*\n* @class\n*/\nPhaser.Component.PhysicsBody = function () {};\n\n/**\n * The PhysicsBody component preUpdate handler.\n * Called automatically by the Game Object.\n *\n * @method\n */\nPhaser.Component.PhysicsBody.preUpdate = function () {\n\n    if (this.fresh && this.exists)\n    {\n        this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);\n        this.worldTransform.tx = this.world.x;\n        this.worldTransform.ty = this.world.y;\n\n        this.previousPosition.set(this.world.x, this.world.y);\n        this.previousRotation = this.rotation;\n\n        if (this.body)\n        {\n            this.body.preUpdate();\n        }\n\n        this.fresh = false;\n\n        return false;\n    }\n\n    this.previousPosition.set(this.world.x, this.world.y);\n    this.previousRotation = this.rotation;\n\n    if (!this._exists || !this.parent.exists)\n    {\n        this.renderOrderID = -1;\n        return false;\n    }\n\n    return true;\n\n};\n\n/**\n * The PhysicsBody component postUpdate handler.\n * Called automatically by the Game Object.\n *\n * @method\n */\nPhaser.Component.PhysicsBody.postUpdate = function () {\n\n    if (this.exists && this.body)\n    {\n        this.body.postUpdate();\n    }\n\n};\n\nPhaser.Component.PhysicsBody.prototype = {\n\n    /**\n    * `body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \n    * properties and methods via it.\n    * \n    * By default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n    * \n    * To enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\n    * and `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n    * \n    * You can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n    *\n    * Important: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \n    * so the physics body is centered on the Game Object.\n    * \n    * If you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.\n    *\n    * @property {Phaser.Physics.Arcade.Body|Phaser.Physics.P2.Body|Phaser.Physics.Ninja.Body|null} body\n    * @default\n    */\n    body: null,\n\n    /**\n    * The position of the Game Object on the x axis relative to the local coordinates of the parent.\n    *\n    * @property {number} x\n    */\n    x: {\n\n        get: function () {\n\n            return this.position.x;\n\n        },\n\n        set: function (value) {\n\n            this.position.x = value;\n\n            if (this.body && !this.body.dirty)\n            {\n                this.body._reset = true;\n            }\n\n        }\n\n    },\n\n    /**\n    * The position of the Game Object on the y axis relative to the local coordinates of the parent.\n    *\n    * @property {number} y\n    */\n    y: {\n\n        get: function () {\n\n            return this.position.y;\n\n        },\n\n        set: function (value) {\n\n            this.position.y = value;\n\n            if (this.body && !this.body.dirty)\n            {\n                this.body._reset = true;\n            }\n\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Reset component allows a Game Object to be reset and repositioned to a new location.\n*\n* @class\n*/\nPhaser.Component.Reset = function () {};\n\n/**\n* Resets the Game Object.\n* \n* This moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n* `visible` and `renderable` to true.\n*\n* If this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n*\n* If this Game Object has a Physics Body it will reset the Body.\n*\n* @method\n* @param {number} x - The x coordinate (in world space) to position the Game Object at.\n* @param {number} y - The y coordinate (in world space) to position the Game Object at.\n* @param {number} [health=1] - The health to give the Game Object if it has the Health component.\n* @return {PIXI.DisplayObject} This instance.\n*/\nPhaser.Component.Reset.prototype.reset = function (x, y, health) {\n\n    if (health === undefined) { health = 1; }\n\n    this.world.set(x, y);\n    this.position.set(x, y);\n\n    this.fresh = true;\n    this.exists = true;\n    this.visible = true;\n    this.renderable = true;\n\n    if (this.components.InWorld)\n    {\n        this._outOfBoundsFired = false;\n    }\n\n    if (this.components.LifeSpan)\n    {\n        this.alive = true;\n        this.health = health;\n    }\n\n    if (this.components.PhysicsBody)\n    {\n        if (this.body)\n        {\n            this.body.reset(x, y, false, false);\n        }\n    }\n\n    return this;\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The ScaleMinMax component allows a Game Object to limit how far it can be scaled by its parent.\n*\n* @class\n*/\nPhaser.Component.ScaleMinMax = function () {};\n\nPhaser.Component.ScaleMinMax.prototype = {\n\n    /**\n    * The callback that will apply any scale limiting to the worldTransform.\n    * @property {function} transformCallback\n    */\n    transformCallback: null,\n\n    /**\n    * The context under which `transformCallback` is called.\n    * @property {object} transformCallbackContext\n    */\n    transformCallbackContext: this,\n\n    /**\n    * The minimum scale this Game Object will scale down to.\n    * \n    * It allows you to prevent a parent from scaling this Game Object lower than the given value.\n    * \n    * Set it to `null` to remove the limit.\n    * @property {Phaser.Point} scaleMin\n    */\n    scaleMin: null,\n\n    /**\n    * The maximum scale this Game Object will scale up to. \n    * \n    * It allows you to prevent a parent from scaling this Game Object higher than the given value.\n    * \n    * Set it to `null` to remove the limit.\n    * @property {Phaser.Point} scaleMax\n    */\n    scaleMax: null,\n\n    /**\n     * Adjust scaling limits, if set, to this Game Object.\n     *\n     * @method\n     * @private\n     * @param {PIXI.Matrix} wt - The updated worldTransform matrix.\n     */\n    checkTransform: function (wt) {\n\n        if (this.scaleMin)\n        {\n            if (wt.a < this.scaleMin.x)\n            {\n                wt.a = this.scaleMin.x;\n            }\n\n            if (wt.d < this.scaleMin.y)\n            {\n                wt.d = this.scaleMin.y;\n            }\n        }\n\n        if (this.scaleMax)\n        {\n            if (wt.a > this.scaleMax.x)\n            {\n                wt.a = this.scaleMax.x;\n            }\n\n            if (wt.d > this.scaleMax.y)\n            {\n                wt.d = this.scaleMax.y;\n            }\n        }\n\n    },\n\n    /**\n     * Sets the scaleMin and scaleMax values. These values are used to limit how far this Game Object will scale based on its parent.\n     * \n     * For example if this Game Object has a `minScale` value of 1 and its parent has a `scale` value of 0.5, the 0.5 will be ignored \n     * and the scale value of 1 will be used, as the parents scale is lower than the minimum scale this Game Object should adhere to.\n     * \n     * By setting these values you can carefully control how Game Objects deal with responsive scaling.\n     * \n     * If only one parameter is given then that value will be used for both scaleMin and scaleMax:\n     * `setScaleMinMax(1)` = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1\n     *\n     * If only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:\n     * `setScaleMinMax(0.5, 2)` = scaleMin.x and y = 0.5 and scaleMax.x and y = 2\n     *\n     * If you wish to set `scaleMin` with different values for x and y then either modify Game Object.scaleMin directly, \n     * or pass `null` for the `maxX` and `maxY` parameters.\n     * \n     * Call `setScaleMinMax(null)` to clear all previously set values.\n     *\n     * @method\n     * @param {number|null} minX - The minimum horizontal scale value this Game Object can scale down to.\n     * @param {number|null} minY - The minimum vertical scale value this Game Object can scale down to.\n     * @param {number|null} maxX - The maximum horizontal scale value this Game Object can scale up to.\n     * @param {number|null} maxY - The maximum vertical scale value this Game Object can scale up to.\n     */\n    setScaleMinMax: function (minX, minY, maxX, maxY) {\n\n        if (minY === undefined)\n        {\n            //  1 parameter, set all to it\n            minY = maxX = maxY = minX;\n        }\n        else if (maxX === undefined)\n        {\n            //  2 parameters, the first is min, the second max\n            maxX = maxY = minY;\n            minY = minX;\n        }\n\n        if (minX === null)\n        {\n            this.scaleMin = null;\n        }\n        else\n        {\n            if (this.scaleMin)\n            {\n                this.scaleMin.set(minX, minY);\n            }\n            else\n            {\n                this.scaleMin = new Phaser.Point(minX, minY);\n            }\n        }\n\n        if (maxX === null)\n        {\n            this.scaleMax = null;\n        }\n        else\n        {\n            if (this.scaleMax)\n            {\n                this.scaleMax.set(maxX, maxY);\n            }\n            else\n            {\n                this.scaleMax = new Phaser.Point(maxX, maxY);\n            }\n        }\n\n        if (this.scaleMin === null)\n        {\n            this.transformCallback = null;\n        }\n        else\n        {\n            this.transformCallback = this.checkTransform;\n            this.transformCallbackContext = this;\n        }\n\n    }\n\n};\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Smoothed component allows a Game Object to control anti-aliasing of an image based texture.\n*\n* @class\n*/\nPhaser.Component.Smoothed = function () {};\n\nPhaser.Component.Smoothed.prototype = {\n\n    /**\n    * Enable or disable texture smoothing for this Game Object.\n    * \n    * It only takes effect if the Game Object is using an image based texture.\n    * \n    * Smoothing is enabled by default.\n    *\n    * @property {boolean} smoothed\n    */\n    smoothed: {\n\n        get: function () {\n\n            return !this.texture.baseTexture.scaleMode;\n\n        },\n\n        set: function (value) {\n\n            if (value)\n            {\n                if (this.texture)\n                {\n                    this.texture.baseTexture.scaleMode = 0;\n                }\n            }\n            else\n            {\n                if (this.texture)\n                {\n                    this.texture.baseTexture.scaleMode = 1;\n                }\n            }\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The GameObjectFactory is a quick way to create many common game objects\n* using {@linkcode Phaser.Game#add `game.add`}.\n*\n* Created objects are _automatically added_ to the appropriate Manager, World, or manually specified parent Group.\n*\n* @class Phaser.GameObjectFactory\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.GameObjectFactory = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    * @protected\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.World} world - A reference to the game world.\n    * @protected\n    */\n    this.world = this.game.world;\n\n};\n\nPhaser.GameObjectFactory.prototype = {\n\n    /**\n    * Adds an existing display object to the game world.\n    * \n    * @method Phaser.GameObjectFactory#existing\n    * @param {any} object - An instance of Phaser.Sprite, Phaser.Button or any other display object.\n    * @return {any} The child that was added to the World.\n    */\n    existing: function (object) {\n\n        return this.world.add(object);\n\n    },\n\n    /**\n    * Weapons provide the ability to easily create a bullet pool and manager.\n    *\n    * Weapons fire Phaser.Bullet objects, which are essentially Sprites with a few extra properties.\n    * The Bullets are enabled for Arcade Physics. They do not currently work with P2 Physics.\n    *\n    * The Bullets are created inside of `Weapon.bullets`, which is a Phaser.Group instance. Anything you\n    * can usually do with a Group, such as move it around the display list, iterate it, etc can be done\n    * to the bullets Group too.\n    *\n    * Bullets can have textures and even animations. You can control the speed at which they are fired,\n    * the firing rate, the firing angle, and even set things like gravity for them.\n    *\n    * @method Phaser.GameObjectFactory#weapon\n    * @param {integer} [quantity=1] - The quantity of bullets to seed the Weapon with. If -1 it will set the pool to automatically expand.\n    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by the bullets during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used by the bullets. Use either an integer for a Frame ID or a string for a frame name.\n    * @param {Phaser.Group} [group] - Optional Group to add the Weapon to. If not specified it will be added to the World group.\n    * @returns {Phaser.Weapon} A Weapon instance.\n    */\n    weapon: function (quantity, key, frame, group) {\n\n        var weapon = this.game.plugins.add(Phaser.Weapon);\n\n        weapon.createBullets(quantity, key, frame, group);\n\n        return weapon;\n\n    },\n\n    /**\n    * Create a new `Image` object.\n    * \n    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.\n    * \n    * It can still rotate, scale, crop and receive input events. \n    * This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.\n    *\n    * @method Phaser.GameObjectFactory#image\n    * @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.\n    * @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.\n    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @returns {Phaser.Image} The newly created Image object.\n    */\n    image: function (x, y, key, frame, group) {\n\n        if (group === undefined) { group = this.world; }\n\n        return group.add(new Phaser.Image(this.game, x, y, key, frame));\n\n    },\n\n    /**\n    * Create a new Sprite with specific position and sprite sheet key.\n    *\n    * At its most basic a Sprite consists of a set of coordinates and a texture that is used when rendered.\n    * They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),\n    * events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.\n    *\n    * @method Phaser.GameObjectFactory#sprite\n    * @param {number} [x=0] - The x coordinate of the sprite. The coordinate is relative to any parent container this sprite may be in.\n    * @param {number} [y=0] - The y coordinate of the sprite. The coordinate is relative to any parent container this sprite may be in.\n    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @returns {Phaser.Sprite} The newly created Sprite object.\n    */\n    sprite: function (x, y, key, frame, group) {\n\n        if (group === undefined) { group = this.world; }\n\n        return group.create(x, y, key, frame);\n\n    },\n\n    /**\n    * Create a new Creature Animation object.\n    *\n    * Creature is a custom Game Object used in conjunction with the Creature Runtime libraries by Kestrel Moon Studios.\n    * \n    * It allows you to display animated Game Objects that were created with the [Creature Automated Animation Tool](http://www.kestrelmoon.com/creature/).\n    * \n    * Note 1: You can only use Phaser.Creature objects in WebGL enabled games. They do not work in Canvas mode games.\n    *\n    * Note 2: You must use a build of Phaser that includes the CreatureMeshBone.js runtime and gl-matrix.js, or have them\n    * loaded before your Phaser game boots.\n    * \n    * See the Phaser custom build process for more details.\n    *\n    * @method Phaser.GameObjectFactory#creature\n    * @param {number} [x=0] - The x coordinate of the creature. The coordinate is relative to any parent container this creature may be in.\n    * @param {number} [y=0] - The y coordinate of the creature. The coordinate is relative to any parent container this creature may be in.\n    * @param {string|PIXI.Texture} [key] - The image used as a texture by this creature object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a PIXI.Texture.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @returns {Phaser.Creature} The newly created Sprite object.\n    */\n    creature: function (x, y, key, mesh, group) {\n\n        if (group === undefined) { group = this.world; }\n\n        var obj = new Phaser.Creature(this.game, x, y, key, mesh);\n\n        group.add(obj);\n\n        return obj;\n\n    },\n\n    /**\n    * Create a tween on a specific object.\n    * \n    * The object can be any JavaScript object or Phaser object such as Sprite.\n    *\n    * @method Phaser.GameObjectFactory#tween\n    * @param {object} object - Object the tween will be run on.\n    * @return {Phaser.Tween} The newly created Phaser.Tween object.\n    */\n    tween: function (object) {\n\n        return this.game.tweens.create(object);\n\n    },\n\n    /**\n    * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.\n    *\n    * @method Phaser.GameObjectFactory#group\n    * @param {any} [parent] - The parent Group or DisplayObjectContainer that will hold this group, if any. If set to null the Group won't be added to the display list. If undefined it will be added to World by default.\n    * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n    * @param {boolean} [enableBody=false] - If true all Sprites created with `Group.create` or `Group.createMulitple` will have a physics body created on them. Change the body type with physicsBodyType.\n    * @param {number} [physicsBodyType=0] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.\n    * @return {Phaser.Group} The newly created Group.\n    */\n    group: function (parent, name, addToStage, enableBody, physicsBodyType) {\n\n        return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType);\n\n    },\n\n    /**\n    * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.\n    * \n    * A Physics Group is the same as an ordinary Group except that is has enableBody turned on by default, so any Sprites it creates\n    * are automatically given a physics body.\n    *\n    * @method Phaser.GameObjectFactory#physicsGroup\n    * @param {number} [physicsBodyType=Phaser.Physics.ARCADE] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2JS, Phaser.Physics.NINJA, etc.\n    * @param {any} [parent] - The parent Group or DisplayObjectContainer that will hold this group, if any. If set to null the Group won't be added to the display list. If undefined it will be added to World by default.\n    * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n    * @return {Phaser.Group} The newly created Group.\n    */\n    physicsGroup: function (physicsBodyType, parent, name, addToStage) {\n\n        return new Phaser.Group(this.game, parent, name, addToStage, true, physicsBodyType);\n\n    },\n\n    /**\n    * A SpriteBatch is a really fast version of a Phaser Group built solely for speed.\n    * Use when you need a lot of sprites or particles all sharing the same texture.\n    * The speed gains are specifically for WebGL. In Canvas mode you won't see any real difference.\n    *\n    * @method Phaser.GameObjectFactory#spriteBatch\n    * @param {Phaser.Group|null} parent - The parent Group that will hold this Sprite Batch. Set to `undefined` or `null` to add directly to game.world.\n    * @param {string} [name='group'] - A name for this Sprite Batch. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Sprite Batch will be added directly to the Game.Stage instead of the parent.\n    * @return {Phaser.SpriteBatch} The newly created Sprite Batch.\n    */\n    spriteBatch: function (parent, name, addToStage) {\n\n        if (parent === undefined) { parent = null; }\n        if (name === undefined) { name = 'group'; }\n        if (addToStage === undefined) { addToStage = false; }\n\n        return new Phaser.SpriteBatch(this.game, parent, name, addToStage);\n\n    },\n\n    /**\n    * Creates a new Sound object.\n    *\n    * @method Phaser.GameObjectFactory#audio\n    * @param {string} key - The Game.cache key of the sound that this object will use.\n    * @param {number} [volume=1] - The volume at which the sound will be played.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The newly created sound object.\n    */\n    audio: function (key, volume, loop, connect) {\n\n        return this.game.sound.add(key, volume, loop, connect);\n\n    },\n\n    /**\n    * Creates a new Sound object.\n    *\n    * @method Phaser.GameObjectFactory#sound\n    * @param {string} key - The Game.cache key of the sound that this object will use.\n    * @param {number} [volume=1] - The volume at which the sound will be played.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The newly created sound object.\n    */\n    sound: function (key, volume, loop, connect) {\n\n        return this.game.sound.add(key, volume, loop, connect);\n\n    },\n\n    /**\n     * Creates a new AudioSprite object.\n     *\n     * @method Phaser.GameObjectFactory#audioSprite\n     * @param {string} key - The Game.cache key of the sound that this object will use.\n     * @return {Phaser.AudioSprite} The newly created AudioSprite object.\n     */\n    audioSprite: function (key) {\n\n        return this.game.sound.addSprite(key);\n\n    },\n\n    /**\n    * Creates a new TileSprite object.\n    *\n    * @method Phaser.GameObjectFactory#tileSprite\n    * @param {number} x - The x coordinate of the TileSprite. The coordinate is relative to any parent container this TileSprite may be in.\n    * @param {number} y - The y coordinate of the TileSprite. The coordinate is relative to any parent container this TileSprite may be in.\n    * @param {number} width - The width of the TileSprite.\n    * @param {number} height - The height of the TileSprite.\n    * @param {string|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Phaser Image Cache entry, or an instance of a PIXI.Texture or BitmapData.\n    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.TileSprite} The newly created TileSprite object.\n    */\n    tileSprite: function (x, y, width, height, key, frame, group) {\n\n        if (group === undefined) { group = this.world; }\n\n        return group.add(new Phaser.TileSprite(this.game, x, y, width, height, key, frame));\n\n    },\n\n    /**\n    * Creates a new Rope object.\n    *\n    * Example usage: https://github.com/codevinsky/phaser-rope-demo/blob/master/dist/demo.js\n    *\n    * @method Phaser.GameObjectFactory#rope\n    * @param {number} [x=0] - The x coordinate of the Rope. The coordinate is relative to any parent container this rope may be in.\n    * @param {number} [y=0] - The y coordinate of the Rope. The coordinate is relative to any parent container this rope may be in.\n    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\n    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.\n    * @param {Array} points - An array of {Phaser.Point}.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.Rope} The newly created Rope object.\n    */\n    rope: function (x, y, key, frame, points, group) {\n\n        if (group === undefined) { group = this.world; }\n\n        return group.add(new Phaser.Rope(this.game, x, y, key, frame, points));\n\n    },\n\n    /**\n    * Creates a new Text object.\n    *\n    * @method Phaser.GameObjectFactory#text\n    * @param {number} [x=0] - The x coordinate of the Text. The coordinate is relative to any parent container this text may be in.\n    * @param {number} [y=0] - The y coordinate of the Text. The coordinate is relative to any parent container this text may be in.\n    * @param {string} [text=''] - The text string that will be displayed.\n    * @param {object} [style] - The style object containing style attributes like font, font size , etc.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.Text} The newly created text object.\n    */\n    text: function (x, y, text, style, group) {\n\n        if (group === undefined) { group = this.world; }\n\n        return group.add(new Phaser.Text(this.game, x, y, text, style));\n\n    },\n\n    /**\n    * Creates a new Button object.\n    *\n    * @method Phaser.GameObjectFactory#button\n    * @param {number} [x=0] - The x coordinate of the Button. The coordinate is relative to any parent container this button may be in.\n    * @param {number} [y=0] - The y coordinate of the Button. The coordinate is relative to any parent container this button may be in.\n    * @param {string} [key] - The image key as defined in the Game.Cache to use as the texture for this button.\n    * @param {function} [callback] - The function to call when this button is pressed\n    * @param {object} [callbackContext] - The context in which the callback will be called (usually 'this')\n    * @param {string|number} [overFrame] - This is the frame or frameName that will be set when this button is in an over state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [outFrame] - This is the frame or frameName that will be set when this button is in an out state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [downFrame] - This is the frame or frameName that will be set when this button is in a down state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [upFrame] - This is the frame or frameName that will be set when this button is in an up state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.Button} The newly created Button object.\n    */\n    button: function (x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame, group) {\n\n        if (group === undefined) { group = this.world; }\n\n        return group.add(new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame));\n\n    },\n\n    /**\n    * Creates a new Graphics object.\n    *\n    * @method Phaser.GameObjectFactory#graphics\n    * @param {number} [x=0] - The x coordinate of the Graphic. The coordinate is relative to any parent container this object may be in.\n    * @param {number} [y=0] - The y coordinate of the Graphic. The coordinate is relative to any parent container this object may be in.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.Graphics} The newly created graphics object.\n    */\n    graphics: function (x, y, group) {\n\n        if (group === undefined) { group = this.world; }\n\n        return group.add(new Phaser.Graphics(this.game, x, y));\n\n    },\n\n    /**\n    * Create a new Emitter.\n    *\n    * A particle emitter can be used for one-time explosions or for\n    * continuous effects like rain and fire. All it really does is launch Particle objects out\n    * at set intervals, and fixes their positions and velocities accordingly.\n    *\n    * @method Phaser.GameObjectFactory#emitter\n    * @param {number} [x=0] - The x coordinate within the Emitter that the particles are emitted from.\n    * @param {number} [y=0] - The y coordinate within the Emitter that the particles are emitted from.\n    * @param {number} [maxParticles=50] - The total number of particles in this emitter.\n    * @return {Phaser.Particles.Arcade.Emitter} The newly created emitter object.\n    */\n    emitter: function (x, y, maxParticles) {\n\n        return this.game.particles.add(new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles));\n\n    },\n\n    /**\n    * Create a new RetroFont object.\n    *\n    * A RetroFont can be used as a texture for an Image or Sprite and optionally add it to the Cache.\n    * A RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.\n    * If you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText\n    * is that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.\n    * The texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,\n    * i.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.\n    *\n    * @method Phaser.GameObjectFactory#retroFont\n    * @param {string} font - The key of the image in the Game.Cache that the RetroFont will use.\n    * @param {number} characterWidth - The width of each character in the font set.\n    * @param {number} characterHeight - The height of each character in the font set.\n    * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.\n    * @param {number} charsPerRow - The number of characters per row in the font set.\n    * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.\n    * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.\n    * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.\n    * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.\n    * @return {Phaser.RetroFont} The newly created RetroFont texture which can be applied to an Image or Sprite.\n    */\n    retroFont: function (font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {\n\n        return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);\n\n    },\n\n    /**\n    * Create a new BitmapText object.\n    *\n    * BitmapText objects work by taking a texture file and an XML file that describes the font structure.\n    * It then generates a new Sprite object for each letter of the text, proportionally spaced out and aligned to \n    * match the font structure.\n    * \n    * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability \n    * to use Web Fonts. However you trade this flexibility for pure rendering speed. You can also create visually compelling BitmapTexts by \n    * processing the font texture in an image editor first, applying fills and any other effects required.\n    *\n    * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n    *\n    * To create a BitmapText data files you can use:\n    *\n    * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/\n    * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\n    * Littera (Web-based, free): http://kvazars.com/littera/\n    *\n    * @method Phaser.GameObjectFactory#bitmapText\n    * @param {number} x - X coordinate to display the BitmapText object at.\n    * @param {number} y - Y coordinate to display the BitmapText object at.\n    * @param {string} font - The key of the BitmapText as stored in Phaser.Cache.\n    * @param {string} [text=''] - The text that will be rendered. This can also be set later via BitmapText.text.\n    * @param {number} [size=32] - The size the font will be rendered at in pixels.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.BitmapText} The newly created bitmapText object.\n    */\n    bitmapText: function (x, y, font, text, size, group) {\n\n        if (group === undefined) { group = this.world; }\n\n        return group.add(new Phaser.BitmapText(this.game, x, y, font, text, size));\n\n    },\n\n    /**\n    * Creates a new Phaser.Tilemap object.\n    *\n    * The map can either be populated with data from a Tiled JSON file or from a CSV file.\n    * To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.\n    * When using CSV data you must provide the key and the tileWidth and tileHeight parameters.\n    * If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.\n    * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.\n    *\n    * @method Phaser.GameObjectFactory#tilemap\n    * @param {string} [key] - The key of the tilemap data as stored in the Cache. If you're creating a blank map either leave this parameter out or pass `null`.\n    * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    * @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    * @return {Phaser.Tilemap} The newly created tilemap object.\n    */\n    tilemap: function (key, tileWidth, tileHeight, width, height) {\n\n        return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);\n\n    },\n\n    /**\n    * A dynamic initially blank canvas to which images can be drawn.\n    *\n    * @method Phaser.GameObjectFactory#renderTexture\n    * @param {number} [width=100] - the width of the RenderTexture.\n    * @param {number} [height=100] - the height of the RenderTexture.\n    * @param {string} [key=''] - Asset key for the RenderTexture when stored in the Cache (see addToCache parameter).\n    * @param {boolean} [addToCache=false] - Should this RenderTexture be added to the Game.Cache? If so you can retrieve it with Cache.getTexture(key)\n    * @return {Phaser.RenderTexture} The newly created RenderTexture object.\n    */\n    renderTexture: function (width, height, key, addToCache) {\n\n        if (key === undefined || key === '') { key = this.game.rnd.uuid(); }\n        if (addToCache === undefined) { addToCache = false; }\n\n        var texture = new Phaser.RenderTexture(this.game, width, height, key);\n\n        if (addToCache)\n        {\n            this.game.cache.addRenderTexture(key, texture);\n        }\n\n        return texture;\n\n    },\n\n    /**\n    * Create a Video object.\n    *\n    * This will return a Phaser.Video object which you can pass to a Sprite to be used as a texture.\n    *\n    * @method Phaser.GameObjectFactory#video\n    * @param {string|null} [key=null] - The key of the video file in the Phaser.Cache that this Video object will play. Set to `null` or leave undefined if you wish to use a webcam as the source. See `startMediaStream` to start webcam capture.\n    * @param {string|null} [url=null] - If the video hasn't been loaded then you can provide a full URL to the file here (make sure to set key to null)\n    * @return {Phaser.Video} The newly created Video object.\n    */\n    video: function (key, url) {\n\n        return new Phaser.Video(this.game, key, url);\n\n    },\n\n    /**\n    * Create a BitmapData object.\n    *\n    * A BitmapData object can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.\n    *\n    * @method Phaser.GameObjectFactory#bitmapData\n    * @param {number} [width=256] - The width of the BitmapData in pixels.\n    * @param {number} [height=256] - The height of the BitmapData in pixels.\n    * @param {string} [key=''] - Asset key for the BitmapData when stored in the Cache (see addToCache parameter).\n    * @param {boolean} [addToCache=false] - Should this BitmapData be added to the Game.Cache? If so you can retrieve it with Cache.getBitmapData(key)\n    * @return {Phaser.BitmapData} The newly created BitmapData object.\n    */\n    bitmapData: function (width, height, key, addToCache) {\n\n        if (addToCache === undefined) { addToCache = false; }\n        if (key === undefined || key === '') { key = this.game.rnd.uuid(); }\n\n        var texture = new Phaser.BitmapData(this.game, key, width, height);\n\n        if (addToCache)\n        {\n            this.game.cache.addBitmapData(key, texture);\n        }\n\n        return texture;\n\n    },\n\n    /**\n    * A WebGL shader/filter that can be applied to Sprites.\n    *\n    * @method Phaser.GameObjectFactory#filter\n    * @param {string} filter - The name of the filter you wish to create, for example HueRotate or SineWave.\n    * @param {any} - Whatever parameters are needed to be passed to the filter init function.\n    * @return {Phaser.Filter} The newly created Phaser.Filter object.\n    */\n    filter: function (filter) {\n\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        var filter = new Phaser.Filter[filter](this.game);\n\n        filter.init.apply(filter, args);\n\n        return filter;\n\n    },\n\n    /**\n    * Add a new Plugin into the PluginManager.\n    *\n    * The Plugin must have 2 properties: `game` and `parent`. Plugin.game is set to the game reference the PluginManager uses, and parent is set to the PluginManager.\n    *\n    * @method Phaser.GameObjectFactory#plugin\n    * @param {object|Phaser.Plugin} plugin - The Plugin to add into the PluginManager. This can be a function or an existing object.\n    * @param {...*} parameter - Additional parameters that will be passed to the Plugin.init method.\n    * @return {Phaser.Plugin} The Plugin that was added to the manager.\n    */\n    plugin: function (plugin) {\n\n        return this.game.plugins.add(plugin);\n\n    }\n\n};\n\nPhaser.GameObjectFactory.prototype.constructor = Phaser.GameObjectFactory;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The GameObjectCreator is a quick way to create common game objects _without_ adding them to the game world.\n* The object creator can be accessed with {@linkcode Phaser.Game#make `game.make`}.\n*\n* @class Phaser.GameObjectCreator\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.GameObjectCreator = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    * @protected\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.World} world - A reference to the game world.\n    * @protected\n    */\n    this.world = this.game.world;\n\n};\n\nPhaser.GameObjectCreator.prototype = {\n\n    /**\n    * Create a new Image object.\n    *\n    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.\n    * It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.\n    *\n    * @method Phaser.GameObjectCreator#image\n    * @param {number} x - X position of the image.\n    * @param {number} y - Y position of the image.\n    * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n    * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n    * @returns {Phaser.Image} the newly created sprite object.\n    */\n    image: function (x, y, key, frame) {\n\n        return new Phaser.Image(this.game, x, y, key, frame);\n\n    },\n\n    /**\n    * Create a new Sprite with specific position and sprite sheet key.\n    *\n    * @method Phaser.GameObjectCreator#sprite\n    * @param {number} x - X position of the new sprite.\n    * @param {number} y - Y position of the new sprite.\n    * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n    * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n    * @returns {Phaser.Sprite} the newly created sprite object.\n    */\n    sprite: function (x, y, key, frame) {\n\n        return new Phaser.Sprite(this.game, x, y, key, frame);\n\n    },\n\n    /**\n    * Create a tween object for a specific object.\n    *\n    * The object can be any JavaScript object or Phaser object such as Sprite.\n    *\n    * @method Phaser.GameObjectCreator#tween\n    * @param {object} obj - Object the tween will be run on.\n    * @return {Phaser.Tween} The Tween object.\n    */\n    tween: function (obj) {\n\n        return new Phaser.Tween(obj, this.game, this.game.tweens);\n\n    },\n\n    /**\n    * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.\n    *\n    * @method Phaser.GameObjectCreator#group\n    * @param {any} parent - The parent Group or DisplayObjectContainer that will hold this group, if any.\n    * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n    * @param {boolean} [enableBody=false] - If true all Sprites created with `Group.create` or `Group.createMulitple` will have a physics body created on them. Change the body type with physicsBodyType.\n    * @param {number} [physicsBodyType=0] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.\n    * @return {Phaser.Group} The newly created Group.\n    */\n    group: function (parent, name, addToStage, enableBody, physicsBodyType) {\n\n        return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType);\n\n    },\n\n    /**\n    * Create a new SpriteBatch.\n    *\n    * @method Phaser.GameObjectCreator#spriteBatch\n    * @param {any} parent - The parent Group or DisplayObjectContainer that will hold this group, if any.\n    * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n    * @return {Phaser.SpriteBatch} The newly created group.\n    */\n    spriteBatch: function (parent, name, addToStage) {\n\n        if (name === undefined) { name = 'group'; }\n        if (addToStage === undefined) { addToStage = false; }\n\n        return new Phaser.SpriteBatch(this.game, parent, name, addToStage);\n\n    },\n\n    /**\n    * Creates a new Sound object.\n    *\n    * @method Phaser.GameObjectCreator#audio\n    * @param {string} key - The Game.cache key of the sound that this object will use.\n    * @param {number} [volume=1] - The volume at which the sound will be played.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The newly created text object.\n    */\n    audio: function (key, volume, loop, connect) {\n\n        return this.game.sound.add(key, volume, loop, connect);\n\n    },\n\n    /**\n     * Creates a new AudioSprite object.\n     *\n     * @method Phaser.GameObjectCreator#audioSprite\n     * @param {string} key - The Game.cache key of the sound that this object will use.\n     * @return {Phaser.AudioSprite} The newly created AudioSprite object.\n     */\n    audioSprite: function (key) {\n\n        return this.game.sound.addSprite(key);\n\n    },\n\n    /**\n    * Creates a new Sound object.\n    *\n    * @method Phaser.GameObjectCreator#sound\n    * @param {string} key - The Game.cache key of the sound that this object will use.\n    * @param {number} [volume=1] - The volume at which the sound will be played.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The newly created text object.\n    */\n    sound: function (key, volume, loop, connect) {\n\n        return this.game.sound.add(key, volume, loop, connect);\n\n    },\n\n    /**\n    * Creates a new TileSprite object.\n    *\n    * @method Phaser.GameObjectCreator#tileSprite\n    * @param {number} x - The x coordinate (in world space) to position the TileSprite at.\n    * @param {number} y - The y coordinate (in world space) to position the TileSprite at.\n    * @param {number} width - The width of the TileSprite.\n    * @param {number} height - The height of the TileSprite.\n    * @param {string|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Phaser Image Cache entry, or an instance of a PIXI.Texture or BitmapData.\n    * @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n    * @return {Phaser.TileSprite} The newly created tileSprite object.\n    */\n    tileSprite: function (x, y, width, height, key, frame) {\n\n        return new Phaser.TileSprite(this.game, x, y, width, height, key, frame);\n\n    },\n\n    /**\n    * Creates a new Rope object.\n    *\n    * @method Phaser.GameObjectCreator#rope\n    * @param {number} x - The x coordinate (in world space) to position the Rope at.\n    * @param {number} y - The y coordinate (in world space) to position the Rope at.\n    * @param {number} width - The width of the Rope.\n    * @param {number} height - The height of the Rope.\n    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n    * @param {string|number} frame - If this Rope is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n    * @return {Phaser.Rope} The newly created rope object.\n    */\n    rope: function (x, y, key, frame, points) {\n\n        return new Phaser.Rope(this.game, x, y, key, frame, points);\n\n    },\n\n    /**\n    * Creates a new Text object.\n    *\n    * @method Phaser.GameObjectCreator#text\n    * @param {number} x - X position of the new text object.\n    * @param {number} y - Y position of the new text object.\n    * @param {string} text - The actual text that will be written.\n    * @param {object} style - The style object containing style attributes like font, font size , etc.\n    * @return {Phaser.Text} The newly created text object.\n    */\n    text: function (x, y, text, style) {\n\n        return new Phaser.Text(this.game, x, y, text, style);\n\n    },\n\n    /**\n    * Creates a new Button object.\n    *\n    * @method Phaser.GameObjectCreator#button\n    * @param {number} [x] X position of the new button object.\n    * @param {number} [y] Y position of the new button object.\n    * @param {string} [key] The image key as defined in the Game.Cache to use as the texture for this button.\n    * @param {function} [callback] The function to call when this button is pressed\n    * @param {object} [callbackContext] The context in which the callback will be called (usually 'this')\n    * @param {string|number} [overFrame] This is the frame or frameName that will be set when this button is in an over state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [outFrame] This is the frame or frameName that will be set when this button is in an out state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [downFrame] This is the frame or frameName that will be set when this button is in a down state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [upFrame] This is the frame or frameName that will be set when this button is in an up state. Give either a number to use a frame ID or a string for a frame name.\n    * @return {Phaser.Button} The newly created button object.\n    */\n    button: function (x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {\n\n        return new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame);\n\n    },\n\n    /**\n    * Creates a new Graphics object.\n    *\n    * @method Phaser.GameObjectCreator#graphics\n    * @param {number} [x=0] - X position of the new graphics object.\n    * @param {number} [y=0] - Y position of the new graphics object.\n    * @return {Phaser.Graphics} The newly created graphics object.\n    */\n    graphics: function (x, y) {\n\n        return new Phaser.Graphics(this.game, x, y);\n\n    },\n\n    /**\n    * Creat a new Emitter.\n    *\n    * An Emitter is a lightweight particle emitter. It can be used for one-time explosions or for\n    * continuous effects like rain and fire. All it really does is launch Particle objects out\n    * at set intervals, and fixes their positions and velocities accorindgly.\n    *\n    * @method Phaser.GameObjectCreator#emitter\n    * @param {number} [x=0] - The x coordinate within the Emitter that the particles are emitted from.\n    * @param {number} [y=0] - The y coordinate within the Emitter that the particles are emitted from.\n    * @param {number} [maxParticles=50] - The total number of particles in this emitter.\n    * @return {Phaser.Emitter} The newly created emitter object.\n    */\n    emitter: function (x, y, maxParticles) {\n\n        return new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles);\n\n    },\n\n    /**\n    * Create a new RetroFont object.\n    *\n    * A RetroFont can be used as a texture for an Image or Sprite and optionally add it to the Cache.\n    * A RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.\n    * If you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText\n    * is that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.\n    * The texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,\n    * i.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.\n    *\n    * @method Phaser.GameObjectCreator#retroFont\n    * @param {string} font - The key of the image in the Game.Cache that the RetroFont will use.\n    * @param {number} characterWidth - The width of each character in the font set.\n    * @param {number} characterHeight - The height of each character in the font set.\n    * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.\n    * @param {number} charsPerRow - The number of characters per row in the font set.\n    * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.\n    * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.\n    * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.\n    * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.\n    * @return {Phaser.RetroFont} The newly created RetroFont texture which can be applied to an Image or Sprite.\n    */\n    retroFont: function (font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {\n\n        return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);\n\n    },\n\n    /**\n    * Create a new BitmapText object.\n    *\n    * BitmapText objects work by taking a texture file and an XML file that describes the font structure.\n    * It then generates a new Sprite object for each letter of the text, proportionally spaced out and aligned to \n    * match the font structure.\n    * \n    * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability \n    * to use Web Fonts. However you trade this flexibility for pure rendering speed. You can also create visually compelling BitmapTexts by \n    * processing the font texture in an image editor first, applying fills and any other effects required.\n    *\n    * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n    *\n    * To create a BitmapText data files you can use:\n    *\n    * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/\n    * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\n    * Littera (Web-based, free): http://kvazars.com/littera/\n    *\n    * @method Phaser.GameObjectCreator#bitmapText\n    * @param {number} x - X coordinate to display the BitmapText object at.\n    * @param {number} y - Y coordinate to display the BitmapText object at.\n    * @param {string} font - The key of the BitmapText as stored in Phaser.Cache.\n    * @param {string} [text=''] - The text that will be rendered. This can also be set later via BitmapText.text.\n    * @param {number} [size=32] - The size the font will be rendered at in pixels.\n    * @param {string} [align='left'] - The alignment of multi-line text. Has no effect if there is only one line of text.\n    * @return {Phaser.BitmapText} The newly created bitmapText object.\n    */\n    bitmapText: function (x, y, font, text, size, align) {\n\n        return new Phaser.BitmapText(this.game, x, y, font, text, size, align);\n\n    },\n\n    /**\n    * Creates a new Phaser.Tilemap object.\n    *\n    * The map can either be populated with data from a Tiled JSON file or from a CSV file.\n    * To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.\n    * When using CSV data you must provide the key and the tileWidth and tileHeight parameters.\n    * If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.\n    * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.\n    *\n    * @method Phaser.GameObjectCreator#tilemap\n    * @param {string} [key] - The key of the tilemap data as stored in the Cache. If you're creating a blank map either leave this parameter out or pass `null`.\n    * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    * @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    */\n    tilemap: function (key, tileWidth, tileHeight, width, height) {\n\n        return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);\n\n    },\n\n    /**\n    * A dynamic initially blank canvas to which images can be drawn.\n    *\n    * @method Phaser.GameObjectCreator#renderTexture\n    * @param {number} [width=100] - the width of the RenderTexture.\n    * @param {number} [height=100] - the height of the RenderTexture.\n    * @param {string} [key=''] - Asset key for the RenderTexture when stored in the Cache (see addToCache parameter).\n    * @param {boolean} [addToCache=false] - Should this RenderTexture be added to the Game.Cache? If so you can retrieve it with Cache.getTexture(key)\n    * @return {Phaser.RenderTexture} The newly created RenderTexture object.\n    */\n    renderTexture: function (width, height, key, addToCache) {\n\n        if (key === undefined || key === '') { key = this.game.rnd.uuid(); }\n        if (addToCache === undefined) { addToCache = false; }\n\n        var texture = new Phaser.RenderTexture(this.game, width, height, key);\n\n        if (addToCache)\n        {\n            this.game.cache.addRenderTexture(key, texture);\n        }\n\n        return texture;\n\n    },\n\n    /**\n    * Create a BitmpaData object.\n    *\n    * A BitmapData object can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.\n    *\n    * @method Phaser.GameObjectCreator#bitmapData\n    * @param {number} [width=256] - The width of the BitmapData in pixels.\n    * @param {number} [height=256] - The height of the BitmapData in pixels.\n    * @param {string} [key=''] - Asset key for the BitmapData when stored in the Cache (see addToCache parameter).\n    * @param {boolean} [addToCache=false] - Should this BitmapData be added to the Game.Cache? If so you can retrieve it with Cache.getBitmapData(key)\n    * @return {Phaser.BitmapData} The newly created BitmapData object.\n    */\n    bitmapData: function (width, height, key, addToCache) {\n\n        if (addToCache === undefined) { addToCache = false; }\n        if (key === undefined || key === '') { key = this.game.rnd.uuid(); }\n\n        var texture = new Phaser.BitmapData(this.game, key, width, height);\n\n        if (addToCache)\n        {\n            this.game.cache.addBitmapData(key, texture);\n        }\n\n        return texture;\n\n    },\n\n    /**\n    * A WebGL shader/filter that can be applied to Sprites.\n    *\n    * @method Phaser.GameObjectCreator#filter\n    * @param {string} filter - The name of the filter you wish to create, for example HueRotate or SineWave.\n    * @param {any} - Whatever parameters are needed to be passed to the filter init function.\n    * @return {Phaser.Filter} The newly created Phaser.Filter object.\n    */\n    filter: function (filter) {\n\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        var filter = new Phaser.Filter[filter](this.game);\n\n        filter.init.apply(filter, args);\n\n        return filter;\n\n    }\n\n};\n\nPhaser.GameObjectCreator.prototype.constructor = Phaser.GameObjectCreator;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Sprites are the lifeblood of your game, used for nearly everything visual.\n*\n* At its most basic a Sprite consists of a set of coordinates and a texture that is rendered to the canvas.\n* They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),\n* events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.\n*\n* @class Phaser.Sprite\n* @constructor\n* @extends PIXI.Sprite\n* @extends Phaser.Component.Core\n* @extends Phaser.Component.Angle\n* @extends Phaser.Component.Animation\n* @extends Phaser.Component.AutoCull\n* @extends Phaser.Component.Bounds\n* @extends Phaser.Component.BringToTop\n* @extends Phaser.Component.Crop\n* @extends Phaser.Component.Delta\n* @extends Phaser.Component.Destroy\n* @extends Phaser.Component.FixedToCamera\n* @extends Phaser.Component.Health\n* @extends Phaser.Component.InCamera\n* @extends Phaser.Component.InputEnabled\n* @extends Phaser.Component.InWorld\n* @extends Phaser.Component.LifeSpan\n* @extends Phaser.Component.LoadTexture\n* @extends Phaser.Component.Overlap\n* @extends Phaser.Component.PhysicsBody\n* @extends Phaser.Component.Reset\n* @extends Phaser.Component.ScaleMinMax\n* @extends Phaser.Component.Smoothed\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} x - The x coordinate (in world space) to position the Sprite at.\n* @param {number} y - The y coordinate (in world space) to position the Sprite at.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n* @param {string|number} frame - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n*/\nPhaser.Sprite = function (game, x, y, key, frame) {\n\n    x = x || 0;\n    y = y || 0;\n    key = key || null;\n    frame = frame || null;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.SPRITE;\n\n    /**\n    * @property {number} physicsType - The const physics body type of this object.\n    * @readonly\n    */\n    this.physicsType = Phaser.SPRITE;\n\n    PIXI.Sprite.call(this, Phaser.Cache.DEFAULT);\n\n    Phaser.Component.Core.init.call(this, game, x, y, key, frame);\n\n};\n\nPhaser.Sprite.prototype = Object.create(PIXI.Sprite.prototype);\nPhaser.Sprite.prototype.constructor = Phaser.Sprite;\n\nPhaser.Component.Core.install.call(Phaser.Sprite.prototype, [\n    'Angle',\n    'Animation',\n    'AutoCull',\n    'Bounds',\n    'BringToTop',\n    'Crop',\n    'Delta',\n    'Destroy',\n    'FixedToCamera',\n    'Health',\n    'InCamera',\n    'InputEnabled',\n    'InWorld',\n    'LifeSpan',\n    'LoadTexture',\n    'Overlap',\n    'PhysicsBody',\n    'Reset',\n    'ScaleMinMax',\n    'Smoothed'\n]);\n\nPhaser.Sprite.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate;\nPhaser.Sprite.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate;\nPhaser.Sprite.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;\nPhaser.Sprite.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;\n\n/**\n* Automatically called by World.preUpdate.\n*\n* @method\n* @memberof Phaser.Sprite\n* @return {boolean} True if the Sprite was rendered, otherwise false.\n*/\nPhaser.Sprite.prototype.preUpdate = function() {\n\n    if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld())\n    {\n        return false;\n    }\n\n    return this.preUpdateCore();\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* An Image is a light-weight object you can use to display anything that doesn't need physics or animation.\n* It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.\n*\n* @class Phaser.Image\n* @extends PIXI.Sprite\n* @extends Phaser.Component.Core\n* @extends Phaser.Component.Angle\n* @extends Phaser.Component.Animation\n* @extends Phaser.Component.AutoCull\n* @extends Phaser.Component.Bounds\n* @extends Phaser.Component.BringToTop\n* @extends Phaser.Component.Crop\n* @extends Phaser.Component.Destroy\n* @extends Phaser.Component.FixedToCamera\n* @extends Phaser.Component.InputEnabled\n* @extends Phaser.Component.LifeSpan\n* @extends Phaser.Component.LoadTexture\n* @extends Phaser.Component.Overlap\n* @extends Phaser.Component.Reset\n* @extends Phaser.Component.ScaleMinMax\n* @extends Phaser.Component.Smoothed\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.\n* @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} [key] - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.\n* @param {string|number} [frame] - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n*/\nPhaser.Image = function (game, x, y, key, frame) {\n\n    x = x || 0;\n    y = y || 0;\n    key = key || null;\n    frame = frame || null;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.IMAGE;\n\n    PIXI.Sprite.call(this, Phaser.Cache.DEFAULT);\n\n    Phaser.Component.Core.init.call(this, game, x, y, key, frame);\n\n};\n\nPhaser.Image.prototype = Object.create(PIXI.Sprite.prototype);\nPhaser.Image.prototype.constructor = Phaser.Image;\n\nPhaser.Component.Core.install.call(Phaser.Image.prototype, [\n    'Angle',\n    'Animation',\n    'AutoCull',\n    'Bounds',\n    'BringToTop',\n    'Crop',\n    'Destroy',\n    'FixedToCamera',\n    'InputEnabled',\n    'LifeSpan',\n    'LoadTexture',\n    'Overlap',\n    'Reset',\n    'ScaleMinMax',\n    'Smoothed'\n]);\n\nPhaser.Image.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;\nPhaser.Image.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;\n\n/**\n* Automatically called by World.preUpdate.\n*\n* @method Phaser.Image#preUpdate\n* @memberof Phaser.Image\n*/\nPhaser.Image.prototype.preUpdate = function() {\n\n    if (!this.preUpdateInWorld())\n    {\n        return false;\n    }\n\n    return this.preUpdateCore();\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Create a new `Button` object. A Button is a special type of Sprite that is set-up to handle Pointer events automatically.\n*\n* The four states a Button responds to are:\n*\n* * 'Over' - when the Pointer moves over the Button. This is also commonly known as 'hover'.\n* * 'Out' - when the Pointer that was previously over the Button moves out of it.\n* * 'Down' - when the Pointer is pressed down on the Button. I.e. touched on a touch enabled device or clicked with the mouse.\n* * 'Up' - when the Pointer that was pressed down on the Button is released again.\n*\n* A different texture/frame and activation sound can be specified for any of the states.\n*\n* Frames can be specified as either an integer (the frame ID) or a string (the frame name); the same values that can be used with a Sprite constructor.\n*\n* @class Phaser.Button\n* @constructor\n* @extends Phaser.Image\n* @param {Phaser.Game} game Current game instance.\n* @param {number} [x=0] - X position of the Button.\n* @param {number} [y=0] - Y position of the Button.\n* @param {string} [key] - The image key (in the Game.Cache) to use as the texture for this Button.\n* @param {function} [callback] - The function to call when this Button is pressed.\n* @param {object} [callbackContext] - The context in which the callback will be called (usually 'this').\n* @param {string|integer} [overFrame] - The frame / frameName when the button is in the Over state.\n* @param {string|integer} [outFrame] - The frame / frameName when the button is in the Out state.\n* @param {string|integer} [downFrame] - The frame / frameName when the button is in the Down state.\n* @param {string|integer} [upFrame] - The frame / frameName when the button is in the Up state.\n*/\nPhaser.Button = function (game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {\n\n    x = x || 0;\n    y = y || 0;\n    key = key || null;\n    callback = callback || null;\n    callbackContext = callbackContext || this;\n\n    Phaser.Image.call(this, game, x, y, key, outFrame);\n\n    /**\n    * The Phaser Object Type.\n    * @property {number} type\n    * @readonly\n    */\n    this.type = Phaser.BUTTON;\n\n    /**\n    * @property {number} physicsType - The const physics body type of this object.\n    * @readonly\n    */\n    this.physicsType = Phaser.SPRITE;\n\n    /**\n    * The name or ID of the Over state frame.\n    * @property {string|integer} onOverFrame\n    * @private\n    */\n    this._onOverFrame = null;\n\n    /**\n    * The name or ID of the Out state frame.\n    * @property {string|integer} onOutFrame\n    * @private\n    */\n    this._onOutFrame = null;\n\n    /**\n    * The name or ID of the Down state frame.\n    * @property {string|integer} onDownFrame\n    * @private\n    */\n    this._onDownFrame = null;\n\n    /**\n    * The name or ID of the Up state frame.\n    * @property {string|integer} onUpFrame\n    * @private\n    */\n    this._onUpFrame = null;\n\n    /**\n    * The Sound to be played when this Buttons Over state is activated.\n    * @property {Phaser.Sound|Phaser.AudioSprite|null} onOverSound\n    * @readonly\n    */\n    this.onOverSound = null;\n\n    /**\n    * The Sound to be played when this Buttons Out state is activated.\n    * @property {Phaser.Sound|Phaser.AudioSprite|null} onOutSound\n    * @readonly\n    */\n    this.onOutSound = null;\n\n    /**\n    * The Sound to be played when this Buttons Down state is activated.\n    * @property {Phaser.Sound|Phaser.AudioSprite|null} onDownSound\n    * @readonly\n    */\n    this.onDownSound = null;\n\n    /**\n    * The Sound to be played when this Buttons Up state is activated.\n    * @property {Phaser.Sound|Phaser.AudioSprite|null} onUpSound\n    * @readonly\n    */\n    this.onUpSound = null;\n\n    /**\n    * The Sound Marker used in conjunction with the onOverSound.\n    * @property {string} onOverSoundMarker\n    * @readonly\n    */\n    this.onOverSoundMarker = '';\n\n    /**\n    * The Sound Marker used in conjunction with the onOutSound.\n    * @property {string} onOutSoundMarker\n    * @readonly\n    */\n    this.onOutSoundMarker = '';\n\n    /**\n    * The Sound Marker used in conjunction with the onDownSound.\n    * @property {string} onDownSoundMarker\n    * @readonly\n    */\n    this.onDownSoundMarker = '';\n\n    /**\n    * The Sound Marker used in conjunction with the onUpSound.\n    * @property {string} onUpSoundMarker\n    * @readonly\n    */\n    this.onUpSoundMarker = '';\n\n    /**\n    * The Signal (or event) dispatched when this Button is in an Over state.\n    * @property {Phaser.Signal} onInputOver\n    */\n    this.onInputOver = new Phaser.Signal();\n\n    /**\n    * The Signal (or event) dispatched when this Button is in an Out state.\n    * @property {Phaser.Signal} onInputOut\n    */\n    this.onInputOut = new Phaser.Signal();\n\n    /**\n    * The Signal (or event) dispatched when this Button is in an Down state.\n    * @property {Phaser.Signal} onInputDown\n    */\n    this.onInputDown = new Phaser.Signal();\n\n    /**\n    * The Signal (or event) dispatched when this Button is in an Up state.\n    * @property {Phaser.Signal} onInputUp\n    */\n    this.onInputUp = new Phaser.Signal();\n\n    /**\n    * If true then onOver events (such as onOverSound) will only be triggered if the Pointer object causing them was the Mouse Pointer.\n    * The frame will still be changed as applicable.\n    *\n    * @property {boolean} onOverMouseOnly\n    * @default\n    */\n    this.onOverMouseOnly = true;\n\n    /**\n    * Suppress the over event if a pointer was just released and it matches the given {@link Phaser.PointerModer pointer mode bitmask}.\n    *\n    * This behavior was introduced in Phaser 2.3.1; this property is a soft-revert of the change.\n    *\n    * @property {Phaser.PointerMode?} justReleasedPreventsOver=ACTIVE_CURSOR\n    */\n    this.justReleasedPreventsOver = Phaser.PointerMode.TOUCH;\n    \n    /**\n    * When true the the texture frame will not be automatically switched on up/down/over/out events.\n    * @property {boolean} freezeFrames\n    * @default\n    */\n    this.freezeFrames = false;\n\n    /**\n    * When the Button is touched / clicked and then released you can force it to enter a state of \"out\" instead of \"up\".\n    *\n    * This can also accept a {@link Phaser.PointerModer pointer mode bitmask} for more refined control.\n    *\n    * @property {boolean|Phaser.PointerMode} forceOut=false\n    * @default\n    */\n    this.forceOut = false;\n\n    this.inputEnabled = true;\n\n    this.input.start(0, true);\n\n    this.input.useHandCursor = true;\n\n    this.setFrames(overFrame, outFrame, downFrame, upFrame);\n\n    if (callback !== null)\n    {\n        this.onInputUp.add(callback, callbackContext);\n    }\n\n    //  Redirect the input events to here so we can handle animation updates, etc\n    this.events.onInputOver.add(this.onInputOverHandler, this);\n    this.events.onInputOut.add(this.onInputOutHandler, this);\n    this.events.onInputDown.add(this.onInputDownHandler, this);\n    this.events.onInputUp.add(this.onInputUpHandler, this);\n\n    this.events.onRemovedFromWorld.add(this.removedFromWorld, this);\n\n};\n\nPhaser.Button.prototype = Object.create(Phaser.Image.prototype);\nPhaser.Button.prototype.constructor = Phaser.Button;\n\n//  State constants; local only. These are tied to property names in Phaser.Button.\nvar STATE_OVER = 'Over';\nvar STATE_OUT = 'Out';\nvar STATE_DOWN = 'Down';\nvar STATE_UP = 'Up';\n\n/**\n* Clears all of the frames set on this Button.\n*\n* @method Phaser.Button#clearFrames\n*/\nPhaser.Button.prototype.clearFrames = function () {\n\n    this.setFrames(null, null, null, null);\n\n};\n\n/**\n* Called when this Button is removed from the World.\n*\n* @method Phaser.Button#removedFromWorld\n* @protected\n*/\nPhaser.Button.prototype.removedFromWorld = function () {\n\n    this.inputEnabled = false;\n\n};\n\n/**\n* Set the frame name/ID for the given state.\n*\n* @method Phaser.Button#setStateFrame\n* @private\n* @param {object} state - See `STATE_*`\n* @param {number|string} frame - The number or string representing the frame.\n* @param {boolean} switchImmediately - Immediately switch to the frame if it was set - and this is true.\n*/\nPhaser.Button.prototype.setStateFrame = function (state, frame, switchImmediately)\n{\n    var frameKey = '_on' + state + 'Frame';\n\n    if (frame !== null) // not null or undefined\n    {\n        this[frameKey] = frame;\n\n        if (switchImmediately)\n        {\n            this.changeStateFrame(state);\n        }\n    }\n    else\n    {\n        this[frameKey] = null;\n    }\n\n};\n\n/**\n* Change the frame to that of the given state, _if_ the state has a frame assigned _and_ if the frames are not currently \"frozen\".\n*\n* @method Phaser.Button#changeStateFrame\n* @private\n* @param {object} state - See `STATE_*`\n* @return {boolean} True only if the frame was assigned a value, possibly the same one it already had.\n*/\nPhaser.Button.prototype.changeStateFrame = function (state) {\n\n    if (this.freezeFrames)\n    {\n        return false;\n    }\n\n    var frameKey = '_on' + state + 'Frame';\n    var frame = this[frameKey];\n\n    if (typeof frame === 'string')\n    {\n        this.frameName = frame;\n        return true;\n    }\n    else if (typeof frame === 'number')\n    {\n        this.frame = frame;\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n\n};\n\n/**\n* Used to manually set the frames that will be used for the different states of the Button.\n*\n* Frames can be specified as either an integer (the frame ID) or a string (the frame name); these are the same values that can be used with a Sprite constructor.\n*\n* @method Phaser.Button#setFrames\n* @public\n* @param {string|integer} [overFrame] - The frame / frameName when the button is in the Over state.\n* @param {string|integer} [outFrame] - The frame / frameName when the button is in the Out state.\n* @param {string|integer} [downFrame] - The frame / frameName when the button is in the Down state.\n* @param {string|integer} [upFrame] - The frame / frameName when the button is in the Up state.\n*/\nPhaser.Button.prototype.setFrames = function (overFrame, outFrame, downFrame, upFrame) {\n\n    this.setStateFrame(STATE_OVER, overFrame, this.input.pointerOver());\n    this.setStateFrame(STATE_OUT, outFrame, !this.input.pointerOver());\n    this.setStateFrame(STATE_DOWN, downFrame, this.input.pointerDown());\n    this.setStateFrame(STATE_UP, upFrame, this.input.pointerUp());\n\n};\n\n/**\n* Set the sound/marker for the given state.\n*\n* @method Phaser.Button#setStateSound\n* @private\n* @param {object} state - See `STATE_*`\n* @param {Phaser.Sound|Phaser.AudioSprite} [sound] - Sound.\n* @param {string} [marker=''] - Sound marker.\n*/\nPhaser.Button.prototype.setStateSound = function (state, sound, marker) {\n\n    var soundKey = 'on' + state + 'Sound';\n    var markerKey = 'on' + state + 'SoundMarker';\n\n    if (sound instanceof Phaser.Sound || sound instanceof Phaser.AudioSprite)\n    {\n        this[soundKey] = sound;\n        this[markerKey] = typeof marker === 'string' ? marker : '';\n    }\n    else\n    {\n        this[soundKey] = null;\n        this[markerKey] = '';\n    }\n\n};\n\n/**\n* Play the sound for the given state, _if_ the state has a sound assigned.\n*\n* @method Phaser.Button#playStateSound\n* @private\n* @param {object} state - See `STATE_*`\n* @return {boolean} True only if a sound was played.\n*/\nPhaser.Button.prototype.playStateSound = function (state) {\n\n    var soundKey = 'on' + state + 'Sound';\n    var sound = this[soundKey];\n\n    if (sound)\n    {\n        var markerKey = 'on' + state + 'SoundMarker';\n        var marker = this[markerKey];\n\n        sound.play(marker);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n\n};\n\n/**\n* Sets the sounds to be played whenever this Button is interacted with. Sounds can be either full Sound objects, or markers pointing to a section of a Sound object.\n* The most common forms of sounds are 'hover' effects and 'click' effects, which is why the order of the parameters is overSound then downSound.\n*\n* Call this function with no parameters to reset all sounds on this Button.\n*\n* @method Phaser.Button#setSounds\n* @public\n* @param {Phaser.Sound|Phaser.AudioSprite} [overSound] - Over Button Sound.\n* @param {string} [overMarker] - Over Button Sound Marker.\n* @param {Phaser.Sound|Phaser.AudioSprite} [downSound] - Down Button Sound.\n* @param {string} [downMarker] - Down Button Sound Marker.\n* @param {Phaser.Sound|Phaser.AudioSprite} [outSound] - Out Button Sound.\n* @param {string} [outMarker] - Out Button Sound Marker.\n* @param {Phaser.Sound|Phaser.AudioSprite} [upSound] - Up Button Sound.\n* @param {string} [upMarker] - Up Button Sound Marker.\n*/\nPhaser.Button.prototype.setSounds = function (overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, upMarker) {\n\n    this.setStateSound(STATE_OVER, overSound, overMarker);\n    this.setStateSound(STATE_OUT, outSound, outMarker);\n    this.setStateSound(STATE_DOWN, downSound, downMarker);\n    this.setStateSound(STATE_UP, upSound, upMarker);\n\n};\n\n/**\n* The Sound to be played when a Pointer moves over this Button.\n*\n* @method Phaser.Button#setOverSound\n* @public\n* @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.\n* @param {string} [marker] - A Sound Marker that will be used in the playback.\n*/\nPhaser.Button.prototype.setOverSound = function (sound, marker) {\n\n    this.setStateSound(STATE_OVER, sound, marker);\n\n};\n\n/**\n* The Sound to be played when a Pointer moves out of this Button.\n*\n* @method Phaser.Button#setOutSound\n* @public\n* @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.\n* @param {string} [marker] - A Sound Marker that will be used in the playback.\n*/\nPhaser.Button.prototype.setOutSound = function (sound, marker) {\n\n    this.setStateSound(STATE_OUT, sound, marker);\n\n};\n\n/**\n* The Sound to be played when a Pointer presses down on this Button.\n*\n* @method Phaser.Button#setDownSound\n* @public\n* @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.\n* @param {string} [marker] - A Sound Marker that will be used in the playback.\n*/\nPhaser.Button.prototype.setDownSound = function (sound, marker) {\n\n    this.setStateSound(STATE_DOWN, sound, marker);\n\n};\n\n/**\n* The Sound to be played when a Pointer has pressed down and is released from this Button.\n*\n* @method Phaser.Button#setUpSound\n* @public\n* @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.\n* @param {string} [marker] - A Sound Marker that will be used in the playback.\n*/\nPhaser.Button.prototype.setUpSound = function (sound, marker) {\n\n    this.setStateSound(STATE_UP, sound, marker);\n\n};\n\n/**\n* Internal function that handles input events.\n*\n* @method Phaser.Button#onInputOverHandler\n* @protected\n* @param {Phaser.Button} sprite - The Button that the event occurred on.\n* @param {Phaser.Pointer} pointer - The Pointer that activated the Button.\n*/\nPhaser.Button.prototype.onInputOverHandler = function (sprite, pointer) {\n\n    if (pointer.justReleased() &&\n        (this.justReleasedPreventsOver & pointer.pointerMode) === pointer.pointerMode)\n    {\n        //  If the Pointer was only just released then we don't fire an over event\n        return;\n    }\n\n    this.changeStateFrame(STATE_OVER);\n\n    if (this.onOverMouseOnly && !pointer.isMouse)\n    {\n        return;\n    }\n\n    this.playStateSound(STATE_OVER);\n\n    if (this.onInputOver)\n    {\n        this.onInputOver.dispatch(this, pointer);\n    }\n\n};\n\n/**\n* Internal function that handles input events.\n*\n* @method Phaser.Button#onInputOutHandler\n* @protected\n* @param {Phaser.Button} sprite - The Button that the event occurred on.\n* @param {Phaser.Pointer} pointer - The Pointer that activated the Button.\n*/\nPhaser.Button.prototype.onInputOutHandler = function (sprite, pointer) {\n\n    this.changeStateFrame(STATE_OUT);\n\n    this.playStateSound(STATE_OUT);\n\n    if (this.onInputOut)\n    {\n        this.onInputOut.dispatch(this, pointer);\n    }\n};\n\n/**\n* Internal function that handles input events.\n*\n* @method Phaser.Button#onInputDownHandler\n* @protected\n* @param {Phaser.Button} sprite - The Button that the event occurred on.\n* @param {Phaser.Pointer} pointer - The Pointer that activated the Button.\n*/\nPhaser.Button.prototype.onInputDownHandler = function (sprite, pointer) {\n\n    this.changeStateFrame(STATE_DOWN);\n\n    this.playStateSound(STATE_DOWN);\n\n    if (this.onInputDown)\n    {\n        this.onInputDown.dispatch(this, pointer);\n    }\n};\n\n/**\n* Internal function that handles input events.\n*\n* @method Phaser.Button#onInputUpHandler\n* @protected\n* @param {Phaser.Button} sprite - The Button that the event occurred on.\n* @param {Phaser.Pointer} pointer - The Pointer that activated the Button.\n*/\nPhaser.Button.prototype.onInputUpHandler = function (sprite, pointer, isOver) {\n\n    this.playStateSound(STATE_UP);\n\n    //  Input dispatched early, before state change (but after sound)\n    if (this.onInputUp)\n    {\n        this.onInputUp.dispatch(this, pointer, isOver);\n    }\n\n    if (this.freezeFrames)\n    {\n        return;\n    }\n\n    if (this.forceOut === true || (this.forceOut & pointer.pointerMode) === pointer.pointerMode)\n    {\n        this.changeStateFrame(STATE_OUT);\n    }\n    else\n    {\n        var changedUp = this.changeStateFrame(STATE_UP);\n        if (!changedUp)\n        {\n            //  No Up frame to show..\n            if (isOver)\n            {\n                this.changeStateFrame(STATE_OVER);\n            }\n            else\n            {\n                this.changeStateFrame(STATE_OUT);\n            }\n        }\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The SpriteBatch class is a really fast version of the DisplayObjectContainer built purely for speed, so use when you need a lot of sprites or particles.\n* It's worth mentioning that by default sprite batches are used through-out the renderer, so you only really need to use a SpriteBatch if you have over\n* 1000 sprites that all share the same texture (or texture atlas). It's also useful if running in Canvas mode and you have a lot of un-rotated or un-scaled\n* Sprites as it skips all of the Canvas setTransform calls, which helps performance, especially on mobile devices.\n*\n* Please note that any Sprite that is part of a SpriteBatch will not have its bounds updated, so will fail checks such as outOfBounds.\n*\n* @class Phaser.SpriteBatch\n* @extends Phaser.Group\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {Phaser.Group|Phaser.Sprite|null} parent - The parent Group, DisplayObject or DisplayObjectContainer that this Group will be added to. If `undefined` or `null` it will use game.world.\n* @param {string} [name=group] - A name for this Group. Not used internally but useful for debugging.\n* @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n*/\nPhaser.SpriteBatch = function (game, parent, name, addToStage) {\n\n    if (parent === undefined || parent === null) { parent = game.world; }\n\n    PIXI.SpriteBatch.call(this);\n\n    Phaser.Group.call(this, game, parent, name, addToStage);\n\n    /**\n    * @property {number} type - Internal Phaser Type value.\n    * @protected\n    */\n    this.type = Phaser.SPRITEBATCH;\n\n};\n\nPhaser.SpriteBatch.prototype = Phaser.Utils.extend(true, Phaser.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, Phaser.Group.prototype);\n\nPhaser.SpriteBatch.prototype.constructor = Phaser.SpriteBatch;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A BitmapData object contains a Canvas element to which you can draw anything you like via normal Canvas context operations.\n* A single BitmapData can be used as the texture for one or many Images / Sprites. \n* So if you need to dynamically create a Sprite texture then they are a good choice.\n*\n* Important note: Every BitmapData creates its own Canvas element. Because BitmapData's are now Game Objects themselves, and don't\n* live on the display list, they are NOT automatically cleared when you change State. Therefore you _must_ call BitmapData.destroy\n* in your State's shutdown method if you wish to free-up the resources the BitmapData used, it will not happen for you.\n*\n* @class Phaser.BitmapData\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {string} key - Internal Phaser reference key for the BitmapData.\n* @param {number} [width=256] - The width of the BitmapData in pixels. If undefined or zero it's set to a default value.\n* @param {number} [height=256] - The height of the BitmapData in pixels. If undefined or zero it's set to a default value.\n* @param {boolean} [skipPool=false] - When this BitmapData generates its internal canvas to use for rendering, it will get the canvas from the CanvasPool if false, or create its own if true.\n*/\nPhaser.BitmapData = function (game, key, width, height, skipPool) {\n\n    if (width === undefined || width === 0) { width = 256; }\n    if (height === undefined || height === 0) { height = 256; }\n    if (skipPool === undefined) { skipPool = false; }\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {string} key - The key of the BitmapData in the Cache, if stored there.\n    */\n    this.key = key;\n\n    /**\n    * @property {number} width - The width of the BitmapData in pixels.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The height of the BitmapData in pixels.\n    */\n    this.height = height;\n\n    /**\n    * @property {HTMLCanvasElement} canvas - The canvas to which this BitmapData draws.\n    * @default\n    */\n    this.canvas = Phaser.Canvas.create(this, width, height, null, skipPool);\n\n    /**\n    * @property {CanvasRenderingContext2D} context - The 2d context of the canvas.\n    * @default\n    */\n    this.context = this.canvas.getContext('2d', { alpha: true });\n\n    /**\n    * @property {CanvasRenderingContext2D} ctx - A reference to BitmapData.context.\n    */\n    this.ctx = this.context;\n\n    /**\n    * @property {string} smoothProperty - The context property needed for smoothing this Canvas.\n    */\n    this.smoothProperty = (game.renderType === Phaser.CANVAS) ? game.renderer.renderSession.smoothProperty : Phaser.Canvas.getSmoothingPrefix(this.context);\n\n    /**\n    * @property {ImageData} imageData - The context image data.\n    * Please note that a call to BitmapData.draw() or BitmapData.copy() does not update immediately this property for performance reason. Use BitmapData.update() to do so.\n    * This property is updated automatically after the first game loop, according to the dirty flag property.\n    */\n    this.imageData = this.context.getImageData(0, 0, width, height);\n\n    /**\n    * A Uint8ClampedArray view into BitmapData.buffer.\n    * Note that this is unavailable in some browsers (such as Epic Browser due to its security restrictions)\n    * @property {Uint8ClampedArray} data\n    */\n    this.data = null;\n\n    if (this.imageData)\n    {\n        this.data = this.imageData.data;\n    }\n\n    /**\n    * @property {Uint32Array} pixels - An Uint32Array view into BitmapData.buffer.\n    */\n    this.pixels = null;\n\n    /**\n    * @property {ArrayBuffer} buffer - An ArrayBuffer the same size as the context ImageData.\n    */\n    if (this.data)\n    {\n        if (this.imageData.data.buffer)\n        {\n            this.buffer = this.imageData.data.buffer;\n            this.pixels = new Uint32Array(this.buffer);\n        }\n        else\n        {\n            if (window['ArrayBuffer'])\n            {\n                this.buffer = new ArrayBuffer(this.imageData.data.length);\n                this.pixels = new Uint32Array(this.buffer);\n            }\n            else\n            {\n                this.pixels = this.imageData.data;\n            }\n        }\n    }\n\n    /**\n    * @property {PIXI.BaseTexture} baseTexture - The PIXI.BaseTexture.\n    * @default\n    */\n    this.baseTexture = new PIXI.BaseTexture(this.canvas);\n\n    /**\n    * @property {PIXI.Texture} texture - The PIXI.Texture.\n    * @default\n    */\n    this.texture = new PIXI.Texture(this.baseTexture);\n\n    /**\n    * @property {Phaser.FrameData} frameData - The FrameData container this BitmapData uses for rendering.\n    */\n    this.frameData = new Phaser.FrameData();\n\n    /**\n    * @property {Phaser.Frame} textureFrame - The Frame this BitmapData uses for rendering.\n    * @default\n    */\n    this.textureFrame = this.frameData.addFrame(new Phaser.Frame(0, 0, 0, width, height, 'bitmapData'));\n\n    this.texture.frame = this.textureFrame;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @default\n    */\n    this.type = Phaser.BITMAPDATA;\n\n    /**\n    * @property {boolean} disableTextureUpload - If disableTextureUpload is true this BitmapData will never send its image data to the GPU when its dirty flag is true.\n    */\n    this.disableTextureUpload = false;\n\n    /**\n    * @property {boolean} dirty - If dirty this BitmapData will be re-rendered.\n    */\n    this.dirty = false;\n\n    //  Aliases\n    this.cls = this.clear;\n\n    /**\n    * @property {number} _image - Internal cache var.\n    * @private\n    */\n    this._image = null;\n\n    /**\n    * @property {Phaser.Point} _pos - Internal cache var.\n    * @private\n    */\n    this._pos = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} _size - Internal cache var.\n    * @private\n    */\n    this._size = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} _scale - Internal cache var.\n    * @private\n    */\n    this._scale = new Phaser.Point();\n\n    /**\n    * @property {number} _rotate - Internal cache var.\n    * @private\n    */\n    this._rotate = 0;\n\n    /**\n    * @property {object} _alpha - Internal cache var.\n    * @private\n    */\n    this._alpha = { prev: 1, current: 1 };\n\n    /**\n    * @property {Phaser.Point} _anchor - Internal cache var.\n    * @private\n    */\n    this._anchor = new Phaser.Point();\n\n    /**\n    * @property {number} _tempR - Internal cache var.\n    * @private\n    */\n    this._tempR = 0;\n\n    /**\n    * @property {number} _tempG - Internal cache var.\n    * @private\n    */\n    this._tempG = 0;\n\n    /**\n    * @property {number} _tempB - Internal cache var.\n    * @private\n    */\n    this._tempB = 0;\n\n    /**\n    * @property {Phaser.Circle} _circle - Internal cache var.\n    * @private\n    */\n    this._circle = new Phaser.Circle();\n\n    /**\n    * @property {HTMLCanvasElement} _swapCanvas - A swap canvas. Used by moveH and moveV, created in those methods.\n    * @private\n    */\n    this._swapCanvas = undefined;\n\n};\n\nPhaser.BitmapData.prototype = {\n\n    /**\n    * Shifts the contents of this BitmapData by the distances given.\n    * \n    * The image will wrap-around the edges on all sides if the wrap argument is true (the default).\n    *\n    * @method Phaser.BitmapData#move\n    * @param {integer} x - The amount of pixels to horizontally shift the canvas by. Use a negative value to shift to the left, positive to the right.\n    * @param {integer} y - The amount of pixels to vertically shift the canvas by. Use a negative value to shift up, positive to shift down.\n    * @param {boolean} [wrap=true] - Wrap the content of the BitmapData.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    move: function (x, y, wrap) {\n\n        if (x !== 0)\n        {\n            this.moveH(x, wrap);\n        }\n\n        if (y !== 0)\n        {\n            this.moveV(y, wrap);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Shifts the contents of this BitmapData horizontally.\n    * \n    * The image will wrap-around the sides if the wrap argument is true (the default).\n    *\n    * @method Phaser.BitmapData#moveH\n    * @param {integer} distance - The amount of pixels to horizontally shift the canvas by. Use a negative value to shift to the left, positive to the right.\n    * @param {boolean} [wrap=true] - Wrap the content of the BitmapData.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    moveH: function (distance, wrap) {\n\n        if (wrap === undefined) { wrap = true; }\n\n        if (this._swapCanvas === undefined)\n        {\n            this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height);\n        }\n\n        var c = this._swapCanvas;\n        var ctx = c.getContext('2d');\n        var h = this.height;\n        var src = this.canvas;\n\n        ctx.clearRect(0, 0, this.width, this.height);\n\n        if (distance < 0)\n        {\n            distance = Math.abs(distance);\n\n            //  Moving to the left\n            var w = this.width - distance;\n\n            //  Left-hand chunk\n            if (wrap)\n            {\n                ctx.drawImage(src, 0, 0, distance, h, w, 0, distance, h);\n            }\n\n            //  Rest of the image\n            ctx.drawImage(src, distance, 0, w, h, 0, 0, w, h);\n        }\n        else\n        {\n            //  Moving to the right\n            var w = this.width - distance;\n\n            //  Right-hand chunk\n            if (wrap)\n            {\n                ctx.drawImage(src, w, 0, distance, h, 0, 0, distance, h);\n            }\n\n            //  Rest of the image\n            ctx.drawImage(src, 0, 0, w, h, distance, 0, w, h);\n        }\n\n        this.clear();\n\n        return this.copy(this._swapCanvas);\n\n    },\n\n    /**\n    * Shifts the contents of this BitmapData vertically.\n    * \n    * The image will wrap-around the sides if the wrap argument is true (the default).\n    *\n    * @method Phaser.BitmapData#moveV\n    * @param {integer} distance - The amount of pixels to vertically shift the canvas by. Use a negative value to shift up, positive to shift down.\n    * @param {boolean} [wrap=true] - Wrap the content of the BitmapData.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    moveV: function (distance, wrap) {\n\n        if (wrap === undefined) { wrap = true; }\n\n        if (this._swapCanvas === undefined)\n        {\n            this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height);\n        }\n\n        var c = this._swapCanvas;\n        var ctx = c.getContext('2d');\n        var w = this.width;\n        var src = this.canvas;\n\n        ctx.clearRect(0, 0, this.width, this.height);\n\n        if (distance < 0)\n        {\n            distance = Math.abs(distance);\n\n            //  Moving up\n            var h = this.height - distance;\n\n            //  Top chunk\n            if (wrap)\n            {\n                ctx.drawImage(src, 0, 0, w, distance, 0, h, w, distance);\n            }\n\n            //  Rest of the image\n            ctx.drawImage(src, 0, distance, w, h, 0, 0, w, h);\n        }\n        else\n        {\n            //  Moving down\n            var h = this.height - distance;\n\n            //  Bottom chunk\n            if (wrap)\n            {\n                ctx.drawImage(src, 0, h, w, distance, 0, 0, w, distance);\n            }\n\n            //  Rest of the image\n            ctx.drawImage(src, 0, 0, w, h, 0, distance, w, h);\n        }\n\n        this.clear();\n\n        return this.copy(this._swapCanvas);\n\n    },\n\n    /**\n    * Updates the given objects so that they use this BitmapData as their texture.\n    * This will replace any texture they will currently have set.\n    *\n    * @method Phaser.BitmapData#add\n    * @param {Phaser.Sprite|Phaser.Sprite[]|Phaser.Image|Phaser.Image[]} object - Either a single Sprite/Image or an Array of Sprites/Images.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    add: function (object) {\n\n        if (Array.isArray(object))\n        {\n            for (var i = 0; i < object.length; i++)\n            {\n                if (object[i]['loadTexture'])\n                {\n                    object[i].loadTexture(this);\n                }\n            }\n        }\n        else\n        {\n            object.loadTexture(this);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Takes the given Game Object, resizes this BitmapData to match it and then draws it into this BitmapDatas canvas, ready for further processing.\n    * The source game object is not modified by this operation.\n    * If the source object uses a texture as part of a Texture Atlas or Sprite Sheet, only the current frame will be used for sizing.\n    * If a string is given it will assume it's a cache key and look in Phaser.Cache for an image key matching the string.\n    *\n    * @method Phaser.BitmapData#load\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Image|HTMLCanvasElement|string} source - The object that will be used to populate this BitmapData. If you give a string it will try and find the Image in the Game.Cache first.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    load: function (source) {\n\n        if (typeof source === 'string')\n        {\n            source = this.game.cache.getImage(source);\n        }\n\n        if (source)\n        {\n            this.resize(source.width, source.height);\n            this.cls();\n        }\n        else\n        {\n            return;\n        }\n\n        this.draw(source);\n\n        this.update();\n\n        return this;\n\n    },\n\n    /**\n    * Clears the BitmapData context using a clearRect.\n    *\n    * @method Phaser.BitmapData#cls\n    */\n\n    /**\n    * Clears the BitmapData context using a clearRect.\n    *\n    * You can optionally define the area to clear.\n    * If the arguments are left empty it will clear the entire canvas.\n    *\n    * You may need to call BitmapData.update after this in order to clear out the pixel data, \n    * but Phaser will not do this automatically for you.\n    *\n    * @method Phaser.BitmapData#clear\n    * @param {number} [x=0] - The x coordinate of the top-left of the area to clear.\n    * @param {number} [y=0] - The y coordinate of the top-left of the area to clear.\n    * @param {number} [width] - The width of the area to clear. If undefined it will use BitmapData.width.\n    * @param {number} [height] - The height of the area to clear. If undefined it will use BitmapData.height.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    clear: function (x, y, width, height) {\n\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (width === undefined) { width = this.width; }\n        if (height === undefined) { height = this.height; }\n\n        this.context.clearRect(x, y, width, height);\n\n        this.dirty = true;\n\n        return this;\n\n    },\n\n    /**\n    * Fills the BitmapData with the given color.\n    *\n    * @method Phaser.BitmapData#fill\n    * @param {number} r - The red color value, between 0 and 0xFF (255).\n    * @param {number} g - The green color value, between 0 and 0xFF (255).\n    * @param {number} b - The blue color value, between 0 and 0xFF (255).\n    * @param {number} [a=1] - The alpha color value, between 0 and 1.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    fill: function (r, g, b, a) {\n\n        if (a === undefined) { a = 1; }\n\n        this.context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n        this.context.fillRect(0, 0, this.width, this.height);\n        this.dirty = true;\n\n        return this;\n\n    },\n\n    /**\n    * Creates a new Image element by converting this BitmapDatas canvas into a dataURL.\n    *\n    * The image is then stored in the image Cache using the key given.\n    *\n    * Finally a PIXI.Texture is created based on the image and returned.\n    *\n    * You can apply the texture to a sprite or any other supporting object by using either the\n    * key or the texture. First call generateTexture:\n    *\n    * `var texture = bitmapdata.generateTexture('ball');`\n    *\n    * Then you can either apply the texture to a sprite:\n    * \n    * `game.add.sprite(0, 0, texture);`\n    *\n    * or by using the string based key:\n    *\n    * `game.add.sprite(0, 0, 'ball');`\n    *\n    * @method Phaser.BitmapData#generateTexture\n    * @param {string} key - The key which will be used to store the image in the Cache.\n    * @return {PIXI.Texture} The newly generated texture.\n    */\n    generateTexture: function (key) {\n\n        var image = new Image();\n\n        image.src = this.canvas.toDataURL(\"image/png\");\n\n        var obj = this.game.cache.addImage(key, '', image);\n\n        return new PIXI.Texture(obj.base);\n\n    },\n\n    /**\n    * Resizes the BitmapData. This changes the size of the underlying canvas and refreshes the buffer.\n    *\n    * @method Phaser.BitmapData#resize\n    * @param {integer} width - The new width of the BitmapData.\n    * @param {integer} height - The new height of the BitmapData.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    resize: function (width, height) {\n\n        if (width !== this.width || height !== this.height)\n        {\n            this.width = width;\n            this.height = height;\n\n            this.canvas.width = width;\n            this.canvas.height = height;\n\n            if (this._swapCanvas !== undefined)\n            {\n                this._swapCanvas.width = width;\n                this._swapCanvas.height = height;\n            }\n\n            this.baseTexture.width = width;\n            this.baseTexture.height = height;\n\n            this.textureFrame.width = width;\n            this.textureFrame.height = height;\n\n            this.texture.width = width;\n            this.texture.height = height;\n\n            this.texture.crop.width = width;\n            this.texture.crop.height = height;\n\n            this.update();\n            this.dirty = true;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * This re-creates the BitmapData.imageData from the current context.\n    * It then re-builds the ArrayBuffer, the data Uint8ClampedArray reference and the pixels Int32Array.\n    * If not given the dimensions defaults to the full size of the context.\n    *\n    * Warning: This is a very expensive operation, so use it sparingly.\n    *\n    * @method Phaser.BitmapData#update\n    * @param {number} [x=0] - The x coordinate of the top-left of the image data area to grab from.\n    * @param {number} [y=0] - The y coordinate of the top-left of the image data area to grab from.\n    * @param {number} [width=1] - The width of the image data area.\n    * @param {number} [height=1] - The height of the image data area.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    update: function (x, y, width, height) {\n\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (width === undefined) { width = Math.max(1, this.width); }\n        if (height === undefined) { height = Math.max(1, this.height); }\n\n        this.imageData = this.context.getImageData(x, y, width, height);\n        this.data = this.imageData.data;\n\n        if (this.imageData.data.buffer)\n        {\n            this.buffer = this.imageData.data.buffer;\n            this.pixels = new Uint32Array(this.buffer);\n        }\n        else\n        {\n            if (window['ArrayBuffer'])\n            {\n                this.buffer = new ArrayBuffer(this.imageData.data.length);\n                this.pixels = new Uint32Array(this.buffer);\n            }\n            else\n            {\n                this.pixels = this.imageData.data;\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Scans through the area specified in this BitmapData and sends a color object for every pixel to the given callback.\n    * The callback will be sent a color object with 6 properties: `{ r: number, g: number, b: number, a: number, color: number, rgba: string }`.\n    * Where r, g, b and a are integers between 0 and 255 representing the color component values for red, green, blue and alpha.\n    * The `color` property is an Int32 of the full color. Note the endianess of this will change per system.\n    * The `rgba` property is a CSS style rgba() string which can be used with context.fillStyle calls, among others.\n    * The callback will also be sent the pixels x and y coordinates respectively.\n    * The callback must return either `false`, in which case no change will be made to the pixel, or a new color object.\n    * If a new color object is returned the pixel will be set to the r, g, b and a color values given within it.\n    *\n    * @method Phaser.BitmapData#processPixelRGB\n    * @param {function} callback - The callback that will be sent each pixel color object to be processed.\n    * @param {object} callbackContext - The context under which the callback will be called.\n    * @param {number} [x=0] - The x coordinate of the top-left of the region to process from.\n    * @param {number} [y=0] - The y coordinate of the top-left of the region to process from.\n    * @param {number} [width] - The width of the region to process.\n    * @param {number} [height] - The height of the region to process.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    processPixelRGB: function (callback, callbackContext, x, y, width, height) {\n\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (width === undefined) { width = this.width; }\n        if (height === undefined) { height = this.height; }\n\n        var w = x + width;\n        var h = y + height;\n        var pixel = Phaser.Color.createColor();\n        var result = { r: 0, g: 0, b: 0, a: 0 };\n        var dirty = false;\n\n        for (var ty = y; ty < h; ty++)\n        {\n            for (var tx = x; tx < w; tx++)\n            {\n                Phaser.Color.unpackPixel(this.getPixel32(tx, ty), pixel);\n\n                result = callback.call(callbackContext, pixel, tx, ty);\n\n                if (result !== false && result !== null && result !== undefined)\n                {\n                    this.setPixel32(tx, ty, result.r, result.g, result.b, result.a, false);\n                    dirty = true;\n                }\n            }\n        }\n\n        if (dirty)\n        {\n            this.context.putImageData(this.imageData, 0, 0);\n            this.dirty = true;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Scans through the area specified in this BitmapData and sends the color for every pixel to the given callback along with its x and y coordinates.\n    * Whatever value the callback returns is set as the new color for that pixel, unless it returns the same color, in which case it's skipped.\n    * Note that the format of the color received will be different depending on if the system is big or little endian.\n    * It is expected that your callback will deal with endianess. If you'd rather Phaser did it then use processPixelRGB instead.\n    * The callback will also be sent the pixels x and y coordinates respectively.\n    *\n    * @method Phaser.BitmapData#processPixel\n    * @param {function} callback - The callback that will be sent each pixel color to be processed.\n    * @param {object} callbackContext - The context under which the callback will be called.\n    * @param {number} [x=0] - The x coordinate of the top-left of the region to process from.\n    * @param {number} [y=0] - The y coordinate of the top-left of the region to process from.\n    * @param {number} [width] - The width of the region to process.\n    * @param {number} [height] - The height of the region to process.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    processPixel: function (callback, callbackContext, x, y, width, height) {\n\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (width === undefined) { width = this.width; }\n        if (height === undefined) { height = this.height; }\n\n        var w = x + width;\n        var h = y + height;\n        var pixel = 0;\n        var result = 0;\n        var dirty = false;\n\n        for (var ty = y; ty < h; ty++)\n        {\n            for (var tx = x; tx < w; tx++)\n            {\n                pixel = this.getPixel32(tx, ty);\n                result = callback.call(callbackContext, pixel, tx, ty);\n\n                if (result !== pixel)\n                {\n                    this.pixels[ty * this.width + tx] = result;\n                    dirty = true;\n                }\n            }\n        }\n\n        if (dirty)\n        {\n            this.context.putImageData(this.imageData, 0, 0);\n            this.dirty = true;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Replaces all pixels matching one color with another. The color values are given as two sets of RGBA values.\n    * An optional region parameter controls if the replacement happens in just a specific area of the BitmapData or the entire thing. \n    *\n    * @method Phaser.BitmapData#replaceRGB\n    * @param {number} r1 - The red color value to be replaced. Between 0 and 255.\n    * @param {number} g1 - The green color value to be replaced. Between 0 and 255.\n    * @param {number} b1 - The blue color value to be replaced. Between 0 and 255.\n    * @param {number} a1 - The alpha color value to be replaced. Between 0 and 255.\n    * @param {number} r2 - The red color value that is the replacement color. Between 0 and 255.\n    * @param {number} g2 - The green color value that is the replacement color. Between 0 and 255.\n    * @param {number} b2 - The blue color value that is the replacement color. Between 0 and 255.\n    * @param {number} a2 - The alpha color value that is the replacement color. Between 0 and 255.\n    * @param {Phaser.Rectangle} [region] - The area to perform the search over. If not given it will replace over the whole BitmapData.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    replaceRGB: function (r1, g1, b1, a1, r2, g2, b2, a2, region) {\n\n        var sx = 0;\n        var sy = 0;\n        var w = this.width;\n        var h = this.height;\n        var source = Phaser.Color.packPixel(r1, g1, b1, a1);\n\n        if (region !== undefined && region instanceof Phaser.Rectangle)\n        {\n            sx = region.x;\n            sy = region.y;\n            w = region.width;\n            h = region.height;\n        }\n\n        for (var y = 0; y < h; y++)\n        {\n            for (var x = 0; x < w; x++)\n            {\n                if (this.getPixel32(sx + x, sy + y) === source)\n                {\n                    this.setPixel32(sx + x, sy + y, r2, g2, b2, a2, false);\n                }\n            }\n        }\n\n        this.context.putImageData(this.imageData, 0, 0);\n        this.dirty = true;\n\n        return this;\n\n    },\n\n    /**\n    * Sets the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.\n    *\n    * @method Phaser.BitmapData#setHSL\n    * @param {number} [h=null] - The hue, in the range 0 - 1.\n    * @param {number} [s=null] - The saturation, in the range 0 - 1.\n    * @param {number} [l=null] - The lightness, in the range 0 - 1.\n    * @param {Phaser.Rectangle} [region] - The area to perform the operation on. If not given it will run over the whole BitmapData.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    setHSL: function (h, s, l, region) {\n        \n        var bHaveH = h || h === 0;\n        var bHaveS = s || s === 0;\n        var bHaveL = l || l === 0;\n\n        if (!bHaveH && !bHaveS && !bHaveL)\n        {\n            return;\n        }\n\n        if (region === undefined)\n        {\n            region = new Phaser.Rectangle(0, 0, this.width, this.height);\n        }\n\n        var pixel = Phaser.Color.createColor();\n\n        for (var y = region.y; y < region.bottom; y++)\n        {\n            for (var x = region.x; x < region.right; x++)\n            {\n                Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);\n\n                if (bHaveH)\n                {\n                    pixel.h = h;\n                }\n\n                if (bHaveS)\n                {\n                    pixel.s = s;\n                }\n\n                if (bHaveL)\n                {\n                    pixel.l = l;\n                }\n\n                Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);\n                this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);\n            }\n        }\n\n        this.context.putImageData(this.imageData, 0, 0);\n        this.dirty = true;\n\n        return this;\n\n    },\n\n    /**\n    * Shifts any or all of the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.\n    * Shifting will add the given value onto the current h, s and l values, not replace them.\n    * The hue is wrapped to keep it within the range 0 to 1. Saturation and lightness are clamped to not exceed 1.\n    *\n    * @method Phaser.BitmapData#shiftHSL\n    * @param {number} [h=null] - The amount to shift the hue by.\n    * @param {number} [s=null] - The amount to shift the saturation by.\n    * @param {number} [l=null] - The amount to shift the lightness by.\n    * @param {Phaser.Rectangle} [region] - The area to perform the operation on. If not given it will run over the whole BitmapData.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    shiftHSL: function (h, s, l, region) {\n\n        if (h === undefined || h === null) { h = false; }\n        if (s === undefined || s === null) { s = false; }\n        if (l === undefined || l === null) { l = false; }\n\n        if (!h && !s && !l)\n        {\n            return;\n        }\n\n        if (region === undefined)\n        {\n            region = new Phaser.Rectangle(0, 0, this.width, this.height);\n        }\n\n        var pixel = Phaser.Color.createColor();\n\n        for (var y = region.y; y < region.bottom; y++)\n        {\n            for (var x = region.x; x < region.right; x++)\n            {\n                Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);\n\n                if (h)\n                {\n                    pixel.h = this.game.math.wrap(pixel.h + h, 0, 1);\n                }\n\n                if (s)\n                {\n                    pixel.s = this.game.math.clamp(pixel.s + s, 0, 1);\n                }\n\n                if (l)\n                {\n                    pixel.l = this.game.math.clamp(pixel.l + l, 0, 1);\n                }\n\n                Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);\n                this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);\n            }\n        }\n\n        this.context.putImageData(this.imageData, 0, 0);\n        this.dirty = true;\n\n        return this;\n\n    },\n\n    /**\n    * Sets the color of the given pixel to the specified red, green, blue and alpha values.\n    *\n    * @method Phaser.BitmapData#setPixel32\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} red - The red color value, between 0 and 0xFF (255).\n    * @param {number} green - The green color value, between 0 and 0xFF (255).\n    * @param {number} blue - The blue color value, between 0 and 0xFF (255).\n    * @param {number} alpha - The alpha color value, between 0 and 0xFF (255).\n    * @param {boolean} [immediate=true] - If `true` the context.putImageData will be called and the dirty flag set.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    setPixel32: function (x, y, red, green, blue, alpha, immediate) {\n\n        if (immediate === undefined) { immediate = true; }\n\n        if (x >= 0 && x <= this.width && y >= 0 && y <= this.height)\n        {\n            if (Phaser.Device.LITTLE_ENDIAN)\n            {\n                this.pixels[y * this.width + x] = (alpha << 24) | (blue << 16) | (green << 8) | red;\n            }\n            else\n            {\n                this.pixels[y * this.width + x] = (red << 24) | (green << 16) | (blue << 8) | alpha;\n            }\n\n            if (immediate)\n            {\n                this.context.putImageData(this.imageData, 0, 0);\n                this.dirty = true;\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Sets the color of the given pixel to the specified red, green and blue values.\n    *\n    * @method Phaser.BitmapData#setPixel\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} red - The red color value, between 0 and 0xFF (255).\n    * @param {number} green - The green color value, between 0 and 0xFF (255).\n    * @param {number} blue - The blue color value, between 0 and 0xFF (255).\n    * @param {boolean} [immediate=true] - If `true` the context.putImageData will be called and the dirty flag set.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    setPixel: function (x, y, red, green, blue, immediate) {\n\n        return this.setPixel32(x, y, red, green, blue, 255, immediate);\n\n    },\n\n    /**\n    * Get the color of a specific pixel in the context into a color object.\n    * If you have drawn anything to the BitmapData since it was created you must call BitmapData.update to refresh the array buffer,\n    * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\n    *\n    * @method Phaser.BitmapData#getPixel\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {object} [out] - An object into which 4 properties will be created: r, g, b and a. If not provided a new object will be created.\n    * @return {object} An object with the red, green, blue and alpha values set in the r, g, b and a properties.\n    */\n    getPixel: function (x, y, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor();\n        }\n\n        var index = ~~(x + (y * this.width));\n\n        index *= 4;\n\n        out.r = this.data[index];\n        out.g = this.data[++index];\n        out.b = this.data[++index];\n        out.a = this.data[++index];\n\n        return out;\n\n    },\n\n    /**\n    * Get the color of a specific pixel including its alpha value.\n    * If you have drawn anything to the BitmapData since it was created you must call BitmapData.update to refresh the array buffer,\n    * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\n    * Note that on little-endian systems the format is 0xAABBGGRR and on big-endian the format is 0xRRGGBBAA.\n    *\n    * @method Phaser.BitmapData#getPixel32\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @return {number} A native color value integer (format: 0xAARRGGBB)\n    */\n    getPixel32: function (x, y) {\n\n        if (x >= 0 && x <= this.width && y >= 0 && y <= this.height)\n        {\n            return this.pixels[y * this.width + x];\n        }\n\n    },\n\n    /**\n    * Get the color of a specific pixel including its alpha value as a color object containing r,g,b,a and rgba properties.\n    * If you have drawn anything to the BitmapData since it was created you must call BitmapData.update to refresh the array buffer,\n    * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\n    *\n    * @method Phaser.BitmapData#getPixelRGB\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.\n    * @param {boolean} [hsl=false] - Also convert the rgb values into hsl?\n    * @param {boolean} [hsv=false] - Also convert the rgb values into hsv?\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    getPixelRGB: function (x, y, out, hsl, hsv) {\n\n        return Phaser.Color.unpackPixel(this.getPixel32(x, y), out, hsl, hsv);\n\n    },\n\n    /**\n    * Gets all the pixels from the region specified by the given Rectangle object.\n    *\n    * @method Phaser.BitmapData#getPixels\n    * @param {Phaser.Rectangle} rect - The Rectangle region to get.\n    * @return {ImageData} Returns a ImageData object containing a Uint8ClampedArray data property.\n    */\n    getPixels: function (rect) {\n\n        return this.context.getImageData(rect.x, rect.y, rect.width, rect.height);\n\n    },\n\n    /**\n    * Scans the BitmapData, pixel by pixel, until it encounters a pixel that isn't transparent (i.e. has an alpha value > 0).\n    * It then stops scanning and returns an object containing the color of the pixel in r, g and b properties and the location in the x and y properties.\n    * \n    * The direction parameter controls from which direction it should start the scan:\n    * \n    * 0 = top to bottom\n    * 1 = bottom to top\n    * 2 = left to right\n    * 3 = right to left\n    *\n    * @method Phaser.BitmapData#getFirstPixel\n    * @param {number} [direction=0] - The direction in which to scan for the first pixel. 0 = top to bottom, 1 = bottom to top, 2 = left to right and 3 = right to left.\n    * @return {object} Returns an object containing the color of the pixel in the `r`, `g` and `b` properties and the location in the `x` and `y` properties.\n    */\n    getFirstPixel: function (direction) {\n\n        if (direction === undefined) { direction = 0; }\n\n        var pixel = Phaser.Color.createColor();\n\n        var x = 0;\n        var y = 0;\n        var v = 1;\n        var scan = false;\n\n        if (direction === 1)\n        {\n            v = -1;\n            y = this.height;\n        }\n        else if (direction === 3)\n        {\n            v = -1;\n            x = this.width;\n        }\n\n        do {\n\n            Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel);\n\n            if (direction === 0 || direction === 1)\n            {\n                //  Top to Bottom / Bottom to Top\n                x++;\n\n                if (x === this.width)\n                {\n                    x = 0;\n                    y += v;\n\n                    if (y >= this.height || y <= 0)\n                    {\n                        scan = true;\n                    }\n                }\n            }\n            else if (direction === 2 || direction === 3)\n            {\n                //  Left to Right / Right to Left\n                y++;\n\n                if (y === this.height)\n                {\n                    y = 0;\n                    x += v;\n\n                    if (x >= this.width || x <= 0)\n                    {\n                        scan = true;\n                    }\n                }\n            }\n        }\n        while (pixel.a === 0 && !scan);\n\n        pixel.x = x;\n        pixel.y = y;\n\n        return pixel;\n\n    },\n\n    /**\n    * Scans the BitmapData and calculates the bounds. This is a rectangle that defines the extent of all non-transparent pixels.\n    * The rectangle returned will extend from the top-left of the image to the bottom-right, excluding transparent pixels.\n    *\n    * @method Phaser.BitmapData#getBounds\n    * @param {Phaser.Rectangle} [rect] - If provided this Rectangle object will be populated with the bounds, otherwise a new object will be created.\n    * @return {Phaser.Rectangle} A Rectangle whose dimensions encompass the full extent of non-transparent pixels in this BitmapData.\n    */\n    getBounds: function (rect) {\n\n        if (rect === undefined) { rect = new Phaser.Rectangle(); }\n\n        rect.x = this.getFirstPixel(2).x;\n\n        //  If we hit this, there's no point scanning any more, the image is empty\n        if (rect.x === this.width)\n        {\n            return rect.setTo(0, 0, 0, 0);\n        }\n\n        rect.y = this.getFirstPixel(0).y;\n        rect.width = (this.getFirstPixel(3).x - rect.x) + 1;\n        rect.height = (this.getFirstPixel(1).y - rect.y) + 1;\n\n        return rect;\n\n    },\n\n    /**\n    * Creates a new Phaser.Image object, assigns this BitmapData to be its texture, adds it to the world then returns it.\n    *\n    * @method Phaser.BitmapData#addToWorld\n    * @param {number} [x=0] - The x coordinate to place the Image at.\n    * @param {number} [y=0] - The y coordinate to place the Image at.\n    * @param {number} [anchorX=0] - Set the x anchor point of the Image. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.\n    * @param {number} [anchorY=0] - Set the y anchor point of the Image. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.\n    * @param {number} [scaleX=1] - The horizontal scale factor of the Image. A value of 1 means no scaling. 2 would be twice the size, and so on.\n    * @param {number} [scaleY=1] - The vertical scale factor of the Image. A value of 1 means no scaling. 2 would be twice the size, and so on.\n    * @return {Phaser.Image} The newly added Image object.\n    */\n    addToWorld: function (x, y, anchorX, anchorY, scaleX, scaleY) {\n\n        scaleX = scaleX || 1;\n        scaleY = scaleY || 1;\n\n        var image = this.game.add.image(x, y, this);\n\n        image.anchor.set(anchorX, anchorY);\n        image.scale.set(scaleX, scaleY);\n\n        return image;\n\n    },\n\n    /**\n     * Copies a rectangular area from the source object to this BitmapData. If you give `null` as the source it will copy from itself.\n     * \n     * You can optionally resize, translate, rotate, scale, alpha or blend as it's drawn.\n     * \n     * All rotation, scaling and drawing takes place around the regions center point by default, but can be changed with the anchor parameters.\n     * \n     * Note that the source image can also be this BitmapData, which can create some interesting effects.\n     * \n     * This method has a lot of parameters for maximum control.\n     * You can use the more friendly methods like `copyRect` and `draw` to avoid having to remember them all.\n     * \n     * You may prefer to use `copyTransform` if you're simply trying to draw a Sprite to this BitmapData,\n     * and don't wish to translate, scale or rotate it from its original values.\n     *\n     * @method Phaser.BitmapData#copy\n     * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Phaser.RenderTexture|Image|HTMLCanvasElement|string} [source] - The source to copy from. If you give a string it will try and find the Image in the Game.Cache first. This is quite expensive so try to provide the image itself.\n     * @param {number} [x=0] - The x coordinate representing the top-left of the region to copy from the source image.\n     * @param {number} [y=0] - The y coordinate representing the top-left of the region to copy from the source image.\n     * @param {number} [width] - The width of the region to copy from the source image. If not specified it will use the full source image width.\n     * @param {number} [height] - The height of the region to copy from the source image. If not specified it will use the full source image height.\n     * @param {number} [tx] - The x coordinate to translate to before drawing. If not specified it will default to the `x` parameter. If `null` and `source` is a Display Object, it will default to `source.x`.\n     * @param {number} [ty] - The y coordinate to translate to before drawing. If not specified it will default to the `y` parameter. If `null` and `source` is a Display Object, it will default to `source.y`.\n     * @param {number} [newWidth] - The new width of the block being copied. If not specified it will default to the `width` parameter.\n     * @param {number} [newHeight] - The new height of the block being copied. If not specified it will default to the `height` parameter.\n     * @param {number} [rotate=0] - The angle in radians to rotate the block to before drawing. Rotation takes place around the center by default, but can be changed with the `anchor` parameters.\n     * @param {number} [anchorX=0] - The anchor point around which the block is rotated and scaled. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.\n     * @param {number} [anchorY=0] - The anchor point around which the block is rotated and scaled. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.\n     * @param {number} [scaleX=1] - The horizontal scale factor of the block. A value of 1 means no scaling. 2 would be twice the size, and so on.\n     * @param {number} [scaleY=1] - The vertical scale factor of the block. A value of 1 means no scaling. 2 would be twice the size, and so on.\n     * @param {number} [alpha=1] - The alpha that will be set on the context before drawing. A value between 0 (fully transparent) and 1, opaque.\n     * @param {string} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all. This is a Canvas globalCompositeOperation value such as 'lighter' or 'xor'.\n     * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.\n     * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n     */\n    copy: function (source, x, y, width, height, tx, ty, newWidth, newHeight, rotate, anchorX, anchorY, scaleX, scaleY, alpha, blendMode, roundPx) {\n\n        if (source === undefined || source === null) { source = this; }\n\n        if (source instanceof Phaser.RenderTexture || source instanceof PIXI.RenderTexture)\n        {\n            source = source.getCanvas();\n        }\n\n        this._image = source;\n\n        if (source instanceof Phaser.Sprite || source instanceof Phaser.Image || source instanceof Phaser.Text || source instanceof PIXI.Sprite)\n        {\n            //  Copy over sprite values\n            this._pos.set(source.texture.crop.x, source.texture.crop.y);\n            this._size.set(source.texture.crop.width, source.texture.crop.height);\n            this._scale.set(source.scale.x, source.scale.y);\n            this._anchor.set(source.anchor.x, source.anchor.y);\n            this._rotate = source.rotation;\n            this._alpha.current = source.alpha;\n\n            if (source.texture instanceof Phaser.RenderTexture || source.texture instanceof PIXI.RenderTexture)\n            {\n                this._image = source.texture.getCanvas();\n            }\n            else\n            {\n                this._image = source.texture.baseTexture.source;\n            }\n\n            if (tx === undefined || tx === null) { tx = source.x; }\n            if (ty === undefined || ty === null) { ty = source.y; }\n\n            if (source.texture.trim)\n            {\n                //  Offset the translation coordinates by the trim amount\n                tx += source.texture.trim.x - source.anchor.x * source.texture.trim.width;\n                ty += source.texture.trim.y - source.anchor.y * source.texture.trim.height;\n            }\n\n            if (source.tint !== 0xFFFFFF)\n            {\n                if (source.cachedTint !== source.tint)\n                {\n                    source.cachedTint = source.tint;\n                    source.tintedTexture = PIXI.CanvasTinter.getTintedTexture(source, source.tint);\n                }\n\n                this._image = source.tintedTexture;\n                this._pos.set(0);\n            }\n        }\n        else\n        {\n            //  Reset\n            this._pos.set(0);\n            this._scale.set(1);\n            this._anchor.set(0);\n            this._rotate = 0;\n            this._alpha.current = 1;\n\n            if (source instanceof Phaser.BitmapData)\n            {\n                this._image = source.canvas;\n            }\n            else if (typeof source === 'string')\n            {\n                source = this.game.cache.getImage(source);\n\n                if (source === null)\n                {\n                    return;\n                }\n                else\n                {\n                    this._image = source;\n                }\n            }\n\n            this._size.set(this._image.width, this._image.height);\n        }\n\n        //  The source region to copy from\n        if (x === undefined || x === null) { x = 0; }\n        if (y === undefined || y === null) { y = 0; }\n\n        //  If they set a width/height then we override the frame values with them\n        if (width)\n        {\n            this._size.x = width;\n        }\n\n        if (height)\n        {\n            this._size.y = height;\n        }\n\n        //  The destination region to copy to\n        if (tx === undefined || tx === null) { tx = x; }\n        if (ty === undefined || ty === null) { ty = y; }\n        if (newWidth === undefined || newWidth === null) { newWidth = this._size.x; }\n        if (newHeight === undefined || newHeight === null) { newHeight = this._size.y; }\n\n        //  Rotation - if set this will override any potential Sprite value\n        if (typeof rotate === 'number')\n        {\n            this._rotate = rotate;\n        }\n\n        //  Anchor - if set this will override any potential Sprite value\n        if (typeof anchorX === 'number')\n        {\n            this._anchor.x = anchorX;\n        }\n\n        if (typeof anchorY === 'number')\n        {\n            this._anchor.y = anchorY;\n        }\n\n        //  Scaling - if set this will override any potential Sprite value\n        if (typeof scaleX === 'number')\n        {\n            this._scale.x = scaleX;\n        }\n\n        if (typeof scaleY === 'number')\n        {\n            this._scale.y = scaleY;\n        }\n\n        //  Effects\n        if (typeof alpha === 'number')\n        {\n            this._alpha.current = alpha;\n        }\n\n        if (blendMode === undefined) { blendMode = null; }\n        if (roundPx === undefined) { roundPx = false; }\n\n        if (this._alpha.current <= 0 || this._scale.x === 0 || this._scale.y === 0 || this._size.x === 0 || this._size.y === 0)\n        {\n            //  Why bother wasting CPU cycles drawing something you can't see?\n            return;\n        }\n\n        var ctx = this.context;\n\n        this._alpha.prev = ctx.globalAlpha;\n\n        ctx.save();\n\n        ctx.globalAlpha = this._alpha.current;\n\n        if (blendMode)\n        {\n            this.op = blendMode;\n        }\n\n        if (roundPx)\n        {\n            tx |= 0;\n            ty |= 0;\n        }\n\n        //  Doesn't work fully with children, or nested scale + rotation transforms (see copyTransform)\n        ctx.translate(tx, ty);\n\n        ctx.scale(this._scale.x, this._scale.y);\n\n        ctx.rotate(this._rotate);\n\n        ctx.drawImage(this._image, this._pos.x + x, this._pos.y + y, this._size.x, this._size.y, -newWidth * this._anchor.x, -newHeight * this._anchor.y, newWidth, newHeight);\n\n        //  Carry on ...\n\n        ctx.restore();\n\n        ctx.globalAlpha = this._alpha.prev;\n\n        this.dirty = true;\n\n        return this;\n\n    },\n\n    /**\n    * Draws the given `source` Game Object to this BitmapData, using its `worldTransform` property to set the\n    * position, scale and rotation of where it is drawn. This function is used internally by `drawGroup`.\n    * It takes the objects tint and scale mode into consideration before drawing.\n    *\n    * You can optionally specify Blend Mode and Round Pixels arguments.\n    * \n    * @method Phaser.BitmapData#copyTransform\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Phaser.BitmapText} [source] - The Game Object to draw.\n    * @param {string} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all. This is a Canvas globalCompositeOperation value such as 'lighter' or 'xor'.\n    * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    copyTransform: function (source, blendMode, roundPx) {\n\n        if (blendMode === undefined) { blendMode = null; }\n        if (roundPx === undefined) { roundPx = false; }\n\n        if (!source.hasOwnProperty('worldTransform') || !source.worldVisible || source.worldAlpha === 0)\n        {\n            return this;\n        }\n\n        var wt = source.worldTransform;\n\n        this._pos.set(source.texture.crop.x, source.texture.crop.y);\n        this._size.set(source.texture.crop.width, source.texture.crop.height);\n\n        if (wt.a === 0 || wt.d === 0 || this._size.x === 0 || this._size.y === 0)\n        {\n             // Why bother wasting CPU cycles drawing something you can't see?\n            return this;\n        }\n\n        if (source.texture instanceof Phaser.RenderTexture || source.texture instanceof PIXI.RenderTexture)\n        {\n            this._image = source.texture.getCanvas();\n        }\n        else\n        {\n            this._image = source.texture.baseTexture.source;\n        }\n\n        var tx = wt.tx;\n        var ty = wt.ty;\n\n        if (source.texture.trim)\n        {\n            //  Offset the translation coordinates by the trim amount\n            tx += source.texture.trim.x - source.anchor.x * source.texture.trim.width;\n            ty += source.texture.trim.y - source.anchor.y * source.texture.trim.height;\n        }\n\n        if (source.tint !== 0xFFFFFF)\n        {\n            if (source.cachedTint !== source.tint)\n            {\n                source.cachedTint = source.tint;\n                source.tintedTexture = PIXI.CanvasTinter.getTintedTexture(source, source.tint);\n            }\n\n            this._image = source.tintedTexture;\n            this._pos.set(0);\n        }\n\n        if (roundPx)\n        {\n            tx |= 0;\n            ty |= 0;\n        }\n\n        var ctx = this.context;\n\n        this._alpha.prev = ctx.globalAlpha;\n\n        ctx.save();\n\n        ctx.globalAlpha = this._alpha.current;\n\n        if (blendMode)\n        {\n            this.op = blendMode;\n        }\n\n        ctx[this.smoothProperty] = (source.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR);\n\n        ctx.setTransform(wt.a, wt.b, wt.c, wt.d, tx, ty);\n\n        ctx.drawImage(this._image,\n            this._pos.x,\n            this._pos.y,\n            this._size.x,\n            this._size.y,\n            -this._size.x * source.anchor.x,\n            -this._size.y * source.anchor.y,\n            this._size.x,\n            this._size.y);\n\n        ctx.restore();\n\n        ctx.globalAlpha = this._alpha.prev;\n\n        this.dirty = true;\n\n        return this;\n\n    },\n\n    /**\n    * Copies the area defined by the Rectangle parameter from the source image to this BitmapData at the given location.\n    *\n    * @method Phaser.BitmapData#copyRect\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Phaser.RenderTexture|Image|string} source - The Image to copy from. If you give a string it will try and find the Image in the Game.Cache.\n    * @param {Phaser.Rectangle} area - The Rectangle region to copy from the source image.\n    * @param {number} x - The destination x coordinate to copy the image to.\n    * @param {number} y - The destination y coordinate to copy the image to.\n    * @param {number} [alpha=1] - The alpha that will be set on the context before drawing. A value between 0 (fully transparent) and 1, opaque.\n    * @param {string} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all. This is a Canvas globalCompositeOperation value such as 'lighter' or 'xor'.\n    * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    copyRect: function (source, area, x, y, alpha, blendMode, roundPx) {\n\n        return this.copy(source, area.x, area.y, area.width, area.height, x, y, area.width, area.height, 0, 0, 0, 1, 1, alpha, blendMode, roundPx);\n\n    },\n\n    /**\n    * Draws the given Phaser.Sprite, Phaser.Image or Phaser.Text to this BitmapData at the coordinates specified.\n    * You can use the optional width and height values to 'stretch' the sprite as it is drawn. This uses drawImage stretching, not scaling.\n    * \n    * The children will be drawn at their `x` and `y` world space coordinates. If this is outside the bounds of the BitmapData they won't be visible.\n    * When drawing it will take into account the rotation, scale, scaleMode, alpha and tint values.\n    * \n    * Note: You should ensure that at least 1 full update has taken place before calling this, \n    * otherwise the objects are likely to render incorrectly, if at all.\n    * You can trigger an update yourself by calling `stage.updateTransform()` before calling `draw`.\n    *\n    * @method Phaser.BitmapData#draw\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.RenderTexture} source - The Sprite, Image or Text object to draw onto this BitmapData.\n    * @param {number} [x=0] - The x coordinate to translate to before drawing. If not specified it will default to `source.x`.\n    * @param {number} [y=0] - The y coordinate to translate to before drawing. If not specified it will default to `source.y`.\n    * @param {number} [width] - The new width of the Sprite being copied. If not specified it will default to `source.width`.\n    * @param {number} [height] - The new height of the Sprite being copied. If not specified it will default to `source.height`.\n    * @param {string} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all. This is a Canvas globalCompositeOperation value such as 'lighter' or 'xor'.\n    * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    draw: function (source, x, y, width, height, blendMode, roundPx) {\n\n        //  By specifying null for most parameters it will tell `copy` to use the Sprite values instead, which is what we want here\n        return this.copy(source, null, null, null, null, x, y, width, height, null, null, null, null, null, null, blendMode, roundPx);\n\n    },\n\n    /**\n    * Draws the immediate children of a Phaser.Group to this BitmapData.\n    * \n    * It's perfectly valid to pass in `game.world` as the Group, and it will iterate through the entire display list.\n    * \n    * Children are drawn _only_ if they have their `exists` property set to `true`, and have image, or RenderTexture, based Textures.\n    * \n    * The children will be drawn at their `x` and `y` world space coordinates. If this is outside the bounds of the BitmapData they won't be visible.\n    * When drawing it will take into account the rotation, scale, scaleMode, alpha and tint values.\n    * \n    * Note: You should ensure that at least 1 full update has taken place before calling this, \n    * otherwise the objects are likely to render incorrectly, if at all.\n    * You can trigger an update yourself by calling `stage.updateTransform()` before calling `drawGroup`.\n    *\n    * @method Phaser.BitmapData#drawGroup\n    * @param {Phaser.Group} group - The Group to draw onto this BitmapData. Can also be Phaser.World.\n    * @param {string} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all. This is a Canvas globalCompositeOperation value such as 'lighter' or 'xor'.\n    * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    drawGroup: function (group, blendMode, roundPx) {\n\n        if (group.total > 0)\n        {\n            group.forEachExists(this.drawGroupProxy, this, blendMode, roundPx);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * A proxy for drawGroup that handles child iteration for more complex Game Objects.\n    * \n    * @method Phaser.BitmapData#drawGroupProxy\n    * @private\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.BitmapText} child - The child to draw.\n    * @param {string} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all. This is a Canvas globalCompositeOperation value such as 'lighter' or 'xor'.\n    * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.\n    */\n    drawGroupProxy: function (child, blendMode, roundPx) {\n\n        if (child.hasOwnProperty('texture'))\n        {\n            this.copyTransform(child, blendMode, roundPx);\n        }\n\n        if (child.type === Phaser.GROUP && child.exists)\n        {\n            this.drawGroup(child, blendMode, roundPx);\n        }\n        else\n        {\n            if (child.hasOwnProperty('children') && child.children.length > 0)\n            {\n                for (var i = 0; i < child.children.length; i++)\n                {\n                    if (child.children[i].exists)\n                    {\n                        this.copyTransform(child.children[i], blendMode, roundPx);\n                    }\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Draws the Game Object or Group to this BitmapData and then recursively iterates through all of its children.\n    * \n    * If a child has an `exists` property then it (and its children) will be only be drawn if exists is `true`.\n    * \n    * The children will be drawn at their `x` and `y` world space coordinates. If this is outside the bounds of the BitmapData \n    * they won't be drawn. Depending on your requirements you may need to resize the BitmapData in advance to match the \n    * bounds of the top-level Game Object.\n    * \n    * When drawing it will take into account the child's world rotation, scale and alpha values.\n    *\n    * It's perfectly valid to pass in `game.world` as the parent object, and it will iterate through the entire display list.\n    * \n    * Note: If you are trying to grab your entire game at the start of a State then you should ensure that at least 1 full update\n    * has taken place before doing so, otherwise all of the objects will render with incorrect positions and scales. You can \n    * trigger an update yourself by calling `stage.updateTransform()` before calling `drawFull`.\n    *\n    * @method Phaser.BitmapData#drawFull\n    * @param {Phaser.World|Phaser.Group|Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText} parent - The Game Object to draw onto this BitmapData and then recursively draw all of its children.\n    * @param {string} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all. This is a Canvas globalCompositeOperation value such as 'lighter' or 'xor'.\n    * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    drawFull: function (parent, blendMode, roundPx) {\n\n        if (parent.worldVisible === false || parent.worldAlpha === 0 || (parent.hasOwnProperty('exists') && parent.exists === false))\n        {\n            return this;\n        }\n\n        if (parent.type !== Phaser.GROUP && parent.type !== Phaser.EMITTER && parent.type !== Phaser.BITMAPTEXT)\n        {\n            if (parent.type === Phaser.GRAPHICS)\n            {\n                var bounds = parent.getBounds();\n                this.ctx.save();\n                this.ctx.translate(bounds.x, bounds.y);\n                PIXI.CanvasGraphics.renderGraphics(parent, this.ctx);\n                this.ctx.restore();\n            }\n            else\n            {\n                this.copy(parent, null, null, null, null, parent.worldPosition.x, parent.worldPosition.y, null, null, parent.worldRotation, null, null, parent.worldScale.x, parent.worldScale.y, parent.worldAlpha, blendMode, roundPx);\n            }\n        }\n\n        if (parent.children)\n        {\n            for (var i = 0; i < parent.children.length; i++)\n            {\n                this.drawFull(parent.children[i], blendMode, roundPx);\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Sets the shadow properties of this BitmapDatas context which will affect all draw operations made to it.\n    * You can cancel an existing shadow by calling this method and passing no parameters.\n    * Note: At the time of writing (October 2014) Chrome still doesn't support shadowBlur used with drawImage.\n    *\n    * @method Phaser.BitmapData#shadow\n    * @param {string} color - The color of the shadow, given in a CSS format, i.e. `#000000` or `rgba(0,0,0,1)`. If `null` or `undefined` the shadow will be reset.\n    * @param {number} [blur=5] - The amount the shadow will be blurred by. Low values = a crisp shadow, high values = a softer shadow.\n    * @param {number} [x=10] - The horizontal offset of the shadow in pixels.\n    * @param {number} [y=10] - The vertical offset of the shadow in pixels.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    shadow: function (color, blur, x, y) {\n\n        var ctx = this.context;\n\n        if (color === undefined || color === null)\n        {\n            ctx.shadowColor = 'rgba(0,0,0,0)';\n        }\n        else\n        {\n            ctx.shadowColor = color;\n            ctx.shadowBlur = blur || 5;\n            ctx.shadowOffsetX = x || 10;\n            ctx.shadowOffsetY = y || 10;\n        }\n        \n        return this;\n\n    },\n\n    /**\n    * Draws the image onto this BitmapData using an image as an alpha mask.\n    *\n    * @method Phaser.BitmapData#alphaMask\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Image|HTMLCanvasElement|string} source - The source to copy from. If you give a string it will try and find the Image in the Game.Cache first. This is quite expensive so try to provide the image itself.\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Image|HTMLCanvasElement|string} [mask] - The object to be used as the mask. If you give a string it will try and find the Image in the Game.Cache first. This is quite expensive so try to provide the image itself. If you don't provide a mask it will use this BitmapData as the mask.\n    * @param {Phaser.Rectangle} [sourceRect] - A Rectangle where x/y define the coordinates to draw the Source image to and width/height define the size.\n    * @param {Phaser.Rectangle} [maskRect] - A Rectangle where x/y define the coordinates to draw the Mask image to and width/height define the size.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    alphaMask: function (source, mask, sourceRect, maskRect) {\n\n        if (maskRect === undefined || maskRect === null)\n        {\n            this.draw(mask).blendSourceAtop();\n        }\n        else\n        {\n            this.draw(mask, maskRect.x, maskRect.y, maskRect.width, maskRect.height).blendSourceAtop();\n        }\n\n        if (sourceRect === undefined || sourceRect === null)\n        {\n            this.draw(source).blendReset();\n        }\n        else\n        {\n            this.draw(source, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height).blendReset();\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Scans this BitmapData for all pixels matching the given r,g,b values and then draws them into the given destination BitmapData.\n    * The original BitmapData remains unchanged.\n    * The destination BitmapData must be large enough to receive all of the pixels that are scanned unless the 'resize' parameter is true.\n    * Although the destination BitmapData is returned from this method, it's actually modified directly in place, meaning this call is perfectly valid:\n    * `picture.extract(mask, r, g, b)`\n    * You can specify optional r2, g2, b2 color values. If given the pixel written to the destination bitmap will be of the r2, g2, b2 color.\n    * If not given it will be written as the same color it was extracted. You can provide one or more alternative colors, allowing you to tint\n    * the color during extraction.\n    *\n    * @method Phaser.BitmapData#extract\n    * @param {Phaser.BitmapData} destination - The BitmapData that the extracted pixels will be drawn to.\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {number} [a=255] - The alpha color component, in the range 0 - 255 that the new pixel will be drawn at.\n    * @param {boolean} [resize=false] - Should the destination BitmapData be resized to match this one before the pixels are copied?\n    * @param {number} [r2] - An alternative red color component to be written to the destination, in the range 0 - 255.\n    * @param {number} [g2] - An alternative green color component to be written to the destination, in the range 0 - 255.\n    * @param {number} [b2] - An alternative blue color component to be written to the destination, in the range 0 - 255.\n    * @returns {Phaser.BitmapData} The BitmapData that the extract pixels were drawn on.\n    */\n    extract: function (destination, r, g, b, a, resize, r2, g2, b2) {\n\n        if (a === undefined) { a = 255; }\n        if (resize === undefined) { resize = false; }\n        if (r2 === undefined) { r2 = r; }\n        if (g2 === undefined) { g2 = g; }\n        if (b2 === undefined) { b2 = b; }\n\n        if (resize)\n        {\n            destination.resize(this.width, this.height);\n        }\n\n        this.processPixelRGB(\n            function (pixel, x, y)\n            {\n                if (pixel.r === r && pixel.g === g && pixel.b === b)\n                {\n                    destination.setPixel32(x, y, r2, g2, b2, a, false);\n                }\n                return false;\n            },\n            this);\n\n        destination.context.putImageData(destination.imageData, 0, 0);\n        destination.dirty = true;\n\n        return destination;\n\n    },\n\n    /**\n    * Draws a filled Rectangle to the BitmapData at the given x, y coordinates and width / height in size.\n    *\n    * @method Phaser.BitmapData#rect\n    * @param {number} x - The x coordinate of the top-left of the Rectangle.\n    * @param {number} y - The y coordinate of the top-left of the Rectangle.\n    * @param {number} width - The width of the Rectangle.\n    * @param {number} height - The height of the Rectangle.\n    * @param {string} [fillStyle] - If set the context fillStyle will be set to this value before the rect is drawn.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    rect: function (x, y, width, height, fillStyle) {\n\n        if (typeof fillStyle !== 'undefined')\n        {\n            this.context.fillStyle = fillStyle;\n        }\n\n        this.context.fillRect(x, y, width, height);\n\n        return this;\n\n    },\n\n    /**\n    * Draws text to the BitmapData in the given font and color.\n    * The default font is 14px Courier, so useful for quickly drawing debug text.\n    * If you need to do a lot of font work to this BitmapData we'd recommend implementing your own text draw method.\n    *\n    * @method Phaser.BitmapData#text\n    * @param {string} text - The text to write to the BitmapData.\n    * @param {number} x - The x coordinate of the top-left of the text string.\n    * @param {number} y - The y coordinate of the top-left of the text string.\n    * @param {string} [font='14px Courier'] - The font. This is passed directly to Context.font, so anything that can support, this can.\n    * @param {string} [color='rgb(255,255,255)'] - The color the text will be drawn in.\n    * @param {boolean} [shadow=true] - Draw a single pixel black shadow below the text (offset by text.x/y + 1)\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    text: function (text, x, y, font, color, shadow) {\n\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (font === undefined) { font = '14px Courier'; }\n        if (color === undefined) { color = 'rgb(255,255,255)'; }\n        if (shadow === undefined) { shadow = true; }\n\n        var ctx = this.context;\n        var prevFont = ctx.font;\n\n        ctx.font = font;\n\n        if (shadow)\n        {\n            ctx.fillStyle = 'rgb(0,0,0)';\n            ctx.fillText(text, x + 1, y + 1);\n        }\n        \n        ctx.fillStyle = color;\n        ctx.fillText(text, x, y);\n\n        ctx.font = prevFont;\n        \n        return this;\n\n    },\n\n    /**\n    * Draws a filled Circle to the BitmapData at the given x, y coordinates and radius in size.\n    *\n    * @method Phaser.BitmapData#circle\n    * @param {number} x - The x coordinate to draw the Circle at. This is the center of the circle.\n    * @param {number} y - The y coordinate to draw the Circle at. This is the center of the circle.\n    * @param {number} radius - The radius of the Circle in pixels. The radius is half the diameter.\n    * @param {string} [fillStyle] - If set the context fillStyle will be set to this value before the circle is drawn.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    circle: function (x, y, radius, fillStyle) {\n\n        var ctx = this.context;\n\n        if (fillStyle !== undefined)\n        {\n            ctx.fillStyle = fillStyle;\n        }\n\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n        ctx.closePath();\n\n        ctx.fill();\n\n        return this;\n\n    },\n\n    /**\n    * Draws a line between the coordinates given in the color and thickness specified.\n    *\n    * @method Phaser.BitmapData#line\n    * @param {number} x1 - The x coordinate to start the line from.\n    * @param {number} y1 - The y coordinate to start the line from.\n    * @param {number} x2 - The x coordinate to draw the line to.\n    * @param {number} y2 - The y coordinate to draw the line to.\n    * @param {string} [color='#fff'] - The stroke color that the line will be drawn in.\n    * @param {number} [width=1] - The line thickness.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    line: function (x1, y1, x2, y2, color, width) {\n\n        if (color === undefined) { color = '#fff'; }\n        if (width === undefined) { width = 1; }\n\n        var ctx = this.context;\n\n        ctx.beginPath();\n\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n\n        ctx.lineWidth = width;\n        ctx.strokeStyle = color;\n        ctx.stroke();\n\n        ctx.closePath();\n\n        return this;\n\n    },\n\n    /**\n    * Takes the given Line object and image and renders it to this BitmapData as a repeating texture line.\n    *\n    * @method Phaser.BitmapData#textureLine\n    * @param {Phaser.Line} line - A Phaser.Line object that will be used to plot the start and end of the line.\n    * @param {string|Image} image - The key of an image in the Phaser.Cache to use as the texture for this line, or an actual Image.\n    * @param {string} [repeat='repeat-x'] - The pattern repeat mode to use when drawing the line. Either `repeat`, `repeat-x` or `no-repeat`.\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    textureLine: function (line, image, repeat) {\n\n        if (repeat === undefined) { repeat = 'repeat-x'; }\n\n        if (typeof image === 'string')\n        {\n            image = this.game.cache.getImage(image);\n\n            if (!image)\n            {\n                return;\n            }\n        }\n\n        var width = line.length;\n\n        if (repeat === 'no-repeat' && width > image.width)\n        {\n            width = image.width;\n        }\n\n        var ctx = this.context;\n\n        ctx.fillStyle = ctx.createPattern(image, repeat);\n\n        this._circle = new Phaser.Circle(line.start.x, line.start.y, image.height);\n\n        this._circle.circumferencePoint(line.angle - 1.5707963267948966, false, this._pos);\n\n        ctx.save();\n        ctx.translate(this._pos.x, this._pos.y);\n        ctx.rotate(line.angle);\n        ctx.fillRect(0, 0, width, image.height);\n        ctx.restore();\n\n        this.dirty = true;\n\n        return this;\n\n    },\n\n    /**\n    * If the game is running in WebGL this will push the texture up to the GPU if it's dirty.\n    * This is called automatically if the BitmapData is being used by a Sprite, otherwise you need to remember to call it in your render function.\n    * If you wish to suppress this functionality set BitmapData.disableTextureUpload to `true`.\n    *\n    * @method Phaser.BitmapData#render\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    render: function () {\n\n        if (!this.disableTextureUpload && this.dirty)\n        {\n            this.baseTexture.dirty();\n            this.dirty = false;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Destroys this BitmapData and puts the canvas it was using back into the canvas pool for re-use.\n    *\n    * @method Phaser.BitmapData#destroy\n    */\n    destroy: function () {\n\n        this.frameData.destroy();\n\n        this.texture.destroy(true);\n\n        PIXI.CanvasPool.remove(this);\n\n    },\n\n    /**\n    * Resets the blend mode (effectively sets it to 'source-over')\n    *\n    * @method Phaser.BitmapData#blendReset\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendReset: function () {\n\n        this.op = 'source-over';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'source-over'\n    *\n    * @method Phaser.BitmapData#blendSourceOver\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendSourceOver: function () {\n\n        this.op = 'source-over';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'source-in'\n    *\n    * @method Phaser.BitmapData#blendSourceIn\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendSourceIn: function () {\n\n        this.op = 'source-in';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'source-out'\n    *\n    * @method Phaser.BitmapData#blendSourceOut\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendSourceOut: function () {\n\n        this.op = 'source-out';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'source-atop'\n    *\n    * @method Phaser.BitmapData#blendSourceAtop\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendSourceAtop: function () {\n\n        this.op = 'source-atop';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'destination-over'\n    *\n    * @method Phaser.BitmapData#blendDestinationOver\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendDestinationOver: function () {\n\n        this.op = 'destination-over';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'destination-in'\n    *\n    * @method Phaser.BitmapData#blendDestinationIn\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendDestinationIn: function () {\n\n        this.op = 'destination-in';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'destination-out'\n    *\n    * @method Phaser.BitmapData#blendDestinationOut\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendDestinationOut: function () {\n\n        this.op = 'destination-out';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'destination-atop'\n    *\n    * @method Phaser.BitmapData#blendDestinationAtop\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendDestinationAtop: function () {\n\n        this.op = 'destination-atop';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'xor'\n    *\n    * @method Phaser.BitmapData#blendXor\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendXor: function () {\n\n        this.op = 'xor';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'lighter'\n    *\n    * @method Phaser.BitmapData#blendAdd\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendAdd: function () {\n\n        this.op = 'lighter';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'multiply'\n    *\n    * @method Phaser.BitmapData#blendMultiply\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendMultiply: function () {\n\n        this.op = 'multiply';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'screen'\n    *\n    * @method Phaser.BitmapData#blendScreen\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendScreen: function () {\n\n        this.op = 'screen';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'overlay'\n    *\n    * @method Phaser.BitmapData#blendOverlay\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendOverlay: function () {\n\n        this.op = 'overlay';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'darken'\n    *\n    * @method Phaser.BitmapData#blendDarken\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendDarken: function () {\n\n        this.op = 'darken';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'lighten'\n    *\n    * @method Phaser.BitmapData#blendLighten\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendLighten: function () {\n\n        this.op = 'lighten';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'color-dodge'\n    *\n    * @method Phaser.BitmapData#blendColorDodge\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendColorDodge: function () {\n\n        this.op = 'color-dodge';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'color-burn'\n    *\n    * @method Phaser.BitmapData#blendColorBurn\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendColorBurn: function () {\n\n        this.op = 'color-burn';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'hard-light'\n    *\n    * @method Phaser.BitmapData#blendHardLight\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendHardLight: function () {\n\n        this.op = 'hard-light';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'soft-light'\n    *\n    * @method Phaser.BitmapData#blendSoftLight\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendSoftLight: function () {\n\n        this.op = 'soft-light';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'difference'\n    *\n    * @method Phaser.BitmapData#blendDifference\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendDifference: function () {\n\n        this.op = 'difference';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'exclusion'\n    *\n    * @method Phaser.BitmapData#blendExclusion\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendExclusion: function () {\n\n        this.op = 'exclusion';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'hue'\n    *\n    * @method Phaser.BitmapData#blendHue\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendHue: function () {\n\n        this.op = 'hue';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'saturation'\n    *\n    * @method Phaser.BitmapData#blendSaturation\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendSaturation: function () {\n\n        this.op = 'saturation';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'color'\n    *\n    * @method Phaser.BitmapData#blendColor\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendColor: function () {\n\n        this.op = 'color';\n        return this;\n\n    },\n\n    /**\n    * Sets the blend mode to 'luminosity'\n    *\n    * @method Phaser.BitmapData#blendLuminosity\n    * @return {Phaser.BitmapData} This BitmapData object for method chaining.\n    */\n    blendLuminosity: function () {\n\n        this.op = 'luminosity';\n        return this;\n\n    }\n\n};\n\n/**\n* @memberof Phaser.BitmapData\n* @property {boolean} smoothed - Gets or sets this BitmapData.contexts smoothing enabled value.\n*/\nObject.defineProperty(Phaser.BitmapData.prototype, \"smoothed\", {\n\n    get: function () {\n\n        Phaser.Canvas.getSmoothingEnabled(this.context);\n\n    },\n\n    set: function (value) {\n\n        Phaser.Canvas.setSmoothingEnabled(this.context, value);\n\n    }\n\n});\n\n/**\n* @memberof Phaser.BitmapData\n* @property {string} op - A short-hand code to get or set the global composite operation of the BitmapDatas canvas.\n*/\nObject.defineProperty(Phaser.BitmapData.prototype, \"op\", {\n\n    get: function () {\n\n        return this.context.globalCompositeOperation;\n\n    },\n\n    set: function (value) {\n\n        this.context.globalCompositeOperation = value;\n\n    }\n\n});\n\n/**\n * Gets a JavaScript object that has 6 properties set that are used by BitmapData in a transform.\n *\n * @method Phaser.BitmapData.getTransform\n * @param {number} translateX - The x translate value.\n * @param {number} translateY - The y translate value.\n * @param {number} scaleX - The scale x value.\n * @param {number} scaleY - The scale y value.\n * @param {number} skewX - The skew x value.\n * @param {number} skewY - The skew y value.\n * @return {object} A JavaScript object containing all of the properties BitmapData needs for transforms.\n */\nPhaser.BitmapData.getTransform = function (translateX, translateY, scaleX, scaleY, skewX, skewY) {\n\n    if (typeof translateX !== 'number') { translateX = 0; }\n    if (typeof translateY !== 'number') { translateY = 0; }\n    if (typeof scaleX !== 'number') { scaleX = 1; }\n    if (typeof scaleY !== 'number') { scaleY = 1; }\n    if (typeof skewX !== 'number') { skewX = 0; }\n    if (typeof skewY !== 'number') { skewY = 0; }\n\n    return { sx: scaleX, sy: scaleY, scaleX: scaleX, scaleY: scaleY, skewX: skewX, skewY: skewY, translateX: translateX, translateY: translateY, tx: translateX, ty: translateY };\n\n};\n\nPhaser.BitmapData.prototype.constructor = Phaser.BitmapData;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and rectangles to the display, and color and fill them.\n * \n * @class Graphics\n * @extends DisplayObjectContainer\n * @constructor\n */\nPIXI.Graphics = function()\n{\n    PIXI.DisplayObjectContainer.call(this);\n\n    this.renderable = true;\n\n    /**\n     * The alpha value used when filling the Graphics object.\n     *\n     * @property fillAlpha\n     * @type Number\n     */\n    this.fillAlpha = 1;\n\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @property lineWidth\n     * @type Number\n     */\n    this.lineWidth = 0;\n\n    /**\n     * The color of any lines drawn.\n     *\n     * @property lineColor\n     * @type String\n     * @default 0\n     */\n    this.lineColor = 0;\n\n    /**\n     * Graphics data\n     *\n     * @property graphicsData\n     * @type Array\n     * @private\n     */\n    this.graphicsData = [];\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of PIXI.blendModes.NORMAL to reset the blend mode.\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n    \n    /**\n     * Current path\n     *\n     * @property currentPath\n     * @type Object\n     * @private\n     */\n    this.currentPath = null;\n    \n    /**\n     * Array containing some WebGL-related properties used by the WebGL renderer.\n     *\n     * @property _webGL\n     * @type Array\n     * @private\n     */\n    this._webGL = [];\n\n    /**\n     * Whether this shape is being used as a mask.\n     *\n     * @property isMask\n     * @type Boolean\n     */\n    this.isMask = false;\n\n    /**\n     * The bounds' padding used for bounds calculation.\n     *\n     * @property boundsPadding\n     * @type Number\n     */\n    this.boundsPadding = 0;\n\n    this._localBounds = new PIXI.Rectangle(0,0,1,1);\n\n    /**\n     * Used to detect if the graphics object has changed. If this is set to true then the graphics object will be recalculated.\n     * \n     * @property dirty\n     * @type Boolean\n     * @private\n     */\n    this.dirty = true;\n\n    /**\n     * Used to detect if the bounds have been invalidated, by this Graphics being cleared or drawn to.\n     * If this is set to true then the updateLocalBounds is called once in the postUpdate method.\n     * \n     * @property _boundsDirty\n     * @type Boolean\n     * @private\n     */\n    this._boundsDirty = false;\n\n    /**\n     * Used to detect if the webgl graphics object has changed. If this is set to true then the graphics object will be recalculated.\n     * \n     * @property webGLDirty\n     * @type Boolean\n     * @private\n     */\n    this.webGLDirty = false;\n\n    /**\n     * Used to detect if the cached sprite object needs to be updated.\n     * \n     * @property cachedSpriteDirty\n     * @type Boolean\n     * @private\n     */\n    this.cachedSpriteDirty = false;\n\n};\n\n// constructor\nPIXI.Graphics.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Graphics.prototype.constructor = PIXI.Graphics;\n\n/**\n * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @method lineStyle\n * @param lineWidth {Number} width of the line to draw, will update the objects stored style\n * @param color {Number} color of the line to draw, will update the objects stored style\n * @param alpha {Number} alpha of the line to draw, will update the objects stored style\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha)\n{\n    this.lineWidth = lineWidth || 0;\n    this.lineColor = color || 0;\n    this.lineAlpha = (alpha === undefined) ? 1 : alpha;\n\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length)\n        {\n            // halfway through a line? start a new one!\n            this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2)));\n        }\n        else\n        {\n            // otherwise its empty so lets just set the line properties\n            this.currentPath.lineWidth = this.lineWidth;\n            this.currentPath.lineColor = this.lineColor;\n            this.currentPath.lineAlpha = this.lineAlpha;\n        }\n    }\n\n    return this;\n};\n\n/**\n * Moves the current drawing position to x, y.\n *\n * @method moveTo\n * @param x {Number} the X coordinate to move to\n * @param y {Number} the Y coordinate to move to\n * @return {Graphics}\n  */\nPIXI.Graphics.prototype.moveTo = function(x, y)\n{\n    this.drawShape(new PIXI.Polygon([x, y]));\n\n    return this;\n};\n\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * The current drawing position is then set to (x, y).\n *\n * @method lineTo\n * @param x {Number} the X coordinate to draw to\n * @param y {Number} the Y coordinate to draw to\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.lineTo = function(x, y)\n{\n    if (!this.currentPath)\n    {\n        this.moveTo(0, 0);\n    }\n\n    this.currentPath.shape.points.push(x, y);\n    this.dirty = true;\n    this._boundsDirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a quadratic bezier curve and then draws it.\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @method quadraticCurveTo\n * @param cpX {Number} Control point x\n * @param cpY {Number} Control point y\n * @param toX {Number} Destination point x\n * @param toY {Number} Destination point y\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points = [0, 0];\n        }\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var xa,\n        ya,\n        n = 20,\n        points = this.currentPath.shape.points;\n\n    if (points.length === 0)\n    {\n        this.moveTo(0, 0);\n    }\n\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var j = 0;\n    for (var i = 1; i <= n; ++i)\n    {\n        j = i / n;\n\n        xa = fromX + ( (cpX - fromX) * j );\n        ya = fromY + ( (cpY - fromY) * j );\n\n        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),\n                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );\n    }\n\n    this.dirty = true;\n    this._boundsDirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * @method bezierCurveTo\n * @param cpX {Number} Control point x\n * @param cpY {Number} Control point y\n * @param cpX2 {Number} Second Control point x\n * @param cpY2 {Number} Second Control point y\n * @param toX {Number} Destination point x\n * @param toY {Number} Destination point y\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points = [0, 0];\n        }\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var n = 20,\n        dt,\n        dt2,\n        dt3,\n        t2,\n        t3,\n        points = this.currentPath.shape.points;\n\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n    var j = 0;\n\n    for (var i = 1; i <= n; ++i)\n    {\n        j = i / n;\n\n        dt = (1 - j);\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n\n        t2 = j * j;\n        t3 = t2 * j;\n        \n        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,\n                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n    \n    this.dirty = true;\n    this._boundsDirty = true;\n\n    return this;\n};\n\n/*\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n * \n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n *\n * @method arcTo\n * @param x1 {Number} The x-coordinate of the beginning of the arc\n * @param y1 {Number} The y-coordinate of the beginning of the arc\n * @param x2 {Number} The x-coordinate of the end of the arc\n * @param y2 {Number} The y-coordinate of the end of the arc\n * @param radius {Number} The radius of the arc\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points.push(x1, y1);\n        }\n    }\n    else\n    {\n        this.moveTo(x1, y1);\n    }\n\n    var points = this.currentPath.shape.points,\n        fromX = points[points.length-2],\n        fromY = points[points.length-1],\n        a1 = fromY - y1,\n        b1 = fromX - x1,\n        a2 = y2   - y1,\n        b2 = x2   - x1,\n        mm = Math.abs(a1 * b2 - b1 * a2);\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length-2] !== x1 || points[points.length-1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n    }\n    else\n    {\n        var dd = a1 * a1 + b1 * b1,\n            cc = a2 * a2 + b2 * b2,\n            tt = a1 * a2 + b1 * b2,\n            k1 = radius * Math.sqrt(dd) / mm,\n            k2 = radius * Math.sqrt(cc) / mm,\n            j1 = k1 * tt / dd,\n            j2 = k2 * tt / cc,\n            cx = k1 * b2 + k2 * b1,\n            cy = k1 * a2 + k2 * a1,\n            px = b1 * (k2 + j1),\n            py = a1 * (k2 + j1),\n            qx = b2 * (k1 + j2),\n            qy = a2 * (k1 + j2),\n            startAngle = Math.atan2(py - cy, px - cx),\n            endAngle   = Math.atan2(qy - cy, qx - cx);\n\n        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n    }\n\n    this.dirty = true;\n    this._boundsDirty = true;\n\n    return this;\n};\n\n/**\n * The arc method creates an arc/curve (used to create circles, or parts of circles).\n *\n * @method arc\n * @param cx {Number} The x-coordinate of the center of the circle\n * @param cy {Number} The y-coordinate of the center of the circle\n * @param radius {Number} The radius of the circle\n * @param startAngle {Number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)\n * @param endAngle {Number} The ending angle, in radians\n * @param anticlockwise {Boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.\n * @param segments {Number} Optional. The number of segments to use when calculating the arc. The default is 40. If you need more fidelity use a higher number.\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise, segments)\n{\n    //  If we do this we can never draw a full circle\n    if (startAngle === endAngle)\n    {\n        return this;\n    }\n\n    if (anticlockwise === undefined) { anticlockwise = false; }\n    if (segments === undefined) { segments = 40; }\n\n    if (!anticlockwise && endAngle <= startAngle)\n    {\n        endAngle += Math.PI * 2;\n    }\n    else if (anticlockwise && startAngle <= endAngle)\n    {\n        startAngle += Math.PI * 2;\n    }\n\n    var sweep = anticlockwise ? (startAngle - endAngle) * -1 : (endAngle - startAngle);\n    var segs =  Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * segments;\n\n    //  Sweep check - moved here because we don't want to do the moveTo below if the arc fails\n    if (sweep === 0)\n    {\n        return this;\n    }\n\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n\n    if (anticlockwise && this.filling)\n    {\n        this.moveTo(cx, cy);\n    }\n    else\n    {\n        this.moveTo(startX, startY);\n    }\n\n    //  currentPath will always exist after calling a moveTo\n    var points = this.currentPath.shape.points;\n\n    var theta = sweep / (segs * 2);\n    var theta2 = theta * 2;\n\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n    \n    var segMinus = segs - 1;\n\n    var remainder = (segMinus % 1) / segMinus;\n\n    for (var i = 0; i <= segMinus; i++)\n    {\n        var real =  i + remainder * i;\n    \n        var angle = ((theta) + startAngle + (theta2 * real));\n\n        var c = Math.cos(angle);\n        var s = -Math.sin(angle);\n\n        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,\n                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);\n    }\n\n    this.dirty = true;\n    this._boundsDirty = true;\n\n    return this;\n};\n\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @method beginFill\n * @param color {Number} the color of the fill\n * @param alpha {Number} the alpha of the fill\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.beginFill = function(color, alpha)\n{\n    this.filling = true;\n    this.fillColor = color || 0;\n    this.fillAlpha = (alpha === undefined) ? 1 : alpha;\n\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length <= 2)\n        {\n            this.currentPath.fill = this.filling;\n            this.currentPath.fillColor = this.fillColor;\n            this.currentPath.fillAlpha = this.fillAlpha;\n        }\n    }\n\n    return this;\n};\n\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @method endFill\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.endFill = function()\n{\n    this.filling = false;\n    this.fillColor = null;\n    this.fillAlpha = 1;\n\n    return this;\n};\n\n/**\n * @method drawRect\n *\n * @param x {Number} The X coord of the top-left of the rectangle\n * @param y {Number} The Y coord of the top-left of the rectangle\n * @param width {Number} The width of the rectangle\n * @param height {Number} The height of the rectangle\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.drawRect = function(x, y, width, height)\n{\n    this.drawShape(new PIXI.Rectangle(x, y, width, height));\n\n    return this;\n};\n\n/**\n * @method drawRoundedRect\n * @param x {Number} The X coord of the top-left of the rectangle\n * @param y {Number} The Y coord of the top-left of the rectangle\n * @param width {Number} The width of the rectangle\n * @param height {Number} The height of the rectangle\n * @param radius {Number} Radius of the rectangle corners. In WebGL this must be a value between 0 and 9.\n */\nPIXI.Graphics.prototype.drawRoundedRect = function(x, y, width, height, radius)\n{\n    this.drawShape(new PIXI.RoundedRectangle(x, y, width, height, radius));\n\n    return this;\n};\n\n/**\n * Draws a circle.\n *\n * @method drawCircle\n * @param x {Number} The X coordinate of the center of the circle\n * @param y {Number} The Y coordinate of the center of the circle\n * @param diameter {Number} The diameter of the circle\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.drawCircle = function(x, y, diameter)\n{\n    this.drawShape(new PIXI.Circle(x, y, diameter));\n\n    return this;\n};\n\n/**\n * Draws an ellipse.\n *\n * @method drawEllipse\n * @param x {Number} The X coordinate of the center of the ellipse\n * @param y {Number} The Y coordinate of the center of the ellipse\n * @param width {Number} The half width of the ellipse\n * @param height {Number} The half height of the ellipse\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.drawEllipse = function(x, y, width, height)\n{\n    this.drawShape(new PIXI.Ellipse(x, y, width, height));\n\n    return this;\n};\n\n/**\n * Draws a polygon using the given path.\n *\n * @method drawPolygon\n * @param path {Array|Phaser.Polygon} The path data used to construct the polygon. Can either be an array of points or a Phaser.Polygon object.\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.drawPolygon = function(path)\n{\n    if (path instanceof Phaser.Polygon || path instanceof PIXI.Polygon)\n    {\n        path = path.points;\n    }\n\n    // prevents an argument assignment deopt\n    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    var points = path;\n\n    if (!Array.isArray(points))\n    {\n        // prevents an argument leak deopt\n        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        points = new Array(arguments.length);\n\n        for (var i = 0; i < points.length; ++i)\n        {\n            points[i] = arguments[i];\n        }\n    }\n\n    this.drawShape(new Phaser.Polygon(points));\n\n    return this;\n};\n\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @method clear\n * @return {Graphics}\n */\nPIXI.Graphics.prototype.clear = function()\n{\n    this.lineWidth = 0;\n    this.filling = false;\n\n    this.dirty = true;\n    this._boundsDirty = true;\n    this.clearDirty = true;\n    this.graphicsData = [];\n\n    this.updateLocalBounds();\n\n    return this;\n};\n\n/**\n * Useful function that returns a texture of the graphics object that can then be used to create sprites\n * This can be quite useful if your geometry is complicated and needs to be reused multiple times.\n *\n * @method generateTexture\n * @param [resolution=1] {Number} The resolution of the texture being generated\n * @param [scaleMode=0] {Number} Should be one of the PIXI.scaleMode consts\n * @param [padding=0] {Number} Add optional extra padding to the generated texture (default 0)\n * @return {Texture} a texture of the graphics object\n */\nPIXI.Graphics.prototype.generateTexture = function(resolution, scaleMode, padding)\n{\n    if (resolution === undefined) { resolution = 1; }\n    if (scaleMode === undefined) { scaleMode = PIXI.scaleModes.DEFAULT; }\n    if (padding === undefined) { padding = 0; }\n\n    var bounds = this.getBounds();\n\n    bounds.width += padding;\n    bounds.height += padding;\n   \n    var canvasBuffer = new PIXI.CanvasBuffer(bounds.width * resolution, bounds.height * resolution);\n    \n    var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas, scaleMode);\n\n    texture.baseTexture.resolution = resolution;\n\n    canvasBuffer.context.scale(resolution, resolution);\n\n    canvasBuffer.context.translate(-bounds.x, -bounds.y);\n\n    PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);\n\n    return texture;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Graphics.prototype._renderWebGL = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if (this.visible === false || this.alpha === 0 || this.isMask === true) return;\n\n    if (this._cacheAsBitmap)\n    {\n        if (this.dirty || this.cachedSpriteDirty)\n        {\n            this._generateCachedSprite();\n   \n            // we will also need to update the texture on the gpu too!\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.worldAlpha = this.worldAlpha;\n\n        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);\n\n        return;\n    }\n    else\n    {\n        renderSession.spriteBatch.stop();\n        renderSession.blendModeManager.setBlendMode(this.blendMode);\n\n        if (this._mask) renderSession.maskManager.pushMask(this._mask, renderSession);\n        if (this._filters) renderSession.filterManager.pushFilter(this._filterBlock);\n      \n        // check blend mode\n        if (this.blendMode !== renderSession.spriteBatch.currentBlendMode)\n        {\n            renderSession.spriteBatch.currentBlendMode = this.blendMode;\n            var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];\n            renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n        }\n        \n        // check if the webgl graphic needs to be updated\n        if (this.webGLDirty)\n        {\n            this.dirty = true;\n            this.webGLDirty = false;\n        }\n        \n        PIXI.WebGLGraphics.renderGraphics(this, renderSession);\n        \n        // only render if it has children!\n        if (this.children.length)\n        {\n            renderSession.spriteBatch.start();\n\n            // simple render children!\n            for (var i = 0; i < this.children.length; i++)\n            {\n                this.children[i]._renderWebGL(renderSession);\n            }\n\n            renderSession.spriteBatch.stop();\n        }\n\n        if (this._filters) renderSession.filterManager.popFilter();\n        if (this._mask) renderSession.maskManager.popMask(this.mask, renderSession);\n          \n        renderSession.drawCount++;\n\n        renderSession.spriteBatch.start();\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Graphics.prototype._renderCanvas = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if (this.visible === false || this.alpha === 0 || this.isMask === true) return;\n\n    // if the tint has changed, set the graphics object to dirty.\n    if (this._prevTint !== this.tint) {\n        this.dirty = true;\n        this._prevTint = this.tint;\n    }\n\n    if (this._cacheAsBitmap)\n    {\n        if (this.dirty || this.cachedSpriteDirty)\n        {\n            this._generateCachedSprite();\n   \n            // we will also need to update the texture\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.alpha = this.alpha;\n\n        PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);\n\n        return;\n    }\n    else\n    {\n        var context = renderSession.context;\n        var transform = this.worldTransform;\n        \n        if (this.blendMode !== renderSession.currentBlendMode)\n        {\n            renderSession.currentBlendMode = this.blendMode;\n            context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n        }\n\n        if (this._mask)\n        {\n            renderSession.maskManager.pushMask(this._mask, renderSession);\n        }\n\n        var resolution = renderSession.resolution;\n        var tx = (transform.tx * renderSession.resolution) + renderSession.shakeX;\n        var ty = (transform.ty * renderSession.resolution) + renderSession.shakeY;\n\n        context.setTransform(transform.a * resolution,\n                             transform.b * resolution,\n                             transform.c * resolution,\n                             transform.d * resolution,\n                             tx,\n                             ty);\n\n        PIXI.CanvasGraphics.renderGraphics(this, context);\n\n         // simple render children!\n        for (var i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderCanvas(renderSession);\n        }\n\n        if (this._mask)\n        {\n            renderSession.maskManager.popMask(renderSession);\n        }\n    }\n};\n\n/**\n * Retrieves the bounds of the graphic shape as a rectangle object\n *\n * @method getBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.Graphics.prototype.getBounds = function(matrix)\n{\n    if (!this._currentBounds)\n    {\n        //  Return an empty object if the item is a mask!\n        if (!this.renderable)\n        {\n            return PIXI.EmptyRectangle;\n        }\n\n        if (this.dirty)\n        {\n            this.updateLocalBounds();\n            this.webGLDirty = true;\n            this.cachedSpriteDirty = true;\n            this.dirty = false;\n        }\n\n        var bounds = this._localBounds;\n\n        var w0 = bounds.x;\n        var w1 = bounds.width + bounds.x;\n\n        var h0 = bounds.y;\n        var h1 = bounds.height + bounds.y;\n\n        var worldTransform = matrix || this.worldTransform;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var x1 = a * w1 + c * h1 + tx;\n        var y1 = d * h1 + b * w1 + ty;\n\n        var x2 = a * w0 + c * h1 + tx;\n        var y2 = d * h1 + b * w0 + ty;\n\n        var x3 = a * w0 + c * h0 + tx;\n        var y3 = d * h0 + b * w0 + ty;\n\n        var x4 =  a * w1 + c * h0 + tx;\n        var y4 =  d * h0 + b * w1 + ty;\n\n        var maxX = x1;\n        var maxY = y1;\n\n        var minX = x1;\n        var minY = y1;\n\n        minX = x2 < minX ? x2 : minX;\n        minX = x3 < minX ? x3 : minX;\n        minX = x4 < minX ? x4 : minX;\n\n        minY = y2 < minY ? y2 : minY;\n        minY = y3 < minY ? y3 : minY;\n        minY = y4 < minY ? y4 : minY;\n\n        maxX = x2 > maxX ? x2 : maxX;\n        maxX = x3 > maxX ? x3 : maxX;\n        maxX = x4 > maxX ? x4 : maxX;\n\n        maxY = y2 > maxY ? y2 : maxY;\n        maxY = y3 > maxY ? y3 : maxY;\n        maxY = y4 > maxY ? y4 : maxY;\n\n        this._bounds.x = minX;\n        this._bounds.width = maxX - minX;\n\n        this._bounds.y = minY;\n        this._bounds.height = maxY - minY;\n\n        this._currentBounds = this._bounds;\n    }\n\n    return this._currentBounds;\n\n};\n\n/**\n * Retrieves the non-global local bounds of the graphic shape as a rectangle. The calculation takes all visible children into consideration.\n *\n * @method getLocalBounds\n * @return {Rectangle} The rectangular bounding area\n */\nPIXI.Graphics.prototype.getLocalBounds = function () {\n    var matrixCache = this.worldTransform;\n\n    this.worldTransform = PIXI.identityMatrix;\n\n    for (var i = 0; i < this.children.length; i++) {\n        this.children[i].updateTransform();\n    }\n\n    var bounds = this.getBounds();\n\n    this.worldTransform = matrixCache;\n\n    for (i = 0; i < this.children.length; i++) {\n        this.children[i].updateTransform();\n    }\n\n    return bounds;\n};\n\n/**\n* Tests if a point is inside this graphics object\n*\n* @param point {Point} the point to test\n* @return {boolean} the result of the test\n*/\nPIXI.Graphics.prototype.containsPoint = function( point )\n{\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var graphicsData = this.graphicsData;\n\n    for (var i = 0; i < graphicsData.length; i++)\n    {\n        var data = graphicsData[i];\n\n        if (!data.fill)\n        {\n            continue;\n        }\n\n        // only deal with fills..\n        if (data.shape)\n        {\n            if (data.shape.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n\n};\n\n/**\n * Update the bounds of the object\n *\n * @method updateLocalBounds\n */\nPIXI.Graphics.prototype.updateLocalBounds = function()\n{\n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    if (this.graphicsData.length)\n    {\n        var shape, points, x, y, w, h;\n\n        for (var i = 0; i < this.graphicsData.length; i++)\n        {\n            var data = this.graphicsData[i];\n            var type = data.type;\n            var lineWidth = data.lineWidth;\n            shape = data.shape;\n\n            if (type === PIXI.Graphics.RECT || type === PIXI.Graphics.RREC)\n            {\n                x = shape.x - lineWidth / 2;\n                y = shape.y - lineWidth / 2;\n                w = shape.width + lineWidth;\n                h = shape.height + lineWidth;\n\n                minX = x < minX ? x : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y < minY ? y : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if (type === PIXI.Graphics.CIRC)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.radius + lineWidth / 2;\n                h = shape.radius + lineWidth / 2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if (type === PIXI.Graphics.ELIP)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.width + lineWidth / 2;\n                h = shape.height + lineWidth / 2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else\n            {\n                // POLY - assumes points are sequential, not Point objects\n                points = shape.points;\n\n                for (var j = 0; j < points.length; j++)\n                {\n                    if (points[j] instanceof Phaser.Point)\n                    {\n                        x = points[j].x;\n                        y = points[j].y;\n                    }\n                    else\n                    {\n                        x = points[j];\n                        y = points[j + 1];\n\n                        if (j < points.length - 1)\n                        {\n                            j++;\n                        }\n                    }\n\n                    minX = x - lineWidth < minX ? x - lineWidth : minX;\n                    maxX = x + lineWidth > maxX ? x + lineWidth : maxX;\n\n                    minY = y - lineWidth < minY ? y - lineWidth : minY;\n                    maxY = y + lineWidth > maxY ? y + lineWidth : maxY;\n                }\n            }\n        }\n    }\n    else\n    {\n        minX = 0;\n        maxX = 0;\n        minY = 0;\n        maxY = 0;\n    }\n\n    var padding = this.boundsPadding;\n    \n    this._localBounds.x = minX - padding;\n    this._localBounds.width = (maxX - minX) + padding * 2;\n\n    this._localBounds.y = minY - padding;\n    this._localBounds.height = (maxY - minY) + padding * 2;\n};\n\n/**\n * Generates the cached sprite when the sprite has cacheAsBitmap = true\n *\n * @method _generateCachedSprite\n * @private\n */\nPIXI.Graphics.prototype._generateCachedSprite = function()\n{\n    var bounds = this.getLocalBounds();\n\n    if (!this._cachedSprite)\n    {\n        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);\n        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);\n        \n        this._cachedSprite = new PIXI.Sprite(texture);\n        this._cachedSprite.buffer = canvasBuffer;\n\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.buffer.resize(bounds.width, bounds.height);\n    }\n\n    // leverage the anchor to account for the offset of the element\n    this._cachedSprite.anchor.x = -(bounds.x / bounds.width);\n    this._cachedSprite.anchor.y = -(bounds.y / bounds.height);\n\n    // this._cachedSprite.buffer.context.save();\n    this._cachedSprite.buffer.context.translate(-bounds.x, -bounds.y);\n    \n    // make sure we set the alpha of the graphics to 1 for the render.. \n    this.worldAlpha = 1;\n\n    // now render the graphic..\n    PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);\n    this._cachedSprite.alpha = this.alpha;\n};\n\n/**\n * Updates texture size based on canvas size\n *\n * @method updateCachedSpriteTexture\n * @private\n */\nPIXI.Graphics.prototype.updateCachedSpriteTexture = function()\n{\n    var cachedSprite = this._cachedSprite;\n    var texture = cachedSprite.texture;\n    var canvas = cachedSprite.buffer.canvas;\n\n    texture.baseTexture.width = canvas.width;\n    texture.baseTexture.height = canvas.height;\n    texture.crop.width = texture.frame.width = canvas.width;\n    texture.crop.height = texture.frame.height = canvas.height;\n\n    cachedSprite._width = canvas.width;\n    cachedSprite._height = canvas.height;\n\n    // update the dirty base textures\n    texture.baseTexture.dirty();\n};\n\n/**\n * Destroys a previous cached sprite.\n *\n * @method destroyCachedSprite\n */\nPIXI.Graphics.prototype.destroyCachedSprite = function()\n{\n    this._cachedSprite.texture.destroy(true);\n    this._cachedSprite = null;\n};\n\n/**\n * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n *\n * @method drawShape\n * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.\n * @return {GraphicsData} The generated GraphicsData object.\n */\nPIXI.Graphics.prototype.drawShape = function(shape)\n{\n    if (this.currentPath)\n    {\n        // check current path!\n        if (this.currentPath.shape.points.length <= 2)\n        {\n            this.graphicsData.pop();\n        }\n    }\n\n    this.currentPath = null;\n\n    //  Handle mixed-type polygons\n    if (shape instanceof Phaser.Polygon)\n    {\n        shape = shape.clone();\n        shape.flatten();\n    }\n\n    var data = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);\n    \n    this.graphicsData.push(data);\n\n    if (data.type === PIXI.Graphics.POLY)\n    {\n        data.shape.closed = this.filling;\n        this.currentPath = data;\n    }\n\n    this.dirty = true;\n    this._boundsDirty = true;\n\n    return data;\n\n};\n\n/**\n * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n * This is useful if your graphics element does not change often, as it will speed up the rendering of the object in exchange for taking up texture memory.\n * It is also useful if you need the graphics object to be anti-aliased, because it will be rendered using canvas.\n * This is not recommended if you are constantly redrawing the graphics element.\n *\n * @property cacheAsBitmap\n * @type Boolean\n * @default false\n * @private\n */\nObject.defineProperty(PIXI.Graphics.prototype, \"cacheAsBitmap\", {\n\n    get: function() {\n        return  this._cacheAsBitmap;\n    },\n\n    set: function(value) {\n\n        this._cacheAsBitmap = value;\n\n        if (this._cacheAsBitmap)\n        {\n            this._generateCachedSprite();\n        }\n        else\n        {\n            this.destroyCachedSprite();\n        }\n\n        this.dirty = true;\n        this.webGLDirty = true;\n\n    }\n});\n\n/**\n * A GraphicsData object.\n * \n * @class GraphicsData\n * @constructor\nPIXI.GraphicsData = function(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape)\n{\n    this.lineWidth = lineWidth;\n    this.lineColor = lineColor;\n    this.lineAlpha = lineAlpha;\n    this._lineTint = lineColor;\n\n    this.fillColor = fillColor;\n    this.fillAlpha = fillAlpha;\n    this._fillTint = fillColor;\n    this.fill = fill;\n\n    this.shape = shape;\n    this.type = shape.type;\n};\n */\n\n/**\n * A GraphicsData object.\n *\n * @class\n * @memberof PIXI\n * @param lineWidth {number} the width of the line to draw\n * @param lineColor {number} the color of the line to draw\n * @param lineAlpha {number} the alpha of the line to draw\n * @param fillColor {number} the color of the fill\n * @param fillAlpha {number} the alpha of the fill\n * @param fill      {boolean} whether or not the shape is filled with a colour\n * @param shape     {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.\n */\n\nPIXI.GraphicsData = function(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape) {\n\n    /*\n     * @member {number} the width of the line to draw\n     */\n    this.lineWidth = lineWidth;\n\n    /*\n     * @member {number} the color of the line to draw\n     */\n    this.lineColor = lineColor;\n\n    /*\n     * @member {number} the alpha of the line to draw\n     */\n    this.lineAlpha = lineAlpha;\n\n    /*\n     * @member {number} cached tint of the line to draw\n     */\n    this._lineTint = lineColor;\n\n    /*\n     * @member {number} the color of the fill\n     */\n    this.fillColor = fillColor;\n\n    /*\n     * @member {number} the alpha of the fill\n     */\n    this.fillAlpha = fillAlpha;\n\n    /*\n     * @member {number} cached tint of the fill\n     */\n    this._fillTint = fillColor;\n\n    /*\n     * @member {boolean} whether or not the shape is filled with a color\n     */\n    this.fill = fill;\n\n    /*\n     * @member {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.\n     */\n    this.shape = shape;\n\n    /*\n     * @member {number} The type of the shape, see the Const.Shapes file for all the existing types,\n     */\n    this.type = shape.type;\n\n};\n\nPIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData;\n\n/**\n * Creates a new GraphicsData object with the same values as this one.\n *\n * @return {GraphicsData}\n */\nPIXI.GraphicsData.prototype.clone = function() {\n\n    return new GraphicsData(\n        this.lineWidth,\n        this.lineColor,\n        this.lineAlpha,\n        this.fillColor,\n        this.fillAlpha,\n        this.fill,\n        this.shape\n    );\n\n};\n/*\nCopyright (c) 2016, Mapbox\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n\n/**\n* @class EarCut\n*/\nPIXI.EarCut = {};\n\nPIXI.EarCut.Triangulate = function (data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = PIXI.EarCut.linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, size;\n\n    if (hasHoles) outerNode = PIXI.EarCut.eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and size are later used to transform coords into integers for z-order calculation\n        size = Math.max(maxX - minX, maxY - minY);\n    }\n\n    PIXI.EarCut.earcutLinked(outerNode, triangles, dim, minX, minY, size);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\n\nPIXI.EarCut.linkedList = function (data, start, end, dim, clockwise) {\n    var sum = 0,\n        i, j, last;\n\n    // calculate original winding order of a polygon ring\n    for (i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n\n    // link points into circular doubly-linked list in the specified winding order\n    if (clockwise === (sum > 0)) {\n        for (i = start; i < end; i += dim) last = PIXI.EarCut.insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = PIXI.EarCut.insertNode(i, data[i], data[i + 1], last);\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\n\nPIXI.EarCut.filterPoints = function (start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (PIXI.EarCut.equals(p, p.next) || PIXI.EarCut.area(p.prev, p, p.next) === 0)) {\n            PIXI.EarCut.removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) return null;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\n\nPIXI.EarCut.earcutLinked = function (ear, triangles, dim, minX, minY, size, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && size) PIXI.EarCut.indexCurve(ear, minX, minY, size);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (size ? PIXI.EarCut.isEarHashed(ear, minX, minY, size) : PIXI.EarCut.isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            PIXI.EarCut.removeNode(ear);\n\n            // skipping the next vertice leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(ear), triangles, dim, minX, minY, size, 1);\n\n                // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = PIXI.EarCut.cureLocalIntersections(ear, triangles, dim);\n                PIXI.EarCut.earcutLinked(ear, triangles, dim, minX, minY, size, 2);\n\n                // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                PIXI.EarCut.splitEarcut(ear, triangles, dim, minX, minY, size);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\n\nPIXI.EarCut.isEar = function (ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (PIXI.EarCut.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (PIXI.EarCut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            PIXI.EarCut.area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nPIXI.EarCut.isEarHashed = function (ear, minX, minY, size) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (PIXI.EarCut.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = PIXI.EarCut.zOrder(minTX, minTY, minX, minY, size),\n        maxZ = PIXI.EarCut.zOrder(maxTX, maxTY, minX, minY, size);\n\n    // first look for points inside the triangle in increasing z-order\n    var p = ear.nextZ;\n\n    while (p && p.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            PIXI.EarCut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            PIXI.EarCut.area(p.prev, p, p.next) >= 0) return false;\n        p = p.nextZ;\n    }\n\n    // then look for points in decreasing z-order\n    p = ear.prevZ;\n\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            PIXI.EarCut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            PIXI.EarCut.area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\n\nPIXI.EarCut.cureLocalIntersections = function (start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        // a self-intersection where edge (v[i-1],v[i]) intersects (v[i+1],v[i+2])\n        if (PIXI.EarCut.intersects(a, p, p.next, b) && PIXI.EarCut.locallyInside(a, b) && PIXI.EarCut.locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            PIXI.EarCut.removeNode(p);\n            PIXI.EarCut.removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\n\nPIXI.EarCut.splitEarcut = function (start, triangles, dim, minX, minY, size) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && PIXI.EarCut.isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = PIXI.EarCut.splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = PIXI.EarCut.filterPoints(a, a.next);\n                c = PIXI.EarCut.filterPoints(c, c.next);\n\n                // run earcut on each half\n                PIXI.EarCut.earcutLinked(a, triangles, dim, minX, minY, size);\n                PIXI.EarCut.earcutLinked(c, triangles, dim, minX, minY, size);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\n\nPIXI.EarCut.eliminateHoles = function (data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = PIXI.EarCut.linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(PIXI.EarCut.getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        PIXI.EarCut.eliminateHole(queue[i], outerNode);\n        outerNode = PIXI.EarCut.filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nPIXI.EarCut.compareX = function (a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\n\nPIXI.EarCut.eliminateHole = function (hole, outerNode) {\n    outerNode = PIXI.EarCut.findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = PIXI.EarCut.splitPolygon(outerNode, hole);\n        PIXI.EarCut.filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\n\nPIXI.EarCut.findHoleBridge = function (hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hole.x === m.x) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= m.x &&\n            PIXI.EarCut.pointInTriangle(hy < m.y ? hx : qx, hy, m.x, m.y, hy < m.y ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && PIXI.EarCut.locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\n\nPIXI.EarCut.indexCurve = function (start, minX, minY, size) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = PIXI.EarCut.zOrder(p.x, p.y, minX, minY, size);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    PIXI.EarCut.sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\nPIXI.EarCut.sortLinked = function (list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize === 0) {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                } else if (qSize === 0 || !q) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else if (p.z <= q.z) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and size of the data bounding box\n\nPIXI.EarCut.zOrder = function (x, y, minX, minY, size) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) / size;\n    y = 32767 * (y - minY) / size;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\n\nPIXI.EarCut.getLeftmost = function (start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\n\nPIXI.EarCut.pointInTriangle = function (ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\nPIXI.EarCut.isValidDiagonal = function (a, b) {\n    return PIXI.EarCut.equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !PIXI.EarCut.intersectsPolygon(a, b) &&\n        PIXI.EarCut.locallyInside(a, b) && PIXI.EarCut.locallyInside(b, a) && PIXI.EarCut.middleInside(a, b);\n}\n\n// signed area of a triangle\n\nPIXI.EarCut.area = function (p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\n\nPIXI.EarCut.equals = function (p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\n\nPIXI.EarCut.intersects = function (p1, q1, p2, q2) {\n    return PIXI.EarCut.area(p1, q1, p2) > 0 !== PIXI.EarCut.area(p1, q1, q2) > 0 &&\n        PIXI.EarCut.area(p2, q2, p1) > 0 !== PIXI.EarCut.area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\n\nPIXI.EarCut.intersectsPolygon = function (a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n            PIXI.EarCut.intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\n\nPIXI.EarCut.locallyInside = function (a, b) {\n    return PIXI.EarCut.area(a.prev, a, a.next) < 0 ?\n        PIXI.EarCut.area(a, b, a.next) >= 0 && PIXI.EarCut.area(a, a.prev, b) >= 0 :\n        PIXI.EarCut.area(a, b, a.prev) < 0 || PIXI.EarCut.area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\n\nPIXI.EarCut.middleInside = function (a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\nPIXI.EarCut.splitPolygon = function (a, b) {\n    var a2 = new PIXI.EarCut.Node(a.i, a.x, a.y),\n        b2 = new PIXI.EarCut.Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\n\nPIXI.EarCut.insertNode = function (i, x, y, last) {\n    var p = new PIXI.EarCut.Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nPIXI.EarCut.removeNode = function (p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nPIXI.EarCut.Node = function (i, x, y) {\n    // vertice index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertice nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A set of functions used by the webGL renderer to draw the primitive graphics data\n *\n * @class WebGLGraphics\n * @private\n * @static\n */\nPIXI.WebGLGraphics = function()\n{\n};\n\n/**\n * The number of points beyond which Pixi swaps to using the Stencil Buffer to render the Graphics.\n *\n * @type {number}\n */\nPIXI.WebGLGraphics.stencilBufferLimit = 6;\n\n/**\n * Renders the graphics object\n *\n * @static\n * @private\n * @method renderGraphics\n * @param graphics {Graphics}\n * @param renderSession {Object}\n */\nPIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession)//projection, offset)\n{\n    var gl = renderSession.gl;\n    var projection = renderSession.projection,\n        offset = renderSession.offset,\n        shader = renderSession.shaderManager.primitiveShader,\n        webGLData;\n\n    if(graphics.dirty)\n    {\n        PIXI.WebGLGraphics.updateGraphics(graphics, gl);\n    }\n\n    var webGL = graphics._webGL[gl.id];\n\n    // This  could be speeded up for sure!\n\n    for (var i = 0; i < webGL.data.length; i++)\n    {\n        if(webGL.data[i].mode === 1)\n        {\n            webGLData = webGL.data[i];\n\n            renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession);\n\n            // render quad..\n            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );\n            \n            renderSession.stencilManager.popStencil(graphics, webGLData, renderSession);\n        }\n        else\n        {\n            webGLData = webGL.data[i];\n           \n\n            renderSession.shaderManager.setShader( shader );//activatePrimitiveShader();\n            shader = renderSession.shaderManager.primitiveShader;\n            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n            \n            gl.uniform1f(shader.flipY, 1);\n            \n            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));\n\n            gl.uniform1f(shader.alpha, graphics.worldAlpha);\n            \n\n            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);\n            gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\n            // set the index buffer!\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );\n        }\n    }\n};\n\n/**\n * Updates the graphics object\n *\n * @static\n * @private\n * @method updateGraphics\n * @param graphicsData {Graphics} The graphics object to update\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLGraphics.updateGraphics = function(graphics, gl)\n{\n    // get the contexts graphics object\n    var webGL = graphics._webGL[gl.id];\n    // if the graphics object does not exist in the webGL context time to create it!\n    if(!webGL)webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl};\n\n    // flag the graphics as not dirty as we are about to update it...\n    graphics.dirty = false;\n\n    var i;\n\n    // if the user cleared the graphics object we will need to clear every object\n    if(graphics.clearDirty)\n    {\n        graphics.clearDirty = false;\n\n        // lop through and return all the webGLDatas to the object pool so than can be reused later on\n        for (i = 0; i < webGL.data.length; i++)\n        {\n            var graphicsData = webGL.data[i];\n            graphicsData.reset();\n            PIXI.WebGLGraphics.graphicsDataPool.push( graphicsData );\n        }\n\n        // clear the array and reset the index.. \n        webGL.data = [];\n        webGL.lastIndex = 0;\n    }\n    \n    var webGLData;\n    \n    // loop through the graphics datas and construct each one..\n    // if the object is a complex fill then the new stencil buffer technique will be used\n    // other wise graphics objects will be pushed into a batch..\n    for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            // need to add the points the the graphics object..\n            data.points = data.shape.points.slice();\n            if(data.shape.closed)\n            {\n                // close the poly if the value is true!\n                if(data.points[0] !== data.points[data.points.length-2] || data.points[1] !== data.points[data.points.length-1])\n                {\n                    data.points.push(data.points[0], data.points[1]);\n                }\n            }\n\n            // MAKE SURE WE HAVE THE CORRECT TYPE..\n            if(data.fill)\n            {\n                if(data.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)\n                {\n                    if(data.points.length < PIXI.WebGLGraphics.stencilBufferLimit * 2)\n                    {\n                        webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);\n                        \n                        var canDrawUsingSimple = PIXI.WebGLGraphics.buildPoly(data, webGLData);\n                   //     console.log(canDrawUsingSimple);\n\n                        if(!canDrawUsingSimple)\n                        {\n                        //    console.log(\"<>>>\")\n                            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);\n                            PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);\n                        }\n                        \n                    }\n                    else\n                    {\n                        webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);\n                        PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);\n                    }\n                }\n            }\n\n            if(data.lineWidth > 0)\n            {\n                webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);\n                PIXI.WebGLGraphics.buildLine(data, webGLData);\n\n            }\n        }\n        else\n        {\n            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);\n            \n            if(data.type === PIXI.Graphics.RECT)\n            {\n                PIXI.WebGLGraphics.buildRectangle(data, webGLData);\n            }\n            else if(data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP)\n            {\n                PIXI.WebGLGraphics.buildCircle(data, webGLData);\n            }\n            else if(data.type === PIXI.Graphics.RREC)\n            {\n                PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData);\n            }\n        }\n\n        webGL.lastIndex++;\n    }\n\n    // upload all the dirty data...\n    for (i = 0; i < webGL.data.length; i++)\n    {\n        webGLData = webGL.data[i];\n        if(webGLData.dirty)webGLData.upload();\n    }\n};\n\n/**\n * @static\n * @private\n * @method switchMode\n * @param webGL {WebGLContext}\n * @param type {Number}\n */\nPIXI.WebGLGraphics.switchMode = function(webGL, type)\n{\n    var webGLData;\n\n    if(!webGL.data.length)\n    {\n        webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);\n        webGLData.mode = type;\n        webGL.data.push(webGLData);\n    }\n    else\n    {\n        webGLData = webGL.data[webGL.data.length-1];\n\n        if(webGLData.mode !== type || type === 1)\n        {\n            webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);\n            webGLData.mode = type;\n            webGL.data.push(webGLData);\n        }\n    }\n\n    webGLData.dirty = true;\n\n    return webGLData;\n};\n\n/**\n * Builds a rectangle to draw\n *\n * @static\n * @private\n * @method buildRectangle\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData)\n{\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.shape;\n    var x = rectData.x;\n    var y = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n\n    if(graphicsData.fill)\n    {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vertPos = verts.length / 6;\n\n        // start\n        verts.push(x, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x , y + height);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y + height);\n        verts.push(r, g, b, alpha);\n\n        // insert 2 dead triangles..\n        indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);\n    }\n\n    if (graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [x, y,\n                  x + width, y,\n                  x + width, y + height,\n                  x, y + height,\n                  x, y];\n\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a rounded rectangle to draw\n *\n * @static\n * @private\n * @method buildRoundedRectangle\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildRoundedRectangle = function(graphicsData, webGLData)\n{\n    var rrectData = graphicsData.shape;\n    var x = rrectData.x;\n    var y = rrectData.y;\n    var width = rrectData.width;\n    var height = rrectData.height;\n\n    var radius = rrectData.radius;\n\n    var recPoints = [];\n    recPoints.push(x, y + radius);\n    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height));\n    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius));\n    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y));\n    recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius));\n\n    if (graphicsData.fill) {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vecPos = verts.length / 6;\n\n        var triangles = PIXI.EarCut.Triangulate(recPoints, null, 2);\n\n        var i = 0;\n\n        for (i = 0; i < triangles.length; i+=3)\n        {\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i+1] + vecPos);\n            indices.push(triangles[i+2] + vecPos);\n            indices.push(triangles[i+2] + vecPos);\n        }\n\n\n        for (i = 0; i < recPoints.length; i++)\n        {\n            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);\n        }\n    }\n\n    if (graphicsData.lineWidth) {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = recPoints;\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @static\n * @private\n * @method quadraticBezierCurve\n * @param fromX {Number} Origin point x\n * @param fromY {Number} Origin point x\n * @param cpX {Number} Control point x\n * @param cpY {Number} Control point y\n * @param toX {Number} Destination point x\n * @param toY {Number} Destination point y\n * @return {Array(Number)}\n */\nPIXI.WebGLGraphics.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY) {\n\n    var xa,\n        ya,\n        xb,\n        yb,\n        x,\n        y,\n        n = 20,\n        points = [];\n\n    function getPt(n1 , n2, perc) {\n        var diff = n2 - n1;\n\n        return n1 + ( diff * perc );\n    }\n\n    var j = 0;\n    for (var i = 0; i <= n; i++ )\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt( fromX , cpX , j );\n        ya = getPt( fromY , cpY , j );\n        xb = getPt( cpX , toX , j );\n        yb = getPt( cpY , toY , j );\n\n        // The Black Dot\n        x = getPt( xa , xb , j );\n        y = getPt( ya , yb , j );\n\n        points.push(x, y);\n    }\n    return points;\n};\n\n/**\n * Builds a circle to draw\n *\n * @static\n * @private\n * @method buildCircle\n * @param graphicsData {Graphics} The graphics object to draw\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData)\n{\n    // need to convert points to a nice regular data\n    var circleData = graphicsData.shape;\n    var x = circleData.x;\n    var y = circleData.y;\n    var width;\n    var height;\n    \n    // TODO - bit hacky??\n    if(graphicsData.type === PIXI.Graphics.CIRC)\n    {\n        width = circleData.radius;\n        height = circleData.radius;\n    }\n    else\n    {\n        width = circleData.width;\n        height = circleData.height;\n    }\n\n    var totalSegs = 40;\n    var seg = (Math.PI * 2) / totalSegs ;\n\n    var i = 0;\n\n    if(graphicsData.fill)\n    {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vecPos = verts.length / 6;\n\n        indices.push(vecPos);\n\n        for (i = 0; i < totalSegs + 1 ; i++)\n        {\n            verts.push(x,y, r, g, b, alpha);\n\n            verts.push(x + Math.sin(seg * i) * width,\n                       y + Math.cos(seg * i) * height,\n                       r, g, b, alpha);\n\n            indices.push(vecPos++, vecPos++);\n        }\n\n        indices.push(vecPos-1);\n    }\n\n    if(graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [];\n\n        for (i = 0; i < totalSegs + 1; i++)\n        {\n            graphicsData.points.push(x + Math.sin(seg * i) * width,\n                                     y + Math.cos(seg * i) * height);\n        }\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a line to draw\n *\n * @static\n * @private\n * @method buildLine\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData)\n{\n    // TODO OPTIMISE!\n    var i = 0;\n    var points = graphicsData.points;\n    if(points.length === 0)return;\n\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    if(graphicsData.lineWidth%2)\n    {\n        for (i = 0; i < points.length; i++) {\n            points[i] += 0.5;\n        }\n    }\n\n    // get first and last point.. figure out the middle!\n    var firstPoint = new PIXI.Point( points[0], points[1] );\n    var lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\n    // if the first point is the last point - gonna have issues :)\n    if(firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        points.pop();\n        points.pop();\n\n        lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\n        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;\n        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var length = points.length / 2;\n    var indexCount = points.length;\n    var indexStart = verts.length/6;\n\n    // DRAW the Line\n    var width = graphicsData.lineWidth / 2;\n\n    // sort color\n    var color = PIXI.hex2rgb(graphicsData.lineColor);\n    var alpha = graphicsData.lineAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;\n    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;\n    var a1, b1, c1, a2, b2, c2;\n    var denom, pdist, dist;\n\n    p1x = points[0];\n    p1y = points[1];\n\n    p2x = points[2];\n    p2y = points[3];\n\n    perpx = -(p1y - p2y);\n    perpy =  p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    // start\n    verts.push(p1x - perpx , p1y - perpy,\n                r, g, b, alpha);\n\n    verts.push(p1x + perpx , p1y + perpy,\n                r, g, b, alpha);\n\n    for (i = 1; i < length-1; i++)\n    {\n        p1x = points[(i-1)*2];\n        p1y = points[(i-1)*2 + 1];\n\n        p2x = points[(i)*2];\n        p2y = points[(i)*2 + 1];\n\n        p3x = points[(i+1)*2];\n        p3y = points[(i+1)*2 + 1];\n\n        perpx = -(p1y - p2y);\n        perpy = p1x - p2x;\n\n        dist = Math.sqrt(perpx*perpx + perpy*perpy);\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp2x = -(p2y - p3y);\n        perp2y = p2x - p3x;\n\n        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);\n        perp2x /= dist;\n        perp2y /= dist;\n        perp2x *= width;\n        perp2y *= width;\n\n        a1 = (-perpy + p1y) - (-perpy + p2y);\n        b1 = (-perpx + p2x) - (-perpx + p1x);\n        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);\n        a2 = (-perp2y + p3y) - (-perp2y + p2y);\n        b2 = (-perp2x + p2x) - (-perp2x + p3x);\n        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);\n\n        denom = a1*b2 - a2*b1;\n\n        if(Math.abs(denom) < 0.1 )\n        {\n\n            denom+=10.1;\n            verts.push(p2x - perpx , p2y - perpy,\n                r, g, b, alpha);\n\n            verts.push(p2x + perpx , p2y + perpy,\n                r, g, b, alpha);\n\n            continue;\n        }\n\n        px = (b1*c2 - b2*c1)/denom;\n        py = (a2*c1 - a1*c2)/denom;\n\n\n        pdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y);\n\n\n        if(pdist > 140 * 140)\n        {\n            perp3x = perpx - perp2x;\n            perp3y = perpy - perp2y;\n\n            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);\n            perp3x /= dist;\n            perp3y /= dist;\n            perp3x *= width;\n            perp3y *= width;\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x + perp3x, p2y +perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            indexCount++;\n        }\n        else\n        {\n\n            verts.push(px , py);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - (px-p2x), p2y - (py - p2y));\n            verts.push(r, g, b, alpha);\n        }\n    }\n\n    p1x = points[(length-2)*2];\n    p1y = points[(length-2)*2 + 1];\n\n    p2x = points[(length-1)*2];\n    p2y = points[(length-1)*2 + 1];\n\n    perpx = -(p1y - p2y);\n    perpy = p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(p2x - perpx , p2y - perpy);\n    verts.push(r, g, b, alpha);\n\n    verts.push(p2x + perpx , p2y + perpy);\n    verts.push(r, g, b, alpha);\n\n    indices.push(indexStart);\n\n    for (i = 0; i < indexCount; i++)\n    {\n        indices.push(indexStart++);\n    }\n\n    indices.push(indexStart-1);\n};\n\n/**\n * Builds a complex polygon to draw\n *\n * @static\n * @private\n * @method buildComplexPoly\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildComplexPoly = function(graphicsData, webGLData)\n{\n    //TODO - no need to copy this as it gets turned into a FLoat32Array anyways..\n    var points = graphicsData.points.slice();\n    if(points.length < 6)return;\n\n    // get first and last point.. figure out the middle!\n    var indices = webGLData.indices;\n    webGLData.points = points;\n    webGLData.alpha = graphicsData.fillAlpha;\n    webGLData.color = PIXI.hex2rgb(graphicsData.fillColor);\n\n    /*\n        calclate the bounds..\n    */\n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    var x,y;\n\n    // get size..\n    for (var i = 0; i < points.length; i+=2)\n    {\n        x = points[i];\n        y = points[i+1];\n\n        minX = x < minX ? x : minX;\n        maxX = x > maxX ? x : maxX;\n\n        minY = y < minY ? y : minY;\n        maxY = y > maxY ? y : maxY;\n    }\n\n    // add a quad to the end cos there is no point making another buffer!\n    points.push(minX, minY,\n                maxX, minY,\n                maxX, maxY,\n                minX, maxY);\n\n    // push a quad onto the end.. \n    \n    //TODO - this aint needed!\n    var length = points.length / 2;\n    for (i = 0; i < length; i++)\n    {\n        indices.push( i );\n    }\n\n};\n\n/**\n * Builds a polygon to draw\n *\n * @static\n * @private\n * @method buildPoly\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData)\n{\n    var points = graphicsData.points;\n\n    if(points.length < 6)return;\n    // get first and last point.. figure out the middle!\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n\n    var length = points.length / 2;\n\n    // sort color\n    var color = PIXI.hex2rgb(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var triangles = PIXI.EarCut.Triangulate(points, null, 2);\n\n    if(!triangles)return false;\n\n    var vertPos = verts.length / 6;\n\n    var i = 0;\n\n    for (i = 0; i < triangles.length; i+=3)\n    {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i+1] + vertPos);\n        indices.push(triangles[i+2] +vertPos);\n        indices.push(triangles[i+2] + vertPos);\n    }\n\n    for (i = 0; i < length; i++)\n    {\n        verts.push(points[i * 2], points[i * 2 + 1],\n                   r, g, b, alpha);\n    }\n\n    return true;\n};\n\nPIXI.WebGLGraphics.graphicsDataPool = [];\n\n/**\n * @class WebGLGraphicsData\n * @private\n * @static\n */\nPIXI.WebGLGraphicsData = function(gl)\n{\n    this.gl = gl;\n\n    //TODO does this need to be split before uploding??\n    this.color = [0,0,0]; // color split!\n    this.points = [];\n    this.indices = [];\n    this.buffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n    this.mode = 1;\n    this.alpha = 1;\n    this.dirty = true;\n};\n\n/**\n * @method reset\n */\nPIXI.WebGLGraphicsData.prototype.reset = function()\n{\n    this.points = [];\n    this.indices = [];\n};\n\n/**\n * @method upload\n */\nPIXI.WebGLGraphicsData.prototype.upload = function()\n{\n    var gl = this.gl;\n\n//    this.lastIndex = graphics.graphicsData.length;\n    this.glPoints = new PIXI.Float32Array(this.points);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);\n\n    this.glIndicies = new PIXI.Uint16Array(this.indices);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW);\n\n    this.dirty = false;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * A set of functions used by the canvas renderer to draw the primitive graphics data.\n *\n * @class CanvasGraphics\n * @static\n */\nPIXI.CanvasGraphics = function()\n{\n};\n\n/*\n * Renders a PIXI.Graphics object to a canvas.\n *\n * @method renderGraphics\n * @static\n * @param graphics {Graphics} the actual graphics object to render\n * @param context {CanvasRenderingContext2D} the 2d drawing method of the canvas\n */\nPIXI.CanvasGraphics.renderGraphics = function(graphics, context)\n{\n    var worldAlpha = graphics.worldAlpha;\n\n    if (graphics.dirty)\n    {\n        this.updateGraphicsTint(graphics);\n        graphics.dirty = false;\n    }\n\n    for (var i = 0; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var shape = data.shape;\n\n        var fillColor = data._fillTint;\n        var lineColor = data._lineTint;\n\n        context.lineWidth = data.lineWidth;\n\n        if (data.type === PIXI.Graphics.POLY)\n        {\n            context.beginPath();\n\n            var points = shape.points;\n\n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            if (shape.closed)\n            {\n                context.lineTo(points[0], points[1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n            if (data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.stroke();\n            }\n        }\n        else if (data.type === PIXI.Graphics.RECT)\n        {\n            if (data.fillColor || data.fillColor === 0)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fillRect(shape.x, shape.y, shape.width, shape.height);\n            }\n\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.strokeRect(shape.x, shape.y, shape.width, shape.height);\n            }\n        }\n        else if (data.type === PIXI.Graphics.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.beginPath();\n            context.arc(shape.x, shape.y, shape.radius,0,2*Math.PI);\n            context.closePath();\n\n            if (data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.stroke();\n            }\n        }\n        else if (data.type === PIXI.Graphics.ELIP)\n        {\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n            var w = shape.width * 2;\n            var h = shape.height * 2;\n\n            var x = shape.x - w/2;\n            var y = shape.y - h/2;\n\n            context.beginPath();\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n            context.closePath();\n\n            if (data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.stroke();\n            }\n        }\n        else if (data.type === PIXI.Graphics.RREC)\n        {\n            var rx = shape.x;\n            var ry = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var radius = shape.radius;\n\n            var maxRadius = Math.min(width, height) / 2 | 0;\n            radius = radius > maxRadius ? maxRadius : radius;\n\n            context.beginPath();\n            context.moveTo(rx, ry + radius);\n            context.lineTo(rx, ry + height - radius);\n            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n            context.lineTo(rx + width - radius, ry + height);\n            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n            context.lineTo(rx + width, ry + radius);\n            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n            context.lineTo(rx + radius, ry);\n            context.quadraticCurveTo(rx, ry, rx, ry + radius);\n            context.closePath();\n\n            if (data.fillColor || data.fillColor === 0)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n\n            if (data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);\n                context.stroke();\n            }\n        }\n    }\n\n};\n\n/*\n * Renders a graphics mask\n *\n * @static\n * @private\n * @method renderGraphicsMask\n * @param graphics {Graphics} the graphics which will be used as a mask\n * @param context {CanvasRenderingContext2D} the context 2d method of the canvas\n */\nPIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context)\n{\n    var len = graphics.graphicsData.length;\n\n    if (len === 0)\n    {\n        return;\n    }\n\n    context.beginPath();\n\n    for (var i = 0; i < len; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var shape = data.shape;\n\n        if (data.type === PIXI.Graphics.POLY)\n        {\n\n            var points = shape.points;\n        \n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n        }\n        else if (data.type === PIXI.Graphics.RECT)\n        {\n            context.rect(shape.x, shape.y, shape.width, shape.height);\n            context.closePath();\n        }\n        else if (data.type === PIXI.Graphics.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n            context.closePath();\n        }\n        else if (data.type === PIXI.Graphics.ELIP)\n        {\n\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n            var w = shape.width * 2;\n            var h = shape.height * 2;\n\n            var x = shape.x - w/2;\n            var y = shape.y - h/2;\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n            context.closePath();\n        }\n        else if (data.type === PIXI.Graphics.RREC)\n        {\n\n            var rx = shape.x;\n            var ry = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var radius = shape.radius;\n\n            var maxRadius = Math.min(width, height) / 2 | 0;\n            radius = radius > maxRadius ? maxRadius : radius;\n\n            context.moveTo(rx, ry + radius);\n            context.lineTo(rx, ry + height - radius);\n            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n            context.lineTo(rx + width - radius, ry + height);\n            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n            context.lineTo(rx + width, ry + radius);\n            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n            context.lineTo(rx + radius, ry);\n            context.quadraticCurveTo(rx, ry, rx, ry + radius);\n            context.closePath();\n        }\n    }\n};\n\nPIXI.CanvasGraphics.updateGraphicsTint = function(graphics)\n{\n    if (graphics.tint === 0xFFFFFF)\n    {\n        return;\n    }\n\n    var tintR = (graphics.tint >> 16 & 0xFF) / 255;\n    var tintG = (graphics.tint >> 8 & 0xFF) / 255;\n    var tintB = (graphics.tint & 0xFF)/ 255;\n\n    for (var i = 0; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n\n        var fillColor = data.fillColor | 0;\n        var lineColor = data.lineColor | 0;\n\n        data._fillTint = (((fillColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (fillColor & 0xFF) / 255 * tintB*255);\n        data._lineTint = (((lineColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (lineColor & 0xFF) / 255 * tintB*255);\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Graphics object is a way to draw primitives to your game. Primitives include forms of geometry, such as Rectangles,\n* Circles and Polygons. They also include lines, arcs and curves. When you initially create a Graphics object it will\n* be empty. To 'draw' to it you first specify a lineStyle or fillStyle (or both), and then draw a shape. For example:\n*\n* ```\n* graphics.beginFill(0xff0000);\n* graphics.drawCircle(50, 50, 100);\n* graphics.endFill();\n* ```\n* \n* This will draw a circle shape to the Graphics object, with a diameter of 100, located at x: 50, y: 50.\n*\n* When a Graphics object is rendered it will render differently based on if the game is running under Canvas or\n* WebGL. Under Canvas it will use the HTML Canvas context drawing operations to draw the path. Under WebGL the\n* graphics data is decomposed into polygons. Both of these are expensive processes, especially with complex shapes.\n* \n* If your Graphics object doesn't change much (or at all) once you've drawn your shape to it, then you will help\n* performance by calling `Graphics.generateTexture`. This will 'bake' the Graphics object into a Texture, and return it.\n* You can then use this Texture for Sprites or other display objects. If your Graphics object updates frequently then\n* you should avoid doing this, as it will constantly generate new textures, which will consume memory.\n*\n* As you can tell, Graphics objects are a bit of a trade-off. While they are extremely useful, you need to be careful\n* in their complexity and quantity of them in your game.\n*\n* @class Phaser.Graphics\n* @constructor\n* @extends PIXI.Graphics\n* @extends Phaser.Component.Core\n* @extends Phaser.Component.Angle\n* @extends Phaser.Component.AutoCull\n* @extends Phaser.Component.Bounds\n* @extends Phaser.Component.Destroy\n* @extends Phaser.Component.FixedToCamera\n* @extends Phaser.Component.InputEnabled\n* @extends Phaser.Component.InWorld\n* @extends Phaser.Component.LifeSpan\n* @extends Phaser.Component.PhysicsBody\n* @extends Phaser.Component.Reset\n* @param {Phaser.Game} game - Current game instance.\n* @param {number} [x=0] - X position of the new graphics object.\n* @param {number} [y=0] - Y position of the new graphics object.\n*/\nPhaser.Graphics = function (game, x, y) {\n\n    if (x === undefined) { x = 0; }\n    if (y === undefined) { y = 0; }\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @default\n    */\n    this.type = Phaser.GRAPHICS;\n\n    /**\n    * @property {number} physicsType - The const physics body type of this object.\n    * @readonly\n    */\n    this.physicsType = Phaser.SPRITE;\n\n    /**\n    * @property {Phaser.Point} anchor - Required for a Graphics shape to work as a Physics body, do not modify this value.\n    * @private\n    */\n    this.anchor = new Phaser.Point();\n\n    PIXI.Graphics.call(this);\n\n    Phaser.Component.Core.init.call(this, game, x, y, '', null);\n\n};\n\nPhaser.Graphics.prototype = Object.create(PIXI.Graphics.prototype);\nPhaser.Graphics.prototype.constructor = Phaser.Graphics;\n\nPhaser.Component.Core.install.call(Phaser.Graphics.prototype, [\n    'Angle',\n    'AutoCull',\n    'Bounds',\n    'Destroy',\n    'FixedToCamera',\n    'InputEnabled',\n    'InWorld',\n    'LifeSpan',\n    'PhysicsBody',\n    'Reset'\n]);\n\nPhaser.Graphics.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate;\nPhaser.Graphics.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate;\nPhaser.Graphics.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;\nPhaser.Graphics.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;\n\n/**\n* Automatically called by World.preUpdate.\n* \n* @method\n* @memberof Phaser.Graphics\n*/\nPhaser.Graphics.prototype.preUpdate = function () {\n\n    if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld())\n    {\n        return false;\n    }\n\n    return this.preUpdateCore();\n\n};\n\n/**\n* Automatically called by World\n* @method Phaser.Graphics.prototype.postUpdate\n*/\nPhaser.Graphics.prototype.postUpdate = function () {\n\n    Phaser.Component.PhysicsBody.postUpdate.call(this);\n    Phaser.Component.FixedToCamera.postUpdate.call(this);\n\n    if (this._boundsDirty)\n    {\n        this.updateLocalBounds();\n        this._boundsDirty = false;\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].postUpdate();\n    }\n\n};\n\n/**\n* Destroy this Graphics instance.\n*\n* @method Phaser.Graphics.prototype.destroy\n* @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?\n*/\nPhaser.Graphics.prototype.destroy = function(destroyChildren) {\n\n    this.clear();\n\n    Phaser.Component.Destroy.prototype.destroy.call(this, destroyChildren);\n\n};\n\n/*\n* Draws a single {Phaser.Polygon} triangle from a {Phaser.Point} array\n*\n* @method Phaser.Graphics.prototype.drawTriangle\n* @param {Array<Phaser.Point>} points - An array of Phaser.Points that make up the three vertices of this triangle\n* @param {boolean} [cull=false] - Should we check if the triangle is back-facing\n*/\nPhaser.Graphics.prototype.drawTriangle = function(points, cull) {\n\n    if (cull === undefined) { cull = false; }\n\n    var triangle = new Phaser.Polygon(points);\n\n    if (cull)\n    {\n        var cameraToFace = new Phaser.Point(this.game.camera.x - points[0].x, this.game.camera.y - points[0].y);\n        var ab = new Phaser.Point(points[1].x - points[0].x, points[1].y - points[0].y);\n        var cb = new Phaser.Point(points[1].x - points[2].x, points[1].y - points[2].y);\n        var faceNormal = cb.cross(ab);\n\n        if (cameraToFace.dot(faceNormal) > 0)\n        {\n            this.drawPolygon(triangle);\n        }\n    }\n    else\n    {\n        this.drawPolygon(triangle);\n    }\n\n};\n\n/*\n* Draws {Phaser.Polygon} triangles \n*\n* @method Phaser.Graphics.prototype.drawTriangles\n* @param {Array<Phaser.Point>|Array<number>} vertices - An array of Phaser.Points or numbers that make up the vertices of the triangles\n* @param {Array<number>} {indices=null} - An array of numbers that describe what order to draw the vertices in\n* @param {boolean} [cull=false] - Should we check if the triangle is back-facing\n*/\nPhaser.Graphics.prototype.drawTriangles = function(vertices, indices, cull) {\n\n    if (cull === undefined) { cull = false; }\n\n    var point1 = new Phaser.Point();\n    var point2 = new Phaser.Point();\n    var point3 = new Phaser.Point();\n    var points = [];\n    var i;\n\n    if (!indices)\n    {\n        if (vertices[0] instanceof Phaser.Point)\n        {\n            for (i = 0; i < vertices.length / 3; i++)\n            {\n                this.drawTriangle([vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]], cull);\n            }\n        }\n        else\n        {\n            for (i = 0; i < vertices.length / 6; i++)\n            {\n                point1.x = vertices[i * 6 + 0];\n                point1.y = vertices[i * 6 + 1];\n                point2.x = vertices[i * 6 + 2];\n                point2.y = vertices[i * 6 + 3];\n                point3.x = vertices[i * 6 + 4];\n                point3.y = vertices[i * 6 + 5];\n                this.drawTriangle([point1, point2, point3], cull);\n            }\n        }\n    }\n    else\n    {\n        if (vertices[0] instanceof Phaser.Point)\n        {\n            for (i = 0; i < indices.length /3; i++)\n            {\n                points.push(vertices[indices[i * 3 ]]);\n                points.push(vertices[indices[i * 3 + 1]]);\n                points.push(vertices[indices[i * 3 + 2]]);\n\n                if (points.length === 3)\n                {\n                    this.drawTriangle(points, cull);\n                    points = [];\n                }\n            }\n        }\n        else\n        {\n            for (i = 0; i < indices.length; i++)\n            {\n                point1.x = vertices[indices[i] * 2];\n                point1.y = vertices[indices[i] * 2 + 1];\n                points.push(point1.copyTo({}));\n\n                if (points.length === 3)\n                {\n                    this.drawTriangle(points, cull);\n                    points = [];\n                }\n            }\n        }\n    }\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A RenderTexture is a special texture that allows any displayObject to be rendered to it. It allows you to take many complex objects and\n* render them down into a single quad (on WebGL) which can then be used to texture other display objects with. A way of generating textures at run-time.\n* \n* @class Phaser.RenderTexture\n* @constructor\n* @extends PIXI.RenderTexture\n* @param {Phaser.Game} game - Current game instance.\n* @param {number} [width=100] - The width of the render texture.\n* @param {number} [height=100] - The height of the render texture.\n* @param {string} [key=''] - The key of the RenderTexture in the Cache, if stored there.\n* @param {number} [scaleMode=Phaser.scaleModes.DEFAULT] - One of the Phaser.scaleModes consts.\n* @param {number} [resolution=1] - The resolution of the texture being generated.\n*/\nPhaser.RenderTexture = function (game, width, height, key, scaleMode, resolution) {\n\n    if (key === undefined) { key = ''; }\n    if (scaleMode === undefined) { scaleMode = Phaser.scaleModes.DEFAULT; }\n    if (resolution === undefined) { resolution = 1; }\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {string} key - The key of the RenderTexture in the Cache, if stored there.\n    */\n    this.key = key;\n\n    /**\n    * @property {number} type - Base Phaser object type.\n    */\n    this.type = Phaser.RENDERTEXTURE;\n\n    /**\n    * @property {PIXI.Matrix} _tempMatrix - The matrix that is applied when display objects are rendered to this RenderTexture.\n    * @private\n    */\n    this._tempMatrix = new PIXI.Matrix();\n\n    PIXI.RenderTexture.call(this, width, height, this.game.renderer, scaleMode, resolution);\n\n    this.render = Phaser.RenderTexture.prototype.render;\n\n};\n\nPhaser.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype);\nPhaser.RenderTexture.prototype.constructor = Phaser.RenderTexture;\n\n/**\n* This function will draw the display object to the RenderTexture at the given coordinates.\n*\n* When the display object is drawn it takes into account scale and rotation.\n*\n* If you don't want those then use RenderTexture.renderRawXY instead.\n*\n* @method Phaser.RenderTexture.prototype.renderXY\n* @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText|Phaser.Group} displayObject - The display object to render to this texture.\n* @param {number} x - The x position to render the object at.\n* @param {number} y - The y position to render the object at.\n* @param {boolean} [clear=false] - If true the texture will be cleared before the display object is drawn.\n*/\nPhaser.RenderTexture.prototype.renderXY = function (displayObject, x, y, clear) {\n\n    displayObject.updateTransform();\n\n    this._tempMatrix.copyFrom(displayObject.worldTransform);\n    this._tempMatrix.tx = x;\n    this._tempMatrix.ty = y;\n\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.renderWebGL(displayObject, this._tempMatrix, clear);\n    }\n    else\n    {\n        this.renderCanvas(displayObject, this._tempMatrix, clear);\n    }\n\n};\n\n/**\n* This function will draw the display object to the RenderTexture at the given coordinates.\n*\n* When the display object is drawn it doesn't take into account scale, rotation or translation.\n*\n* If you need those then use RenderTexture.renderXY instead.\n*\n* @method Phaser.RenderTexture.prototype.renderRawXY\n* @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText|Phaser.Group} displayObject - The display object to render to this texture.\n* @param {number} x - The x position to render the object at.\n* @param {number} y - The y position to render the object at.\n* @param {boolean} [clear=false] - If true the texture will be cleared before the display object is drawn.\n*/\nPhaser.RenderTexture.prototype.renderRawXY = function (displayObject, x, y, clear) {\n\n    this._tempMatrix.identity().translate(x, y);\n\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.renderWebGL(displayObject, this._tempMatrix, clear);\n    }\n    else\n    {\n        this.renderCanvas(displayObject, this._tempMatrix, clear);\n    }\n\n};\n\n/**\n* This function will draw the display object to the RenderTexture.\n*\n* In versions of Phaser prior to 2.4.0 the second parameter was a Phaser.Point object. \n* This is now a Matrix allowing you much more control over how the Display Object is rendered.\n* If you need to replicate the earlier behavior please use Phaser.RenderTexture.renderXY instead.\n*\n* If you wish for the displayObject to be rendered taking its current scale, rotation and translation into account then either\n* pass `null`, leave it undefined or pass `displayObject.worldTransform` as the matrix value.\n*\n* @method Phaser.RenderTexture.prototype.render\n* @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText|Phaser.Group} displayObject - The display object to render to this texture.\n* @param {Phaser.Matrix} [matrix] - Optional matrix to apply to the display object before rendering. If null or undefined it will use the worldTransform matrix of the given display object.\n* @param {boolean} [clear=false] - If true the texture will be cleared before the display object is drawn.\n*/\nPhaser.RenderTexture.prototype.render = function (displayObject, matrix, clear) {\n\n    if (matrix === undefined || matrix === null)\n    {\n        this._tempMatrix.copyFrom(displayObject.worldTransform);\n    }\n    else\n    {\n        this._tempMatrix.copyFrom(matrix);\n    }\n\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.renderWebGL(displayObject, this._tempMatrix, clear);\n    }\n    else\n    {\n        this.renderCanvas(displayObject, this._tempMatrix, clear);\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Create a new game object for displaying Text.\n*\n* This uses a local hidden Canvas object and renders the type into it. It then makes a texture from this for rendering to the view.\n* Because of this you can only display fonts that are currently loaded and available to the browser: fonts must be pre-loaded.\n*\n* See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts across mobile browsers.\n*\n* @class Phaser.Text\n* @extends Phaser.Sprite\n* @constructor\n* @param {Phaser.Game} game - Current game instance.\n* @param {number} x - X position of the new text object.\n* @param {number} y - Y position of the new text object.\n* @param {string} text - The actual text that will be written.\n* @param {object} [style] - The style properties to be set on the Text.\n* @param {string} [style.font='bold 20pt Arial'] - The style and size of the font.\n* @param {string} [style.fontStyle=(from font)] - The style of the font (eg. 'italic'): overrides the value in `style.font`.\n* @param {string} [style.fontVariant=(from font)] - The variant of the font (eg. 'small-caps'): overrides the value in `style.font`.\n* @param {string} [style.fontWeight=(from font)] - The weight of the font (eg. 'bold'): overrides the value in `style.font`.\n* @param {string|number} [style.fontSize=(from font)] - The size of the font (eg. 32 or '32px'): overrides the value in `style.font`.\n* @param {string} [style.backgroundColor=null] - A canvas fillstyle that will be used as the background for the whole Text object. Set to `null` to disable.\n* @param {string} [style.fill='black'] - A canvas fillstyle that will be used on the text eg 'red', '#00FF00'.\n* @param {string} [style.align='left'] - Horizontal alignment of each line in multiline text. Can be: 'left', 'center' or 'right'. Does not affect single lines of text (see `textBounds` and `boundsAlignH` for that).\n* @param {string} [style.boundsAlignH='left'] - Horizontal alignment of the text within the `textBounds`. Can be: 'left', 'center' or 'right'.\n* @param {string} [style.boundsAlignV='top'] - Vertical alignment of the text within the `textBounds`. Can be: 'top', 'middle' or 'bottom'.\n* @param {string} [style.stroke='black'] - A canvas stroke style that will be used on the text stroke eg 'blue', '#FCFF00'.\n* @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke. Default is 0 (no stroke).\n* @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used.\n* @param {number} [style.wordWrapWidth=100] - The width in pixels at which text will wrap.\n* @param {number} [style.maxLines=0] - The maximum number of lines to be shown for wrapped text.\n* @param {number} [style.tabs=0] - The size (in pixels) of the tabs, for when text includes tab characters. 0 disables. Can be an array of varying tab sizes, one per tab stop.\n*/\nPhaser.Text = function (game, x, y, text, style) {\n\n    x = x || 0;\n    y = y || 0;\n\n    if (text === undefined || text === null)\n    {\n        text = '';\n    }\n    else\n    {\n        text = text.toString();\n    }\n\n    style = Phaser.Utils.extend({}, style);\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @default\n    */\n    this.type = Phaser.TEXT;\n\n    /**\n    * @property {number} physicsType - The const physics body type of this object.\n    * @readonly\n    */\n    this.physicsType = Phaser.SPRITE;\n\n    /**\n    * Specify a padding value which is added to the line width and height when calculating the Text size.\n    * ALlows you to add extra spacing if Phaser is unable to accurately determine the true font dimensions.\n    * @property {Phaser.Point} padding\n    */\n    this.padding = new Phaser.Point();\n\n    /**\n    * The textBounds property allows you to specify a rectangular region upon which text alignment is based.\n    * See `Text.setTextBounds` for more details.\n    * @property {Phaser.Rectangle} textBounds\n    * @readOnly\n    */\n    this.textBounds = null;\n\n    /**\n     * @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.\n     */\n    this.canvas = PIXI.CanvasPool.create(this);\n\n    /**\n     * @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.\n     */\n    this.context = this.canvas.getContext('2d');\n\n    /**\n    * @property {array} colors - An array of the color values as specified by {@link Phaser.Text#addColor addColor}.\n    */\n    this.colors = [];\n\n    /**\n    * @property {array} strokeColors - An array of the stroke color values as specified by {@link Phaser.Text#addStrokeColor addStrokeColor}.\n    */\n    this.strokeColors = [];\n\n    /**\n    * @property {array} fontStyles - An array of the font styles values as specified by {@link Phaser.Text#addFontStyle addFontStyle}.\n    */\n    this.fontStyles = [];\n\n    /**\n    * @property {array} fontWeights - An array of the font weights values as specified by {@link Phaser.Text#addFontWeight addFontWeight}.\n    */\n    this.fontWeights = [];\n\n    /**\n    * Should the linePositionX and Y values be automatically rounded before rendering the Text?\n    * You may wish to enable this if you want to remove the effect of sub-pixel aliasing from text.\n    * @property {boolean} autoRound\n    * @default\n    */\n    this.autoRound = false;\n\n    /**\n    * Will this Text object use Basic or Advanced Word Wrapping?\n    * \n    * Advanced wrapping breaks long words if they are the first of a line, and repeats the process as necessary.\n    * White space is condensed (e.g., consecutive spaces are replaced with one).\n    * Lines are trimmed of white space before processing.\n    * \n    * It throws an error if wordWrapWidth is less than a single character.\n    * @property {boolean} useAdvancedWrap\n    * @default\n    */\n    this.useAdvancedWrap = false;\n\n    /**\n     * @property {number} _res - Internal canvas resolution var.\n     * @private\n     */\n    this._res = game.renderer.resolution;\n\n    /**\n    * @property {string} _text - Internal cache var.\n    * @private\n    */\n    this._text = text;\n\n    /**\n    * @property {object} _fontComponents - The font, broken down into components, set in `setStyle`.\n    * @private\n    */\n    this._fontComponents = null;\n\n    /**\n    * @property {number} lineSpacing - Additional spacing (in pixels) between each line of text if multi-line.\n    * @private\n    */\n    this._lineSpacing = 0;\n\n    /**\n    * @property {number} _charCount - Internal character counter used by the text coloring.\n    * @private\n    */\n    this._charCount = 0;\n\n    /**\n    * @property {number} _width - Internal width var.\n    * @private\n    */\n    this._width = 0;\n\n    /**\n    * @property {number} _height - Internal height var.\n    * @private\n    */\n    this._height = 0;\n\n    Phaser.Sprite.call(this, game, x, y, PIXI.Texture.fromCanvas(this.canvas));\n\n    this.setStyle(style);\n\n    if (text !== '')\n    {\n        this.updateText();\n    }\n\n};\n\nPhaser.Text.prototype = Object.create(Phaser.Sprite.prototype);\nPhaser.Text.prototype.constructor = Phaser.Text;\n\n/**\n* Automatically called by World.preUpdate.\n* \n* @method Phaser.Text#preUpdate\n* @protected\n*/\nPhaser.Text.prototype.preUpdate = function () {\n\n    if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld())\n    {\n        return false;\n    }\n\n    return this.preUpdateCore();\n\n};\n\n/**\n* Override this function to handle any special update requirements.\n*\n* @method Phaser.Text#update\n* @protected\n*/\nPhaser.Text.prototype.update = function() {\n\n};\n\n/**\n* Destroy this Text object, removing it from the group it belongs to.\n*\n* @method Phaser.Text#destroy\n* @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?\n*/\nPhaser.Text.prototype.destroy = function (destroyChildren) {\n\n    this.texture.destroy(true);\n\n    Phaser.Component.Destroy.prototype.destroy.call(this, destroyChildren);\n\n};\n\n/**\n* Sets a drop shadow effect on the Text. You can specify the horizontal and vertical distance of the drop shadow with the `x` and `y` parameters.\n* The color controls the shade of the shadow (default is black) and can be either an `rgba` or `hex` value.\n* The blur is the strength of the shadow. A value of zero means a hard shadow, a value of 10 means a very soft shadow.\n* To remove a shadow already in place you can call this method with no parameters set.\n* \n* @method Phaser.Text#setShadow\n* @param {number} [x=0] - The shadowOffsetX value in pixels. This is how far offset horizontally the shadow effect will be.\n* @param {number} [y=0] - The shadowOffsetY value in pixels. This is how far offset vertically the shadow effect will be.\n* @param {string} [color='rgba(0,0,0,1)'] - The color of the shadow, as given in CSS rgba or hex format. Set the alpha component to 0 to disable the shadow.\n* @param {number} [blur=0] - The shadowBlur value. Make the shadow softer by applying a Gaussian blur to it. A number from 0 (no blur) up to approx. 10 (depending on scene).\n* @param {boolean} [shadowStroke=true] - Apply the drop shadow to the Text stroke (if set).\n* @param {boolean} [shadowFill=true] - Apply the drop shadow to the Text fill (if set).\n* @return {Phaser.Text} This Text instance.\n*/\nPhaser.Text.prototype.setShadow = function (x, y, color, blur, shadowStroke, shadowFill) {\n\n    if (x === undefined) { x = 0; }\n    if (y === undefined) { y = 0; }\n    if (color === undefined) { color = 'rgba(0, 0, 0, 1)'; }\n    if (blur === undefined) { blur = 0; }\n    if (shadowStroke === undefined) { shadowStroke = true; }\n    if (shadowFill === undefined) { shadowFill = true; }\n\n    this.style.shadowOffsetX = x;\n    this.style.shadowOffsetY = y;\n    this.style.shadowColor = color;\n    this.style.shadowBlur = blur;\n    this.style.shadowStroke = shadowStroke;\n    this.style.shadowFill = shadowFill;\n    this.dirty = true;\n\n    return this;\n\n};\n\n/**\n* Set the style of the text by passing a single style object to it.\n*\n* @method Phaser.Text#setStyle\n* @param {object} [style] - The style properties to be set on the Text.\n* @param {string} [style.font='bold 20pt Arial'] - The style and size of the font.\n* @param {string} [style.fontStyle=(from font)] - The style of the font (eg. 'italic'): overrides the value in `style.font`.\n* @param {string} [style.fontVariant=(from font)] - The variant of the font (eg. 'small-caps'): overrides the value in `style.font`.\n* @param {string} [style.fontWeight=(from font)] - The weight of the font (eg. 'bold'): overrides the value in `style.font`.\n* @param {string|number} [style.fontSize=(from font)] - The size of the font (eg. 32 or '32px'): overrides the value in `style.font`.\n* @param {string} [style.backgroundColor=null] - A canvas fillstyle that will be used as the background for the whole Text object. Set to `null` to disable.\n* @param {string} [style.fill='black'] - A canvas fillstyle that will be used on the text eg 'red', '#00FF00'.\n* @param {string} [style.align='left'] - Horizontal alignment of each line in multiline text. Can be: 'left', 'center' or 'right'. Does not affect single lines of text (see `textBounds` and `boundsAlignH` for that).\n* @param {string} [style.boundsAlignH='left'] - Horizontal alignment of the text within the `textBounds`. Can be: 'left', 'center' or 'right'.\n* @param {string} [style.boundsAlignV='top'] - Vertical alignment of the text within the `textBounds`. Can be: 'top', 'middle' or 'bottom'.\n* @param {string} [style.stroke='black'] - A canvas stroke style that will be used on the text stroke eg 'blue', '#FCFF00'.\n* @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke. Default is 0 (no stroke).\n* @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used.\n* @param {number} [style.wordWrapWidth=100] - The width in pixels at which text will wrap.\n* @param {number} [style.maxLines=0] - The maximum number of lines to be shown for wrapped text.\n* @param {number|array} [style.tabs=0] - The size (in pixels) of the tabs, for when text includes tab characters. 0 disables. Can be an array of varying tab sizes, one per tab stop.\n* @param {boolean} [update=false] - Immediately update the Text object after setting the new style? Or wait for the next frame.\n* @return {Phaser.Text} This Text instance.\n*/\nPhaser.Text.prototype.setStyle = function (style, update) {\n\n    if (update === undefined) { update = false; }\n\n    style = style || {};\n    style.font = style.font || 'bold 20pt Arial';\n    style.backgroundColor = style.backgroundColor || null;\n    style.fill = style.fill || 'black';\n    style.align = style.align || 'left';\n    style.boundsAlignH = style.boundsAlignH || 'left';\n    style.boundsAlignV = style.boundsAlignV || 'top';\n    style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n    style.strokeThickness = style.strokeThickness || 0;\n    style.wordWrap = style.wordWrap || false;\n    style.wordWrapWidth = style.wordWrapWidth || 100;\n    style.maxLines = style.maxLines || 0;\n    style.shadowOffsetX = style.shadowOffsetX || 0;\n    style.shadowOffsetY = style.shadowOffsetY || 0;\n    style.shadowColor = style.shadowColor || 'rgba(0,0,0,0)';\n    style.shadowBlur = style.shadowBlur || 0;\n    style.tabs = style.tabs || 0;\n\n    var components = this.fontToComponents(style.font);\n\n    if (style.fontStyle)\n    {\n        components.fontStyle = style.fontStyle;\n    }\n\n    if (style.fontVariant)\n    {\n        components.fontVariant = style.fontVariant;\n    }\n\n    if (style.fontWeight)\n    {\n        components.fontWeight = style.fontWeight;\n    }\n\n    if (style.fontSize)\n    {\n        if (typeof style.fontSize === 'number')\n        {\n            style.fontSize = style.fontSize + 'px';\n        }\n\n        components.fontSize = style.fontSize;\n    }\n\n    this._fontComponents = components;\n\n    style.font = this.componentsToFont(this._fontComponents);\n\n    this.style = style;\n    this.dirty = true;\n\n    if (update)\n    {\n        this.updateText();\n    }\n\n    return this;\n\n};\n\n/**\n* Renders text. This replaces the Pixi.Text.updateText function as we need a few extra bits in here.\n*\n* @method Phaser.Text#updateText\n* @private\n*/\nPhaser.Text.prototype.updateText = function () {\n\n    this.texture.baseTexture.resolution = this._res;\n\n    this.context.font = this.style.font;\n\n    var outputText = this.text;\n\n    if (this.style.wordWrap)\n    {\n        outputText = this.runWordWrap(this.text);\n    }\n\n    //  Split text into lines\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n    //  Calculate text width\n    var tabs = this.style.tabs;\n    var lineWidths = [];\n    var maxLineWidth = 0;\n    var fontProperties = this.determineFontProperties(this.style.font);\n\n    var drawnLines = lines.length;\n    \n    if (this.style.maxLines > 0 && this.style.maxLines < lines.length)\n    {\n        drawnLines = this.style.maxLines;\n    }\n\n    this._charCount = 0;\n\n    for (var i = 0; i < drawnLines; i++)\n    {\n        if (tabs === 0)\n        {\n            //  Simple layout (no tabs)\n            var lineWidth =  this.style.strokeThickness + this.padding.x;\n\n            if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0)\n            {\n                lineWidth += this.measureLine(lines[i]);\n            }\n            else\n            {\n                lineWidth += this.context.measureText(lines[i]).width;\n            }\n\n            // Adjust for wrapped text\n            if (this.style.wordWrap)\n            {\n                lineWidth -= this.context.measureText(' ').width;\n            }\n        }\n        else\n        {\n            //  Complex layout (tabs)\n            var line = lines[i].split(/(?:\\t)/);\n            var lineWidth = this.padding.x + this.style.strokeThickness;\n\n            if (Array.isArray(tabs))\n            {\n                var tab = 0;\n\n                for (var c = 0; c < line.length; c++)\n                {\n                    var section = 0;\n\n                    if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0)\n                    {\n                        section = this.measureLine(line[c]);\n                    }\n                    else\n                    {\n                        section = Math.ceil(this.context.measureText(line[c]).width);\n                    }\n\n                    if (c > 0)\n                    {\n                        tab += tabs[c - 1];\n                    }\n\n                    lineWidth = tab + section;\n                }\n            }\n            else\n            {\n                for (var c = 0; c < line.length; c++)\n                {\n                    //  How far to the next tab?\n                    if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0)\n                    {\n                        lineWidth += this.measureLine(line[c]);\n                    }\n                    else\n                    {\n                        lineWidth += Math.ceil(this.context.measureText(line[c]).width);\n                    }\n\n                    var diff = this.game.math.snapToCeil(lineWidth, tabs) - lineWidth;\n\n                    lineWidth += diff;\n                }\n            }\n        }\n\n        lineWidths[i] = Math.ceil(lineWidth);\n        maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);\n    }\n\n    this.canvas.width = maxLineWidth * this._res;\n    \n    //  Calculate text height\n    var lineHeight = fontProperties.fontSize + this.style.strokeThickness + this.padding.y;\n    var height = lineHeight * drawnLines;\n    var lineSpacing = this._lineSpacing;\n\n    if (lineSpacing < 0 && Math.abs(lineSpacing) > lineHeight)\n    {\n        lineSpacing = -lineHeight;\n    }\n\n    //  Adjust for line spacing\n    if (lineSpacing !== 0)\n    {\n        height += (lineSpacing > 0) ? lineSpacing * lines.length : lineSpacing * (lines.length - 1);\n    }\n\n    this.canvas.height = height * this._res;\n\n    this.context.scale(this._res, this._res);\n\n    if (navigator.isCocoonJS)\n    {\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n\n    if (this.style.backgroundColor)\n    {\n        this.context.fillStyle = this.style.backgroundColor;\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n    \n    this.context.fillStyle = this.style.fill;\n    this.context.font = this.style.font;\n    this.context.strokeStyle = this.style.stroke;\n    this.context.textBaseline = 'alphabetic';\n\n    this.context.lineWidth = this.style.strokeThickness;\n    this.context.lineCap = 'round';\n    this.context.lineJoin = 'round';\n\n    var linePositionX;\n    var linePositionY;\n\n    this._charCount = 0;\n\n    //  Draw text line by line\n    for (i = 0; i < drawnLines; i++)\n    {\n        //  Split the line by\n\n        linePositionX = this.style.strokeThickness / 2;\n        linePositionY = (this.style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;\n\n        if (i > 0)\n        {\n            linePositionY += (lineSpacing * i);\n        }\n\n        if (this.style.align === 'right')\n        {\n            linePositionX += maxLineWidth - lineWidths[i];\n        }\n        else if (this.style.align === 'center')\n        {\n            linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        if (this.autoRound)\n        {\n            linePositionX = Math.round(linePositionX);\n            linePositionY = Math.round(linePositionY);\n        }\n\n        if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0)\n        {\n            this.updateLine(lines[i], linePositionX, linePositionY);\n        }\n        else\n        {\n            if (this.style.stroke && this.style.strokeThickness)\n            {\n                this.updateShadow(this.style.shadowStroke);\n\n                if (tabs === 0)\n                {\n                    this.context.strokeText(lines[i], linePositionX, linePositionY);\n                }\n                else\n                {\n                    this.renderTabLine(lines[i], linePositionX, linePositionY, false);\n                }\n            }\n\n            if (this.style.fill)\n            {\n                this.updateShadow(this.style.shadowFill);\n\n                if (tabs === 0)\n                {\n                    this.context.fillText(lines[i], linePositionX, linePositionY);\n                }\n                else\n                {\n                    this.renderTabLine(lines[i], linePositionX, linePositionY, true);\n                }\n            }\n        }\n    }\n\n    this.updateTexture();\n\n    this.dirty = false;\n\n};\n\n/**\n* Renders a line of text that contains tab characters if Text.tab > 0.\n* Called automatically by updateText.\n*\n* @method Phaser.Text#renderTabLine\n* @private\n* @param {string} line - The line of text to render.\n* @param {integer} x - The x position to start rendering from.\n* @param {integer} y - The y position to start rendering from.\n* @param {boolean} fill - If true uses fillText, if false uses strokeText.\n*/\nPhaser.Text.prototype.renderTabLine = function (line, x, y, fill) {\n\n    var text = line.split(/(?:\\t)/);\n    var tabs = this.style.tabs;\n    var snap = 0;\n\n    if (Array.isArray(tabs))\n    {\n        var tab = 0;\n\n        for (var c = 0; c < text.length; c++)\n        {\n            if (c > 0)\n            {\n                tab += tabs[c - 1];\n            }\n\n            snap = x + tab;\n\n            if (fill)\n            {\n                this.context.fillText(text[c], snap, y);\n            }\n            else\n            {\n                this.context.strokeText(text[c], snap, y);\n            }\n        }\n    }\n    else\n    {\n        for (var c = 0; c < text.length; c++)\n        {\n            var section = Math.ceil(this.context.measureText(text[c]).width);\n\n            //  How far to the next tab?\n            snap = this.game.math.snapToCeil(x, tabs);\n\n            if (fill)\n            {\n                this.context.fillText(text[c], snap, y);\n            }\n            else\n            {\n                this.context.strokeText(text[c], snap, y);\n            }\n\n            x = snap + section;\n        }\n    }\n\n};\n\n/**\n* Sets the Shadow on the Text.context based on the Style settings, or disables it if not enabled.\n* This is called automatically by Text.updateText.\n*\n* @method Phaser.Text#updateShadow\n* @param {boolean} state - If true the shadow will be set to the Style values, otherwise it will be set to zero.\n*/\nPhaser.Text.prototype.updateShadow = function (state) {\n\n    if (state)\n    {\n        this.context.shadowOffsetX = this.style.shadowOffsetX;\n        this.context.shadowOffsetY = this.style.shadowOffsetY;\n        this.context.shadowColor = this.style.shadowColor;\n        this.context.shadowBlur = this.style.shadowBlur;\n    }\n    else\n    {\n        this.context.shadowOffsetX = 0;\n        this.context.shadowOffsetY = 0;\n        this.context.shadowColor = 0;\n        this.context.shadowBlur = 0;\n    }\n\n};\n\n/**\n* Measures a line of text character by character taking into the account the specified character styles.\n*\n* @method Phaser.Text#measureLine\n* @private\n* @param {string} line - The line of text to measure.\n* @return {integer} length of the line.\n*/\nPhaser.Text.prototype.measureLine = function (line) {\n\n    var lineLength = 0;\n\n    for (var i = 0; i < line.length; i++)\n    {\n        var letter = line[i];\n\n        if (this.fontWeights.length > 0 || this.fontStyles.length > 0)\n        {\n            var components = this.fontToComponents(this.context.font);\n\n            if (this.fontStyles[this._charCount])\n            {\n                components.fontStyle = this.fontStyles[this._charCount];\n            }\n\n            if (this.fontWeights[this._charCount])\n            {\n                components.fontWeight = this.fontWeights[this._charCount];\n            }\n\n            this.context.font = this.componentsToFont(components);\n        }\n\n        if (this.style.stroke && this.style.strokeThickness)\n        {\n            if (this.strokeColors[this._charCount])\n            {\n                this.context.strokeStyle = this.strokeColors[this._charCount];\n            }\n\n            this.updateShadow(this.style.shadowStroke);\n        }\n\n        if (this.style.fill)\n        {\n            if (this.colors[this._charCount])\n            {\n                this.context.fillStyle = this.colors[this._charCount];\n            }\n\n            this.updateShadow(this.style.shadowFill);\n        }\n\n        lineLength += this.context.measureText(letter).width;\n\n        this._charCount++;\n    }\n\n    return Math.ceil(lineLength);\n};\n\n/**\n* Updates a line of text, applying fill and stroke per-character colors or style and weight per-character font if applicable.\n*\n* @method Phaser.Text#updateLine\n* @private\n*/\nPhaser.Text.prototype.updateLine = function (line, x, y) {\n\n    for (var i = 0; i < line.length; i++)\n    {\n        var letter = line[i];\n\n        if (this.fontWeights.length > 0 || this.fontStyles.length > 0)\n        {\n            var components = this.fontToComponents(this.context.font);\n\n            if (this.fontStyles[this._charCount])\n            {\n                components.fontStyle = this.fontStyles[this._charCount];\n            }\n        \n            if (this.fontWeights[this._charCount])\n            {\n                components.fontWeight = this.fontWeights[this._charCount];\n            }\n      \n            this.context.font = this.componentsToFont(components);\n        }\n\n        if (this.style.stroke && this.style.strokeThickness)\n        {\n            if (this.strokeColors[this._charCount])\n            {\n                this.context.strokeStyle = this.strokeColors[this._charCount];\n            }\n\n            this.updateShadow(this.style.shadowStroke);\n            this.context.strokeText(letter, x, y);\n        }\n\n        if (this.style.fill)\n        {\n            if (this.colors[this._charCount])\n            {\n                this.context.fillStyle = this.colors[this._charCount];\n            }\n\n            this.updateShadow(this.style.shadowFill);\n            this.context.fillText(letter, x, y);\n        }\n\n        x += this.context.measureText(letter).width;\n\n        this._charCount++;\n    }\n\n};\n\n/**\n* Clears any text fill or stroke colors that were set by `addColor` or `addStrokeColor`.\n*\n* @method Phaser.Text#clearColors\n* @return {Phaser.Text} This Text instance.\n*/\nPhaser.Text.prototype.clearColors = function () {\n\n    this.colors = [];\n    this.strokeColors = [];\n    this.dirty = true;\n\n    return this;\n\n};\n\n/**\n* Clears any text styles or weights font that were set by `addFontStyle` or `addFontWeight`.\n*\n* @method Phaser.Text#clearFontValues\n* @return {Phaser.Text} This Text instance.\n*/\nPhaser.Text.prototype.clearFontValues = function () {\n\n    this.fontStyles = [];\n    this.fontWeights = [];\n    this.dirty = true;\n\n    return this;\n\n};\n\n/**\n* Set specific colors for certain characters within the Text.\n*\n* It works by taking a color value, which is a typical HTML string such as `#ff0000` or `rgb(255,0,0)` and a position.\n* The position value is the index of the character in the Text string to start applying this color to.\n* Once set the color remains in use until either another color or the end of the string is encountered.\n* For example if the Text was `Photon Storm` and you did `Text.addColor('#ffff00', 6)` it would color in the word `Storm` in yellow.\n*\n* If you wish to change the stroke color see addStrokeColor instead.\n*\n* @method Phaser.Text#addColor\n* @param {string} color - A canvas fillstyle that will be used on the text eg `red`, `#00FF00`, `rgba()`.\n* @param {number} position - The index of the character in the string to start applying this color value from.\n* @return {Phaser.Text} This Text instance.\n*/\nPhaser.Text.prototype.addColor = function (color, position) {\n\n    this.colors[position] = color;\n    this.dirty = true;\n\n    return this;\n\n};\n\n/**\n* Set specific stroke colors for certain characters within the Text.\n*\n* It works by taking a color value, which is a typical HTML string such as `#ff0000` or `rgb(255,0,0)` and a position.\n* The position value is the index of the character in the Text string to start applying this color to.\n* Once set the color remains in use until either another color or the end of the string is encountered.\n* For example if the Text was `Photon Storm` and you did `Text.addColor('#ffff00', 6)` it would color in the word `Storm` in yellow.\n*\n* This has no effect if stroke is disabled or has a thickness of 0.\n*\n* If you wish to change the text fill color see addColor instead.\n*\n* @method Phaser.Text#addStrokeColor\n* @param {string} color - A canvas fillstyle that will be used on the text stroke eg `red`, `#00FF00`, `rgba()`.\n* @param {number} position - The index of the character in the string to start applying this color value from.\n* @return {Phaser.Text} This Text instance.\n*/\nPhaser.Text.prototype.addStrokeColor = function (color, position) {\n\n    this.strokeColors[position] = color;\n    this.dirty = true;\n\n    return this;\n\n};\n\n/**\n* Set specific font styles for certain characters within the Text.\n*\n* It works by taking a font style value, which is a typical string such as `normal`, `italic` or `oblique`.\n* The position value is the index of the character in the Text string to start applying this font style to.\n* Once set the font style remains in use until either another font style or the end of the string is encountered.\n* For example if the Text was `Photon Storm` and you did `Text.addFontStyle('italic', 6)` it would font style in the word `Storm` in italic.\n*\n* If you wish to change the text font weight see addFontWeight instead.\n*\n* @method Phaser.Text#addFontStyle\n* @param {string} style - A canvas font-style that will be used on the text style eg `normal`, `italic`, `oblique`.\n* @param {number} position - The index of the character in the string to start applying this font style value from.\n* @return {Phaser.Text} This Text instance.\n*/\nPhaser.Text.prototype.addFontStyle = function (style, position) {\n\n    this.fontStyles[position] = style;\n    this.dirty = true;\n\n    return this;\n\n};\n\n/**\n* Set specific font weights for certain characters within the Text.\n*\n* It works by taking a font weight value, which is a typical string such as `normal`, `bold`, `bolder`, etc.\n* The position value is the index of the character in the Text string to start applying this font weight to.\n* Once set the font weight remains in use until either another font weight or the end of the string is encountered.\n* For example if the Text was `Photon Storm` and you did `Text.addFontWeight('bold', 6)` it would font weight in the word `Storm` in bold.\n*\n* If you wish to change the text font style see addFontStyle instead.\n*\n* @method Phaser.Text#addFontWeight\n* @param {string} style - A canvas font-weight that will be used on the text weight eg `normal`, `bold`, `bolder`, `lighter`, etc.\n* @param {number} position - The index of the character in the string to start applying this font weight value from.\n* @return {Phaser.Text} This Text instance.\n*/\nPhaser.Text.prototype.addFontWeight = function (weight, position) {\n\n    this.fontWeights[position] = weight;\n    this.dirty = true;\n\n    return this;\n\n};\n\n/**\n* Runs the given text through the Text.runWordWrap function and returns\n* the results as an array, where each element of the array corresponds to a wrapped\n* line of text.\n*\n* Useful if you wish to control pagination on long pieces of content.\n*\n* @method Phaser.Text#precalculateWordWrap\n* @param {string} text - The text for which the wrapping will be calculated.\n* @return {array} An array of strings with the pieces of wrapped text.\n*/\nPhaser.Text.prototype.precalculateWordWrap = function (text) {\n\n    this.texture.baseTexture.resolution = this._res;\n    this.context.font = this.style.font;\n\n    var wrappedLines = this.runWordWrap(text);\n\n    return wrappedLines.split(/(?:\\r\\n|\\r|\\n)/);\n\n};\n\n/**\n* Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal bounds.\n*\n* @method Phaser.Text#runWordWrap\n* @param {string} text - The text to perform word wrap detection against.\n* @private\n*/\nPhaser.Text.prototype.runWordWrap = function (text) {\n\n    if (this.useAdvancedWrap)\n    {\n        return this.advancedWordWrap(text);\n    }\n    else\n    {\n        return this.basicWordWrap(text);\n    }\n\n};\n\n/**\n* Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal bounds.\n* White space is condensed (e.g., consecutive spaces are replaced with one).\n* Lines are trimmed of white space before processing.\n* Throws an error if the user was smart enough to specify a wordWrapWidth less than a single character.\n*\n* @method Phaser.Text#advancedWordWrap\n* @param {string} text - The text to perform word wrap detection against.\n* @private\n*/\nPhaser.Text.prototype.advancedWordWrap = function (text) {\n\n    var context = this.context;\n    var wordWrapWidth = this.style.wordWrapWidth;\n\n    var output = '';\n\n    // (1) condense whitespace\n    // (2) split into lines\n    var lines = text\n        .replace(/ +/gi, ' ')\n        .split(/\\r?\\n/gi);\n\n    var linesCount = lines.length;\n\n    for (var i = 0; i < linesCount; i++)\n    {\n        var line = lines[i];\n        var out = '';\n\n        // trim whitespace\n        line = line.replace(/^ *|\\s*$/gi, '');\n\n        // if entire line is less than wordWrapWidth\n        // append the entire line and exit early\n        var lineWidth = context.measureText(line).width;\n\n        if (lineWidth < wordWrapWidth)\n        {\n            output += line + '\\n';\n            continue;\n        }\n\n        // otherwise, calculate new lines\n        var currentLineWidth = wordWrapWidth;\n\n        // split into words\n        var words = line.split(' ');\n\n        for (var j = 0; j < words.length; j++)\n        {\n            var word = words[j];\n            var wordWithSpace = word + ' ';\n            var wordWidth = context.measureText(wordWithSpace).width;\n\n            if (wordWidth > currentLineWidth)\n            {\n                // break word\n                if (j === 0)\n                {\n                    // shave off letters from word until it's small enough\n                    var newWord = wordWithSpace;\n\n                    while (newWord.length)\n                    {\n                        newWord = newWord.slice(0, -1);\n                        wordWidth = context.measureText(newWord).width;\n\n                        if (wordWidth <= currentLineWidth)\n                        {\n                            break;\n                        }\n                    }\n\n                    // if wordWrapWidth is too small for even a single\n                    // letter, shame user failure with a fatal error\n                    if (!newWord.length)\n                    {\n                        throw new Error('This text\\'s wordWrapWidth setting is less than a single character!');\n                    }\n\n                    // replace current word in array with remainder\n                    var secondPart = word.substr(newWord.length);\n\n                    words[j] = secondPart;\n\n                    // append first piece to output\n                    out += newWord;\n                }\n\n                // if existing word length is 0, don't include it\n                var offset = (words[j].length) ? j : j + 1;\n\n                // collapse rest of sentence\n                var remainder = words.slice(offset).join(' ')\n                // remove any trailing white space\n                .replace(/[ \\n]*$/gi, '');\n\n                // prepend remainder to next line\n                lines[i + 1] = remainder + ' ' + (lines[i + 1] || '');\n                linesCount = lines.length;\n\n                break; // processing on this line\n\n                // append word with space to output\n            }\n            else\n            {\n                out += wordWithSpace;\n                currentLineWidth -= wordWidth;\n            }\n        }\n\n        // append processed line to output\n        output += out.replace(/[ \\n]*$/gi, '') + '\\n';\n    }\n\n    // trim the end of the string\n    output = output.replace(/[\\s|\\n]*$/gi, '');\n\n    return output;\n\n};\n\n/**\n* Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal bounds.\n*\n* @method Phaser.Text#basicWordWrap\n* @param {string} text - The text to perform word wrap detection against.\n* @private\n*/\nPhaser.Text.prototype.basicWordWrap = function (text) {\n\n    var result = '';\n    var lines = text.split('\\n');\n\n    for (var i = 0; i < lines.length; i++)\n    {\n        var spaceLeft = this.style.wordWrapWidth;\n        var words = lines[i].split(' ');\n\n        for (var j = 0; j < words.length; j++)\n        {\n            var wordWidth = this.context.measureText(words[j]).width;\n            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n\n            if (wordWidthWithSpace > spaceLeft)\n            {\n                // Skip printing the newline if it's the first word of the line that is greater than the word wrap width.\n                if (j > 0)\n                {\n                    result += '\\n';\n                }\n                result += words[j] + ' ';\n                spaceLeft = this.style.wordWrapWidth - wordWidth;\n            }\n            else\n            {\n                spaceLeft -= wordWidthWithSpace;\n                result += words[j] + ' ';\n            }\n        }\n\n        if (i < lines.length-1)\n        {\n            result += '\\n';\n        }\n    }\n\n    return result;\n\n};\n\n/**\n* Updates the internal `style.font` if it now differs according to generation from components.\n*\n* @method Phaser.Text#updateFont\n* @private\n* @param {object} components - Font components.\n*/\nPhaser.Text.prototype.updateFont = function (components) {\n\n    var font = this.componentsToFont(components);\n\n    if (this.style.font !== font)\n    {\n        this.style.font = font;\n        this.dirty = true;\n\n        if (this.parent)\n        {\n            this.updateTransform();\n        }\n    }\n\n};\n\n/**\n* Converting a short CSS-font string into the relevant components.\n*\n* @method Phaser.Text#fontToComponents\n* @private\n* @param {string} font - a CSS font string\n*/\nPhaser.Text.prototype.fontToComponents = function (font) {\n\n    // The format is specified in http://www.w3.org/TR/CSS2/fonts.html#font-shorthand:\n    // style - normal | italic | oblique | inherit\n    // variant - normal | small-caps | inherit\n    // weight - normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit\n    // size - xx-small | x-small | small | medium | large | x-large | xx-large,\n    //        larger | smaller\n    //        {number} (em | ex | ch | rem | vh | vw | vmin | vmax | px | mm | cm | in | pt | pc | %)\n    // font-family - rest (but identifiers or quoted with comma separation)\n    var m = font.match(/^\\s*(?:\\b(normal|italic|oblique|inherit)?\\b)\\s*(?:\\b(normal|small-caps|inherit)?\\b)\\s*(?:\\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\\b)\\s*(?:\\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\\d*(?:[.]\\d*)?(?:%|[a-z]{2,5}))?\\b)\\s*(.*)\\s*$/);\n\n    if (m)\n    {\n        var family = m[5].trim();\n\n        // If it looks like the value should be quoted, but isn't, then quote it.\n        if (!/^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(family) && !/['\",]/.exec(family))\n        {\n            family = \"'\" + family + \"'\";\n        }\n\n        return {\n            font: font,\n            fontStyle: m[1] || 'normal',\n            fontVariant: m[2] || 'normal',\n            fontWeight: m[3] || 'normal',\n            fontSize: m[4] || 'medium',\n            fontFamily: family\n        };\n    }\n    else\n    {\n        console.warn(\"Phaser.Text - unparsable CSS font: \" + font);\n\n        return {\n            font: font\n        };\n    }\n\n};\n\n/**\n* Converts individual font components (see `fontToComponents`) to a short CSS font string.\n*\n* @method Phaser.Text#componentsToFont\n* @private\n* @param {object} components - Font components.\n*/\nPhaser.Text.prototype.componentsToFont = function (components) {\n\n    var parts = [];\n    var v;\n\n    v = components.fontStyle;\n    if (v && v !== 'normal') { parts.push(v); }\n\n    v = components.fontVariant;\n    if (v && v !== 'normal') { parts.push(v); }\n\n    v = components.fontWeight;\n    if (v && v !== 'normal') { parts.push(v); }\n\n    v = components.fontSize;\n    if (v && v !== 'medium') { parts.push(v); }\n\n    v = components.fontFamily;\n    if (v) { parts.push(v); }\n\n    if (!parts.length)\n    {\n        // Fallback to whatever value the 'font' was\n        parts.push(components.font);\n    }\n\n    return parts.join(\" \");\n\n};\n\n/**\n* The text to be displayed by this Text object.\n* Use a \\n to insert a carriage return and split the text.\n* The text will be rendered with any style currently set.\n*\n* Use the optional `immediate` argument if you need the Text display to update immediately.\n* \n* If not it will re-create the texture of this Text object during the next time the render\n* loop is called.\n*\n* @method Phaser.Text#setText\n* @param {string} [text] - The text to be displayed. Set to an empty string to clear text that is already present.\n* @param {boolean} [immediate=false] - Update the texture used by this Text object immediately (true) or automatically during the next render loop (false).\n* @return {Phaser.Text} This Text instance.\n*/\nPhaser.Text.prototype.setText = function (text, immediate) {\n\n    if (immediate === undefined) { immediate = false; }\n\n    this.text = text.toString() || '';\n\n    if (immediate)\n    {\n        this.updateText();\n    }\n    else\n    {\n        this.dirty = true;\n    }\n\n    return this;\n\n};\n\n/**\n * Converts the given array into a tab delimited string and then updates this Text object.\n * This is mostly used when you want to display external data using tab stops.\n *\n * The array can be either single or multi dimensional depending on the result you need:\n *\n * `[ 'a', 'b', 'c' ]` would convert in to `\"a\\tb\\tc\"`.\n *\n * Where as:\n *\n * `[\n *      [ 'a', 'b', 'c' ],\n *      [ 'd', 'e', 'f']\n * ]`\n *\n * would convert in to: `\"a\\tb\\tc\\nd\\te\\tf\"`\n *\n * @method Phaser.Text#parseList\n * @param {array} list - The array of data to convert into a string.\n * @return {Phaser.Text} This Text instance.\n */\nPhaser.Text.prototype.parseList = function (list) {\n\n    if (!Array.isArray(list))\n    {\n        return this;\n    }\n    else\n    {\n        var s = \"\";\n\n        for (var i = 0; i < list.length; i++)\n        {\n            if (Array.isArray(list[i]))\n            {\n                s += list[i].join(\"\\t\");\n\n                if (i < list.length - 1)\n                {\n                    s += \"\\n\";\n                }\n            }\n            else\n            {\n                s += list[i];\n\n                if (i < list.length - 1)\n                {\n                    s += \"\\t\";\n                }\n            }\n        }\n    }\n\n    this.text = s;\n    this.dirty = true;\n\n    return this;\n\n};\n\n/**\n * The Text Bounds is a rectangular region that you control the dimensions of into which the Text object itself is positioned,\n * regardless of the number of lines in the text, the font size or any other attribute.\n *\n * Alignment is controlled via the properties `boundsAlignH` and `boundsAlignV` within the Text.style object, or can be directly\n * set through the setters `Text.boundsAlignH` and `Text.boundsAlignV`. Bounds alignment is independent of text alignment.\n *\n * For example: If your game is 800x600 in size and you set the text bounds to be 0,0,800,600 then by setting boundsAlignH to\n * 'center' and boundsAlignV to 'bottom' the text will render in the center and at the bottom of your game window, regardless of\n * how many lines of text there may be. Even if you adjust the text content or change the style it will remain at the bottom center\n * of the text bounds.\n *\n * This is especially powerful when you need to align text against specific coordinates in your game, but the actual text dimensions\n * may vary based on font (say for multi-lingual games).\n *\n * If `Text.wordWrapWidth` is greater than the width of the text bounds it is clamped to match the bounds width.\n *\n * Call this method with no arguments given to reset an existing textBounds.\n * \n * It works by calculating the final position based on the Text.canvas size, which is modified as the text is updated. Some fonts\n * have additional padding around them which you can mitigate by tweaking the Text.padding property. It then adjusts the `pivot`\n * property based on the given bounds and canvas size. This means if you need to set the pivot property directly in your game then\n * you either cannot use `setTextBounds` or you must place the Text object inside another DisplayObject on which you set the pivot.\n *\n * @method Phaser.Text#setTextBounds\n * @param {number} [x] - The x coordinate of the Text Bounds region.\n * @param {number} [y] - The y coordinate of the Text Bounds region.\n * @param {number} [width] - The width of the Text Bounds region.\n * @param {number} [height] - The height of the Text Bounds region.\n * @return {Phaser.Text} This Text instance.\n */\nPhaser.Text.prototype.setTextBounds = function (x, y, width, height) {\n\n    if (x === undefined)\n    {\n        this.textBounds = null;\n    }\n    else\n    {\n        if (!this.textBounds)\n        {\n            this.textBounds = new Phaser.Rectangle(x, y, width, height);\n        }\n        else\n        {\n            this.textBounds.setTo(x, y, width, height);\n        }\n\n        if (this.style.wordWrapWidth > width)\n        {\n            this.style.wordWrapWidth = width;\n        }\n    }\n\n    this.updateTexture();\n    \n    return this;\n\n};\n\n/**\n * Updates the texture based on the canvas dimensions.\n *\n * @method Phaser.Text#updateTexture\n * @private\n */\nPhaser.Text.prototype.updateTexture = function () {\n\n    var base = this.texture.baseTexture;\n    var crop = this.texture.crop;\n    var frame = this.texture.frame;\n\n    var w = this.canvas.width;\n    var h = this.canvas.height;\n\n    base.width = w;\n    base.height = h;\n\n    crop.width = w;\n    crop.height = h;\n\n    frame.width = w;\n    frame.height = h;\n\n    this.texture.width = w;\n    this.texture.height = h;\n\n    this._width = w;\n    this._height = h;\n\n    if (this.textBounds)\n    {\n        var x = this.textBounds.x;\n        var y = this.textBounds.y;\n\n        //  Align the canvas based on the bounds\n        if (this.style.boundsAlignH === 'right')\n        {\n            x += this.textBounds.width - this.canvas.width / this.resolution;\n        }\n        else if (this.style.boundsAlignH === 'center')\n        {\n            x += this.textBounds.halfWidth - (this.canvas.width / this.resolution / 2);\n        }\n\n        if (this.style.boundsAlignV === 'bottom')\n        {\n            y += this.textBounds.height - this.canvas.height / this.resolution;\n        }\n        else if (this.style.boundsAlignV === 'middle')\n        {\n            y += this.textBounds.halfHeight - (this.canvas.height / this.resolution / 2);\n        }\n\n        this.pivot.x = -x;\n        this.pivot.y = -y;\n    }\n\n    //  Can't render something with a zero sized dimension\n    this.renderable = (w !== 0 && h !== 0);\n\n    this.texture.requiresReTint = true;\n\n    this.texture.baseTexture.dirty();\n\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method Phaser.Text#_renderWebGL\n* @private\n* @param {RenderSession} renderSession - The Render Session to render the Text on.\n*/\nPhaser.Text.prototype._renderWebGL = function (renderSession) {\n\n    if (this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n\n    PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);\n\n};\n\n/**\n* Renders the object using the Canvas renderer.\n*\n* @method Phaser.Text#_renderCanvas\n* @private\n* @param {RenderSession} renderSession - The Render Session to render the Text on.\n*/\nPhaser.Text.prototype._renderCanvas = function (renderSession) {\n\n    if (this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n     \n    PIXI.Sprite.prototype._renderCanvas.call(this, renderSession);\n\n};\n\n/**\n* Calculates the ascent, descent and fontSize of a given font style.\n*\n* @method Phaser.Text#determineFontProperties\n* @private\n* @param {object} fontStyle \n*/\nPhaser.Text.prototype.determineFontProperties = function (fontStyle) {\n\n    var properties = Phaser.Text.fontPropertiesCache[fontStyle];\n\n    if (!properties)\n    {\n        properties = {};\n        \n        var canvas = Phaser.Text.fontPropertiesCanvas;\n        var context = Phaser.Text.fontPropertiesContext;\n\n        context.font = fontStyle;\n\n        var width = Math.ceil(context.measureText('|MÉq').width);\n        var baseline = Math.ceil(context.measureText('|MÉq').width);\n        var height = 2 * baseline;\n\n        baseline = baseline * 1.4 | 0;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = fontStyle;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText('|MÉq', 0, baseline);\n\n        if (!context.getImageData(0, 0, width, height))\n        {\n            properties.ascent = baseline;\n            properties.descent = baseline + 6;\n            properties.fontSize = properties.ascent + properties.descent;\n\n            Phaser.Text.fontPropertiesCache[fontStyle] = properties;\n\n            return properties;\n        }\n\n        var imagedata = context.getImageData(0, 0, width, height).data;\n        var pixels = imagedata.length;\n        var line = width * 4;\n\n        var i, j;\n\n        var idx = 0;\n        var stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; i++)\n        {\n            for (j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n\n            if (!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; i--)\n        {\n            for (j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n\n            if (!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        //TODO might need a tweak. kind of a temp fix!\n        properties.descent += 6;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        Phaser.Text.fontPropertiesCache[fontStyle] = properties;\n    }\n\n    return properties;\n\n};\n\n/**\n* Returns the bounds of the Text as a rectangle.\n* The bounds calculation takes the worldTransform into account.\n*\n* @method Phaser.Text#getBounds\n* @param {Phaser.Matrix} matrix - The transformation matrix of the Text.\n* @return {Phaser.Rectangle} The framing rectangle\n*/\nPhaser.Text.prototype.getBounds = function (matrix) {\n\n    if (this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n\n    return PIXI.Sprite.prototype.getBounds.call(this, matrix);\n\n};\n\n/**\n* The text to be displayed by this Text object.\n* Use a \\n to insert a carriage return and split the text.\n* The text will be rendered with any style currently set.\n*\n* @name Phaser.Text#text\n* @property {string} text\n*/\nObject.defineProperty(Phaser.Text.prototype, 'text', {\n\n    get: function() {\n        return this._text;\n    },\n\n    set: function(value) {\n\n        if (value !== this._text)\n        {\n            this._text = value.toString() || '';\n            this.dirty = true;\n\n            if (this.parent)\n            {\n                this.updateTransform();\n            }\n        }\n\n    }\n\n});\n\n/**\n* Change the font used.\n*\n* This is equivalent of the `font` property specified to {@link Phaser.Text#setStyle setStyle}, except\n* that unlike using `setStyle` this will not change any current font fill/color settings.\n*\n* The CSS font string can also be individually altered with the `font`, `fontSize`, `fontWeight`, `fontStyle`, and `fontVariant` properties.\n*\n* @name Phaser.Text#cssFont\n* @property {string} cssFont\n*/\nObject.defineProperty(Phaser.Text.prototype, 'cssFont', {\n\n    get: function() {\n        return this.componentsToFont(this._fontComponents);\n    },\n\n    set: function (value)\n    {\n        value = value || 'bold 20pt Arial';\n        this._fontComponents = this.fontToComponents(value);\n        this.updateFont(this._fontComponents);\n    }\n\n});\n\n/**\n* Change the font family that the text will be rendered in, such as 'Arial'.\n*\n* Multiple CSS font families and generic fallbacks can be specified as long as\n* {@link http://www.w3.org/TR/CSS2/fonts.html#propdef-font-family CSS font-family rules} are followed.\n*\n* To change the entire font string use {@link Phaser.Text#cssFont cssFont} instead: eg. `text.cssFont = 'bold 20pt Arial'`.\n*\n* @name Phaser.Text#font\n* @property {string} font\n*/\nObject.defineProperty(Phaser.Text.prototype, 'font', {\n\n    get: function() {\n        return this._fontComponents.fontFamily;\n    },\n\n    set: function(value) {\n\n        value = value || 'Arial';\n        value = value.trim();\n\n        // If it looks like the value should be quoted, but isn't, then quote it.\n        if (!/^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(value) && !/['\",]/.exec(value))\n        {\n            value = \"'\" + value + \"'\";\n        }\n\n        this._fontComponents.fontFamily = value;\n        this.updateFont(this._fontComponents);\n\n    }\n\n});\n\n/**\n* The size of the font.\n*\n* If the font size is specified in pixels (eg. `32` or `'32px`') then a number (ie. `32`) representing\n* the font size in pixels is returned; otherwise the value with CSS unit is returned as a string (eg. `'12pt'`).\n*\n* @name Phaser.Text#fontSize\n* @property {number|string} fontSize\n*/\nObject.defineProperty(Phaser.Text.prototype, 'fontSize', {\n\n    get: function() {\n\n        var size = this._fontComponents.fontSize;\n\n        if (size && /(?:^0$|px$)/.exec(size))\n        {\n            return parseInt(size, 10);\n        }\n        else\n        {\n            return size;\n        }\n\n    },\n\n    set: function(value) {\n\n        value = value || '0';\n        \n        if (typeof value === 'number')\n        {\n            value = value + 'px';\n        }\n\n        this._fontComponents.fontSize = value;\n        this.updateFont(this._fontComponents);\n\n    }\n\n});\n\n/**\n* The weight of the font: 'normal', 'bold', or {@link http://www.w3.org/TR/CSS2/fonts.html#propdef-font-weight a valid CSS font weight}.\n* @name Phaser.Text#fontWeight\n* @property {string} fontWeight\n*/\nObject.defineProperty(Phaser.Text.prototype, 'fontWeight', {\n\n    get: function() {\n        return this._fontComponents.fontWeight || 'normal';\n    },\n\n    set: function(value) {\n\n        value = value || 'normal';\n        this._fontComponents.fontWeight = value;\n        this.updateFont(this._fontComponents);\n\n    }\n\n});\n\n/**\n* The style of the font: 'normal', 'italic', 'oblique'\n* @name Phaser.Text#fontStyle\n* @property {string} fontStyle\n*/\nObject.defineProperty(Phaser.Text.prototype, 'fontStyle', {\n\n    get: function() {\n        return this._fontComponents.fontStyle || 'normal';\n    },\n\n    set: function(value) {\n\n        value = value || 'normal';\n        this._fontComponents.fontStyle = value;\n        this.updateFont(this._fontComponents);\n\n    }\n\n});\n\n/**\n* The variant the font: 'normal', 'small-caps'\n* @name Phaser.Text#fontVariant\n* @property {string} fontVariant\n*/\nObject.defineProperty(Phaser.Text.prototype, 'fontVariant', {\n\n    get: function() {\n        return this._fontComponents.fontVariant || 'normal';\n    },\n\n    set: function(value) {\n\n        value = value || 'normal';\n        this._fontComponents.fontVariant = value;\n        this.updateFont(this._fontComponents);\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#fill\n* @property {object} fill - A canvas fillstyle that will be used on the text eg 'red', '#00FF00'.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'fill', {\n\n    get: function() {\n        return this.style.fill;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.fill)\n        {\n            this.style.fill = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* Controls the horizontal alignment for multiline text.\n* Can be: 'left', 'center' or 'right'.\n* Does not affect single lines of text. For that please see `setTextBounds`.\n* @name Phaser.Text#align\n* @property {string} align\n*/\nObject.defineProperty(Phaser.Text.prototype, 'align', {\n\n    get: function() {\n        return this.style.align;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.align)\n        {\n            this.style.align = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* The resolution of the canvas the text is rendered to.\n* This defaults to match the resolution of the renderer, but can be changed on a per Text object basis.\n* @name Phaser.Text#resolution\n* @property {integer} resolution\n*/\nObject.defineProperty(Phaser.Text.prototype, 'resolution', {\n\n    get: function() {\n        return this._res;\n    },\n\n    set: function(value) {\n\n        if (value !== this._res)\n        {\n            this._res = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* The size (in pixels) of the tabs, for when text includes tab characters. 0 disables. \n* Can be an integer or an array of varying tab sizes, one tab per element.\n* For example if you set tabs to 100 then when Text encounters a tab it will jump ahead 100 pixels.\n* If you set tabs to be `[100,200]` then it will set the first tab at 100px and the second at 200px.\n* \n* @name Phaser.Text#tabs\n* @property {integer|array} tabs\n*/\nObject.defineProperty(Phaser.Text.prototype, 'tabs', {\n\n    get: function() {\n        return this.style.tabs;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.tabs)\n        {\n            this.style.tabs = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* Horizontal alignment of the text within the `textBounds`. Can be: 'left', 'center' or 'right'.\n* @name Phaser.Text#boundsAlignH\n* @property {string} boundsAlignH\n*/\nObject.defineProperty(Phaser.Text.prototype, 'boundsAlignH', {\n\n    get: function() {\n        return this.style.boundsAlignH;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.boundsAlignH)\n        {\n            this.style.boundsAlignH = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* Vertical alignment of the text within the `textBounds`. Can be: 'top', 'middle' or 'bottom'.\n* @name Phaser.Text#boundsAlignV\n* @property {string} boundsAlignV\n*/\nObject.defineProperty(Phaser.Text.prototype, 'boundsAlignV', {\n\n    get: function() {\n        return this.style.boundsAlignV;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.boundsAlignV)\n        {\n            this.style.boundsAlignV = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#stroke\n* @property {string} stroke - A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'stroke', {\n\n    get: function() {\n        return this.style.stroke;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.stroke)\n        {\n            this.style.stroke = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#strokeThickness\n* @property {number} strokeThickness - A number that represents the thickness of the stroke. Default is 0 (no stroke)\n*/\nObject.defineProperty(Phaser.Text.prototype, 'strokeThickness', {\n\n    get: function() {\n        return this.style.strokeThickness;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.strokeThickness)\n        {\n            this.style.strokeThickness = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#wordWrap\n* @property {boolean} wordWrap - Indicates if word wrap should be used.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'wordWrap', {\n\n    get: function() {\n        return this.style.wordWrap;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.wordWrap)\n        {\n            this.style.wordWrap = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#wordWrapWidth\n* @property {number} wordWrapWidth - The width at which text will wrap.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'wordWrapWidth', {\n\n    get: function() {\n        return this.style.wordWrapWidth;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.wordWrapWidth)\n        {\n            this.style.wordWrapWidth = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#lineSpacing\n* @property {number} lineSpacing - Additional spacing (in pixels) between each line of text if multi-line.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'lineSpacing', {\n\n    get: function() {\n        return this._lineSpacing;\n    },\n\n    set: function(value) {\n\n        if (value !== this._lineSpacing)\n        {\n            this._lineSpacing = parseFloat(value);\n            this.dirty = true;\n\n            if (this.parent)\n            {\n                this.updateTransform();\n            }\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowOffsetX\n* @property {number} shadowOffsetX - The shadowOffsetX value in pixels. This is how far offset horizontally the shadow effect will be.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowOffsetX', {\n\n    get: function() {\n        return this.style.shadowOffsetX;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowOffsetX)\n        {\n            this.style.shadowOffsetX = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowOffsetY\n* @property {number} shadowOffsetY - The shadowOffsetY value in pixels. This is how far offset vertically the shadow effect will be.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowOffsetY', {\n\n    get: function() {\n        return this.style.shadowOffsetY;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowOffsetY)\n        {\n            this.style.shadowOffsetY = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowColor\n* @property {string} shadowColor - The color of the shadow, as given in CSS rgba format. Set the alpha component to 0 to disable the shadow.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowColor', {\n\n    get: function() {\n        return this.style.shadowColor;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowColor)\n        {\n            this.style.shadowColor = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowBlur\n* @property {number} shadowBlur - The shadowBlur value. Make the shadow softer by applying a Gaussian blur to it. A number from 0 (no blur) up to approx. 10 (depending on scene).\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowBlur', {\n\n    get: function() {\n        return this.style.shadowBlur;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowBlur)\n        {\n            this.style.shadowBlur = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowStroke\n* @property {boolean} shadowStroke - Sets if the drop shadow is applied to the Text stroke.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowStroke', {\n\n    get: function() {\n        return this.style.shadowStroke;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowStroke)\n        {\n            this.style.shadowStroke = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowFill\n* @property {boolean} shadowFill - Sets if the drop shadow is applied to the Text fill.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowFill', {\n\n    get: function() {\n        return this.style.shadowFill;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowFill)\n        {\n            this.style.shadowFill = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#width\n* @property {number} width - The width of the Text. Setting this will modify the scale to achieve the value requested.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'width', {\n\n    get: function() {\n\n        if (this.dirty)\n        {\n            this.updateText();\n            this.dirty = false;\n        }\n\n        return this.scale.x * this.texture.frame.width;\n    },\n\n    set: function(value) {\n\n        this.scale.x = value / this.texture.frame.width;\n        this._width = value;\n    }\n\n});\n\n/**\n* @name Phaser.Text#height\n* @property {number} height - The height of the Text. Setting this will modify the scale to achieve the value requested.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'height', {\n\n    get: function() {\n\n        if (this.dirty)\n        {\n            this.updateText();\n            this.dirty = false;\n        }\n\n        return this.scale.y * this.texture.frame.height;\n    },\n\n    set: function(value) {\n\n        this.scale.y = value / this.texture.frame.height;\n        this._height = value;\n    }\n\n});\n\nPhaser.Text.fontPropertiesCache = {};\n\nPhaser.Text.fontPropertiesCanvas = document.createElement('canvas');\nPhaser.Text.fontPropertiesContext = Phaser.Text.fontPropertiesCanvas.getContext('2d');\n\nPhaser.TileSprite = function () {};\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @classdesc\n* Detects device support capabilities and is responsible for device initialization - see {@link Phaser.Device.whenReady whenReady}.\n*\n* This class represents a singleton object that can be accessed directly as `game.device`\n* (or, as a fallback, `Phaser.Device` when a game instance is not available) without the need to instantiate it.\n*\n* Unless otherwise noted the device capabilities are only guaranteed after initialization. Initialization\n* occurs automatically and is guaranteed complete before {@link Phaser.Game} begins its \"boot\" phase.\n* Feature detection can be modified in the {@link Phaser.Device.onInitialized onInitialized} signal.\n*\n* When checking features using the exposed properties only the *truth-iness* of the value should be relied upon\n* unless the documentation states otherwise: properties may return `false`, `''`, `null`, or even `undefined`\n* when indicating the lack of a feature.\n*\n* Uses elements from System.js by MrDoob and Modernizr\n*\n* @description\n* It is not possible to instantiate the Device class manually.\n*\n* @class\n* @protected\n*/\nPhaser.Device = function () {\n\n    /**\n    * The time the device became ready.\n    * @property {integer} deviceReadyAt\n    * @protected\n    */\n    this.deviceReadyAt = 0;\n\n    /**\n    * The time as which initialization has completed.\n    * @property {boolean} initialized\n    * @protected\n    */\n    this.initialized = false;\n\n    //  Browser / Host / Operating System\n\n    /**\n    * @property {boolean} desktop - Is running on a desktop?\n    * @default\n    */\n    this.desktop = false;\n\n    /**\n    * @property {boolean} iOS - Is running on iOS?\n    * @default\n    */\n    this.iOS = false;\n\n    /**\n    * @property {number} iOSVersion - If running in iOS this will contain the major version number.\n    * @default\n    */\n    this.iOSVersion = 0;\n\n    /**\n    * @property {boolean} cocoonJS - Is the game running under CocoonJS?\n    * @default\n    */\n    this.cocoonJS = false;\n    \n    /**\n    * @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?\n    * @default\n    */\n    this.cocoonJSApp = false;\n    \n    /**\n    * @property {boolean} cordova - Is the game running under Apache Cordova?\n    * @default\n    */\n    this.cordova = false;\n    \n    /**\n    * @property {boolean} node - Is the game running under Node.js?\n    * @default\n    */\n    this.node = false;\n    \n    /**\n    * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?\n    * @default\n    */\n    this.nodeWebkit = false;\n    \n    /**\n    * @property {boolean} electron - Is the game running under GitHub Electron?\n    * @default\n    */\n    this.electron = false;\n    \n    /**\n    * @property {boolean} ejecta - Is the game running under Ejecta?\n    * @default\n    */\n    this.ejecta = false;\n\n    /**\n    * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?\n    * @default\n    */\n    this.crosswalk = false;\n\n    /**\n    * @property {boolean} android - Is running on android?\n    * @default\n    */\n    this.android = false;\n\n    /**\n    * @property {boolean} chromeOS - Is running on chromeOS?\n    * @default\n    */\n    this.chromeOS = false;\n\n    /**\n    * @property {boolean} linux - Is running on linux?\n    * @default\n    */\n    this.linux = false;\n\n    /**\n    * @property {boolean} macOS - Is running on macOS?\n    * @default\n    */\n    this.macOS = false;\n\n    /**\n    * @property {boolean} windows - Is running on windows?\n    * @default\n    */\n    this.windows = false;\n\n    /**\n    * @property {boolean} windowsPhone - Is running on a Windows Phone?\n    * @default\n    */\n    this.windowsPhone = false;\n\n    //  Features\n\n    /**\n    * @property {boolean} canvas - Is canvas available?\n    * @default\n    */\n    this.canvas = false;\n\n    /**\n    * @property {?boolean} canvasBitBltShift - True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.\n    * @default\n    */\n    this.canvasBitBltShift = null;\n\n    /**\n    * @property {boolean} webGL - Is webGL available?\n    * @default\n    */\n    this.webGL = false;\n\n    /**\n    * @property {boolean} file - Is file available?\n    * @default\n    */\n    this.file = false;\n\n    /**\n    * @property {boolean} fileSystem - Is fileSystem available?\n    * @default\n    */\n    this.fileSystem = false;\n\n    /**\n    * @property {boolean} localStorage - Is localStorage available?\n    * @default\n    */\n    this.localStorage = false;\n\n    /**\n    * @property {boolean} worker - Is worker available?\n    * @default\n    */\n    this.worker = false;\n\n    /**\n    * @property {boolean} css3D - Is css3D available?\n    * @default\n    */\n    this.css3D = false;\n\n    /**\n    * @property {boolean} pointerLock - Is Pointer Lock available?\n    * @default\n    */\n    this.pointerLock = false;\n\n    /**\n    * @property {boolean} typedArray - Does the browser support TypedArrays?\n    * @default\n    */\n    this.typedArray = false;\n\n    /**\n    * @property {boolean} vibration - Does the device support the Vibration API?\n    * @default\n    */\n    this.vibration = false;\n\n    /**\n    * @property {boolean} getUserMedia - Does the device support the getUserMedia API?\n    * @default\n    */\n    this.getUserMedia = true;\n\n    /**\n    * @property {boolean} quirksMode - Is the browser running in strict mode (false) or quirks mode? (true)\n    * @default\n    */\n    this.quirksMode = false;\n\n    //  Input\n\n    /**\n    * @property {boolean} touch - Is touch available?\n    * @default\n    */\n    this.touch = false;\n\n    /**\n    * @property {boolean} mspointer - Is mspointer available?\n    * @default\n    */\n    this.mspointer = false;\n\n    /**\n    * @property {?string} wheelType - The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'\n    * @default\n    * @protected\n    */\n    this.wheelEvent = null;\n\n    //  Browser\n\n    /**\n    * @property {boolean} arora - Set to true if running in Arora.\n    * @default\n    */\n    this.arora = false;\n\n    /**\n    * @property {boolean} chrome - Set to true if running in Chrome.\n    * @default\n    */\n    this.chrome = false;\n\n    /**\n    * @property {number} chromeVersion - If running in Chrome this will contain the major version number.\n    * @default\n    */\n    this.chromeVersion = 0;\n\n    /**\n    * @property {boolean} epiphany - Set to true if running in Epiphany.\n    * @default\n    */\n    this.epiphany = false;\n\n    /**\n    * @property {boolean} firefox - Set to true if running in Firefox.\n    * @default\n    */\n    this.firefox = false;\n\n    /**\n    * @property {number} firefoxVersion - If running in Firefox this will contain the major version number.\n    * @default\n    */\n    this.firefoxVersion = 0;\n\n    /**\n    * @property {boolean} ie - Set to true if running in Internet Explorer.\n    * @default\n    */\n    this.ie = false;\n\n    /**\n    * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.\n    * @default\n    */\n    this.ieVersion = 0;\n\n    /**\n    * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)\n    * @default\n    */\n    this.trident = false;\n\n    /**\n    * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}\n    * @default\n    */\n    this.tridentVersion = 0;\n\n    /**\n    * @property {boolean} edge - Set to true if running in Microsoft Edge browser.\n    * @default\n    */\n    this.edge = false;\n\n    /**\n    * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.\n    * @default\n    */\n    this.mobileSafari = false;\n\n    /**\n    * @property {boolean} midori - Set to true if running in Midori.\n    * @default\n    */\n    this.midori = false;\n\n    /**\n    * @property {boolean} opera - Set to true if running in Opera.\n    * @default\n    */\n    this.opera = false;\n\n    /**\n    * @property {boolean} safari - Set to true if running in Safari.\n    * @default\n    */\n    this.safari = false;\n\n    /**\n    * @property {number} safariVersion - If running in Safari this will contain the major version number.\n    * @default\n    */\n    this.safariVersion = 0;\n\n    /**\n    * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView\n    * @default\n    */\n    this.webApp = false;\n\n    /**\n    * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)\n    * @default\n    */\n    this.silk = false;\n\n    //  Audio\n\n    /**\n    * @property {boolean} audioData - Are Audio tags available?\n    * @default\n    */\n    this.audioData = false;\n\n    /**\n    * @property {boolean} webAudio - Is the WebAudio API available?\n    * @default\n    */\n    this.webAudio = false;\n\n    /**\n    * @property {boolean} ogg - Can this device play ogg files?\n    * @default\n    */\n    this.ogg = false;\n\n    /**\n    * @property {boolean} opus - Can this device play opus files?\n    * @default\n    */\n    this.opus = false;\n\n    /**\n    * @property {boolean} mp3 - Can this device play mp3 files?\n    * @default\n    */\n    this.mp3 = false;\n\n    /**\n    * @property {boolean} wav - Can this device play wav files?\n    * @default\n    */\n    this.wav = false;\n\n    /**\n    * Can this device play m4a files?\n    * @property {boolean} m4a - True if this device can play m4a files.\n    * @default\n    */\n    this.m4a = false;\n\n    /**\n    * @property {boolean} webm - Can this device play webm files?\n    * @default\n    */\n    this.webm = false;\n\n    /**\n    * @property {boolean} dolby - Can this device play EC-3 Dolby Digital Plus files?\n    * @default\n    */\n    this.dolby = false;\n\n    //  Video\n\n    /**\n    * @property {boolean} oggVideo - Can this device play ogg video files?\n    * @default\n    */\n    this.oggVideo = false;\n\n    /**\n    * @property {boolean} h264Video - Can this device play h264 mp4 video files?\n    * @default\n    */\n    this.h264Video = false;\n\n    /**\n    * @property {boolean} mp4Video - Can this device play h264 mp4 video files?\n    * @default\n    */\n    this.mp4Video = false;\n\n    /**\n    * @property {boolean} webmVideo - Can this device play webm video files?\n    * @default\n    */\n    this.webmVideo = false;\n\n    /**\n    * @property {boolean} vp9Video - Can this device play vp9 video files?\n    * @default\n    */\n    this.vp9Video = false;\n\n    /**\n    * @property {boolean} hlsVideo - Can this device play hls video files?\n    * @default\n    */\n    this.hlsVideo = false;\n\n    //  Device\n\n    /**\n    * @property {boolean} iPhone - Is running on iPhone?\n    * @default\n    */\n    this.iPhone = false;\n\n    /**\n    * @property {boolean} iPhone4 - Is running on iPhone4?\n    * @default\n    */\n    this.iPhone4 = false;\n\n    /**\n    * @property {boolean} iPad - Is running on iPad?\n    * @default\n    */\n    this.iPad = false;\n\n    // Device features\n\n    /**\n    * @property {number} pixelRatio - PixelRatio of the host device?\n    * @default\n    */\n    this.pixelRatio = 0;\n\n    /**\n    * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)\n    * @default\n    */\n    this.littleEndian = false;\n\n    /**\n    * @property {boolean} LITTLE_ENDIAN - Same value as `littleEndian`.\n    * @default\n    */\n    this.LITTLE_ENDIAN = false;\n\n    /**\n    * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?\n    * @default\n    */\n    this.support32bit = false;\n\n    /**\n    * @property {boolean} fullscreen - Does the browser support the Full Screen API?\n    * @default\n    */\n    this.fullscreen = false;\n\n    /**\n    * @property {string} requestFullscreen - If the browser supports the Full Screen API this holds the call you need to use to activate it.\n    * @default\n    */\n    this.requestFullscreen = '';\n\n    /**\n    * @property {string} cancelFullscreen - If the browser supports the Full Screen API this holds the call you need to use to cancel it.\n    * @default\n    */\n    this.cancelFullscreen = '';\n\n    /**\n    * @property {boolean} fullscreenKeyboard - Does the browser support access to the Keyboard during Full Screen mode?\n    * @default\n    */\n    this.fullscreenKeyboard = false;\n\n};\n\n// Device is really a singleton/static entity; instantiate it\n// and add new methods directly sans-prototype.\nPhaser.Device = new Phaser.Device();\n\n/**\n* This signal is dispatched after device initialization occurs but before any of the ready\n* callbacks (see {@link Phaser.Device.whenReady whenReady}) have been invoked.\n*\n* Local \"patching\" for a particular device can/should be done in this event.\n*\n* _Note_: This signal is removed after the device has been readied; if a handler has not been\n* added _before_ `new Phaser.Game(..)` it is probably too late.\n*\n* @type {?Phaser.Signal}\n* @static\n*/\nPhaser.Device.onInitialized = new Phaser.Signal();\n\n/**\n* Add a device-ready handler and ensure the device ready sequence is started.\n*\n* Phaser.Device will _not_ activate or initialize until at least one `whenReady` handler is added,\n* which is normally done automatically be calling `new Phaser.Game(..)`.\n*\n* The handler is invoked when the device is considered \"ready\", which may be immediately\n* if the device is already \"ready\". See {@link Phaser.Device#deviceReadyAt deviceReadyAt}.\n*\n* @method\n* @param {function} handler - Callback to invoke when the device is ready. It is invoked with the given context the Phaser.Device object is supplied as the first argument.\n* @param {object} [context] - Context in which to invoke the handler\n* @param {boolean} [nonPrimer=false] - If true the device ready check will not be started.\n*/\nPhaser.Device.whenReady = function (callback, context, nonPrimer) {\n\n    var readyCheck = this._readyCheck;\n\n    if (this.deviceReadyAt || !readyCheck)\n    {\n        callback.call(context, this);\n    }\n    else if (readyCheck._monitor || nonPrimer)\n    {\n        readyCheck._queue = readyCheck._queue || [];\n        readyCheck._queue.push([callback, context]);\n    }\n    else\n    {\n        readyCheck._monitor = readyCheck.bind(this);\n        readyCheck._queue = readyCheck._queue || [];\n        readyCheck._queue.push([callback, context]);\n        \n        var cordova = typeof window.cordova !== 'undefined';\n        var cocoonJS = navigator['isCocoonJS'];\n\n        if (document.readyState === 'complete' || document.readyState === 'interactive')\n        {\n            // Why is there an additional timeout here?\n            window.setTimeout(readyCheck._monitor, 0);\n        }\n        else if (cordova && !cocoonJS)\n        {\n            // Ref. http://docs.phonegap.com/en/3.5.0/cordova_events_events.md.html#deviceready\n            //  Cordova, but NOT Cocoon?\n            document.addEventListener('deviceready', readyCheck._monitor, false);\n        }\n        else\n        {\n            document.addEventListener('DOMContentLoaded', readyCheck._monitor, false);\n            window.addEventListener('load', readyCheck._monitor, false);\n        }\n    }\n\n};\n\n/**\n* Internal method used for checking when the device is ready.\n* This function is removed from Phaser.Device when the device becomes ready.\n*\n* @method\n* @private\n*/\nPhaser.Device._readyCheck = function () {\n\n    var readyCheck = this._readyCheck;\n\n    if (!document.body)\n    {\n        window.setTimeout(readyCheck._monitor, 20);\n    }\n    else if (!this.deviceReadyAt)\n    {\n        this.deviceReadyAt = Date.now();\n\n        document.removeEventListener('deviceready', readyCheck._monitor);\n        document.removeEventListener('DOMContentLoaded', readyCheck._monitor);\n        window.removeEventListener('load', readyCheck._monitor);\n\n        this._initialize();\n        this.initialized = true;\n\n        this.onInitialized.dispatch(this);\n\n        var item;\n        while ((item = readyCheck._queue.shift()))\n        {\n            var callback = item[0];\n            var context = item[1];\n            callback.call(context, this);\n        }\n\n        // Remove no longer useful methods and properties.\n        this._readyCheck = null;\n        this._initialize = null;\n        this.onInitialized = null;\n    }\n\n};\n\n/**\n* Internal method to initialize the capability checks.\n* This function is removed from Phaser.Device once the device is initialized.\n*\n* @method\n* @private\n*/\nPhaser.Device._initialize = function () {\n\n    var device = this;\n\n    /**\n    * Check which OS is game running on.\n    */\n    function _checkOS () {\n\n        var ua = navigator.userAgent;\n\n        if (/Playstation Vita/.test(ua))\n        {\n            device.vita = true;\n        }\n        else if (/Kindle/.test(ua) || /\\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua))\n        {\n            device.kindle = true;\n            // This will NOT detect early generations of Kindle Fire, I think there is no reliable way...\n            // E.g. \"Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true\"\n        }\n        else if (/Android/.test(ua))\n        {\n            device.android = true;\n        }\n        else if (/CrOS/.test(ua))\n        {\n            device.chromeOS = true;\n        }\n        else if (/iP[ao]d|iPhone/i.test(ua))\n        {\n            device.iOS = true;\n            (navigator.appVersion).match(/OS (\\d+)/);\n            device.iOSVersion = parseInt(RegExp.$1, 10);\n        }\n        else if (/Linux/.test(ua))\n        {\n            device.linux = true;\n        }\n        else if (/Mac OS/.test(ua))\n        {\n            device.macOS = true;\n        }\n        else if (/Windows/.test(ua))\n        {\n            device.windows = true;\n        }\n\n        if (/Windows Phone/i.test(ua) || /IEMobile/i.test(ua))\n        {\n            device.android = false;\n            device.iOS = false;\n            device.macOS = false;\n            device.windows = true;\n            device.windowsPhone = true;\n        }\n\n        var silk = /Silk/.test(ua); // detected in browsers\n\n        if (device.windows || device.macOS || (device.linux && !silk) || device.chromeOS)\n        {\n            device.desktop = true;\n        }\n\n        //  Windows Phone / Table reset\n        if (device.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))\n        {\n            device.desktop = false;\n        }\n\n    }\n\n    /**\n    * Check HTML5 features of the host environment.\n    */\n    function _checkFeatures () {\n\n        device.canvas = !!window['CanvasRenderingContext2D'] || device.cocoonJS;\n\n        try {\n            device.localStorage = !!localStorage.getItem;\n        } catch (error) {\n            device.localStorage = false;\n        }\n\n        device.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];\n        device.fileSystem = !!window['requestFileSystem'];\n\n        device.webGL = ( function () { try { var canvas = document.createElement( 'canvas' ); /*Force screencanvas to false*/ canvas.screencanvas = false; return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ); } catch( e ) { return false; } } )();\n        device.webGL = !!device.webGL;\n\n        device.worker = !!window['Worker'];\n\n        device.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;\n\n        device.quirksMode = (document.compatMode === 'CSS1Compat') ? false : true;\n\n        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;\n\n        window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n        device.getUserMedia = device.getUserMedia && !!navigator.getUserMedia && !!window.URL;\n\n        // Older versions of firefox (< 21) apparently claim support but user media does not actually work\n        if (device.firefox && device.firefoxVersion < 21)\n        {\n            device.getUserMedia = false;\n        }\n\n        // TODO: replace canvasBitBltShift detection with actual feature check\n\n        // Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it\n        // is safer to not try and use the fast copy-over method.\n        if (!device.iOS && (device.ie || device.firefox || device.chrome))\n        {\n            device.canvasBitBltShift = true;\n        }\n\n        // Known not to work\n        if (device.safari || device.mobileSafari)\n        {\n            device.canvasBitBltShift = false;\n        }\n\n    }\n\n    /**\n    * Checks/configures various input.\n    */\n    function _checkInput () {\n\n        if ('ontouchstart' in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1))\n        {\n            device.touch = true;\n        }\n\n        if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled)\n        {\n            device.mspointer = true;\n        }\n\n        if (!device.cocoonJS)\n        {\n            // See https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n            if ('onwheel' in window || (device.ie && 'WheelEvent' in window))\n            {\n                // DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+\n                device.wheelEvent = 'wheel';\n            }\n            else if ('onmousewheel' in window)\n            {\n                // Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.\n                device.wheelEvent = 'mousewheel';\n            }\n            else if (device.firefox && 'MouseScrollEvent' in window)\n            {\n                // FF prior to 17. This should probably be scrubbed.\n                device.wheelEvent = 'DOMMouseScroll';\n            }\n        }\n\n    }\n\n    /**\n    * Checks for support of the Full Screen API.\n    */\n    function _checkFullScreenSupport () {\n\n        var fs = [\n            'requestFullscreen',\n            'requestFullScreen',\n            'webkitRequestFullscreen',\n            'webkitRequestFullScreen',\n            'msRequestFullscreen',\n            'msRequestFullScreen',\n            'mozRequestFullScreen',\n            'mozRequestFullscreen'\n        ];\n\n        var element = document.createElement('div');\n\n        for (var i = 0; i < fs.length; i++)\n        {\n            if (element[fs[i]])\n            {\n                device.fullscreen = true;\n                device.requestFullscreen = fs[i];\n                break;\n            }\n        }\n\n        var cfs = [\n            'cancelFullScreen',\n            'exitFullscreen',\n            'webkitCancelFullScreen',\n            'webkitExitFullscreen',\n            'msCancelFullScreen',\n            'msExitFullscreen',\n            'mozCancelFullScreen',\n            'mozExitFullscreen'\n        ];\n\n        if (device.fullscreen)\n        {\n            for (var i = 0; i < cfs.length; i++)\n            {\n                if (document[cfs[i]])\n                {\n                    device.cancelFullscreen = cfs[i];\n                    break;\n                }\n            }\n        }\n\n        //  Keyboard Input?\n        if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'])\n        {\n            device.fullscreenKeyboard = true;\n        }\n\n    }\n\n    /**\n    * Check what browser is game running in.\n    */\n    function _checkBrowser () {\n\n        var ua = navigator.userAgent;\n\n        if (/Arora/.test(ua))\n        {\n            device.arora = true;\n        }\n        else if (/Edge\\/\\d+/.test(ua))\n        {\n            device.edge = true;\n        }\n        else if (/Chrome\\/(\\d+)/.test(ua) && !device.windowsPhone)\n        {\n            device.chrome = true;\n            device.chromeVersion = parseInt(RegExp.$1, 10);\n        }\n        else if (/Epiphany/.test(ua))\n        {\n            device.epiphany = true;\n        }\n        else if (/Firefox\\D+(\\d+)/.test(ua))\n        {\n            device.firefox = true;\n            device.firefoxVersion = parseInt(RegExp.$1, 10);\n        }\n        else if (/AppleWebKit/.test(ua) && device.iOS)\n        {\n            device.mobileSafari = true;\n        }\n        else if (/MSIE (\\d+\\.\\d+);/.test(ua))\n        {\n            device.ie = true;\n            device.ieVersion = parseInt(RegExp.$1, 10);\n        }\n        else if (/Midori/.test(ua))\n        {\n            device.midori = true;\n        }\n        else if (/Opera/.test(ua))\n        {\n            device.opera = true;\n        }\n        else if (/Safari\\/(\\d+)/.test(ua) && !device.windowsPhone)\n        {\n            device.safari = true;\n\n            if (/Version\\/(\\d+)\\./.test(ua))\n            {\n                device.safariVersion = parseInt(RegExp.$1, 10);\n            }\n        }\n        else if (/Trident\\/(\\d+\\.\\d+)(.*)rv:(\\d+\\.\\d+)/.test(ua))\n        {\n            device.ie = true;\n            device.trident = true;\n            device.tridentVersion = parseInt(RegExp.$1, 10);\n            device.ieVersion = parseInt(RegExp.$3, 10);\n        }\n\n        //  Silk gets its own if clause because its ua also contains 'Safari'\n        if (/Silk/.test(ua))\n        {\n            device.silk = true;\n        }\n\n        //  WebApp mode in iOS\n        if (navigator['standalone'])\n        {\n            device.webApp = true;\n        }\n        \n        if (typeof window.cordova !== 'undefined')\n        {\n            device.cordova = true;\n        }\n        \n        if (typeof process !== 'undefined' && typeof require !== 'undefined')\n        {\n            device.node = true;\n        }\n        \n        if (device.node && typeof process.versions === 'object')\n        {\n            device.nodeWebkit = !!process.versions['node-webkit'];\n            \n            device.electron = !!process.versions.electron;\n        }\n        \n        if (navigator['isCocoonJS'])\n        {\n            device.cocoonJS = true;\n        }\n        \n        if (device.cocoonJS)\n        {\n            try {\n                device.cocoonJSApp = (typeof CocoonJS !== 'undefined');\n            }\n            catch(error)\n            {\n                device.cocoonJSApp = false;\n            }\n        }\n\n        if (typeof window.ejecta !== 'undefined')\n        {\n            device.ejecta = true;\n        }\n\n        if (/Crosswalk/.test(ua))\n        {\n            device.crosswalk = true;\n        }\n\n    }\n\n    /**\n    * Check video support.\n    */\n    function _checkVideo () {\n\n        var videoElement = document.createElement(\"video\");\n        var result = false;\n\n        try {\n            if (result = !!videoElement.canPlayType)\n            {\n                if (videoElement.canPlayType('video/ogg; codecs=\"theora\"').replace(/^no$/, ''))\n                {\n                    device.oggVideo = true;\n                }\n\n                if (videoElement.canPlayType('video/mp4; codecs=\"avc1.42E01E\"').replace(/^no$/, ''))\n                {\n                    // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546\n                    device.h264Video = true;\n                    device.mp4Video = true;\n                }\n\n                if (videoElement.canPlayType('video/webm; codecs=\"vp8, vorbis\"').replace(/^no$/, ''))\n                {\n                    device.webmVideo = true;\n                }\n\n                if (videoElement.canPlayType('video/webm; codecs=\"vp9\"').replace(/^no$/, ''))\n                {\n                    device.vp9Video = true;\n                }\n\n                if (videoElement.canPlayType('application/x-mpegURL; codecs=\"avc1.42E01E\"').replace(/^no$/, ''))\n                {\n                    device.hlsVideo = true;\n                }\n            }\n        } catch (e) {}\n    }\n\n    /**\n    * Check audio support.\n    */\n    function _checkAudio () {\n\n        device.audioData = !!(window['Audio']);\n        device.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']);\n        var audioElement = document.createElement('audio');\n        var result = false;\n\n        try {\n            if (result = !!audioElement.canPlayType)\n            {\n                if (audioElement.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''))\n                {\n                    device.ogg = true;\n                }\n\n                if (audioElement.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, ''))\n                {\n                    device.opus = true;\n                }\n\n                if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, ''))\n                {\n                    device.mp3 = true;\n                }\n\n                // Mimetypes accepted:\n                //   developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements\n                //   bit.ly/iphoneoscodecs\n                if (audioElement.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, ''))\n                {\n                    device.wav = true;\n                }\n\n                if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, ''))\n                {\n                    device.m4a = true;\n                }\n\n                if (audioElement.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''))\n                {\n                    device.webm = true;\n                }\n\n                if (audioElement.canPlayType('audio/mp4;codecs=\"ec-3\"') !== '')\n                {\n                    if (device.edge)\n                    {\n                        device.dolby = true;\n                    }\n                    else if (device.safari && device.safariVersion >= 9)\n                    {\n                        if (/Mac OS X (\\d+)_(\\d+)/.test(navigator.userAgent))\n                        {\n                            var major = parseInt(RegExp.$1, 10);\n                            var minor = parseInt(RegExp.$2, 10);\n\n                            if ((major === 10 && minor >= 11) || major > 10)\n                            {\n                                device.dolby = true;\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n        }\n\n    }\n\n    /**\n    * Check Little or Big Endian system.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    */\n    function _checkIsLittleEndian () {\n\n        var a = new ArrayBuffer(4);\n        var b = new Uint8Array(a);\n        var c = new Uint32Array(a);\n\n        b[0] = 0xa1;\n        b[1] = 0xb2;\n        b[2] = 0xc3;\n        b[3] = 0xd4;\n\n        if (c[0] === 0xd4c3b2a1)\n        {\n            return true;\n        }\n\n        if (c[0] === 0xa1b2c3d4)\n        {\n            return false;\n        }\n        else\n        {\n            //  Could not determine endianness\n            return null;\n        }\n\n    }\n\n    /**\n    * Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    */\n    function _checkIsUint8ClampedImageData () {\n\n        if (Uint8ClampedArray === undefined)\n        {\n            return false;\n        }\n\n        var elem = PIXI.CanvasPool.create(this, 1, 1);\n        var ctx = elem.getContext('2d');\n\n        if (!ctx)\n        {\n            return false;\n        }\n\n        var image = ctx.createImageData(1, 1);\n\n        PIXI.CanvasPool.remove(this);\n\n        return image.data instanceof Uint8ClampedArray;\n\n    }\n\n    /**\n    * Check PixelRatio, iOS device, Vibration API, ArrayBuffers and endianess.\n    */\n    function _checkDevice () {\n\n        device.pixelRatio = window['devicePixelRatio'] || 1;\n        device.iPhone = navigator.userAgent.toLowerCase().indexOf('iphone') !== -1;\n        device.iPhone4 = (device.pixelRatio === 2 && device.iPhone);\n        device.iPad = navigator.userAgent.toLowerCase().indexOf('ipad') !== -1;\n\n        if (typeof Int8Array !== 'undefined')\n        {\n            device.typedArray = true;\n        }\n        else\n        {\n            device.typedArray = false;\n        }\n\n        if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')\n        {\n            device.littleEndian = _checkIsLittleEndian();\n            device.LITTLE_ENDIAN = device.littleEndian;\n        }\n\n        device.support32bit = (typeof ArrayBuffer !== 'undefined' && typeof Uint8ClampedArray !== 'undefined' && typeof Int32Array !== 'undefined' && device.littleEndian !== null && _checkIsUint8ClampedImageData());\n\n        navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;\n\n        if (navigator.vibrate)\n        {\n            device.vibration = true;\n        }\n\n    }\n\n    /**\n    * Check whether the host environment support 3D CSS.\n    */\n    function _checkCSS3D () {\n\n        var el = document.createElement('p');\n        var has3d;\n        var transforms = {\n            'webkitTransform': '-webkit-transform',\n            'OTransform': '-o-transform',\n            'msTransform': '-ms-transform',\n            'MozTransform': '-moz-transform',\n            'transform': 'transform'\n        };\n\n        // Add it to the body to get the computed style.\n        document.body.insertBefore(el, null);\n\n        for (var t in transforms)\n        {\n            if (el.style[t] !== undefined)\n            {\n                el.style[t] = \"translate3d(1px,1px,1px)\";\n                has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);\n            }\n        }\n\n        document.body.removeChild(el);\n        device.css3D = (has3d !== undefined && has3d.length > 0 && has3d !== \"none\");\n\n    }\n\n    //  Run the checks\n    _checkOS();\n    _checkBrowser();\n    _checkAudio();\n    _checkVideo();\n    _checkCSS3D();\n    _checkDevice();\n    _checkFeatures();\n    _checkFullScreenSupport();\n    _checkInput();\n\n};\n\n/**\n* Check whether the host environment can play audio.\n*\n* @method canPlayAudio\n* @memberof Phaser.Device.prototype\n* @param {string} type - One of 'mp3, 'ogg', 'm4a', 'wav', 'webm' or 'opus'.\n* @return {boolean} True if the given file type is supported by the browser, otherwise false.\n*/\nPhaser.Device.canPlayAudio = function (type) {\n\n    if (type === 'mp3' && this.mp3)\n    {\n        return true;\n    }\n    else if (type === 'ogg' && (this.ogg || this.opus))\n    {\n        return true;\n    }\n    else if (type === 'm4a' && this.m4a)\n    {\n        return true;\n    }\n    else if (type === 'opus' && this.opus)\n    {\n        return true;\n    }\n    else if (type === 'wav' && this.wav)\n    {\n        return true;\n    }\n    else if (type === 'webm' && this.webm)\n    {\n        return true;\n    }\n    else if (type === 'mp4' && this.dolby)\n    {\n        return true;\n    }\n\n    return false;\n\n};\n\n/**\n* Check whether the host environment can play video files.\n*\n* @method canPlayVideo\n* @memberof Phaser.Device.prototype\n* @param {string} type - One of 'mp4, 'ogg', 'webm' or 'mpeg'.\n* @return {boolean} True if the given file type is supported by the browser, otherwise false.\n*/\nPhaser.Device.canPlayVideo = function (type) {\n\n    if (type === 'webm' && (this.webmVideo || this.vp9Video))\n    {\n        return true;\n    }\n    else if (type === 'mp4' && (this.mp4Video || this.h264Video))\n    {\n        return true;\n    }\n    else if ((type === 'ogg' || type === 'ogv') && this.oggVideo)\n    {\n        return true;\n    }\n    else if (type === 'mpeg' && this.hlsVideo)\n    {\n        return true;\n    }\n\n    return false;\n\n};\n\n/**\n* Check whether the console is open.\n* Note that this only works in Firefox with Firebug and earlier versions of Chrome.\n* It used to work in Chrome, but then they removed the ability: {@link http://src.chromium.org/viewvc/blink?view=revision&revision=151136}\n*\n* @method isConsoleOpen\n* @memberof Phaser.Device.prototype\n*/\nPhaser.Device.isConsoleOpen = function () {\n\n    if (window.console && window.console['firebug'])\n    {\n        return true;\n    }\n\n    if (window.console)\n    {\n        console.profile();\n        console.profileEnd();\n\n        if (console.clear)\n        {\n            console.clear();\n        }\n\n        if (console['profiles'])\n        {\n            return console['profiles'].length > 0;\n        }\n    }\n\n    return false;\n\n};\n\n/**\n* Detect if the host is a an Android Stock browser.\n* This is available before the device \"ready\" event.\n*\n* Authors might want to scale down on effects and switch to the CANVAS rendering method on those devices.\n*\n* @example\n* var defaultRenderingMode = Phaser.Device.isAndroidStockBrowser() ? Phaser.CANVAS : Phaser.AUTO;\n* \n* @method isAndroidStockBrowser\n* @memberof Phaser.Device.prototype\n*/\nPhaser.Device.isAndroidStockBrowser = function () {\n\n    var matches = window.navigator.userAgent.match(/Android.*AppleWebKit\\/([\\d.]+)/);\n    return matches && matches[1] < 537;\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Canvas class handles everything related to creating the `canvas` DOM tag that Phaser will use, \n* including styles, offset and aspect ratio.\n*\n* @class Phaser.Canvas\n* @static\n*/\nPhaser.Canvas = {\n\n    /**\n    * Creates a `canvas` DOM element. The element is not automatically added to the document.\n    *\n    * @method Phaser.Canvas.create\n    * @param {object} parent - The object that will own the canvas that is created.\n    * @param {number} [width=256] - The width of the canvas element.\n    * @param {number} [height=256] - The height of the canvas element..\n    * @param {string} [id=(none)] - If specified, and not the empty string, this will be set as the ID of the canvas element. Otherwise no ID will be set.\n    * @param {boolean} [skipPool=false] - If `true` the canvas will not be placed in the CanvasPool global.\n    * @return {HTMLCanvasElement} The newly created canvas element.\n    */\n    create: function (parent, width, height, id, skipPool) {\n\n        width = width || 256;\n        height = height || 256;\n\n        var canvas = (skipPool) ? document.createElement('canvas') : PIXI.CanvasPool.create(parent, width, height);\n\n        if (typeof id === 'string' && id !== '')\n        {\n            canvas.id = id;\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n        canvas.style.display = 'block';\n\n        return canvas;\n\n    },\n\n    /**\n    * Sets the background color behind the canvas. This changes the canvas style property.\n    *\n    * @method Phaser.Canvas.setBackgroundColor\n    * @param {HTMLCanvasElement} canvas - The canvas to set the background color on.\n    * @param {string} [color='rgb(0,0,0)'] - The color to set. Can be in the format 'rgb(r,g,b)', or '#RRGGBB' or any valid CSS color.\n    * @return {HTMLCanvasElement} Returns the source canvas.\n    */\n    setBackgroundColor: function (canvas, color) {\n\n        color = color || 'rgb(0,0,0)';\n\n        canvas.style.backgroundColor = color;\n\n        return canvas;\n\n    },\n\n    /**\n    * Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.\n    *\n    * @method Phaser.Canvas.setTouchAction\n    * @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.\n    * @param {string} [value] - The touch action to set. Defaults to 'none'.\n    * @return {HTMLCanvasElement} The source canvas.\n    */\n    setTouchAction: function (canvas, value) {\n\n        value = value || 'none';\n\n        canvas.style.msTouchAction = value;\n        canvas.style['ms-touch-action'] = value;\n        canvas.style['touch-action'] = value;\n\n        return canvas;\n\n    },\n\n    /**\n    * Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.\n    *\n    * @method Phaser.Canvas.setUserSelect\n    * @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.\n    * @param {string} [value] - The touch action to set. Defaults to 'none'.\n    * @return {HTMLCanvasElement} The source canvas.\n    */\n    setUserSelect: function (canvas, value) {\n\n        value = value || 'none';\n\n        canvas.style['-webkit-touch-callout'] = value;\n        canvas.style['-webkit-user-select'] = value;\n        canvas.style['-khtml-user-select'] = value;\n        canvas.style['-moz-user-select'] = value;\n        canvas.style['-ms-user-select'] = value;\n        canvas.style['user-select'] = value;\n        canvas.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)';\n\n        return canvas;\n\n    },\n\n    /**\n    * Adds the given canvas element to the DOM. The canvas will be added as a child of the given parent.\n    * If no parent is given it will be added as a child of the document.body.\n    *\n    * @method Phaser.Canvas.addToDOM\n    * @param {HTMLCanvasElement} canvas - The canvas to be added to the DOM.\n    * @param {string|HTMLElement} parent - The DOM element to add the canvas to.\n    * @param {boolean} [overflowHidden=true] - If set to true it will add the overflow='hidden' style to the parent DOM element.\n    * @return {HTMLCanvasElement} Returns the source canvas.\n    */\n    addToDOM: function (canvas, parent, overflowHidden) {\n\n        var target;\n\n        if (overflowHidden === undefined) { overflowHidden = true; }\n\n        if (parent)\n        {\n            if (typeof parent === 'string')\n            {\n                // hopefully an element ID\n                target = document.getElementById(parent);\n            }\n            else if (typeof parent === 'object' && parent.nodeType === 1)\n            {\n                // quick test for a HTMLelement\n                target = parent;\n            }\n        }\n\n        // Fallback, covers an invalid ID and a non HTMLelement object\n        if (!target)\n        {\n            target = document.body;\n        }\n\n        if (overflowHidden && target.style)\n        {\n            target.style.overflow = 'hidden';\n        }\n\n        target.appendChild(canvas);\n\n        return canvas;\n\n    },\n\n    /**\n    * Removes the given canvas element from the DOM.\n    *\n    * @method Phaser.Canvas.removeFromDOM\n    * @param {HTMLCanvasElement} canvas - The canvas to be removed from the DOM.\n    */\n    removeFromDOM: function (canvas) {\n\n        if (canvas.parentNode)\n        {\n            canvas.parentNode.removeChild(canvas);\n        }\n\n    },\n\n    /**\n    * Sets the transform of the given canvas to the matrix values provided.\n    *\n    * @method Phaser.Canvas.setTransform\n    * @param {CanvasRenderingContext2D} context - The context to set the transform on.\n    * @param {number} translateX - The value to translate horizontally by.\n    * @param {number} translateY - The value to translate vertically by.\n    * @param {number} scaleX - The value to scale horizontally by.\n    * @param {number} scaleY - The value to scale vertically by.\n    * @param {number} skewX - The value to skew horizontaly by.\n    * @param {number} skewY - The value to skew vertically by.\n    * @return {CanvasRenderingContext2D} Returns the source context.\n    */\n    setTransform: function (context, translateX, translateY, scaleX, scaleY, skewX, skewY) {\n\n        context.setTransform(scaleX, skewX, skewY, scaleY, translateX, translateY);\n\n        return context;\n\n    },\n\n    /**\n    * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.\n    * By default browsers have image smoothing enabled, which isn't always what you visually want, especially\n    * when using pixel art in a game. Note that this sets the property on the context itself, so that any image\n    * drawn to the context will be affected. This sets the property across all current browsers but support is\n    * patchy on earlier browsers, especially on mobile.\n    *\n    * @method Phaser.Canvas.setSmoothingEnabled\n    * @param {CanvasRenderingContext2D} context - The context to enable or disable the image smoothing on.\n    * @param {boolean} value - If set to true it will enable image smoothing, false will disable it.\n    * @return {CanvasRenderingContext2D} Returns the source context.\n    */\n    setSmoothingEnabled: function (context, value) {\n\n        var s = Phaser.Canvas.getSmoothingPrefix(context);\n\n        if (s)\n        {\n            context[s] = value;\n        }\n\n        return context;\n\n    },\n\n    /**\n    * Gets the Smoothing Enabled vendor prefix being used on the given context, or null if not set.\n    *\n    * @method Phaser.Canvas.getSmoothingPrefix\n    * @param {CanvasRenderingContext2D} context - The context to enable or disable the image smoothing on.\n    * @return {string|null} Returns the smoothingEnabled vendor prefix, or null if not set on the context.\n    */\n    getSmoothingPrefix: function (context) {\n\n        var vendor = [ 'i', 'webkitI', 'msI', 'mozI', 'oI' ];\n\n        for (var prefix in vendor)\n        {\n            var s = vendor[prefix] + 'mageSmoothingEnabled';\n\n            if (s in context)\n            {\n                return s;\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n     * Returns `true` if the given context has image smoothing enabled, otherwise returns `false`.\n     *\n     * @method Phaser.Canvas.getSmoothingEnabled\n     * @param {CanvasRenderingContext2D} context - The context to check for smoothing on.\n     * @return {boolean} True if the given context has image smoothing enabled, otherwise false.\n     */\n    getSmoothingEnabled: function (context) {\n\n        var s = Phaser.Canvas.getSmoothingPrefix(context);\n\n        if (s)\n        {\n            return context[s];\n        }\n\n    },\n\n    /**\n    * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).\n    * Note that if this doesn't given the desired result then see the setSmoothingEnabled.\n    *\n    * @method Phaser.Canvas.setImageRenderingCrisp\n    * @param {HTMLCanvasElement} canvas - The canvas to set image-rendering crisp on.\n    * @return {HTMLCanvasElement} Returns the source canvas.\n    */\n    setImageRenderingCrisp: function (canvas) {\n\n        var types = [ 'optimizeSpeed', 'crisp-edges', '-moz-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'pixelated' ];\n\n        for (var i = 0; i < types.length; i++)\n        {\n            canvas.style['image-rendering'] = types[i];\n        }\n\n        canvas.style.msInterpolationMode = 'nearest-neighbor';\n\n        return canvas;\n\n    },\n\n    /**\n    * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').\n    * Note that if this doesn't given the desired result then see the CanvasUtils.setSmoothingEnabled method.\n    *\n    * @method Phaser.Canvas.setImageRenderingBicubic\n    * @param {HTMLCanvasElement} canvas The canvas to set image-rendering bicubic on.\n    * @return {HTMLCanvasElement} Returns the source canvas.\n    */\n    setImageRenderingBicubic: function (canvas) {\n\n        canvas.style['image-rendering'] = 'auto';\n        canvas.style.msInterpolationMode = 'bicubic';\n\n        return canvas;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Abstracts away the use of RAF or setTimeOut for the core game update loop.\n*\n* @class Phaser.RequestAnimationFrame\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {boolean} [forceSetTimeOut=false] - Tell Phaser to use setTimeOut even if raf is available.\n*/\nPhaser.RequestAnimationFrame = function(game, forceSetTimeOut) {\n\n    if (forceSetTimeOut === undefined) { forceSetTimeOut = false; }\n\n    /**\n    * @property {Phaser.Game} game - The currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} isRunning - true if RequestAnimationFrame is running, otherwise false.\n    * @default\n    */\n    this.isRunning = false;\n\n    /**\n    * @property {boolean} forceSetTimeOut - Tell Phaser to use setTimeOut even if raf is available.\n    */\n    this.forceSetTimeOut = forceSetTimeOut;\n\n    var vendors = [\n        'ms',\n        'moz',\n        'webkit',\n        'o'\n    ];\n\n    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++)\n    {\n        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'];\n    }\n\n    /**\n    * @property {boolean} _isSetTimeOut  - true if the browser is using setTimeout instead of raf.\n    * @private\n    */\n    this._isSetTimeOut = false;\n\n    /**\n    * @property {function} _onLoop - The function called by the update.\n    * @private\n    */\n    this._onLoop = null;\n\n    /**\n    * @property {number} _timeOutID - The callback ID used when calling cancel.\n    * @private\n    */\n    this._timeOutID = null;\n\n};\n\nPhaser.RequestAnimationFrame.prototype = {\n\n    /**\n    * Starts the requestAnimationFrame running or setTimeout if unavailable in browser\n    * @method Phaser.RequestAnimationFrame#start\n    */\n    start: function () {\n\n        this.isRunning = true;\n\n        var _this = this;\n\n        if (!window.requestAnimationFrame || this.forceSetTimeOut)\n        {\n            this._isSetTimeOut = true;\n\n            this._onLoop = function () {\n                return _this.updateSetTimeout();\n            };\n\n            this._timeOutID = window.setTimeout(this._onLoop, 0);\n        }\n        else\n        {\n            this._isSetTimeOut = false;\n\n            this._onLoop = function (time) {\n                return _this.updateRAF(time);\n            };\n\n            this._timeOutID = window.requestAnimationFrame(this._onLoop);\n        }\n\n    },\n\n    /**\n    * The update method for the requestAnimationFrame\n    * @method Phaser.RequestAnimationFrame#updateRAF\n    */\n    updateRAF: function (rafTime) {\n\n        if (this.isRunning)\n        {\n            // floor the rafTime to make it equivalent to the Date.now() provided by updateSetTimeout (just below)\n            this.game.update(Math.floor(rafTime));\n\n            this._timeOutID = window.requestAnimationFrame(this._onLoop);\n        }\n\n    },\n\n    /**\n    * The update method for the setTimeout.\n    * @method Phaser.RequestAnimationFrame#updateSetTimeout\n    */\n    updateSetTimeout: function () {\n\n        if (this.isRunning)\n        {\n            this.game.update(Date.now());\n\n            this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);\n        }\n\n    },\n\n    /**\n    * Stops the requestAnimationFrame from running.\n    * @method Phaser.RequestAnimationFrame#stop\n    */\n    stop: function () {\n\n        if (this._isSetTimeOut)\n        {\n            clearTimeout(this._timeOutID);\n        }\n        else\n        {\n            window.cancelAnimationFrame(this._timeOutID);\n        }\n\n        this.isRunning = false;\n\n    },\n\n    /**\n    * Is the browser using setTimeout?\n    * @method Phaser.RequestAnimationFrame#isSetTimeOut\n    * @return {boolean}\n    */\n    isSetTimeOut: function () {\n        return this._isSetTimeOut;\n    },\n\n    /**\n    * Is the browser using requestAnimationFrame?\n    * @method Phaser.RequestAnimationFrame#isRAF\n    * @return {boolean}\n    */\n    isRAF: function () {\n        return (this._isSetTimeOut === false);\n    }\n\n};\n\nPhaser.RequestAnimationFrame.prototype.constructor = Phaser.RequestAnimationFrame;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A collection of useful mathematical functions.\n*\n* These are normally accessed through `game.math`.\n*\n* @class Phaser.Math\n* @static\n* @see {@link Phaser.Utils}\n* @see {@link Phaser.ArrayUtils}\n*/\nPhaser.Math = {\n\n    /**\n    * Twice PI.\n    * @property {number} Phaser.Math#PI2\n    * @default ~6.283\n    */\n    PI2: Math.PI * 2,\n\n    /**\n    * Returns a number between the `min` and `max` values.\n    *\n    * @method Phaser.Math#between\n    * @param {number} min - The minimum value. Must be positive, and less than 'max'.\n    * @param {number} max - The maximum value. Must be position, and greater than 'min'.\n    * @return {number} A value between the range min to max.\n    */\n    between: function (min, max) {\n\n        return Math.floor(Math.random() * (max - min + 1) + min);\n\n    },\n\n    /**\n    * Two number are fuzzyEqual if their difference is less than epsilon.\n    *\n    * @method Phaser.Math#fuzzyEqual\n    * @param {number} a - The first number to compare.\n    * @param {number} b - The second number to compare.\n    * @param {number} [epsilon=0.0001] - The epsilon (a small value used in the calculation)\n    * @return {boolean} True if |a-b|<epsilon\n    */\n    fuzzyEqual: function (a, b, epsilon) {\n\n        if (epsilon === undefined) { epsilon = 0.0001; }\n\n        return Math.abs(a - b) < epsilon;\n\n    },\n\n    /**\n    * `a` is fuzzyLessThan `b` if it is less than b + epsilon.\n    *\n    * @method Phaser.Math#fuzzyLessThan\n    * @param {number} a - The first number to compare.\n    * @param {number} b - The second number to compare.\n    * @param {number} [epsilon=0.0001] - The epsilon (a small value used in the calculation)\n    * @return {boolean} True if a<b+epsilon\n    */\n    fuzzyLessThan: function (a, b, epsilon) {\n\n        if (epsilon === undefined) { epsilon = 0.0001; }\n\n        return a < b + epsilon;\n\n    },\n\n    /**\n    * `a` is fuzzyGreaterThan `b` if it is more than b - epsilon.\n    *\n    * @method Phaser.Math#fuzzyGreaterThan\n    * @param {number} a - The first number to compare.\n    * @param {number} b - The second number to compare.\n    * @param {number} [epsilon=0.0001] - The epsilon (a small value used in the calculation)\n    * @return {boolean} True if a>b+epsilon\n    */\n    fuzzyGreaterThan: function (a, b, epsilon) {\n\n        if (epsilon === undefined) { epsilon = 0.0001; }\n\n        return a > b - epsilon;\n\n    },\n\n    /**\n    * Applies a fuzzy ceil to the given value.\n    * \n    * @method Phaser.Math#fuzzyCeil\n    * @param {number} val - The value to ceil.\n    * @param {number} [epsilon=0.0001] - The epsilon (a small value used in the calculation)\n    * @return {number} ceiling(val-epsilon)\n    */\n    fuzzyCeil: function (val, epsilon) {\n\n        if (epsilon === undefined) { epsilon = 0.0001; }\n\n        return Math.ceil(val - epsilon);\n\n    },\n\n    /**\n    * Applies a fuzzy floor to the given value.\n    * \n    * @method Phaser.Math#fuzzyFloor\n    * @param {number} val - The value to floor.\n    * @param {number} [epsilon=0.0001] - The epsilon (a small value used in the calculation)\n    * @return {number} floor(val+epsilon)\n    */\n    fuzzyFloor: function (val, epsilon) {\n\n        if (epsilon === undefined) { epsilon = 0.0001; }\n\n        return Math.floor(val + epsilon);\n\n    },\n\n    /**\n    * Averages all values passed to the function and returns the result.\n    *\n    * @method Phaser.Math#average\n    * @params {...number} The numbers to average\n    * @return {number} The average of all given values.\n    */\n    average: function () {\n\n        var sum = 0;\n        var len = arguments.length;\n\n        for (var i = 0; i < len; i++)\n        {\n            sum += (+arguments[i]);\n        }\n\n        return sum / len;\n\n    },\n\n    /**\n    * @method Phaser.Math#shear\n    * @param {number} n\n    * @return {number} n mod 1\n    */\n    shear: function (n) {\n\n        return n % 1;\n\n    },\n\n    /**\n    * Snap a value to nearest grid slice, using rounding.\n    *\n    * Example: if you have an interval gap of 5 and a position of 12... you will snap to 10 whereas 14 will snap to 15.\n    *\n    * @method Phaser.Math#snapTo\n    * @param {number} input - The value to snap.\n    * @param {number} gap - The interval gap of the grid.\n    * @param {number} [start=0] - Optional starting offset for gap.\n    * @return {number} The snapped value.\n    */\n    snapTo: function (input, gap, start) {\n\n        if (start === undefined) { start = 0; }\n\n        if (gap === 0) {\n            return input;\n        }\n\n        input -= start;\n        input = gap * Math.round(input / gap);\n\n        return start + input;\n\n    },\n\n    /**\n    * Snap a value to nearest grid slice, using floor.\n    *\n    * Example: if you have an interval gap of 5 and a position of 12... you will snap to 10.\n    * As will 14 snap to 10... but 16 will snap to 15.\n    *\n    * @method Phaser.Math#snapToFloor\n    * @param {number} input - The value to snap.\n    * @param {number} gap - The interval gap of the grid.\n    * @param {number} [start=0] - Optional starting offset for gap.\n    * @return {number} The snapped value.\n    */\n    snapToFloor: function (input, gap, start) {\n\n        if (start === undefined) { start = 0; }\n\n        if (gap === 0) {\n            return input;\n        }\n\n        input -= start;\n        input = gap * Math.floor(input / gap);\n\n        return start + input;\n\n    },\n\n    /**\n    * Snap a value to nearest grid slice, using ceil.\n    *\n    * Example: if you have an interval gap of 5 and a position of 12... you will snap to 15.\n    * As will 14 will snap to 15... but 16 will snap to 20.\n    *\n    * @method Phaser.Math#snapToCeil\n    * @param {number} input - The value to snap.\n    * @param {number} gap - The interval gap of the grid.\n    * @param {number} [start=0] - Optional starting offset for gap.\n    * @return {number} The snapped value.\n    */\n    snapToCeil: function (input, gap, start) {\n\n        if (start === undefined) { start = 0; }\n\n        if (gap === 0) {\n            return input;\n        }\n\n        input -= start;\n        input = gap * Math.ceil(input / gap);\n\n        return start + input;\n\n    },\n\n    /**\n    * Round to some place comparative to a `base`, default is 10 for decimal place.\n    * The `place` is represented by the power applied to `base` to get that place.\n    *\n    *     e.g. 2000/7 ~= 285.714285714285714285714 ~= (bin)100011101.1011011011011011\n    *\n    *     roundTo(2000/7,3) === 0\n    *     roundTo(2000/7,2) == 300\n    *     roundTo(2000/7,1) == 290\n    *     roundTo(2000/7,0) == 286\n    *     roundTo(2000/7,-1) == 285.7\n    *     roundTo(2000/7,-2) == 285.71\n    *     roundTo(2000/7,-3) == 285.714\n    *     roundTo(2000/7,-4) == 285.7143\n    *     roundTo(2000/7,-5) == 285.71429\n    *\n    *     roundTo(2000/7,3,2)  == 288       -- 100100000\n    *     roundTo(2000/7,2,2)  == 284       -- 100011100\n    *     roundTo(2000/7,1,2)  == 286       -- 100011110\n    *     roundTo(2000/7,0,2)  == 286       -- 100011110\n    *     roundTo(2000/7,-1,2) == 285.5     -- 100011101.1\n    *     roundTo(2000/7,-2,2) == 285.75    -- 100011101.11\n    *     roundTo(2000/7,-3,2) == 285.75    -- 100011101.11\n    *     roundTo(2000/7,-4,2) == 285.6875  -- 100011101.1011\n    *     roundTo(2000/7,-5,2) == 285.71875 -- 100011101.10111\n    *\n    * Note what occurs when we round to the 3rd space (8ths place), 100100000, this is to be assumed\n    * because we are rounding 100011.1011011011011011 which rounds up.\n    *\n    * @method Phaser.Math#roundTo\n    * @param {number} value - The value to round.\n    * @param {number} [place=0] - The place to round to.\n    * @param {number} [base=10] - The base to round in. Default is 10 for decimal.\n    * @return {number} The rounded value.\n    */\n    roundTo: function (value, place, base) {\n\n        if (place === undefined) { place = 0; }\n        if (base === undefined) { base = 10; }\n\n        var p = Math.pow(base, -place);\n\n        return Math.round(value * p) / p;\n\n    },\n\n    /**\n    * Floors to some place comparative to a `base`, default is 10 for decimal place.\n    * The `place` is represented by the power applied to `base` to get that place.\n    * \n    * @method Phaser.Math#floorTo\n    * @param {number} value - The value to round.\n    * @param {number} [place=0] - The place to round to.\n    * @param {number} [base=10] - The base to round in. Default is 10 for decimal.\n    * @return {number} The rounded value.\n    */\n    floorTo: function (value, place, base) {\n\n        if (place === undefined) { place = 0; }\n        if (base === undefined) { base = 10; }\n\n        var p = Math.pow(base, -place);\n\n        return Math.floor(value * p) / p;\n\n    },\n\n    /**\n    * Ceils to some place comparative to a `base`, default is 10 for decimal place.\n    * The `place` is represented by the power applied to `base` to get that place.\n    * \n    * @method Phaser.Math#ceilTo\n    * @param {number} value - The value to round.\n    * @param {number} [place=0] - The place to round to.\n    * @param {number} [base=10] - The base to round in. Default is 10 for decimal.\n    * @return {number} The rounded value.\n    */\n    ceilTo: function (value, place, base) {\n\n        if (place === undefined) { place = 0; }\n        if (base === undefined) { base = 10; }\n\n        var p = Math.pow(base, -place);\n\n        return Math.ceil(value * p) / p;\n\n    },\n\n    /**\n    * Rotates currentAngle towards targetAngle, taking the shortest rotation distance.\n    * The lerp argument is the amount to rotate by in this call.\n    * \n    * @method Phaser.Math#rotateToAngle\n    * @param {number} currentAngle - The current angle, in radians.\n    * @param {number} targetAngle - The target angle to rotate to, in radians.\n    * @param {number} [lerp=0.05] - The lerp value to add to the current angle.\n    * @return {number} The adjusted angle.\n    */\n    rotateToAngle: function (currentAngle, targetAngle, lerp) {\n\n        if (lerp === undefined) { lerp = 0.05; }\n\n        if (currentAngle === targetAngle)\n        {\n            return currentAngle;\n        }\n\n        if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (Phaser.Math.PI2 - lerp))\n        {\n            currentAngle = targetAngle;\n        }\n        else\n        {\n            if (Math.abs(targetAngle - currentAngle) > Math.PI)\n            {\n                if (targetAngle < currentAngle)\n                {\n                    targetAngle += Phaser.Math.PI2;\n                }\n                else\n                {\n                    targetAngle -= Phaser.Math.PI2;\n                }\n            }\n\n            if (targetAngle > currentAngle)\n            {\n                currentAngle += lerp;\n            }\n            else if (targetAngle < currentAngle)\n            {\n                currentAngle -= lerp;\n            }\n        }\n\n        return currentAngle;\n\n    },\n\n    /**\n    * Gets the shortest angle between `angle1` and `angle2`.\n    * Both angles must be in the range -180 to 180, which is the same clamped\n    * range that `sprite.angle` uses, so you can pass in two sprite angles to\n    * this method, and get the shortest angle back between the two of them.\n    *\n    * The angle returned will be in the same range. If the returned angle is\n    * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's\n    * a clockwise rotation.\n    * \n    * @method Phaser.Math#getShortestAngle\n    * @param {number} angle1 - The first angle. In the range -180 to 180.\n    * @param {number} angle2 - The second angle. In the range -180 to 180.\n    * @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.\n    */\n    getShortestAngle: function (angle1, angle2) {\n\n        var difference = angle2 - angle1;\n\n        if (difference === 0)\n        {\n            return 0;\n        }\n\n        var times = Math.floor((difference - (-180)) / 360);\n\n        return difference - (times * 360);\n\n    },\n\n    /**\n    * Find the angle of a segment from (x1, y1) -> (x2, y2).\n    * \n    * @method Phaser.Math#angleBetween\n    * @param {number} x1 - The x coordinate of the first value.\n    * @param {number} y1 - The y coordinate of the first value.\n    * @param {number} x2 - The x coordinate of the second value.\n    * @param {number} y2 - The y coordinate of the second value.\n    * @return {number} The angle, in radians.\n    */\n    angleBetween: function (x1, y1, x2, y2) {\n\n        return Math.atan2(y2 - y1, x2 - x1);\n\n    },\n\n    /**\n    * Find the angle of a segment from (x1, y1) -> (x2, y2).\n    * \n    * The difference between this method and Math.angleBetween is that this assumes the y coordinate travels\n    * down the screen.\n    *\n    * @method Phaser.Math#angleBetweenY\n    * @param {number} x1 - The x coordinate of the first value.\n    * @param {number} y1 - The y coordinate of the first value.\n    * @param {number} x2 - The x coordinate of the second value.\n    * @param {number} y2 - The y coordinate of the second value.\n    * @return {number} The angle, in radians.\n    */\n    angleBetweenY: function (x1, y1, x2, y2) {\n\n        return Math.atan2(x2 - x1, y2 - y1);\n\n    },\n\n    /**\n    * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\n    * \n    * @method Phaser.Math#angleBetweenPoints\n    * @param {Phaser.Point} point1 - The first point.\n    * @param {Phaser.Point} point2 - The second point.\n    * @return {number} The angle between the two points, in radians.\n    */\n    angleBetweenPoints: function (point1, point2) {\n\n        return Math.atan2(point2.y - point1.y, point2.x - point1.x);\n\n    },\n\n    /**\n    * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\n    * @method Phaser.Math#angleBetweenPointsY\n    * @param {Phaser.Point} point1\n    * @param {Phaser.Point} point2\n    * @return {number} The angle, in radians.\n    */\n    angleBetweenPointsY: function (point1, point2) {\n\n        return Math.atan2(point2.x - point1.x, point2.y - point1.y);\n\n    },\n\n    /**\n    * Reverses an angle.\n    * @method Phaser.Math#reverseAngle\n    * @param {number} angleRad - The angle to reverse, in radians.\n    * @return {number} The reverse angle, in radians.\n    */\n    reverseAngle: function (angleRad) {\n\n        return this.normalizeAngle(angleRad + Math.PI, true);\n\n    },\n\n    /**\n    * Normalizes an angle to the [0,2pi) range.\n    * @method Phaser.Math#normalizeAngle\n    * @param {number} angleRad - The angle to normalize, in radians.\n    * @return {number} The angle, fit within the [0,2pi] range, in radians.\n    */\n    normalizeAngle: function (angleRad) {\n\n        angleRad = angleRad % (2 * Math.PI);\n        return angleRad >= 0 ? angleRad : angleRad + 2 * Math.PI;\n\n    },\n\n    /**\n    * Adds the given amount to the value, but never lets the value go over the specified maximum.\n    *\n    * @method Phaser.Math#maxAdd\n    * @param {number} value - The value to add the amount to.\n    * @param {number} amount - The amount to add to the value.\n    * @param {number} max - The maximum the value is allowed to be.\n    * @return {number} The new value.\n    */\n    maxAdd: function (value, amount, max) {\n\n        return Math.min(value + amount, max);\n\n    },\n\n    /**\n    * Subtracts the given amount from the value, but never lets the value go below the specified minimum.\n    *\n    * @method Phaser.Math#minSub\n    * @param {number} value - The base value.\n    * @param {number} amount - The amount to subtract from the base value.\n    * @param {number} min - The minimum the value is allowed to be.\n    * @return {number} The new value.\n    */\n    minSub: function (value, amount, min) {\n\n        return Math.max(value - amount, min);\n\n    },\n\n    /**\n    * Ensures that the value always stays between min and max, by wrapping the value around.\n    *\n    * If `max` is not larger than `min` the result is 0.\n    *\n    * @method Phaser.Math#wrap\n    * @param {number} value - The value to wrap.\n    * @param {number} min - The minimum the value is allowed to be.\n    * @param {number} max - The maximum the value is allowed to be, should be larger than `min`.\n    * @return {number} The wrapped value.\n    */\n    wrap: function (value, min, max) {\n\n        var range = max - min;\n\n        if (range <= 0)\n        {\n            return 0;\n        }\n\n        var result = (value - min) % range;\n\n        if (result < 0)\n        {\n            result += range;\n        }\n\n        return result + min;\n\n    },\n\n    /**\n    * Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.\n    *\n    * Values _must_ be positive integers, and are passed through Math.abs. See {@link Phaser.Math#wrap} for an alternative.\n    *\n    * @method Phaser.Math#wrapValue\n    * @param {number} value - The value to add the amount to.\n    * @param {number} amount - The amount to add to the value.\n    * @param {number} max - The maximum the value is allowed to be.\n    * @return {number} The wrapped value.\n    */\n    wrapValue: function (value, amount, max) {\n\n        var diff;\n        value = Math.abs(value);\n        amount = Math.abs(amount);\n        max = Math.abs(max);\n        diff = (value + amount) % max;\n\n        return diff;\n\n    },\n\n    /**\n    * Returns true if the number given is odd.\n    *\n    * @method Phaser.Math#isOdd\n    * @param {integer} n - The number to check.\n    * @return {boolean} True if the given number is odd. False if the given number is even.\n    */\n    isOdd: function (n) {\n\n        // Does not work with extremely large values\n        return !!(n & 1);\n\n    },\n\n    /**\n    * Returns true if the number given is even.\n    *\n    * @method Phaser.Math#isEven\n    * @param {integer} n - The number to check.\n    * @return {boolean} True if the given number is even. False if the given number is odd.\n    */\n    isEven: function (n) {\n\n        // Does not work with extremely large values\n        return !(n & 1);\n\n    },\n\n    /**\n    * Variation of Math.min that can be passed either an array of numbers or the numbers as parameters.\n    *\n    * Prefer the standard `Math.min` function when appropriate.\n    *\n    * @method Phaser.Math#min\n    * @return {number} The lowest value from those given.\n    * @see {@link http://jsperf.com/math-s-min-max-vs-homemade}\n    */\n    min: function () {\n\n        if (arguments.length === 1 && typeof arguments[0] === 'object')\n        {\n            var data = arguments[0];\n        }\n        else\n        {\n            var data = arguments;\n        }\n\n        for (var i = 1, min = 0, len = data.length; i < len; i++)\n        {\n            if (data[i] < data[min])\n            {\n                min = i;\n            }\n        }\n\n        return data[min];\n\n    },\n\n    /**\n    * Variation of Math.max that can be passed either an array of numbers or the numbers as parameters.\n    *\n    * Prefer the standard `Math.max` function when appropriate.\n    *\n    * @method Phaser.Math#max\n    * @return {number} The largest value from those given.\n    * @see {@link http://jsperf.com/math-s-min-max-vs-homemade}\n    */\n    max: function () {\n\n        if (arguments.length === 1 && typeof arguments[0] === 'object')\n        {\n            var data = arguments[0];\n        }\n        else\n        {\n            var data = arguments;\n        }\n\n        for (var i = 1, max = 0, len = data.length; i < len; i++)\n        {\n            if (data[i] > data[max])\n            {\n                max = i;\n            }\n        }\n\n        return data[max];\n\n    },\n\n    /**\n    * Variation of Math.min that can be passed a property and either an array of objects or the objects as parameters.\n    * It will find the lowest matching property value from the given objects.\n    *\n    * @method Phaser.Math#minProperty\n    * @return {number} The lowest value from those given.\n    */\n    minProperty: function (property) {\n\n        if (arguments.length === 2 && typeof arguments[1] === 'object')\n        {\n            var data = arguments[1];\n        }\n        else\n        {\n            var data = arguments.slice(1);\n        }\n\n        for (var i = 1, min = 0, len = data.length; i < len; i++)\n        {\n            if (data[i][property] < data[min][property])\n            {\n                min = i;\n            }\n        }\n\n        return data[min][property];\n\n    },\n\n    /**\n    * Variation of Math.max that can be passed a property and either an array of objects or the objects as parameters.\n    * It will find the largest matching property value from the given objects.\n    *\n    * @method Phaser.Math#maxProperty\n    * @return {number} The largest value from those given.\n    */\n    maxProperty: function (property) {\n\n        if (arguments.length === 2 && typeof arguments[1] === 'object')\n        {\n            var data = arguments[1];\n        }\n        else\n        {\n            var data = arguments.slice(1);\n        }\n\n        for (var i = 1, max = 0, len = data.length; i < len; i++)\n        {\n            if (data[i][property] > data[max][property])\n            {\n                max = i;\n            }\n        }\n\n        return data[max][property];\n\n    },\n\n    /**\n    * Keeps an angle value between -180 and +180; or -PI and PI if radians.\n    *\n    * @method Phaser.Math#wrapAngle\n    * @param {number} angle - The angle value to wrap\n    * @param {boolean} [radians=false] - Set to `true` if the angle is given in radians, otherwise degrees is expected.\n    * @return {number} The new angle value; will be the same as the input angle if it was within bounds.\n    */\n    wrapAngle: function (angle, radians) {\n\n        return radians ? this.wrap(angle, -Math.PI, Math.PI) : this.wrap(angle, -180, 180);\n\n    },\n\n    /**\n    * A Linear Interpolation Method, mostly used by Phaser.Tween.\n    *\n    * @method Phaser.Math#linearInterpolation\n    * @param {Array} v - The input array of values to interpolate between.\n    * @param {number} k - The percentage of interpolation, between 0 and 1.\n    * @return {number} The interpolated value\n    */\n    linearInterpolation: function (v, k) {\n\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n\n        if (k < 0)\n        {\n            return this.linear(v[0], v[1], f);\n        }\n\n        if (k > 1)\n        {\n            return this.linear(v[m], v[m - 1], m - f);\n        }\n\n        return this.linear(v[i], v[i + 1 > m ? m : i + 1], f - i);\n\n    },\n\n    /**\n    * A Bezier Interpolation Method, mostly used by Phaser.Tween.\n    *\n    * @method Phaser.Math#bezierInterpolation\n    * @param {Array} v - The input array of values to interpolate between.\n    * @param {number} k - The percentage of interpolation, between 0 and 1.\n    * @return {number} The interpolated value\n    */\n    bezierInterpolation: function (v, k) {\n\n        var b = 0;\n        var n = v.length - 1;\n\n        for (var i = 0; i <= n; i++)\n        {\n            b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * this.bernstein(n, i);\n        }\n\n        return b;\n\n    },\n\n    /**\n    * A Catmull Rom Interpolation Method, mostly used by Phaser.Tween.\n    *\n    * @method Phaser.Math#catmullRomInterpolation\n    * @param {Array} v - The input array of values to interpolate between.\n    * @param {number} k - The percentage of interpolation, between 0 and 1.\n    * @return {number} The interpolated value\n    */\n    catmullRomInterpolation: function (v, k) {\n\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n\n        if (v[0] === v[m])\n        {\n            if (k < 0)\n            {\n                i = Math.floor(f = m * (1 + k));\n            }\n\n            return this.catmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n        }\n        else\n        {\n            if (k < 0)\n            {\n                return v[0] - (this.catmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);\n            }\n\n            if (k > 1)\n            {\n                return v[m] - (this.catmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            }\n\n            return this.catmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n\n    },\n\n    /**\n    * Calculates a linear (interpolation) value over t.\n    *\n    * @method Phaser.Math#linear\n    * @param {number} p0\n    * @param {number} p1\n    * @param {number} t - A value between 0 and 1.\n    * @return {number}\n    */\n    linear: function (p0, p1, t) {\n\n        return (p1 - p0) * t + p0;\n\n    },\n\n    /**\n    * @method Phaser.Math#bernstein\n    * @protected\n    * @param {number} n\n    * @param {number} i\n    * @return {number}\n    */\n    bernstein: function (n, i) {\n\n        return this.factorial(n) / this.factorial(i) / this.factorial(n - i);\n\n    },\n\n    /**\n    * @method Phaser.Math#factorial\n    * @param {number} value - the number you want to evaluate\n    * @return {number}\n    */\n    factorial: function (value) {\n\n        if (value === 0)\n        {\n            return 1;\n        }\n\n        var res = value;\n\n        while(--value)\n        {\n            res *= value;\n        }\n\n        return res;\n\n    },\n\n    /**\n    * Calculates a catmum rom value.\n    *\n    * @method Phaser.Math#catmullRom\n    * @protected\n    * @param {number} p0\n    * @param {number} p1\n    * @param {number} p2\n    * @param {number} p3\n    * @param {number} t\n    * @return {number}\n    */\n    catmullRom: function (p0, p1, p2, p3, t) {\n\n        var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;\n\n        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\n    },\n\n    /**\n    * The absolute difference between two values.\n    *\n    * @method Phaser.Math#difference\n    * @param {number} a - The first value to check.\n    * @param {number} b - The second value to check.\n    * @return {number} The absolute difference between the two values.\n    */\n    difference: function (a, b) {\n\n        return Math.abs(a - b);\n\n    },\n\n    /**\n    * Round to the next whole number _away_ from zero.\n    *\n    * @method Phaser.Math#roundAwayFromZero\n    * @param {number} value - Any number.\n    * @return {integer} The rounded value of that number.\n    */\n    roundAwayFromZero: function (value) {\n\n        // \"Opposite\" of truncate.\n        return (value > 0) ? Math.ceil(value) : Math.floor(value);\n\n    },\n\n    /**\n    * Generate a sine and cosine table simultaneously and extremely quickly.\n    * The parameters allow you to specify the length, amplitude and frequency of the wave.\n    * This generator is fast enough to be used in real-time.\n    * Code based on research by Franky of scene.at\n    *\n    * @method Phaser.Math#sinCosGenerator\n    * @param {number} length - The length of the wave\n    * @param {number} sinAmplitude - The amplitude to apply to the sine table (default 1.0) if you need values between say -+ 125 then give 125 as the value\n    * @param {number} cosAmplitude - The amplitude to apply to the cosine table (default 1.0) if you need values between say -+ 125 then give 125 as the value\n    * @param {number} frequency  - The frequency of the sine and cosine table data\n    * @return {{sin:number[], cos:number[]}} Returns the table data.\n    */\n    sinCosGenerator: function (length, sinAmplitude, cosAmplitude, frequency) {\n\n        if (sinAmplitude === undefined) { sinAmplitude = 1.0; }\n        if (cosAmplitude === undefined) { cosAmplitude = 1.0; }\n        if (frequency === undefined) { frequency = 1.0; }\n\n        var sin = sinAmplitude;\n        var cos = cosAmplitude;\n        var frq = frequency * Math.PI / length;\n\n        var cosTable = [];\n        var sinTable = [];\n\n        for (var c = 0; c < length; c++) {\n\n            cos -= sin * frq;\n            sin += cos * frq;\n\n            cosTable[c] = cos;\n            sinTable[c] = sin;\n\n        }\n\n        return { sin: sinTable, cos: cosTable, length: length };\n\n    },\n\n    /**\n    * Returns the euclidian distance between the two given set of coordinates.\n    *\n    * @method Phaser.Math#distance\n    * @param {number} x1\n    * @param {number} y1\n    * @param {number} x2\n    * @param {number} y2\n    * @return {number} The distance between the two sets of coordinates.\n    */\n    distance: function (x1, y1, x2, y2) {\n\n        var dx = x1 - x2;\n        var dy = y1 - y2;\n\n        return Math.sqrt(dx * dx + dy * dy);\n\n    },\n\n    /**\n    * Returns the euclidean distance squared between the two given set of\n    * coordinates (cuts out a square root operation before returning).\n    *\n    * @method Phaser.Math#distanceSq\n    * @param {number} x1\n    * @param {number} y1\n    * @param {number} x2\n    * @param {number} y2\n    * @return {number} The distance squared between the two sets of coordinates.\n    */\n    distanceSq: function (x1, y1, x2, y2) {\n\n        var dx = x1 - x2;\n        var dy = y1 - y2;\n\n        return dx * dx + dy * dy;\n\n    },\n\n    /**\n    * Returns the distance between the two given set of coordinates at the power given.\n    *\n    * @method Phaser.Math#distancePow\n    * @param {number} x1\n    * @param {number} y1\n    * @param {number} x2\n    * @param {number} y2\n    * @param {number} [pow=2]\n    * @return {number} The distance between the two sets of coordinates.\n    */\n    distancePow: function (x1, y1, x2, y2, pow) {\n\n        if (pow === undefined) { pow = 2; }\n\n        return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));\n\n    },\n\n    /**\n    * Force a value within the boundaries by clamping it to the range `min`, `max`.\n    *\n    * @method Phaser.Math#clamp\n    * @param {float} v - The value to be clamped.\n    * @param {float} min - The minimum bounds.\n    * @param {float} max - The maximum bounds.\n    * @return {number} The clamped value.\n    */\n    clamp: function (v, min, max) {\n\n        if (v < min)\n        {\n            return min;\n        }\n        else if (max < v)\n        {\n            return max;\n        }\n        else\n        {\n            return v;\n        }\n\n    },\n\n    /**\n    * Clamp `x` to the range `[a, Infinity)`.\n    * Roughly the same as `Math.max(x, a)`, except for NaN handling.\n    *\n    * @method Phaser.Math#clampBottom\n    * @param {number} x\n    * @param {number} a\n    * @return {number}\n    */\n    clampBottom: function (x, a) {\n\n        return x < a ? a : x;\n\n    },\n\n    /**\n    * Checks if two values are within the given tolerance of each other.\n    *\n    * @method Phaser.Math#within\n    * @param {number} a - The first number to check\n    * @param {number} b - The second number to check\n    * @param {number} tolerance - The tolerance. Anything equal to or less than this is considered within the range.\n    * @return {boolean} True if a is <= tolerance of b.\n    * @see {@link Phaser.Math.fuzzyEqual}\n    */\n    within: function (a, b, tolerance) {\n\n        return (Math.abs(a - b) <= tolerance);\n\n    },\n\n    /**\n    * Linear mapping from range <a1, a2> to range <b1, b2>\n    *\n    * @method Phaser.Math#mapLinear\n    * @param {number} x - The value to map\n    * @param {number} a1 - First endpoint of the range <a1, a2>\n    * @param {number} a2 - Final endpoint of the range <a1, a2>\n    * @param {number} b1 - First endpoint of the range <b1, b2>\n    * @param {number} b2 - Final endpoint of the range  <b1, b2>\n    * @return {number}\n    */\n    mapLinear: function (x, a1, a2, b1, b2) {\n\n        return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n    },\n\n    /**\n    * Smoothstep function as detailed at http://en.wikipedia.org/wiki/Smoothstep\n    *\n    * @method Phaser.Math#smoothstep\n    * @param {float} x - The input value.\n    * @param {float} min - The left edge. Should be smaller than the right edge.\n    * @param {float} max - The right edge.\n    * @return {float} A value between 0 and 1.\n    */\n    smoothstep: function (x, min, max) {\n\n        // Scale, bias and saturate x to 0..1 range\n        x = Math.max(0, Math.min(1, (x - min) / (max - min)));\n\n        // Evaluate polynomial\n        return x * x * (3 - 2 * x);\n\n    },\n\n    /**\n    * Smootherstep function as detailed at http://en.wikipedia.org/wiki/Smoothstep\n    *\n    * @method Phaser.Math#smootherstep\n    * @param {float} x - The input value.\n    * @param {float} min - The left edge. Should be smaller than the right edge.\n    * @param {float} max - The right edge.\n    * @return {float} A value between 0 and 1.\n    */\n    smootherstep: function (x, min, max) {\n\n        x = Math.max(0, Math.min(1, (x - min) / (max - min)));\n\n        return x * x * x * (x * (x * 6 - 15) + 10);\n\n    },\n\n    /**\n    * A value representing the sign of the value: -1 for negative, +1 for positive, 0 if value is 0.\n    *\n    * This works differently from `Math.sign` for values of NaN and -0, etc.\n    *\n    * @method Phaser.Math#sign\n    * @param {number} x\n    * @return {integer} An integer in {-1, 0, 1}\n    */\n    sign: function (x) {\n\n        return ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );\n\n    },\n\n    /**\n    * Work out what percentage value `a` is of value `b` using the given base.\n    *\n    * @method Phaser.Math#percent\n    * @param {number} a - The value to work out the percentage for.\n    * @param {number} b - The value you wish to get the percentage of.\n    * @param {number} [base=0] - The base value.\n    * @return {number} The percentage a is of b, between 0 and 1.\n    */\n    percent: function (a, b, base) {\n\n        if (base === undefined) { base = 0; }\n\n        if (a > b || base > b)\n        {\n            return 1;\n        }\n        else if (a < base || base > a)\n        {\n            return 0;\n        }\n        else\n        {\n            return (a - base) / b;\n        }\n\n    }\n\n};\n\nvar degreeToRadiansFactor = Math.PI / 180;\nvar radianToDegreesFactor = 180 / Math.PI;\n\n/**\n* Convert degrees to radians.\n*\n* @method Phaser.Math#degToRad\n* @param {number} degrees - Angle in degrees.\n* @return {number} Angle in radians.\n*/\nPhaser.Math.degToRad = function degToRad (degrees) {\n    return degrees * degreeToRadiansFactor;\n};\n\n/**\n* Convert radians to degrees.\n*\n* @method Phaser.Math#radToDeg\n* @param {number} radians - Angle in radians.\n* @return {number} Angle in degrees\n*/\nPhaser.Math.radToDeg = function radToDeg (radians) {\n    return radians * radianToDegreesFactor;\n};\n\n/* jshint noempty: false */\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* An extremely useful repeatable random data generator.\n*\n* Based on Nonsense by Josh Faul https://github.com/jocafa/Nonsense.\n*\n* The random number genererator is based on the Alea PRNG, but is modified.\n*  - https://github.com/coverslide/node-alea\n*  - https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n*  - http://baagoe.org/en/wiki/Better_random_numbers_for_javascript (original, perm. 404)\n*\n* @class Phaser.RandomDataGenerator\n* @constructor\n* @param {any[]|string} [seeds] - An array of values to use as the seed, or a generator state (from {#state}).\n*/\nPhaser.RandomDataGenerator = function (seeds) {\n\n    if (seeds === undefined) { seeds = []; }\n\n    /**\n    * @property {number} c - Internal var.\n    * @private\n    */\n    this.c = 1;\n\n    /**\n    * @property {number} s0 - Internal var.\n    * @private\n    */\n    this.s0 = 0;\n\n    /**\n    * @property {number} s1 - Internal var.\n    * @private\n    */\n    this.s1 = 0;\n\n    /**\n    * @property {number} s2 - Internal var.\n    * @private\n    */\n    this.s2 = 0;\n\n    if (typeof seeds === 'string')\n    {\n        this.state(seeds);\n    }\n    else\n    {\n        this.sow(seeds);\n    }\n\n};\n\nPhaser.RandomDataGenerator.prototype = {\n\n    /**\n    * Private random helper.\n    *\n    * @method Phaser.RandomDataGenerator#rnd\n    * @private\n    * @return {number}\n    */\n    rnd: function () {\n\n        var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\n\n        this.c = t | 0;\n        this.s0 = this.s1;\n        this.s1 = this.s2;\n        this.s2 = t - this.c;\n\n        return this.s2;\n    },\n\n    /**\n    * Reset the seed of the random data generator.\n    *\n    * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.\n    *\n    * @method Phaser.RandomDataGenerator#sow\n    * @param {any[]} seeds - The array of seeds: the `toString()` of each value is used.\n    */\n    sow: function (seeds) {\n\n        // Always reset to default seed\n        this.s0 = this.hash(' ');\n        this.s1 = this.hash(this.s0);\n        this.s2 = this.hash(this.s1);\n        this.c = 1;\n\n        if (!seeds)\n        {\n            return;\n        }\n\n        // Apply any seeds\n        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)\n        {\n            var seed = seeds[i];\n\n            this.s0 -= this.hash(seed);\n            this.s0 += ~~(this.s0 < 0);\n            this.s1 -= this.hash(seed);\n            this.s1 += ~~(this.s1 < 0);\n            this.s2 -= this.hash(seed);\n            this.s2 += ~~(this.s2 < 0);\n        }\n\n    },\n\n    /**\n    * Internal method that creates a seed hash.\n    *\n    * @method Phaser.RandomDataGenerator#hash\n    * @private\n    * @param {any} data\n    * @return {number} hashed value.\n    */\n    hash: function (data) {\n\n        var h, i, n;\n        n = 0xefc8249d;\n        data = data.toString();\n\n        for (i = 0; i < data.length; i++) {\n            n += data.charCodeAt(i);\n            h = 0.02519603282416938 * n;\n            n = h >>> 0;\n            h -= n;\n            h *= n;\n            n = h >>> 0;\n            h -= n;\n            n += h * 0x100000000;// 2^32\n        }\n\n        return (n >>> 0) * 2.3283064365386963e-10;// 2^-32\n\n    },\n\n    /**\n    * Returns a random integer between 0 and 2^32.\n    *\n    * @method Phaser.RandomDataGenerator#integer\n    * @return {number} A random integer between 0 and 2^32.\n    */\n    integer: function() {\n\n        return this.rnd.apply(this) * 0x100000000;// 2^32\n\n    },\n\n    /**\n    * Returns a random real number between 0 and 1.\n    *\n    * @method Phaser.RandomDataGenerator#frac\n    * @return {number} A random real number between 0 and 1.\n    */\n    frac: function() {\n\n        return this.rnd.apply(this) + (this.rnd.apply(this) * 0x200000 | 0) * 1.1102230246251565e-16;   // 2^-53\n\n    },\n\n    /**\n    * Returns a random real number between 0 and 2^32.\n    *\n    * @method Phaser.RandomDataGenerator#real\n    * @return {number} A random real number between 0 and 2^32.\n    */\n    real: function() {\n\n        return this.integer() + this.frac();\n\n    },\n\n    /**\n    * Returns a random integer between and including min and max.\n    *\n    * @method Phaser.RandomDataGenerator#integerInRange\n    * @param {number} min - The minimum value in the range.\n    * @param {number} max - The maximum value in the range.\n    * @return {number} A random number between min and max.\n    */\n    integerInRange: function (min, max) {\n\n        return Math.floor(this.realInRange(0, max - min + 1) + min);\n\n    },\n\n    /**\n    * Returns a random integer between and including min and max.\n    * This method is an alias for RandomDataGenerator.integerInRange.\n    *\n    * @method Phaser.RandomDataGenerator#between\n    * @param {number} min - The minimum value in the range.\n    * @param {number} max - The maximum value in the range.\n    * @return {number} A random number between min and max.\n    */\n    between: function (min, max) {\n\n        return this.integerInRange(min, max);\n\n    },\n\n    /**\n    * Returns a random real number between min and max.\n    *\n    * @method Phaser.RandomDataGenerator#realInRange\n    * @param {number} min - The minimum value in the range.\n    * @param {number} max - The maximum value in the range.\n    * @return {number} A random number between min and max.\n    */\n    realInRange: function (min, max) {\n\n        return this.frac() * (max - min) + min;\n\n    },\n\n    /**\n    * Returns a random real number between -1 and 1.\n    *\n    * @method Phaser.RandomDataGenerator#normal\n    * @return {number} A random real number between -1 and 1.\n    */\n    normal: function () {\n\n        return 1 - 2 * this.frac();\n\n    },\n\n    /**\n    * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368\n    *\n    * @method Phaser.RandomDataGenerator#uuid\n    * @return {string} A valid RFC4122 version4 ID hex string\n    */\n    uuid: function () {\n\n        var a = '';\n        var b = '';\n\n        for (b = a = ''; a++ < 36; b +=~a % 5 | a * 3&4 ? (a^15 ? 8^this.frac() * (a^20 ? 16 : 4) : 4).toString(16) : '-')\n        {\n        }\n\n        return b;\n\n    },\n\n    /**\n    * Returns a random member of `array`.\n    *\n    * @method Phaser.RandomDataGenerator#pick\n    * @param {Array} ary - An Array to pick a random member of.\n    * @return {any} A random member of the array.\n    */\n    pick: function (ary) {\n\n        return ary[this.integerInRange(0, ary.length - 1)];\n\n    },\n\n    /**\n    * Returns a sign to be used with multiplication operator.\n    *\n    * @method Phaser.RandomDataGenerator#sign\n    * @return {number} -1 or +1.\n    */\n    sign: function () {\n\n        return this.pick([-1, 1]);\n\n    },\n\n    /**\n    * Returns a random member of `array`, favoring the earlier entries.\n    *\n    * @method Phaser.RandomDataGenerator#weightedPick\n    * @param {Array} ary - An Array to pick a random member of.\n    * @return {any} A random member of the array.\n    */\n    weightedPick: function (ary) {\n\n        return ary[~~(Math.pow(this.frac(), 2) * (ary.length - 1) + 0.5)];\n\n    },\n\n    /**\n    * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.\n    *\n    * @method Phaser.RandomDataGenerator#timestamp\n    * @param {number} min - The minimum value in the range.\n    * @param {number} max - The maximum value in the range.\n    * @return {number} A random timestamp between min and max.\n    */\n    timestamp: function (min, max) {\n\n        return this.realInRange(min || 946684800000, max || 1577862000000);\n\n    },\n\n    /**\n    * Returns a random angle between -180 and 180.\n    *\n    * @method Phaser.RandomDataGenerator#angle\n    * @return {number} A random number between -180 and 180.\n    */\n    angle: function() {\n\n        return this.integerInRange(-180, 180);\n\n    },\n\n    /**\n    * Gets or Sets the state of the generator. This allows you to retain the values\n    * that the generator is using between games, i.e. in a game save file.\n    * \n    * To seed this generator with a previously saved state you can pass it as the \n    * `seed` value in your game config, or call this method directly after Phaser has booted.\n    *\n    * Call this method with no parameters to return the current state.\n    * \n    * If providing a state it should match the same format that this method\n    * returns, which is a string with a header `!rnd` followed by the `c`,\n    * `s0`, `s1` and `s2` values respectively, each comma-delimited. \n    *\n    * @method Phaser.RandomDataGenerator#state\n    * @param {string} [state] - Generator state to be set.\n    * @return {string} The current state of the generator.\n    */\n    state: function (state) {\n\n        if (typeof state === 'string' && state.match(/^!rnd/))\n        {\n            state = state.split(',');\n\n            this.c = parseFloat(state[1]);\n            this.s0 = parseFloat(state[2]);\n            this.s1 = parseFloat(state[3]);\n            this.s2 = parseFloat(state[4]);\n        }\n\n        return ['!rnd', this.c, this.s0, this.s1, this.s2].join(',');\n\n    }\n\n};\n\nPhaser.RandomDataGenerator.prototype.constructor = Phaser.RandomDataGenerator;\n\n/**\n * @author       Timo Hausmann\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2016 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n/**\n* A QuadTree implementation. The original code was a conversion of the Java code posted to GameDevTuts.\n* However I've tweaked it massively to add node indexing, removed lots of temp. var creation and significantly increased performance as a result.\n* Original version at https://github.com/timohausmann/quadtree-js/\n*\n* @class Phaser.QuadTree\n* @constructor\n* @param {number} x - The top left coordinate of the quadtree.\n* @param {number} y - The top left coordinate of the quadtree.\n* @param {number} width - The width of the quadtree in pixels.\n* @param {number} height - The height of the quadtree in pixels.\n* @param {number} [maxObjects=10] - The maximum number of objects per node.\n* @param {number} [maxLevels=4] - The maximum number of levels to iterate to.\n* @param {number} [level=0] - Which level is this?\n*/\nPhaser.QuadTree = function(x, y, width, height, maxObjects, maxLevels, level) {\n\n    /**\n    * @property {number} maxObjects - The maximum number of objects per node.\n    * @default\n    */\n    this.maxObjects = 10;\n\n    /**\n    * @property {number} maxLevels - The maximum number of levels to break down to.\n    * @default\n    */\n    this.maxLevels = 4;\n\n    /**\n    * @property {number} level - The current level.\n    */\n    this.level = 0;\n\n    /**\n    * @property {object} bounds - Object that contains the quadtree bounds.\n    */\n    this.bounds = {};\n\n    /**\n    * @property {array} objects - Array of quadtree children.\n    */\n    this.objects = [];\n\n    /**\n    * @property {array} nodes - Array of associated child nodes.\n    */\n    this.nodes = [];\n\n    /**\n    * @property {array} _empty - Internal empty array.\n    * @private\n    */\n    this._empty = [];\n\n    this.reset(x, y, width, height, maxObjects, maxLevels, level);\n\n};\n\nPhaser.QuadTree.prototype = {\n\n    /**\n    * Resets the QuadTree.\n    *\n    * @method Phaser.QuadTree#reset\n    * @param {number} x - The top left coordinate of the quadtree.\n    * @param {number} y - The top left coordinate of the quadtree.\n    * @param {number} width - The width of the quadtree in pixels.\n    * @param {number} height - The height of the quadtree in pixels.\n    * @param {number} [maxObjects=10] - The maximum number of objects per node.\n    * @param {number} [maxLevels=4] - The maximum number of levels to iterate to.\n    * @param {number} [level=0] - Which level is this?\n    */\n    reset: function (x, y, width, height, maxObjects, maxLevels, level) {\n\n        this.maxObjects = maxObjects || 10;\n        this.maxLevels = maxLevels || 4;\n        this.level = level || 0;\n\n        this.bounds = {\n            x: Math.round(x),\n            y: Math.round(y),\n            width: width,\n            height: height,\n            subWidth: Math.floor(width / 2),\n            subHeight: Math.floor(height / 2),\n            right: Math.round(x) + Math.floor(width / 2),\n            bottom: Math.round(y) + Math.floor(height / 2)\n        };\n\n        this.objects.length = 0;\n        this.nodes.length = 0;\n\n    },\n\n    /**\n    * Populates this quadtree with the children of the given Group. In order to be added the child must exist and have a body property.\n    *\n    * @method Phaser.QuadTree#populate\n    * @param {Phaser.Group} group - The Group to add to the quadtree.\n    */\n    populate: function (group) {\n\n        group.forEach(this.populateHandler, this, true);\n\n    },\n\n    /**\n    * Handler for the populate method.\n    *\n    * @method Phaser.QuadTree#populateHandler\n    * @param {Phaser.Sprite|object} sprite - The Sprite to check.\n    */\n    populateHandler: function (sprite) {\n\n        if (sprite.body && sprite.exists)\n        {\n            this.insert(sprite.body);\n        }\n\n    },\n\n    /**\n    * Split the node into 4 subnodes\n    *\n    * @method Phaser.QuadTree#split\n    */\n    split: function () {\n\n        //  top right node\n        this.nodes[0] = new Phaser.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, (this.level + 1));\n\n        //  top left node\n        this.nodes[1] = new Phaser.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, (this.level + 1));\n\n        //  bottom left node\n        this.nodes[2] = new Phaser.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, (this.level + 1));\n\n        //  bottom right node\n        this.nodes[3] = new Phaser.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, (this.level + 1));\n\n    },\n\n    /**\n    * Insert the object into the node. If the node exceeds the capacity, it will split and add all objects to their corresponding subnodes.\n    *\n    * @method Phaser.QuadTree#insert\n    * @param {Phaser.Physics.Arcade.Body|object} body - The Body object to insert into the quadtree. Can be any object so long as it exposes x, y, right and bottom properties.\n    */\n    insert: function (body) {\n\n        var i = 0;\n        var index;\n\n        //  if we have subnodes ...\n        if (this.nodes[0] != null)\n        {\n            index = this.getIndex(body);\n\n            if (index !== -1)\n            {\n                this.nodes[index].insert(body);\n                return;\n            }\n        }\n\n        this.objects.push(body);\n\n        if (this.objects.length > this.maxObjects && this.level < this.maxLevels)\n        {\n            //  Split if we don't already have subnodes\n            if (this.nodes[0] == null)\n            {\n                this.split();\n            }\n\n            //  Add objects to subnodes\n            while (i < this.objects.length)\n            {\n                index = this.getIndex(this.objects[i]);\n\n                if (index !== -1)\n                {\n                    //  this is expensive - see what we can do about it\n                    this.nodes[index].insert(this.objects.splice(i, 1)[0]);\n                }\n                else\n                {\n                    i++;\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Determine which node the object belongs to.\n    *\n    * @method Phaser.QuadTree#getIndex\n    * @param {Phaser.Rectangle|object} rect - The bounds in which to check.\n    * @return {number} index - Index of the subnode (0-3), or -1 if rect cannot completely fit within a subnode and is part of the parent node.\n    */\n    getIndex: function (rect) {\n\n        //  default is that rect doesn't fit, i.e. it straddles the internal quadrants\n        var index = -1;\n\n        if (rect.x < this.bounds.right && rect.right < this.bounds.right)\n        {\n            if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom)\n            {\n                //  rect fits within the top-left quadrant of this quadtree\n                index = 1;\n            }\n            else if (rect.y > this.bounds.bottom)\n            {\n                //  rect fits within the bottom-left quadrant of this quadtree\n                index = 2;\n            }\n        }\n        else if (rect.x > this.bounds.right)\n        {\n            //  rect can completely fit within the right quadrants\n            if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom)\n            {\n                //  rect fits within the top-right quadrant of this quadtree\n                index = 0;\n            }\n            else if (rect.y > this.bounds.bottom)\n            {\n                //  rect fits within the bottom-right quadrant of this quadtree\n                index = 3;\n            }\n        }\n\n        return index;\n\n    },\n\n    /**\n    * Return all objects that could collide with the given Sprite or Rectangle.\n    *\n    * @method Phaser.QuadTree#retrieve\n    * @param {Phaser.Sprite|Phaser.Rectangle} source - The source object to check the QuadTree against. Either a Sprite or Rectangle.\n    * @return {array} - Array with all detected objects.\n    */\n    retrieve: function (source) {\n\n        if (source instanceof Phaser.Rectangle)\n        {\n            var returnObjects = this.objects;\n\n            var index = this.getIndex(source);\n        }\n        else\n        {\n            if (!source.body)\n            {\n                return this._empty;\n            }\n\n            var returnObjects = this.objects;\n\n            var index = this.getIndex(source.body);\n        }\n\n        if (this.nodes[0])\n        {\n            //  If rect fits into a subnode ..\n            if (index !== -1)\n            {\n                returnObjects = returnObjects.concat(this.nodes[index].retrieve(source));\n            }\n            else\n            {\n                //  If rect does not fit into a subnode, check it against all subnodes (unrolled for speed)\n                returnObjects = returnObjects.concat(this.nodes[0].retrieve(source));\n                returnObjects = returnObjects.concat(this.nodes[1].retrieve(source));\n                returnObjects = returnObjects.concat(this.nodes[2].retrieve(source));\n                returnObjects = returnObjects.concat(this.nodes[3].retrieve(source));\n            }\n        }\n\n        return returnObjects;\n\n    },\n\n    /**\n    * Clear the quadtree.\n    * @method Phaser.QuadTree#clear\n    */\n    clear: function () {\n\n        this.objects.length = 0;\n\n        var i = this.nodes.length;\n\n        while (i--)\n        {\n            this.nodes[i].clear();\n            this.nodes.splice(i, 1);\n        }\n\n        this.nodes.length = 0;\n    }\n\n};\n\nPhaser.QuadTree.prototype.constructor = Phaser.QuadTree;\n\n/**\n* Javascript QuadTree\n* @version 1.0\n*\n* @version 1.3, March 11th 2014\n* @author Richard Davey\n* The original code was a conversion of the Java code posted to GameDevTuts. However I've tweaked\n* it massively to add node indexing, removed lots of temp. var creation and significantly\n* increased performance as a result.\n*\n* Original version at https://github.com/timohausmann/quadtree-js/\n*/\n\n/**\n* @copyright © 2012 Timo Hausmann\n*\n* Permission is hereby granted, free of charge, to any person obtaining\n* a copy of this software and associated documentation files (the\n* \"Software\"), to deal in the Software without restriction, including\n* without limitation the rights to use, copy, modify, merge, publish,\n* distribute, sublicense, and/or sell copies of the Software, and to\n* permit persons to whom the Software is furnished to do so, subject to\n* the following conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* @author       Steven Rogers <soldoutactivist@gmail.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* This is a stub for the Phaser Net Class.\n* It allows you to exclude the default Net from your build, without making Game crash.\n*/\n\nvar netNoop = function () {};\n\nPhaser.Net = netNoop;\n\nPhaser.Net.prototype = {\n    isDisabled: true,\n\n    getHostName: netNoop,\n    checkDomainName: netNoop,\n    updateQueryString: netNoop,\n    getQueryString: netNoop,\n    decodeURI: netNoop\n};\n\nPhaser.Net.prototype.constructor = Phaser.Net;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Game has a single instance of the TweenManager through which all Tween objects are created and updated.\n* Tweens are hooked into the game clock and pause system, adjusting based on the game state.\n*\n* TweenManager is based heavily on tween.js by http://soledadpenades.com.\n* The difference being that tweens belong to a games instance of TweenManager, rather than to a global TWEEN object.\n* It also has callbacks swapped for Signals and a few issues patched with regard to properties and completion errors.\n* Please see https://github.com/sole/tween.js for a full list of contributors.\n* \n* @class Phaser.TweenManager\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.TweenManager = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * Are all newly created Tweens frame or time based? A frame based tween will use the physics elapsed timer when updating. This means\n    * it will retain the same consistent frame rate, regardless of the speed of the device. The duration value given should\n    * be given in frames.\n    * \n    * If the Tween uses a time based update (which is the default) then the duration is given in milliseconds.\n    * In this situation a 2000ms tween will last exactly 2 seconds, regardless of the device and how many visual updates the tween\n    * has actually been through. For very short tweens you may wish to experiment with a frame based update instead.\n    * @property {boolean} frameBased\n    * @default\n    */\n    this.frameBased = false;\n\n    /**\n    * @property {array<Phaser.Tween>} _tweens - All of the currently running tweens.\n    * @private\n    */\n    this._tweens = [];\n\n    /**\n    * @property {array<Phaser.Tween>} _add - All of the tweens queued to be added in the next update.\n    * @private\n    */\n    this._add = [];\n\n    this.easeMap = {\n\n        \"Power0\": Phaser.Easing.Power0,\n        \"Power1\": Phaser.Easing.Power1,\n        \"Power2\": Phaser.Easing.Power2,\n        \"Power3\": Phaser.Easing.Power3,\n        \"Power4\": Phaser.Easing.Power4,\n\n        \"Linear\": Phaser.Easing.Linear.None,\n        \"Quad\": Phaser.Easing.Quadratic.Out,\n        \"Cubic\": Phaser.Easing.Cubic.Out,\n        \"Quart\": Phaser.Easing.Quartic.Out,\n        \"Quint\": Phaser.Easing.Quintic.Out,\n        \"Sine\": Phaser.Easing.Sinusoidal.Out,\n        \"Expo\": Phaser.Easing.Exponential.Out,\n        \"Circ\": Phaser.Easing.Circular.Out,\n        \"Elastic\": Phaser.Easing.Elastic.Out,\n        \"Back\": Phaser.Easing.Back.Out,\n        \"Bounce\": Phaser.Easing.Bounce.Out,\n\n        \"Quad.easeIn\": Phaser.Easing.Quadratic.In,\n        \"Cubic.easeIn\": Phaser.Easing.Cubic.In,\n        \"Quart.easeIn\": Phaser.Easing.Quartic.In,\n        \"Quint.easeIn\": Phaser.Easing.Quintic.In,\n        \"Sine.easeIn\": Phaser.Easing.Sinusoidal.In,\n        \"Expo.easeIn\": Phaser.Easing.Exponential.In,\n        \"Circ.easeIn\": Phaser.Easing.Circular.In,\n        \"Elastic.easeIn\": Phaser.Easing.Elastic.In,\n        \"Back.easeIn\": Phaser.Easing.Back.In,\n        \"Bounce.easeIn\": Phaser.Easing.Bounce.In,\n\n        \"Quad.easeOut\": Phaser.Easing.Quadratic.Out,\n        \"Cubic.easeOut\": Phaser.Easing.Cubic.Out,\n        \"Quart.easeOut\": Phaser.Easing.Quartic.Out,\n        \"Quint.easeOut\": Phaser.Easing.Quintic.Out,\n        \"Sine.easeOut\": Phaser.Easing.Sinusoidal.Out,\n        \"Expo.easeOut\": Phaser.Easing.Exponential.Out,\n        \"Circ.easeOut\": Phaser.Easing.Circular.Out,\n        \"Elastic.easeOut\": Phaser.Easing.Elastic.Out,\n        \"Back.easeOut\": Phaser.Easing.Back.Out,\n        \"Bounce.easeOut\": Phaser.Easing.Bounce.Out,\n\n        \"Quad.easeInOut\": Phaser.Easing.Quadratic.InOut,\n        \"Cubic.easeInOut\": Phaser.Easing.Cubic.InOut,\n        \"Quart.easeInOut\": Phaser.Easing.Quartic.InOut,\n        \"Quint.easeInOut\": Phaser.Easing.Quintic.InOut,\n        \"Sine.easeInOut\": Phaser.Easing.Sinusoidal.InOut,\n        \"Expo.easeInOut\": Phaser.Easing.Exponential.InOut,\n        \"Circ.easeInOut\": Phaser.Easing.Circular.InOut,\n        \"Elastic.easeInOut\": Phaser.Easing.Elastic.InOut,\n        \"Back.easeInOut\": Phaser.Easing.Back.InOut,\n        \"Bounce.easeInOut\": Phaser.Easing.Bounce.InOut\n\n    };\n\n    this.game.onPause.add(this._pauseAll, this);\n    this.game.onResume.add(this._resumeAll, this);\n\n};\n\nPhaser.TweenManager.prototype = {\n\n    /**\n    * Get all the tween objects in an array.\n    * @method Phaser.TweenManager#getAll\n    * @returns {Phaser.Tween[]} Array with all tween objects.\n    */\n    getAll: function () {\n\n        return this._tweens;\n\n    },\n\n    /**\n    * Remove all tweens running and in the queue. Doesn't call any of the tween onComplete events.\n    * @method Phaser.TweenManager#removeAll\n    */\n    removeAll: function () {\n\n        for (var i = 0; i < this._tweens.length; i++)\n        {\n            this._tweens[i].pendingDelete = true;\n        }\n\n        this._add = [];\n\n    },\n    \n    /**\n    * Remove all tweens from a specific object, array of objects or Group.\n    * \n    * @method Phaser.TweenManager#removeFrom\n    * @param {object|object[]|Phaser.Group} obj - The object you want to remove the tweens from.\n    * @param {boolean} [children=true] - If passing a group, setting this to true will remove the tweens from all of its children instead of the group itself.\n    */\n    removeFrom: function (obj, children) {\n        \n        if (children === undefined) { children = true; }\n\n        var i;\n        var len;\n\n        if (Array.isArray(obj))\n        {\n            for (i = 0, len = obj.length; i < len; i++)\n            {\n                this.removeFrom(obj[i]);\n            }\n        }\n        else if (obj.type === Phaser.GROUP && children)\n        {\n            for (var i = 0, len = obj.children.length; i < len; i++)\n            {\n                this.removeFrom(obj.children[i]);\n            }\n        }\n        else\n        {\n            for (i = 0, len = this._tweens.length; i < len; i++)\n            {\n                if (obj === this._tweens[i].target)\n                {\n                    this.remove(this._tweens[i]);\n                }\n            }\n\n            for (i = 0, len = this._add.length; i < len; i++)\n            {\n                if (obj === this._add[i].target)\n                {\n                    this.remove(this._add[i]);\n                }\n            }\n        }\n        \n    },\n\n    /**\n    * Add a new tween into the TweenManager.\n    *\n    * @method Phaser.TweenManager#add\n    * @param {Phaser.Tween} tween - The tween object you want to add.\n    * @returns {Phaser.Tween} The tween object you added to the manager.\n    */\n    add: function (tween) {\n\n        tween._manager = this;\n        this._add.push(tween);\n\n    },\n\n    /**\n    * Create a tween object for a specific object. The object can be any JavaScript object or Phaser object such as Sprite.\n    *\n    * @method Phaser.TweenManager#create\n    * @param {object} object - Object the tween will be run on.\n    * @returns {Phaser.Tween} The newly created tween object.\n    */\n    create: function (object) {\n\n        return new Phaser.Tween(object, this.game, this);\n\n    },\n\n    /**\n    * Remove a tween from this manager.\n    *\n    * @method Phaser.TweenManager#remove\n    * @param {Phaser.Tween} tween - The tween object you want to remove.\n    */\n    remove: function (tween) {\n\n        var i = this._tweens.indexOf(tween);\n\n        if (i !== -1)\n        {\n            this._tweens[i].pendingDelete = true;\n        }\n        else\n        {\n            i = this._add.indexOf(tween);\n\n            if (i !== -1)\n            {\n                this._add[i].pendingDelete = true;\n            }\n        }\n\n    },\n\n    /**\n    * Update all the tween objects you added to this manager.\n    *\n    * @method Phaser.TweenManager#update\n    * @returns {boolean} Return false if there's no tween to update, otherwise return true.\n    */\n    update: function () {\n\n        var addTweens = this._add.length;\n        var numTweens = this._tweens.length;\n\n        if (numTweens === 0 && addTweens === 0)\n        {\n            return false;\n        }\n\n        var i = 0;\n\n        while (i < numTweens)\n        {\n            if (this._tweens[i].update(this.game.time.time))\n            {\n                i++;\n            }\n            else\n            {\n                this._tweens.splice(i, 1);\n\n                numTweens--;\n            }\n        }\n\n        //  If there are any new tweens to be added, do so now - otherwise they can be spliced out of the array before ever running\n        if (addTweens > 0)\n        {\n            this._tweens = this._tweens.concat(this._add);\n            this._add.length = 0;\n        }\n\n        return true;\n\n    },\n\n    /**\n    * Checks to see if a particular Sprite is currently being tweened.\n    *\n    * @method Phaser.TweenManager#isTweening\n    * @param {object} object - The object to check for tweens against.\n    * @returns {boolean} Returns true if the object is currently being tweened, false if not.\n    */\n    isTweening: function(object) {\n\n        return this._tweens.some(function(tween) {\n            return tween.target === object;\n        });\n\n    },\n\n    /**\n    * Private. Called by game focus loss. Pauses all currently running tweens.\n    *\n    * @method Phaser.TweenManager#_pauseAll\n    * @private\n    */\n    _pauseAll: function () {\n\n        for (var i = this._tweens.length - 1; i >= 0; i--)\n        {\n            this._tweens[i]._pause();\n        }\n\n    },\n\n    /**\n    * Private. Called by game focus loss. Resumes all currently paused tweens.\n    *\n    * @method Phaser.TweenManager#_resumeAll\n    * @private\n    */\n    _resumeAll: function () {\n\n        for (var i = this._tweens.length - 1; i >= 0; i--)\n        {\n            this._tweens[i]._resume();\n        }\n\n    },\n\n    /**\n    * Pauses all currently running tweens.\n    *\n    * @method Phaser.TweenManager#pauseAll\n    */\n    pauseAll: function () {\n\n        for (var i = this._tweens.length - 1; i >= 0; i--)\n        {\n            this._tweens[i].pause();\n        }\n\n    },\n\n    /**\n    * Resumes all currently paused tweens.\n    *\n    * @method Phaser.TweenManager#resumeAll\n    */\n    resumeAll: function () {\n\n        for (var i = this._tweens.length - 1; i >= 0; i--)\n        {\n            this._tweens[i].resume(true);\n        }\n\n    }\n\n};\n\nPhaser.TweenManager.prototype.constructor = Phaser.TweenManager;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Tween allows you to alter one or more properties of a target object over a defined period of time.\n* This can be used for things such as alpha fading Sprites, scaling them or motion.\n* Use `Tween.to` or `Tween.from` to set-up the tween values. You can create multiple tweens on the same object\n* by calling Tween.to multiple times on the same Tween. Additional tweens specified in this way become \"child\" tweens and\n* are played through in sequence. You can use Tween.timeScale and Tween.reverse to control the playback of this Tween and all of its children.\n*\n* @class Phaser.Tween\n* @constructor\n* @param {object} target - The target object, such as a Phaser.Sprite or Phaser.Sprite.scale.\n* @param {Phaser.Game} game - Current game instance.\n* @param {Phaser.TweenManager} manager - The TweenManager responsible for looking after this Tween.\n*/\nPhaser.Tween = function (target, game, manager) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {object} target - The target object, such as a Phaser.Sprite or property like Phaser.Sprite.scale.\n    */\n    this.target = target;\n\n    /**\n    * @property {Phaser.TweenManager} manager - Reference to the TweenManager responsible for updating this Tween.\n    */\n    this.manager = manager;\n\n    /**\n    * @property {Array} timeline - An Array of TweenData objects that comprise the different parts of this Tween.\n    */\n    this.timeline = [];\n\n    /**\n    * If set to `true` the current tween will play in reverse.\n    * If the tween hasn't yet started this has no effect.\n    * If there are child tweens then all child tweens will play in reverse from the current point.\n    * @property {boolean} reverse\n    * @default\n    */\n    this.reverse = false;\n\n    /**\n    * The speed at which the tweens will run. A value of 1 means it will match the game frame rate. 0.5 will run at half the frame rate. 2 at double the frame rate, etc.\n    * If a tweens duration is 1 second but timeScale is 0.5 then it will take 2 seconds to complete.\n    *\n    * @property {number} timeScale\n    * @default\n    */\n    this.timeScale = 1;\n\n    /**\n    * @property {number} repeatCounter - If the Tween and any child tweens are set to repeat this contains the current repeat count.\n    */\n    this.repeatCounter = 0;\n\n    /**\n    * @property {boolean} pendingDelete - True if this Tween is ready to be deleted by the TweenManager.\n    * @default\n    * @readonly\n    */\n    this.pendingDelete = false;\n\n    /**\n    * The onStart event is fired when the Tween begins. If there is a delay before the tween starts then onStart fires after the delay is finished.\n    * It will be sent 2 parameters: the target object and this tween.\n    * @property {Phaser.Signal} onStart\n    */\n    this.onStart = new Phaser.Signal();\n\n    /**\n    * The onLoop event is fired if the Tween, or any child tweens loop.\n    * It will be sent 2 parameters: the target object and this tween.\n    * \n    * @property {Phaser.Signal} onLoop\n    */\n    this.onLoop = new Phaser.Signal();\n\n    /**\n    * The onRepeat event is fired if the Tween and all of its children repeats. If this tween has no children this will never be fired.\n    * It will be sent 2 parameters: the target object and this tween.\n    * @property {Phaser.Signal} onRepeat\n    */\n    this.onRepeat = new Phaser.Signal();\n\n    /**\n    * The onChildComplete event is fired when the Tween or any of its children completes.\n    * Fires every time a child completes unless a child is set to repeat forever.\n    * It will be sent 2 parameters: the target object and this tween.\n    * @property {Phaser.Signal} onChildComplete\n    */\n    this.onChildComplete = new Phaser.Signal();\n\n    /**\n    * The onComplete event is fired when the Tween and all of its children completes. Does not fire if the Tween is set to loop or repeatAll(-1).\n    * It will be sent 2 parameters: the target object and this tween.\n    * @property {Phaser.Signal} onComplete\n    */\n    this.onComplete = new Phaser.Signal();\n\n    /**\n    * @property {boolean} isRunning - If the tween is running this is set to true, otherwise false. Tweens that are in a delayed state or waiting to start are considered as being running.\n    * @default\n    */\n    this.isRunning = false;\n\n    /**\n    * @property {number} current - The current Tween child being run.\n    * @default\n    * @readonly\n    */\n    this.current = 0;\n\n    /**\n    * @property {object} properties - Target property cache used when building the child data values.\n    */\n    this.properties = {};\n\n    /**\n    * @property {Phaser.Tween} chainedTween - If this Tween is chained to another this holds a reference to it.\n    */\n    this.chainedTween = null;\n\n    /**\n    * @property {boolean} isPaused - Is this Tween paused or not?\n    * @default\n    */\n    this.isPaused = false;\n\n    /**\n    * Is this Tween frame or time based? A frame based tween will use the physics elapsed timer when updating. This means\n    * it will retain the same consistent frame rate, regardless of the speed of the device. The duration value given should\n    * be given in frames.\n    *\n    * If the Tween uses a time based update (which is the default) then the duration is given in milliseconds.\n    * In this situation a 2000ms tween will last exactly 2 seconds, regardless of the device and how many visual updates the tween\n    * has actually been through. For very short tweens you may wish to experiment with a frame based update instead.\n    *\n    * The default value is whatever you've set in TweenManager.frameBased.\n    *\n    * @property {boolean} frameBased\n    * @default\n    */\n    this.frameBased = manager.frameBased;\n\n    /**\n    * @property {function} _onUpdateCallback - An onUpdate callback.\n    * @private\n    * @default null\n    */\n    this._onUpdateCallback = null;\n\n    /**\n    * @property {object} _onUpdateCallbackContext - The context in which to call the onUpdate callback.\n    * @private\n    * @default null\n    */\n    this._onUpdateCallbackContext = null;\n\n    /**\n    * @property {number} _pausedTime - Private pause timer.\n    * @private\n    * @default\n    */\n    this._pausedTime = 0;\n\n    /**\n    * @property {boolean} _codePaused - Was the Tween paused by code or by Game focus loss?\n    * @private\n    */\n    this._codePaused = false;\n\n    /**\n    * @property {boolean} _hasStarted - Internal var to track if the Tween has started yet or not.\n    * @private\n    */\n    this._hasStarted = false;\n};\n\nPhaser.Tween.prototype = {\n\n    /**\n    * Sets this tween to be a `to` tween on the properties given. A `to` tween starts at the current value and tweens to the destination value given.\n    * For example a Sprite with an `x` coordinate of 100 could be tweened to `x` 200 by giving a properties object of `{ x: 200 }`.\n    * The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as \"Circ\".\n    * \".easeIn\", \".easeOut\" and \"easeInOut\" variants are all supported for all ease types.\n    *\n    * @method Phaser.Tween#to\n    * @param {object} properties - An object containing the properties you want to tween, such as `Sprite.x` or `Sound.volume`. Given as a JavaScript object.\n    * @param {number} [duration=1000] - Duration of this tween in ms. Or if `Tween.frameBased` is true this represents the number of frames that should elapse.\n    * @param {function|string} [ease=null] - Easing function. If not set it will default to Phaser.Easing.Default, which is Phaser.Easing.Linear.None by default but can be over-ridden.\n    * @param {boolean} [autoStart=false] - Set to `true` to allow this tween to start automatically. Otherwise call Tween.start().\n    * @param {number} [delay=0] - Delay before this tween will start in milliseconds. Defaults to 0, no delay.\n    * @param {number} [repeat=0] - Should the tween automatically restart once complete? If you want it to run forever set as -1. This only effects this individual tween, not any chained tweens.\n    * @param {boolean} [yoyo=false] - A tween that yoyos will reverse itself and play backwards automatically. A yoyo'd tween doesn't fire the Tween.onComplete event, so listen for Tween.onLoop instead.\n    * @return {Phaser.Tween} This Tween object.\n    */\n    to: function (properties, duration, ease, autoStart, delay, repeat, yoyo) {\n\n        if (duration === undefined || duration <= 0) { duration = 1000; }\n        if (ease === undefined || ease === null) { ease = Phaser.Easing.Default; }\n        if (autoStart === undefined) { autoStart = false; }\n        if (delay === undefined) { delay = 0; }\n        if (repeat === undefined) { repeat = 0; }\n        if (yoyo === undefined) { yoyo = false; }\n\n        if (typeof ease === 'string' && this.manager.easeMap[ease])\n        {\n            ease = this.manager.easeMap[ease];\n        }\n\n        if (this.isRunning)\n        {\n            console.warn('Phaser.Tween.to cannot be called after Tween.start');\n            return this;\n        }\n\n        this.timeline.push(new Phaser.TweenData(this).to(properties, duration, ease, delay, repeat, yoyo));\n\n        if (autoStart)\n        {\n            this.start();\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Sets this tween to be a `from` tween on the properties given. A `from` tween sets the target to the destination value and tweens to its current value.\n    * For example a Sprite with an `x` coordinate of 100 tweened from `x` 500 would be set to `x` 500 and then tweened to `x` 100 by giving a properties object of `{ x: 500 }`.\n    * The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as \"Circ\".\n    * \".easeIn\", \".easeOut\" and \"easeInOut\" variants are all supported for all ease types.\n    *\n    * @method Phaser.Tween#from\n    * @param {object} properties - An object containing the properties you want to tween., such as `Sprite.x` or `Sound.volume`. Given as a JavaScript object.\n    * @param {number} [duration=1000] - Duration of this tween in ms. Or if `Tween.frameBased` is true this represents the number of frames that should elapse.\n    * @param {function|string} [ease=null] - Easing function. If not set it will default to Phaser.Easing.Default, which is Phaser.Easing.Linear.None by default but can be over-ridden.\n    * @param {boolean} [autoStart=false] - Set to `true` to allow this tween to start automatically. Otherwise call Tween.start().\n    * @param {number} [delay=0] - Delay before this tween will start in milliseconds. Defaults to 0, no delay.\n    * @param {number} [repeat=0] - Should the tween automatically restart once complete? If you want it to run forever set as -1. This only effects this individual tween, not any chained tweens.\n    * @param {boolean} [yoyo=false] - A tween that yoyos will reverse itself and play backwards automatically. A yoyo'd tween doesn't fire the Tween.onComplete event, so listen for Tween.onLoop instead.\n    * @return {Phaser.Tween} This Tween object.\n    */\n    from: function (properties, duration, ease, autoStart, delay, repeat, yoyo) {\n\n        if (duration === undefined) { duration = 1000; }\n        if (ease === undefined || ease === null) { ease = Phaser.Easing.Default; }\n        if (autoStart === undefined) { autoStart = false; }\n        if (delay === undefined) { delay = 0; }\n        if (repeat === undefined) { repeat = 0; }\n        if (yoyo === undefined) { yoyo = false; }\n\n        if (typeof ease === 'string' && this.manager.easeMap[ease])\n        {\n            ease = this.manager.easeMap[ease];\n        }\n\n        if (this.isRunning)\n        {\n            console.warn('Phaser.Tween.from cannot be called after Tween.start');\n            return this;\n        }\n\n        this.timeline.push(new Phaser.TweenData(this).from(properties, duration, ease, delay, repeat, yoyo));\n\n        if (autoStart)\n        {\n            this.start();\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Starts the tween running. Can also be called by the autoStart parameter of `Tween.to` or `Tween.from`.\n    * This sets the `Tween.isRunning` property to `true` and dispatches a `Tween.onStart` signal.\n    * If the Tween has a delay set then nothing will start tweening until the delay has expired.\n    *\n    * @method Phaser.Tween#start\n    * @param {number} [index=0] - If this Tween contains child tweens you can specify which one to start from. The default is zero, i.e. the first tween created.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    start: function (index) {\n\n        if (index === undefined) { index = 0; }\n\n        if (this.game === null || this.target === null || this.timeline.length === 0 || this.isRunning)\n        {\n            return this;\n        }\n\n        //  Populate the tween data\n        for (var i = 0; i < this.timeline.length; i++)\n        {\n            //  Build our master property list with the starting values\n            for (var property in this.timeline[i].vEnd)\n            {\n                this.properties[property] = this.target[property] || 0;\n\n                if (!Array.isArray(this.properties[property]))\n                {\n                    //  Ensures we're using numbers, not strings\n                    this.properties[property] *= 1.0;\n                }\n            }\n        }\n\n        for (var i = 0; i < this.timeline.length; i++)\n        {\n            this.timeline[i].loadValues();\n        }\n\n        this.manager.add(this);\n\n        this.isRunning = true;\n\n        if (index < 0 || index > this.timeline.length - 1)\n        {\n            index = 0;\n        }\n\n        this.current = index;\n\n        this.timeline[this.current].start();\n\n        return this;\n\n    },\n\n    /**\n    * Stops the tween if running and flags it for deletion from the TweenManager.\n    * If called directly the `Tween.onComplete` signal is not dispatched and no chained tweens are started unless the complete parameter is set to `true`.\n    * If you just wish to pause a tween then use Tween.pause instead.\n    *\n    * @method Phaser.Tween#stop\n    * @param {boolean} [complete=false] - Set to `true` to dispatch the Tween.onComplete signal.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    stop: function (complete) {\n\n        if (complete === undefined) { complete = false; }\n\n        this.isRunning = false;\n\n        this._onUpdateCallback = null;\n        this._onUpdateCallbackContext = null;\n\n        if (complete)\n        {\n            this.onComplete.dispatch(this.target, this);\n            this._hasStarted = false;\n\n            if (this.chainedTween)\n            {\n                this.chainedTween.start();\n            }\n        }\n\n        this.manager.remove(this);\n\n        return this;\n\n    },\n\n    /**\n    * Updates either a single TweenData or all TweenData objects properties to the given value.\n    * Used internally by methods like Tween.delay, Tween.yoyo, etc. but can also be called directly if you know which property you want to tweak.\n    * The property is not checked, so if you pass an invalid one you'll generate a run-time error.\n    *\n    * @method Phaser.Tween#updateTweenData\n    * @param {string} property - The property to update.\n    * @param {number|function} value - The value to set the property to.\n    * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the delay on all the children.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    updateTweenData: function (property, value, index) {\n\n        if (this.timeline.length === 0) { return this; }\n\n        if (index === undefined) { index = 0; }\n\n        if (index === -1)\n        {\n            for (var i = 0; i < this.timeline.length; i++)\n            {\n                this.timeline[i][property] = value;\n            }\n        }\n        else\n        {\n            this.timeline[index][property] = value;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Sets the delay in milliseconds before this tween will start. If there are child tweens it sets the delay before the first child starts.\n    * The delay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.\n    * If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to delay.\n    * If you have child tweens and pass -1 as the index value it sets the delay across all of them.\n    *\n    * @method Phaser.Tween#delay\n    * @param {number} duration - The amount of time in ms that the Tween should wait until it begins once started is called. Set to zero to remove any active delay.\n    * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the delay on all the children.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    delay: function (duration, index) {\n\n        return this.updateTweenData('delay', duration, index);\n\n    },\n\n    /**\n    * Sets the number of times this tween will repeat.\n    * If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to repeat.\n    * If you have child tweens and pass -1 as the index value it sets the number of times they'll repeat across all of them.\n    * If you wish to define how many times this Tween and all children will repeat see Tween.repeatAll.\n    *\n    * @method Phaser.Tween#repeat\n    * @param {number} total - How many times a tween should repeat before completing. Set to zero to remove an active repeat. Set to -1 to repeat forever.\n    * @param {number} [repeat=0] - This is the amount of time to pause (in ms) before the repeat will start.\n    * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the repeat value on all the children.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    repeat: function (total, repeatDelay, index) {\n\n        if (repeatDelay === undefined) { repeatDelay = 0; }\n\n        this.updateTweenData('repeatCounter', total, index);\n\n        return this.updateTweenData('repeatDelay', repeatDelay, index);\n\n    },\n\n    /**\n    * Sets the delay in milliseconds before this tween will repeat itself.\n    * The repeatDelay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.\n    * If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to set repeatDelay on.\n    * If you have child tweens and pass -1 as the index value it sets the repeatDelay across all of them.\n    *\n    * @method Phaser.Tween#repeatDelay\n    * @param {number} duration - The amount of time in ms that the Tween should wait until it repeats or yoyos once start is called. Set to zero to remove any active repeatDelay.\n    * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the repeatDelay on all the children.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    repeatDelay: function (duration, index) {\n\n        return this.updateTweenData('repeatDelay', duration, index);\n\n    },\n\n    /**\n    * A Tween that has yoyo set to true will run through from its starting values to its end values and then play back in reverse from end to start.\n    * Used in combination with repeat you can create endless loops.\n    * If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to yoyo.\n    * If you have child tweens and pass -1 as the index value it sets the yoyo property across all of them.\n    * If you wish to yoyo this Tween and all of its children then see Tween.yoyoAll.\n    *\n    * @method Phaser.Tween#yoyo\n    * @param {boolean} enable - Set to true to yoyo this tween, or false to disable an already active yoyo.\n    * @param {number} [yoyoDelay=0] - This is the amount of time to pause (in ms) before the yoyo will start.\n    * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set yoyo on all the children.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    yoyo: function(enable, yoyoDelay, index) {\n\n        if (yoyoDelay === undefined) { yoyoDelay = 0; }\n\n        this.updateTweenData('yoyo', enable, index);\n\n        return this.updateTweenData('yoyoDelay', yoyoDelay, index);\n\n    },\n\n    /**\n    * Sets the delay in milliseconds before this tween will run a yoyo (only applies if yoyo is enabled).\n    * The repeatDelay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.\n    * If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to set repeatDelay on.\n    * If you have child tweens and pass -1 as the index value it sets the repeatDelay across all of them.\n    *\n    * @method Phaser.Tween#yoyoDelay\n    * @param {number} duration - The amount of time in ms that the Tween should wait until it repeats or yoyos once start is called. Set to zero to remove any active yoyoDelay.\n    * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the yoyoDelay on all the children.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    yoyoDelay: function (duration, index) {\n\n        return this.updateTweenData('yoyoDelay', duration, index);\n\n    },\n\n    /**\n    * Set easing function this tween will use, i.e. Phaser.Easing.Linear.None.\n    * The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as \"Circ\".\n    * \".easeIn\", \".easeOut\" and \"easeInOut\" variants are all supported for all ease types.\n    * If you have child tweens and pass -1 as the index value it sets the easing function defined here across all of them.\n    *\n    * @method Phaser.Tween#easing\n    * @param {function|string} ease - The easing function this tween will use, i.e. Phaser.Easing.Linear.None.\n    * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the easing function on all children.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    easing: function (ease, index) {\n\n        if (typeof ease === 'string' && this.manager.easeMap[ease])\n        {\n            ease = this.manager.easeMap[ease];\n        }\n\n        return this.updateTweenData('easingFunction', ease, index);\n\n    },\n\n    /**\n    * Sets the interpolation function the tween will use. By default it uses Phaser.Math.linearInterpolation.\n    * Also available: Phaser.Math.bezierInterpolation and Phaser.Math.catmullRomInterpolation.\n    * The interpolation function is only used if the target properties is an array.\n    * If you have child tweens and pass -1 as the index value and it will set the interpolation function across all of them.\n    *\n    * @method Phaser.Tween#interpolation\n    * @param {function} interpolation - The interpolation function to use (Phaser.Math.linearInterpolation by default)\n    * @param {object} [context] - The context under which the interpolation function will be run.\n    * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the interpolation function on all children.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    interpolation: function (interpolation, context, index) {\n\n        if (context === undefined) { context = Phaser.Math; }\n\n        this.updateTweenData('interpolationFunction', interpolation, index);\n\n        return this.updateTweenData('interpolationContext', context, index);\n\n    },\n\n    /**\n    * Set how many times this tween and all of its children will repeat.\n    * A tween (A) with 3 children (B,C,D) with a `repeatAll` value of 2 would play as: ABCDABCD before completing.\n    *\n    * @method Phaser.Tween#repeatAll\n    * @param {number} [total=0] - How many times this tween and all children should repeat before completing. Set to zero to remove an active repeat. Set to -1 to repeat forever.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    repeatAll: function (total) {\n\n        if (total === undefined) { total = 0; }\n\n        this.repeatCounter = total;\n\n        return this;\n\n    },\n\n    /**\n    * This method allows you to chain tweens together. Any tween chained to this tween will have its `Tween.start` method called\n    * as soon as this tween completes. If this tween never completes (i.e. repeatAll or loop is set) then the chain will never progress.\n    * Note that `Tween.onComplete` will fire when *this* tween completes, not when the whole chain completes.\n    * For that you should listen to `onComplete` on the final tween in your chain.\n    *\n    * If you pass multiple tweens to this method they will be joined into a single long chain.\n    * For example if this is Tween A and you pass in B, C and D then B will be chained to A, C will be chained to B and D will be chained to C.\n    * Any previously chained tweens that may have been set will be overwritten.\n    *\n    * @method Phaser.Tween#chain\n    * @param {...Phaser.Tween} tweens - One or more tweens that will be chained to this one.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    chain: function () {\n\n        var i = arguments.length;\n\n        while (i--)\n        {\n            if (i > 0)\n            {\n                arguments[i - 1].chainedTween = arguments[i];\n            }\n            else\n            {\n                this.chainedTween = arguments[i];\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Enables the looping of this tween. The tween will loop forever, and onComplete will never fire.\n    *\n    * If `value` is `true` then this is the same as setting `Tween.repeatAll(-1)`.\n    * If `value` is `false` it is the same as setting `Tween.repeatAll(0)` and will reset the `repeatCounter` to zero.\n    *\n    * Usage:\n    * game.add.tween(p).to({ x: 700 }, 1000, Phaser.Easing.Linear.None, true)\n    * .to({ y: 300 }, 1000, Phaser.Easing.Linear.None)\n    * .to({ x: 0 }, 1000, Phaser.Easing.Linear.None)\n    * .to({ y: 0 }, 1000, Phaser.Easing.Linear.None)\n    * .loop();\n    * @method Phaser.Tween#loop\n    * @param {boolean} [value=true] - If `true` this tween will loop once it reaches the end. Set to `false` to remove an active loop.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    loop: function (value) {\n\n        if (value === undefined) { value = true; }\n\n        this.repeatCounter = (value) ? -1 : 0;\n\n        return this;\n\n    },\n\n    /**\n    * Sets a callback to be fired each time this tween updates.\n    *\n    * @method Phaser.Tween#onUpdateCallback\n    * @param {function} callback - The callback to invoke each time this tween is updated. Set to `null` to remove an already active callback.\n    * @param {object} callbackContext - The context in which to call the onUpdate callback.\n    * @return {Phaser.Tween} This tween. Useful for method chaining.\n    */\n    onUpdateCallback: function (callback, callbackContext) {\n\n        this._onUpdateCallback = callback;\n        this._onUpdateCallbackContext = callbackContext;\n\n        return this;\n\n    },\n\n    /**\n    * Pauses the tween. Resume playback with Tween.resume.\n    *\n    * @method Phaser.Tween#pause\n    */\n    pause: function () {\n\n        this.isPaused = true;\n\n        this._codePaused = true;\n\n        this._pausedTime = this.game.time.time;\n\n    },\n\n    /**\n    * This is called by the core Game loop. Do not call it directly, instead use Tween.pause.\n    *\n    * @private\n    * @method Phaser.Tween#_pause\n    */\n    _pause: function () {\n\n        if (!this._codePaused)\n        {\n            this.isPaused = true;\n\n            this._pausedTime = this.game.time.time;\n        }\n\n    },\n\n    /**\n    * Resumes a paused tween.\n    *\n    * @method Phaser.Tween#resume\n    */\n    resume: function () {\n\n        if (this.isPaused)\n        {\n            this.isPaused = false;\n\n            this._codePaused = false;\n\n            for (var i = 0; i < this.timeline.length; i++)\n            {\n                if (!this.timeline[i].isRunning)\n                {\n                    this.timeline[i].startTime += (this.game.time.time - this._pausedTime);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * This is called by the core Game loop. Do not call it directly, instead use Tween.pause.\n    * @method Phaser.Tween#_resume\n    * @private\n    */\n    _resume: function () {\n\n        if (this._codePaused)\n        {\n            return;\n        }\n        else\n        {\n            this.resume();\n        }\n\n    },\n\n    /**\n    * Core tween update function called by the TweenManager. Does not need to be invoked directly.\n    *\n    * @method Phaser.Tween#update\n    * @param {number} time - A timestamp passed in by the TweenManager.\n    * @return {boolean} false if the tween and all child tweens have completed and should be deleted from the manager, otherwise true (still active).\n    */\n    update: function (time) {\n\n        if (this.pendingDelete || !this.target)\n        {\n            return false;\n        }\n\n        if (this.isPaused)\n        {\n            return true;\n        }\n\n        var status = this.timeline[this.current].update(time);\n\n        if (status === Phaser.TweenData.PENDING)\n        {\n            return true;\n        }\n        else if (status === Phaser.TweenData.RUNNING)\n        {\n            if (!this._hasStarted)\n            {\n                this.onStart.dispatch(this.target, this);\n                this._hasStarted = true;\n            }\n\n            if (this._onUpdateCallback !== null)\n            {\n                this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]);\n            }\n\n            //  In case the update callback modifies this tween\n            return this.isRunning;\n        }\n        else if (status === Phaser.TweenData.LOOPED)\n        {\n            if (this.timeline[this.current].repeatCounter === -1)\n            {\n                this.onLoop.dispatch(this.target, this);\n            }\n            else\n            {\n                this.onRepeat.dispatch(this.target, this);\n            }\n\n            return true;\n        }\n        else if (status === Phaser.TweenData.COMPLETE)\n        {\n            var complete = false;\n\n            //  What now?\n            if (this.reverse)\n            {\n                this.current--;\n\n                if (this.current < 0)\n                {\n                    this.current = this.timeline.length - 1;\n                    complete = true;\n                }\n            }\n            else\n            {\n                this.current++;\n\n                if (this.current === this.timeline.length)\n                {\n                    this.current = 0;\n                    complete = true;\n                }\n            }\n\n            if (complete)\n            {\n                //  We've reached the start or end of the child tweens (depending on Tween.reverse), should we repeat it?\n                if (this.repeatCounter === -1)\n                {\n                    this.timeline[this.current].start();\n                    this.onLoop.dispatch(this.target, this);\n                    return true;\n                }\n                else if (this.repeatCounter > 0)\n                {\n                    this.repeatCounter--;\n\n                    this.timeline[this.current].start();\n                    this.onRepeat.dispatch(this.target, this);\n                    return true;\n                }\n                else\n                {\n                    //  No more repeats and no more children, so we're done\n                    this.isRunning = false;\n                    this.onComplete.dispatch(this.target, this);\n                    this._hasStarted = false;\n\n                    if (this.chainedTween)\n                    {\n                        this.chainedTween.start();\n                    }\n\n                    return false;\n                }\n            }\n            else\n            {\n                //  We've still got some children to go\n                this.onChildComplete.dispatch(this.target, this);\n                this.timeline[this.current].start();\n                return true;\n            }\n        }\n\n    },\n\n    /**\n    * This will generate an array populated with the tweened object values from start to end.\n    * It works by running the tween simulation at the given frame rate based on the values set-up in Tween.to and Tween.from.\n    * It ignores delay and repeat counts and any chained tweens, but does include child tweens.\n    * Just one play through of the tween data is returned, including yoyo if set.\n    *\n    * @method Phaser.Tween#generateData\n    * @param {number} [frameRate=60] - The speed in frames per second that the data should be generated at. The higher the value, the larger the array it creates.\n    * @param {array} [data] - If given the generated data will be appended to this array, otherwise a new array will be returned.\n    * @return {array} An array of tweened values.\n    */\n    generateData: function (frameRate, data) {\n\n        if (this.game === null || this.target === null)\n        {\n            return null;\n        }\n\n        if (frameRate === undefined) { frameRate = 60; }\n        if (data === undefined) { data = []; }\n\n        //  Populate the tween data\n        for (var i = 0; i < this.timeline.length; i++)\n        {\n            //  Build our master property list with the starting values\n            for (var property in this.timeline[i].vEnd)\n            {\n                this.properties[property] = this.target[property] || 0;\n\n                if (!Array.isArray(this.properties[property]))\n                {\n                    //  Ensures we're using numbers, not strings\n                    this.properties[property] *= 1.0;\n                }\n            }\n        }\n\n        for (var i = 0; i < this.timeline.length; i++)\n        {\n            this.timeline[i].loadValues();\n        }\n\n        for (var i = 0; i < this.timeline.length; i++)\n        {\n            data = data.concat(this.timeline[i].generateData(frameRate));\n        }\n\n        return data;\n\n    }\n\n};\n\n/**\n* @name Phaser.Tween#totalDuration\n* @property {Phaser.TweenData} totalDuration - Gets the total duration of this Tween, including all child tweens, in milliseconds.\n*/\nObject.defineProperty(Phaser.Tween.prototype, 'totalDuration', {\n\n    get: function () {\n\n        var total = 0;\n\n        for (var i = 0; i < this.timeline.length; i++)\n        {\n            total += this.timeline[i].duration;\n        }\n\n        return total;\n\n    }\n\n});\n\nPhaser.Tween.prototype.constructor = Phaser.Tween;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Phaser.Tween contains at least one TweenData object. It contains all of the tween data values, such as the\n* starting and ending values, the ease function, interpolation and duration. The Tween acts as a timeline manager for\n* TweenData objects and can contain multiple TweenData objects.\n*\n* @class Phaser.TweenData\n* @constructor\n* @param {Phaser.Tween} parent - The Tween that owns this TweenData object.\n*/\nPhaser.TweenData = function (parent) {\n\n    /**\n    * @property {Phaser.Tween} parent - The Tween which owns this TweenData.\n    */\n    this.parent = parent;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = parent.game;\n\n    /**\n    * @property {object} vStart - An object containing the values at the start of the tween.\n    * @private\n    */\n    this.vStart = {};\n\n    /**\n    * @property {object} vStartCache - Cached starting values.\n    * @private\n    */\n    this.vStartCache = {};\n\n    /**\n    * @property {object} vEnd - An object containing the values at the end of the tween.\n    * @private\n    */\n    this.vEnd = {};\n\n    /**\n    * @property {object} vEndCache - Cached ending values.\n    * @private\n    */\n    this.vEndCache = {};\n\n    /**\n    * @property {number} duration - The duration of the tween in ms.\n    * @default\n    */\n    this.duration = 1000;\n\n    /**\n    * @property {number} percent - A value between 0 and 1 that represents how far through the duration this tween is.\n    * @readonly\n    */\n    this.percent = 0;\n\n    /**\n    * @property {number} value - The current calculated value.\n    * @readonly\n    */\n    this.value = 0;\n\n    /**\n    * @property {number} repeatCounter - If the Tween is set to repeat this contains the current repeat count.\n    */\n    this.repeatCounter = 0;\n\n    /**\n    * @property {number} repeatDelay - The amount of time in ms between repeats of this tween.\n    */\n    this.repeatDelay = 0;\n\n    /**\n    * @property {number} repeatTotal - The total number of times this Tween will repeat.\n    * @readonly\n    */\n    this.repeatTotal = 0;\n\n    /**\n    * @property {boolean} interpolate - True if the Tween will use interpolation (i.e. is an Array to Array tween)\n    * @default\n    */\n    this.interpolate = false;\n\n    /**\n    * @property {boolean} yoyo - True if the Tween is set to yoyo, otherwise false.\n    * @default\n    */\n    this.yoyo = false;\n\n    /**\n    * @property {number} yoyoDelay - The amount of time in ms between yoyos of this tween.\n    */\n    this.yoyoDelay = 0;\n\n    /**\n    * @property {boolean} inReverse - When a Tween is yoyoing this value holds if it's currently playing forwards (false) or in reverse (true).\n    * @default\n    */\n    this.inReverse = false;\n\n    /**\n    * @property {number} delay - The amount to delay by until the Tween starts (in ms). Only applies to the start, use repeatDelay to handle repeats.\n    * @default\n    */\n    this.delay = 0;\n\n    /**\n    * @property {number} dt - Current time value.\n    */\n    this.dt = 0;\n\n    /**\n    * @property {number} startTime - The time the Tween started or null if it hasn't yet started.\n    */\n    this.startTime = null;\n\n    /**\n    * @property {function} easingFunction - The easing function used for the Tween.\n    * @default Phaser.Easing.Default\n    */\n    this.easingFunction = Phaser.Easing.Default;\n\n    /**\n    * @property {function} interpolationFunction - The interpolation function used for the Tween.\n    * @default Phaser.Math.linearInterpolation\n    */\n    this.interpolationFunction = Phaser.Math.linearInterpolation;\n\n    /**\n    * @property {object} interpolationContext - The interpolation function context used for the Tween.\n    * @default Phaser.Math\n    */\n    this.interpolationContext = Phaser.Math;\n\n    /**\n    * @property {boolean} isRunning - If the tween is running this is set to `true`. Unless Phaser.Tween a TweenData that is waiting for a delay to expire is *not* considered as running.\n    * @default\n    */\n    this.isRunning = false;\n\n    /**\n    * @property {boolean} isFrom - Is this a from tween or a to tween?\n    * @default\n    */\n    this.isFrom = false;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.TweenData.PENDING = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.TweenData.RUNNING = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.TweenData.LOOPED = 2;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.TweenData.COMPLETE = 3;\n\nPhaser.TweenData.prototype = {\n\n    /**\n    * Sets this tween to be a `to` tween on the properties given. A `to` tween starts at the current value and tweens to the destination value given.\n    * For example a Sprite with an `x` coordinate of 100 could be tweened to `x` 200 by giving a properties object of `{ x: 200 }`.\n    *\n    * @method Phaser.TweenData#to\n    * @param {object} properties - The properties you want to tween, such as `Sprite.x` or `Sound.volume`. Given as a JavaScript object.\n    * @param {number} [duration=1000] - Duration of this tween in ms.\n    * @param {function} [ease=null] - Easing function. If not set it will default to Phaser.Easing.Default, which is Phaser.Easing.Linear.None by default but can be over-ridden at will.\n    * @param {number} [delay=0] - Delay before this tween will start, defaults to 0 (no delay). Value given is in ms.\n    * @param {number} [repeat=0] - Should the tween automatically restart once complete? If you want it to run forever set as -1. This ignores any chained tweens.\n    * @param {boolean} [yoyo=false] - A tween that yoyos will reverse itself and play backwards automatically. A yoyo'd tween doesn't fire the Tween.onComplete event, so listen for Tween.onLoop instead.\n    * @return {Phaser.TweenData} This Tween object.\n    */\n    to: function (properties, duration, ease, delay, repeat, yoyo) {\n\n        this.vEnd = properties;\n        this.duration = duration;\n        this.easingFunction = ease;\n        this.delay = delay;\n        this.repeatTotal = repeat;\n        this.yoyo = yoyo;\n\n        this.isFrom = false;\n\n        return this;\n\n    },\n\n    /**\n    * Sets this tween to be a `from` tween on the properties given. A `from` tween sets the target to the destination value and tweens to its current value.\n    * For example a Sprite with an `x` coordinate of 100 tweened from `x` 500 would be set to `x` 500 and then tweened to `x` 100 by giving a properties object of `{ x: 500 }`.\n    *\n    * @method Phaser.TweenData#from\n    * @param {object} properties - The properties you want to tween, such as `Sprite.x` or `Sound.volume`. Given as a JavaScript object.\n    * @param {number} [duration=1000] - Duration of this tween in ms.\n    * @param {function} [ease=null] - Easing function. If not set it will default to Phaser.Easing.Default, which is Phaser.Easing.Linear.None by default but can be over-ridden at will.\n    * @param {number} [delay=0] - Delay before this tween will start, defaults to 0 (no delay). Value given is in ms.\n    * @param {number} [repeat=0] - Should the tween automatically restart once complete? If you want it to run forever set as -1. This ignores any chained tweens.\n    * @param {boolean} [yoyo=false] - A tween that yoyos will reverse itself and play backwards automatically. A yoyo'd tween doesn't fire the Tween.onComplete event, so listen for Tween.onLoop instead.\n    * @return {Phaser.TweenData} This Tween object.\n    */\n    from: function (properties, duration, ease, delay, repeat, yoyo) {\n\n        this.vEnd = properties;\n        this.duration = duration;\n        this.easingFunction = ease;\n        this.delay = delay;\n        this.repeatTotal = repeat;\n        this.yoyo = yoyo;\n\n        this.isFrom = true;\n\n        return this;\n\n    },\n\n    /**\n    * Starts the Tween running.\n    *\n    * @method Phaser.TweenData#start\n    * @return {Phaser.TweenData} This Tween object.\n    */\n    start: function () {\n\n        this.startTime = this.game.time.time + this.delay;\n\n        if (this.parent.reverse)\n        {\n            this.dt = this.duration;\n        }\n        else\n        {\n            this.dt = 0;\n        }\n\n        if (this.delay > 0)\n        {\n            this.isRunning = false;\n        }\n        else\n        {\n            this.isRunning = true;\n        }\n\n        if (this.isFrom)\n        {\n            //  Reverse them all and instant set them\n            for (var property in this.vStartCache)\n            {\n                this.vStart[property] = this.vEndCache[property];\n                this.vEnd[property] = this.vStartCache[property];\n                this.parent.target[property] = this.vStart[property];\n            }\n        }\n\n        this.value = 0;\n        this.yoyoCounter = 0;\n        this.repeatCounter = this.repeatTotal;\n\n        return this;\n\n    },\n\n    /**\n    * Loads the values from the target object into this Tween.\n    *\n    * @private\n    * @method Phaser.TweenData#loadValues\n    * @return {Phaser.TweenData} This Tween object.\n    */\n    loadValues: function () {\n\n        for (var property in this.parent.properties)\n        {\n            //  Load the property from the parent object\n            this.vStart[property] = this.parent.properties[property];\n\n            //  Check if an Array was provided as property value\n            if (Array.isArray(this.vEnd[property]))\n            {\n                if (this.vEnd[property].length === 0)\n                {\n                    continue;\n                }\n\n                if (this.percent === 0)\n                {\n                    //  Put the start value at the beginning of the array\n                    //  but we only want to do this once, if the Tween hasn't run before\n                    this.vEnd[property] = [this.vStart[property]].concat(this.vEnd[property]);\n                }\n            }\n\n            if (typeof this.vEnd[property] !== 'undefined')\n            {\n                if (typeof this.vEnd[property] === 'string')\n                {\n                    //  Parses relative end values with start as base (e.g.: +10, -3)\n                    this.vEnd[property] = this.vStart[property] + parseFloat(this.vEnd[property], 10);\n                }\n\n                this.parent.properties[property] = this.vEnd[property];\n            }\n            else\n            {\n                //  Null tween\n                this.vEnd[property] = this.vStart[property];\n            }\n\n            this.vStartCache[property] = this.vStart[property];\n            this.vEndCache[property] = this.vEnd[property];\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Updates this Tween. This is called automatically by Phaser.Tween.\n    *\n    * @protected\n    * @method Phaser.TweenData#update\n    * @param {number} time - A timestamp passed in by the Tween parent.\n    * @return {number} The current status of this Tween. One of the Phaser.TweenData constants: PENDING, RUNNING, LOOPED or COMPLETE.\n    */\n    update: function (time) {\n\n        if (!this.isRunning)\n        {\n            if (time >= this.startTime)\n            {\n                this.isRunning = true;\n            }\n            else\n            {\n                return Phaser.TweenData.PENDING;\n            }\n        }\n        else\n        {\n            //  Is Running, but is waiting to repeat\n            if (time < this.startTime)\n            {\n                return Phaser.TweenData.RUNNING;\n            }\n        }\n\n        var ms = (this.parent.frameBased) ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;\n\n        if (this.parent.reverse)\n        {\n            this.dt -= ms * this.parent.timeScale;\n            this.dt = Math.max(this.dt, 0);\n        }\n        else\n        {\n            this.dt += ms * this.parent.timeScale;\n            this.dt = Math.min(this.dt, this.duration);\n        }\n\n        this.percent = this.dt / this.duration;\n\n        this.value = this.easingFunction(this.percent);\n\n        for (var property in this.vEnd)\n        {\n            var start = this.vStart[property];\n            var end = this.vEnd[property];\n\n            if (Array.isArray(end))\n            {\n                this.parent.target[property] = this.interpolationFunction.call(this.interpolationContext, end, this.value);\n            }\n            else\n            {\n                this.parent.target[property] = start + ((end - start) * this.value);\n            }\n        }\n\n        if ((!this.parent.reverse && this.percent === 1) || (this.parent.reverse && this.percent === 0))\n        {\n            return this.repeat();\n        }\n        \n        return Phaser.TweenData.RUNNING;\n\n    },\n\n    /**\n    * This will generate an array populated with the tweened object values from start to end.\n    * It works by running the tween simulation at the given frame rate based on the values set-up in Tween.to and Tween.from.\n    * Just one play through of the tween data is returned, including yoyo if set.\n    *\n    * @method Phaser.TweenData#generateData\n    * @param {number} [frameRate=60] - The speed in frames per second that the data should be generated at. The higher the value, the larger the array it creates.\n    * @return {array} An array of tweened values.\n    */\n    generateData: function (frameRate) {\n\n        if (this.parent.reverse)\n        {\n            this.dt = this.duration;\n        }\n        else\n        {\n            this.dt = 0;\n        }\n\n        var data = [];\n        var complete = false;\n        var fps = (1 / frameRate) * 1000;\n\n        do\n        {\n            if (this.parent.reverse)\n            {\n                this.dt -= fps;\n                this.dt = Math.max(this.dt, 0);\n            }\n            else\n            {\n                this.dt += fps;\n                this.dt = Math.min(this.dt, this.duration);\n            }\n\n            this.percent = this.dt / this.duration;\n\n            this.value = this.easingFunction(this.percent);\n\n            var blob = {};\n\n            for (var property in this.vEnd)\n            {\n                var start = this.vStart[property];\n                var end = this.vEnd[property];\n\n                if (Array.isArray(end))\n                {\n                    blob[property] = this.interpolationFunction(end, this.value);\n                }\n                else\n                {\n                    blob[property] = start + ((end - start) * this.value);\n                }\n            }\n\n            data.push(blob);\n\n            if ((!this.parent.reverse && this.percent === 1) || (this.parent.reverse && this.percent === 0))\n            {\n                complete = true;\n            }\n\n        } while (!complete);\n\n        if (this.yoyo)\n        {\n            var reversed = data.slice();\n            reversed.reverse();\n            data = data.concat(reversed);\n        }\n\n        return data;\n\n    },\n\n    /**\n    * Checks if this Tween is meant to repeat or yoyo and handles doing so.\n    *\n    * @private\n    * @method Phaser.TweenData#repeat\n    * @return {number} Either Phaser.TweenData.LOOPED or Phaser.TweenData.COMPLETE.\n    */\n    repeat: function () {\n\n        //  If not a yoyo and repeatCounter = 0 then we're done\n        if (this.yoyo)\n        {\n            //  We're already in reverse mode, which means the yoyo has finished and there's no repeats, so end\n            if (this.inReverse && this.repeatCounter === 0)\n            {\n                //  Restore the properties\n                for (var property in this.vStartCache)\n                {\n                    this.vStart[property] = this.vStartCache[property];\n                    this.vEnd[property] = this.vEndCache[property];\n                }\n\n                this.inReverse = false;\n\n                return Phaser.TweenData.COMPLETE;\n            }\n\n            this.inReverse = !this.inReverse;\n        }\n        else\n        {\n            if (this.repeatCounter === 0)\n            {\n                return Phaser.TweenData.COMPLETE;\n            }\n        }\n\n        if (this.inReverse)\n        {\n            //  If inReverse we're going from vEnd to vStartCache\n            for (var property in this.vStartCache)\n            {\n                this.vStart[property] = this.vEndCache[property];\n                this.vEnd[property] = this.vStartCache[property];\n            }\n        }\n        else\n        {\n            //  If not inReverse we're just repopulating the cache again\n            for (var property in this.vStartCache)\n            {\n                this.vStart[property] = this.vStartCache[property];\n                this.vEnd[property] = this.vEndCache[property];\n            }\n\n            //  -1 means repeat forever, otherwise decrement the repeatCounter\n            //  We only decrement this counter if the tween isn't doing a yoyo, as that doesn't count towards the repeat total\n            if (this.repeatCounter > 0)\n            {\n                this.repeatCounter--;\n            }\n        }\n\n        this.startTime = this.game.time.time;\n\n        if (this.yoyo && this.inReverse)\n        {\n            this.startTime += this.yoyoDelay;\n        }\n        else if (!this.inReverse)\n        {\n            this.startTime += this.repeatDelay;\n        }\n\n        if (this.parent.reverse)\n        {\n            this.dt = this.duration;\n        }\n        else\n        {\n            this.dt = 0;\n        }\n\n        return Phaser.TweenData.LOOPED;\n\n    }\n\n};\n\nPhaser.TweenData.prototype.constructor = Phaser.TweenData;\n\n/* jshint curly: false */\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A collection of easing methods defining ease-in and ease-out curves.\n*\n* @class Phaser.Easing\n*/\nPhaser.Easing = {\n\n    /**\n    * Linear easing.\n    *\n    * @class Phaser.Easing.Linear\n    */\n    Linear: {\n\n        /**\n        * Linear Easing (no variation).\n        *\n        * @method Phaser.Easing.Linear#None\n        * @param {number} k - The value to be tweened.\n        * @returns {number} k.\n        */\n        None: function ( k ) {\n\n            return k;\n\n        }\n\n    },\n\n    /**\n    * Quadratic easing.\n    *\n    * @class Phaser.Easing.Quadratic\n    */\n    Quadratic: {\n\n        /**\n        * Ease-in.\n        *\n        * @method Phaser.Easing.Quadratic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} k^2.\n        */\n        In: function ( k ) {\n\n            return k * k;\n\n        },\n\n        /**\n        * Ease-out.\n        *\n        * @method Phaser.Easing.Quadratic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} k* (2-k).\n        */\n        Out: function ( k ) {\n\n            return k * ( 2 - k );\n\n        },\n\n        /**\n        * Ease-in/out.\n        *\n        * @method Phaser.Easing.Quadratic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;\n            return - 0.5 * ( --k * ( k - 2 ) - 1 );\n\n        }\n\n    },\n\n    /**\n    * Cubic easing.\n    *\n    * @class Phaser.Easing.Cubic\n    */\n    Cubic: {\n\n        /**\n        * Cubic ease-in.\n        *\n        * @method Phaser.Easing.Cubic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return k * k * k;\n\n        },\n\n        /**\n        * Cubic ease-out.\n        *\n        * @method Phaser.Easing.Cubic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return --k * k * k + 1;\n\n        },\n\n        /**\n        * Cubic ease-in/out.\n        *\n        * @method Phaser.Easing.Cubic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;\n            return 0.5 * ( ( k -= 2 ) * k * k + 2 );\n\n        }\n\n    },\n\n    /**\n    * Quartic easing.\n    *\n    * @class Phaser.Easing.Quartic\n    */\n    Quartic: {\n\n        /**\n        * Quartic ease-in.\n        *\n        * @method Phaser.Easing.Quartic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return k * k * k * k;\n\n        },\n\n        /**\n        * Quartic ease-out.\n        *\n        * @method Phaser.Easing.Quartic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return 1 - ( --k * k * k * k );\n\n        },\n\n        /**\n        * Quartic ease-in/out.\n        *\n        * @method Phaser.Easing.Quartic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;\n            return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );\n\n        }\n\n    },\n\n    /**\n    * Quintic easing.\n    *\n    * @class Phaser.Easing.Quintic\n    */\n    Quintic: {\n\n        /**\n        * Quintic ease-in.\n        *\n        * @method Phaser.Easing.Quintic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return k * k * k * k * k;\n\n        },\n\n        /**\n        * Quintic ease-out.\n        *\n        * @method Phaser.Easing.Quintic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return --k * k * k * k * k + 1;\n\n        },\n\n        /**\n        * Quintic ease-in/out.\n        *\n        * @method Phaser.Easing.Quintic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;\n            return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );\n\n        }\n\n    },\n\n    /**\n    * Sinusoidal easing.\n    *\n    * @class Phaser.Easing.Sinusoidal\n    */\n    Sinusoidal: {\n\n        /**\n        * Sinusoidal ease-in.\n        *\n        * @method Phaser.Easing.Sinusoidal#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            if (k === 0) return 0;\n            if (k === 1) return 1;\n            return 1 - Math.cos( k * Math.PI / 2 );\n\n        },\n\n        /**\n        * Sinusoidal ease-out.\n        *\n        * @method Phaser.Easing.Sinusoidal#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            if (k === 0) return 0;\n            if (k === 1) return 1;\n            return Math.sin( k * Math.PI / 2 );\n\n        },\n\n        /**\n        * Sinusoidal ease-in/out.\n        *\n        * @method Phaser.Easing.Sinusoidal#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if (k === 0) return 0;\n            if (k === 1) return 1;\n            return 0.5 * ( 1 - Math.cos( Math.PI * k ) );\n\n        }\n\n    },\n\n    /**\n    * Exponential easing.\n    *\n    * @class Phaser.Easing.Exponential\n    */\n    Exponential: {\n\n        /**\n        * Exponential ease-in.\n        *\n        * @method Phaser.Easing.Exponential#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return k === 0 ? 0 : Math.pow( 1024, k - 1 );\n\n        },\n\n        /**\n        * Exponential ease-out.\n        *\n        * @method Phaser.Easing.Exponential#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );\n\n        },\n\n        /**\n        * Exponential ease-in/out.\n        *\n        * @method Phaser.Easing.Exponential#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( k === 0 ) return 0;\n            if ( k === 1 ) return 1;\n            if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );\n            return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );\n\n        }\n\n    },\n\n    /**\n    * Circular easing.\n    *\n    * @class Phaser.Easing.Circular\n    */\n    Circular: {\n\n        /**\n        * Circular ease-in.\n        *\n        * @method Phaser.Easing.Circular#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return 1 - Math.sqrt( 1 - k * k );\n\n        },\n\n        /**\n        * Circular ease-out.\n        *\n        * @method Phaser.Easing.Circular#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return Math.sqrt( 1 - ( --k * k ) );\n\n        },\n\n        /**\n        * Circular ease-in/out.\n        *\n        * @method Phaser.Easing.Circular#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);\n            return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);\n\n        }\n\n    },\n\n    /**\n    * Elastic easing.\n    *\n    * @class Phaser.Easing.Elastic\n    */\n    Elastic: {\n\n        /**\n        * Elastic ease-in.\n        *\n        * @method Phaser.Easing.Elastic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            var s, a = 0.1, p = 0.4;\n            if ( k === 0 ) return 0;\n            if ( k === 1 ) return 1;\n            if ( !a || a < 1 ) { a = 1; s = p / 4; }\n            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );\n            return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );\n\n        },\n\n        /**\n        * Elastic ease-out.\n        *\n        * @method Phaser.Easing.Elastic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            var s, a = 0.1, p = 0.4;\n            if ( k === 0 ) return 0;\n            if ( k === 1 ) return 1;\n            if ( !a || a < 1 ) { a = 1; s = p / 4; }\n            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );\n            return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );\n\n        },\n\n        /**\n        * Elastic ease-in/out.\n        *\n        * @method Phaser.Easing.Elastic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            var s, a = 0.1, p = 0.4;\n            if ( k === 0 ) return 0;\n            if ( k === 1 ) return 1;\n            if ( !a || a < 1 ) { a = 1; s = p / 4; }\n            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );\n            if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );\n            return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;\n\n        }\n\n    },\n\n    /**\n    * Back easing.\n    *\n    * @class Phaser.Easing.Back\n    */\n    Back: {\n\n        /**\n        * Back ease-in.\n        *\n        * @method Phaser.Easing.Back#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            var s = 1.70158;\n            return k * k * ( ( s + 1 ) * k - s );\n\n        },\n\n        /**\n        * Back ease-out.\n        *\n        * @method Phaser.Easing.Back#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            var s = 1.70158;\n            return --k * k * ( ( s + 1 ) * k + s ) + 1;\n\n        },\n\n        /**\n        * Back ease-in/out.\n        *\n        * @method Phaser.Easing.Back#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            var s = 1.70158 * 1.525;\n            if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );\n            return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );\n\n        }\n\n    },\n\n    /**\n    * Bounce easing.\n    *\n    * @class Phaser.Easing.Bounce\n    */\n    Bounce: {\n\n        /**\n        * Bounce ease-in.\n        *\n        * @method Phaser.Easing.Bounce#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return 1 - Phaser.Easing.Bounce.Out( 1 - k );\n\n        },\n\n        /**\n        * Bounce ease-out.\n        *\n        * @method Phaser.Easing.Bounce#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            if ( k < ( 1 / 2.75 ) ) {\n\n                return 7.5625 * k * k;\n\n            } else if ( k < ( 2 / 2.75 ) ) {\n\n                return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\n\n            } else if ( k < ( 2.5 / 2.75 ) ) {\n\n                return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\n\n            } else {\n\n                return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\n\n            }\n\n        },\n\n        /**\n        * Bounce ease-in/out.\n        *\n        * @method Phaser.Easing.Bounce#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( k < 0.5 ) return Phaser.Easing.Bounce.In( k * 2 ) * 0.5;\n            return Phaser.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;\n\n        }\n\n    }\n\n};\n\nPhaser.Easing.Default = Phaser.Easing.Linear.None;\nPhaser.Easing.Power0 = Phaser.Easing.Linear.None;\nPhaser.Easing.Power1 = Phaser.Easing.Quadratic.Out;\nPhaser.Easing.Power2 = Phaser.Easing.Cubic.Out;\nPhaser.Easing.Power3 = Phaser.Easing.Quartic.Out;\nPhaser.Easing.Power4 = Phaser.Easing.Quintic.Out;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* This is the core internal game clock.\n*\n* It manages the elapsed time and calculation of elapsed values, used for game object motion and tweens,\n* and also handles the standard Timer pool.\n*\n* To create a general timed event, use the master {@link Phaser.Timer} accessible through {@link Phaser.Time.events events}.\n*\n* There are different *types* of time in Phaser:\n*\n* - ***Game time*** always runs at the speed of time in real life.\n*\n*   Unlike wall-clock time, *game time stops when Phaser is paused*.\n*\n*   Game time is used for {@link Phaser.Timer timer events}.\n*\n* - ***Physics time*** represents the amount of time given to physics calculations.\n*\n*   *When {@link #slowMotion} is in effect physics time runs slower than game time.*\n*   Like game time, physics time stops when Phaser is paused.\n*\n*   Physics time is used for physics calculations and {@link Phaser.Tween tweens}.\n*\n* - {@link https://en.wikipedia.org/wiki/Wall-clock_time ***Wall-clock time***} represents the duration between two events in real life time.\n*\n*   This time is independent of Phaser and always progresses, regardless of if Phaser is paused.\n*\n* @class Phaser.Time\n* @constructor\n* @param {Phaser.Game} game A reference to the currently running game.\n*/\nPhaser.Time = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    * @protected\n    */\n    this.game = game;\n\n    /**\n    * The `Date.now()` value when the time was last updated.\n    * @property {integer} time\n    * @protected\n    */\n    this.time = 0;\n\n    /**\n    * The `now` when the previous update occurred.\n    * @property {number} prevTime\n    * @protected\n    */\n    this.prevTime = 0;\n\n    /**\n    * An increasing value representing cumulative milliseconds since an undisclosed epoch.\n    *\n    * While this value is in milliseconds and can be used to compute time deltas,\n    * it must must _not_ be used with `Date.now()` as it may not use the same epoch / starting reference.\n    *\n    * The source may either be from a high-res source (eg. if RAF is available) or the standard Date.now;\n    * the value can only be relied upon within a particular game instance.\n    *\n    * @property {number} now\n    * @protected\n    */\n    this.now = 0;\n\n    /**\n    * Elapsed time since the last time update, in milliseconds, based on `now`.\n    *\n    * This value _may_ include time that the game is paused/inactive.\n    *\n    * _Note:_ This is updated only once per game loop - even if multiple logic update steps are done.\n    * Use {@link Phaser.Timer#physicsTime physicsTime} as a basis of game/logic calculations instead.\n    *\n    * @property {number} elapsed\n    * @see Phaser.Time.time\n    * @protected\n    */\n    this.elapsed = 0;\n\n    /**\n    * The time in ms since the last time update, in milliseconds, based on `time`.\n    *\n    * This value is corrected for game pauses and will be \"about zero\" after a game is resumed.\n    *\n    * _Note:_ This is updated once per game loop - even if multiple logic update steps are done.\n    * Use {@link Phaser.Timer#physicsTime physicsTime} as a basis of game/logic calculations instead.\n    *\n    * @property {integer} elapsedMS\n    * @protected\n    */\n    this.elapsedMS = 0;\n\n    /**\n    * The physics update delta, in fractional seconds.\n    *\n    * This should be used as an applicable multiplier by all logic update steps (eg. `preUpdate/postUpdate/update`)\n    * to ensure consistent game timing. Game/logic timing can drift from real-world time if the system\n    * is unable to consistently maintain the desired FPS.\n    *\n    * With fixed-step updates this is normally equivalent to `1.0 / desiredFps`.\n    *\n    * @property {number} physicsElapsed\n    */\n    this.physicsElapsed = 1 / 60;\n\n    /**\n    * The physics update delta, in milliseconds - equivalent to `physicsElapsed * 1000`.\n    *\n    * @property {number} physicsElapsedMS\n    */\n    this.physicsElapsedMS = (1 / 60) * 1000;\n\n    /**\n    * The desiredFps multiplier as used by Game.update.\n    * @property {integer} desiredFpsMult\n    * @protected\n    */\n    this.desiredFpsMult = 1.0 / 60;\n\n    /**\n    * The desired frame rate of the game.\n    *\n    * This is used is used to calculate the physic/logic multiplier and how to apply catch-up logic updates.\n    *\n    * @property {number} _desiredFps\n    * @private\n    * @default\n    */\n    this._desiredFps = 60;\n\n    /**\n    * The suggested frame rate for your game, based on an averaged real frame rate.\n    * This value is only populated if `Time.advancedTiming` is enabled.\n    *\n    * _Note:_ This is not available until after a few frames have passed; until then\n    * it's set to the same value as desiredFps.\n    *\n    * @property {number} suggestedFps\n    * @default\n    */\n    this.suggestedFps = this.desiredFps;\n\n    /**\n    * Scaling factor to make the game move smoothly in slow motion\n    * - 1.0 = normal speed\n    * - 2.0 = half speed\n    * @property {number} slowMotion\n    * @default\n    */\n    this.slowMotion = 1.0;\n\n    /**\n    * If true then advanced profiling, including the fps rate, fps min/max, suggestedFps and msMin/msMax are updated.\n    * @property {boolean} advancedTiming\n    * @default\n    */\n    this.advancedTiming = false;\n\n    /**\n    * Advanced timing result: The number of render frames record in the last second.\n    *\n    * Only calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\n    * @property {integer} frames\n    * @readonly\n    */\n    this.frames = 0;\n\n    /**\n    * Advanced timing result: Frames per second.\n    *\n    * Only calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\n    * @property {number} fps\n    * @readonly\n    */\n    this.fps = 0;\n\n    /**\n    * Advanced timing result: The lowest rate the fps has dropped to.\n    *\n    * Only calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\n    * This value can be manually reset.\n    * @property {number} fpsMin\n    */\n    this.fpsMin = 1000;\n\n    /**\n    * Advanced timing result: The highest rate the fps has reached (usually no higher than 60fps).\n    *\n    * Only calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\n    * This value can be manually reset.\n    * @property {number} fpsMax\n    */\n    this.fpsMax = 0;\n\n    /**\n    * Advanced timing result: The minimum amount of time the game has taken between consecutive frames.\n    *\n    * Only calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\n    * This value can be manually reset.\n    * @property {number} msMin\n    * @default\n    */\n    this.msMin = 1000;\n\n    /**\n    * Advanced timing result: The maximum amount of time the game has taken between consecutive frames.\n    *\n    * Only calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\n    * This value can be manually reset.\n    * @property {number} msMax\n    */\n    this.msMax = 0;\n\n    /**\n    * Records how long the game was last paused, in milliseconds.\n    * (This is not updated until the game is resumed.)\n    * @property {number} pauseDuration\n    */\n    this.pauseDuration = 0;\n\n    /**\n    * @property {number} timeToCall - The value that setTimeout needs to work out when to next update\n    * @protected\n    */\n    this.timeToCall = 0;\n\n    /**\n    * @property {number} timeExpected - The time when the next call is expected when using setTimer to control the update loop\n    * @protected\n    */\n    this.timeExpected = 0;\n\n    /**\n    * A {@link Phaser.Timer} object bound to the master clock (this Time object) which events can be added to.\n    * @property {Phaser.Timer} events\n    */\n    this.events = new Phaser.Timer(this.game, false);\n\n    /**\n    * @property {number} _frameCount - count the number of calls to time.update since the last suggestedFps was calculated\n    * @private\n    */\n    this._frameCount = 0;\n\n    /**\n    * @property {number} _elapsedAcumulator - sum of the elapsed time since the last suggestedFps was calculated\n    * @private\n    */\n    this._elapsedAccumulator = 0;\n\n    /**\n    * @property {number} _started - The time at which the Game instance started.\n    * @private\n    */\n    this._started = 0;\n\n    /**\n    * @property {number} _timeLastSecond - The time (in ms) that the last second counter ticked over.\n    * @private\n    */\n    this._timeLastSecond = 0;\n\n    /**\n    * @property {number} _pauseStarted - The time the game started being paused.\n    * @private\n    */\n    this._pauseStarted = 0;\n\n    /**\n    * @property {boolean} _justResumed - Internal value used to recover from the game pause state.\n    * @private\n    */\n    this._justResumed = false;\n\n    /**\n    * @property {Phaser.Timer[]} _timers - Internal store of Phaser.Timer objects.\n    * @private\n    */\n    this._timers = [];\n\n};\n\nPhaser.Time.prototype = {\n\n    /**\n    * Called automatically by Phaser.Game after boot. Should not be called directly.\n    *\n    * @method Phaser.Time#boot\n    * @protected\n    */\n    boot: function () {\n\n        this._started = Date.now();\n        this.time = Date.now();\n        this.events.start();\n        this.timeExpected = this.time;\n\n    },\n\n    /**\n    * Adds an existing Phaser.Timer object to the Timer pool.\n    *\n    * @method Phaser.Time#add\n    * @param {Phaser.Timer} timer - An existing Phaser.Timer object.\n    * @return {Phaser.Timer} The given Phaser.Timer object.\n    */\n    add: function (timer) {\n\n        this._timers.push(timer);\n\n        return timer;\n\n    },\n\n    /**\n    * Creates a new stand-alone Phaser.Timer object.\n    *\n    * @method Phaser.Time#create\n    * @param {boolean} [autoDestroy=true] - A Timer that is set to automatically destroy itself will do so after all of its events have been dispatched (assuming no looping events).\n    * @return {Phaser.Timer} The Timer object that was created.\n    */\n    create: function (autoDestroy) {\n\n        if (autoDestroy === undefined) { autoDestroy = true; }\n\n        var timer = new Phaser.Timer(this.game, autoDestroy);\n\n        this._timers.push(timer);\n\n        return timer;\n\n    },\n\n    /**\n    * Remove all Timer objects, regardless of their state and clears all Timers from the {@link Phaser.Time#events events} timer.\n    *\n    * @method Phaser.Time#removeAll\n    */\n    removeAll: function () {\n\n        for (var i = 0; i < this._timers.length; i++)\n        {\n            this._timers[i].destroy();\n        }\n\n        this._timers = [];\n\n        this.events.removeAll();\n\n    },\n\n    /**\n    * Refreshes the Time.time and Time.elapsedMS properties from the system clock.\n    *\n    * @method Phaser.Time#refresh\n    */\n    refresh: function () {\n\n        //  Set to the old Date.now value\n        var previousDateNow = this.time;\n\n        // this.time always holds a Date.now value\n        this.time = Date.now();\n\n        //  Adjust accordingly.\n        this.elapsedMS = this.time - previousDateNow;\n\n    },\n\n    /**\n    * Updates the game clock and if enabled the advanced timing data. This is called automatically by Phaser.Game.\n    *\n    * @method Phaser.Time#update\n    * @protected\n    * @param {number} time - The current relative timestamp; see {@link Phaser.Time#now now}.\n    */\n    update: function (time) {\n\n        //  Set to the old Date.now value\n        var previousDateNow = this.time;\n\n        // this.time always holds a Date.now value\n        this.time = Date.now();\n\n        //  Adjust accordingly.\n        this.elapsedMS = this.time - previousDateNow;\n\n        // 'now' is currently still holding the time of the last call, move it into prevTime\n        this.prevTime = this.now;\n\n        // update 'now' to hold the current time\n        // this.now may hold the RAF high resolution time value if RAF is available (otherwise it also holds Date.now)\n        this.now = time;\n\n        // elapsed time between previous call and now - this could be a high resolution value\n        this.elapsed = this.now - this.prevTime;\n\n        if (this.game.raf._isSetTimeOut)\n        {\n            // console.log('Time isSet', this._desiredFps, 'te', this.timeExpected, 'time', time);\n\n            // time to call this function again in ms in case we're using timers instead of RequestAnimationFrame to update the game\n            this.timeToCall = Math.floor(Math.max(0, (1000.0 / this._desiredFps) - (this.timeExpected - time)));\n\n            // time when the next call is expected if using timers\n            this.timeExpected = time + this.timeToCall;\n\n            // console.log('Time expect', this.timeExpected);\n        }\n\n        if (this.advancedTiming)\n        {\n            this.updateAdvancedTiming();\n        }\n\n        //  Paused but still running?\n        if (!this.game.paused)\n        {\n            //  Our internal Phaser.Timer\n            this.events.update(this.time);\n\n            if (this._timers.length)\n            {\n                this.updateTimers();\n            }\n        }\n\n    },\n\n    /**\n    * Handles the updating of the Phaser.Timers (if any)\n    * Called automatically by Time.update.\n    *\n    * @method Phaser.Time#updateTimers\n    * @private\n    */\n    updateTimers: function () {\n\n        //  Any game level timers\n        var i = 0;\n        var len = this._timers.length;\n\n        while (i < len)\n        {\n            if (this._timers[i].update(this.time))\n            {\n                i++;\n            }\n            else\n            {\n                //  Timer requests to be removed\n                this._timers.splice(i, 1);\n                len--;\n            }\n        }\n\n    },\n\n    /**\n    * Handles the updating of the advanced timing values (if enabled)\n    * Called automatically by Time.update.\n    *\n    * @method Phaser.Time#updateAdvancedTiming\n    * @private\n    */\n    updateAdvancedTiming: function () {\n\n        // count the number of time.update calls\n        this._frameCount++;\n        this._elapsedAccumulator += this.elapsed;\n\n        // occasionally recalculate the suggestedFps based on the accumulated elapsed time\n        if (this._frameCount >= this._desiredFps * 2)\n        {\n            // this formula calculates suggestedFps in multiples of 5 fps\n            this.suggestedFps = Math.floor(200 / (this._elapsedAccumulator / this._frameCount)) * 5;\n            this._frameCount = 0;\n            this._elapsedAccumulator = 0;\n        }\n\n        this.msMin = Math.min(this.msMin, this.elapsed);\n        this.msMax = Math.max(this.msMax, this.elapsed);\n\n        this.frames++;\n\n        if (this.now > this._timeLastSecond + 1000)\n        {\n            this.fps = Math.round((this.frames * 1000) / (this.now - this._timeLastSecond));\n            this.fpsMin = Math.min(this.fpsMin, this.fps);\n            this.fpsMax = Math.max(this.fpsMax, this.fps);\n            this._timeLastSecond = this.now;\n            this.frames = 0;\n        }\n\n    },\n\n    /**\n    * Called when the game enters a paused state.\n    *\n    * @method Phaser.Time#gamePaused\n    * @private\n    */\n    gamePaused: function () {\n\n        this._pauseStarted = Date.now();\n\n        this.events.pause();\n\n        var i = this._timers.length;\n\n        while (i--)\n        {\n            this._timers[i]._pause();\n        }\n\n    },\n\n    /**\n    * Called when the game resumes from a paused state.\n    *\n    * @method Phaser.Time#gameResumed\n    * @private\n    */\n    gameResumed: function () {\n\n        // Set the parameter which stores Date.now() to make sure it's correct on resume\n        this.time = Date.now();\n\n        this.pauseDuration = this.time - this._pauseStarted;\n\n        this.events.resume();\n\n        var i = this._timers.length;\n\n        while (i--)\n        {\n            this._timers[i]._resume();\n        }\n\n    },\n\n    /**\n    * The number of seconds that have elapsed since the game was started.\n    *\n    * @method Phaser.Time#totalElapsedSeconds\n    * @return {number} The number of seconds that have elapsed since the game was started.\n    */\n    totalElapsedSeconds: function() {\n        return (this.time - this._started) * 0.001;\n    },\n\n    /**\n    * How long has passed since the given time.\n    *\n    * @method Phaser.Time#elapsedSince\n    * @param {number} since - The time you want to measure against.\n    * @return {number} The difference between the given time and now.\n    */\n    elapsedSince: function (since) {\n        return this.time - since;\n    },\n\n    /**\n    * How long has passed since the given time (in seconds).\n    *\n    * @method Phaser.Time#elapsedSecondsSince\n    * @param {number} since - The time you want to measure (in seconds).\n    * @return {number} Duration between given time and now (in seconds).\n    */\n    elapsedSecondsSince: function (since) {\n        return (this.time - since) * 0.001;\n    },\n\n    /**\n    * Resets the private _started value to now and removes all currently running Timers.\n    *\n    * @method Phaser.Time#reset\n    */\n    reset: function () {\n\n        this._started = this.time;\n        this.removeAll();\n\n    }\n\n};\n\n/**\n* The desired frame rate of the game.\n*\n* This is used is used to calculate the physic / logic multiplier and how to apply catch-up logic updates.\n* \n* @name Phaser.Time#desiredFps\n* @property {integer} desiredFps - The desired frame rate of the game. Defaults to 60.\n*/\nObject.defineProperty(Phaser.Time.prototype, \"desiredFps\", {\n\n    get: function () {\n\n        return this._desiredFps;\n\n    },\n\n    set: function (value) {\n\n        this._desiredFps = value;\n\n        //  Set the physics elapsed time... this will always be 1 / this.desiredFps \n        //  because we're using fixed time steps in game.update\n        this.physicsElapsed = 1 / value;\n\n        this.physicsElapsedMS = this.physicsElapsed * 1000;\n\n        this.desiredFpsMult = 1.0 / value;\n\n    }\n\n});\n\nPhaser.Time.prototype.constructor = Phaser.Time;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Timer is a way to create and manage {@link Phaser.TimerEvent timer events} that wait for a specific duration and then run a callback.\n* Many different timer events, with individual delays, can be added to the same Timer.\n*\n* All Timer delays are in milliseconds (there are 1000 ms in 1 second); so a delay value of 250 represents a quarter of a second.\n*\n* Timers are based on real life time, adjusted for game pause durations.\n* That is, *timer events are based on elapsed {@link Phaser.Time game time}* and do *not* take physics time or slow motion into account.\n*\n* @class Phaser.Timer\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {boolean} [autoDestroy=true] - If true, the timer will automatically destroy itself after all the events have been dispatched (assuming no looping events).\n*/\nPhaser.Timer = function (game, autoDestroy) {\n\n    if (autoDestroy === undefined) { autoDestroy = true; }\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    * @protected\n    */\n    this.game = game;\n\n    /**\n    * True if the Timer is actively running.\n    *\n    * Do not modify this boolean - use {@link Phaser.Timer#pause pause} (and {@link Phaser.Timer#resume resume}) to pause the timer.\n    * @property {boolean} running\n    * @default\n    * @readonly\n    */\n    this.running = false;\n\n    /**\n    * If true, the timer will automatically destroy itself after all the events have been dispatched (assuming no looping events).\n    * @property {boolean} autoDestroy\n    */\n    this.autoDestroy = autoDestroy;\n\n    /**\n    * @property {boolean} expired - An expired Timer is one in which all of its events have been dispatched and none are pending.\n    * @readonly\n    * @default\n    */\n    this.expired = false;\n\n    /**\n    * @property {number} elapsed - Elapsed time since the last frame (in ms).\n    * @protected\n    */\n    this.elapsed = 0;\n\n    /**\n    * @property {Phaser.TimerEvent[]} events - An array holding all of this timers Phaser.TimerEvent objects. Use the methods add, repeat and loop to populate it.\n    */\n    this.events = [];\n\n    /**\n    * This signal will be dispatched when this Timer has completed which means that there are no more events in the queue.\n    *\n    * The signal is supplied with one argument, `timer`, which is this Timer object.\n    *\n    * @property {Phaser.Signal} onComplete\n    */\n    this.onComplete = new Phaser.Signal();\n\n    /**\n    * @property {number} nextTick - The time the next tick will occur.\n    * @readonly\n    * @protected\n    */\n    this.nextTick = 0;\n\n    /**\n    * @property {number} timeCap - If the difference in time between two frame updates exceeds this value, the event times are reset to avoid catch-up situations.\n    */\n    this.timeCap = 1000;\n\n    /**\n    * @property {boolean} paused - The paused state of the Timer. You can pause the timer by calling Timer.pause() and Timer.resume() or by the game pausing.\n    * @readonly\n    * @default\n    */\n    this.paused = false;\n\n    /**\n    * @property {boolean} _codePaused - Was the Timer paused by code or by Game focus loss?\n    * @private\n    */\n    this._codePaused = false;\n\n    /**\n    * @property {number} _started - The time at which this Timer instance started running.\n    * @private\n    * @default\n    */\n    this._started = 0;\n\n    /**\n    * @property {number} _pauseStarted - The time the game started being paused.\n    * @private\n    */\n    this._pauseStarted = 0;\n\n    /**\n    * @property {number} _pauseTotal - Total paused time.\n    * @private\n    */\n    this._pauseTotal = 0;\n\n    /**\n    * @property {number} _now - The current start-time adjusted time.\n    * @private\n    */\n    this._now = Date.now();\n\n    /**\n    * @property {number} _len - Temp. array length variable.\n    * @private\n    */\n    this._len = 0;\n\n    /**\n    * @property {number} _marked - Temp. counter variable.\n    * @private\n    */\n    this._marked = 0;\n\n    /**\n    * @property {number} _i - Temp. array counter variable.\n    * @private\n    */\n    this._i = 0;\n\n    /**\n    * @property {number} _diff - Internal cache var.\n    * @private\n    */\n    this._diff = 0;\n\n    /**\n    * @property {number} _newTick - Internal cache var.\n    * @private\n    */\n    this._newTick = 0;\n\n};\n\n/**\n* Number of milliseconds in a minute.\n* @constant\n* @type {integer}\n*/\nPhaser.Timer.MINUTE = 60000;\n\n/**\n* Number of milliseconds in a second.\n* @constant\n* @type {integer}\n*/\nPhaser.Timer.SECOND = 1000;\n\n/**\n* Number of milliseconds in half a second.\n* @constant\n* @type {integer}\n*/\nPhaser.Timer.HALF = 500;\n\n/**\n* Number of milliseconds in a quarter of a second.\n* @constant\n* @type {integer}\n*/\nPhaser.Timer.QUARTER = 250;\n\nPhaser.Timer.prototype = {\n\n    /**\n    * Creates a new TimerEvent on this Timer.\n    *\n    * Use {@link Phaser.Timer#add}, {@link Phaser.Timer#repeat}, or {@link Phaser.Timer#loop} methods to create a new event.\n    *\n    * @method Phaser.Timer#create\n    * @private\n    * @param {integer} delay - The number of milliseconds, in {@link Phaser.Time game time}, before the timer event occurs.\n    * @param {boolean} loop - Should the event loop or not?\n    * @param {number} repeatCount - The number of times the event will repeat.\n    * @param {function} callback - The callback that will be called when the timer event occurs.\n    * @param {object} callbackContext - The context in which the callback will be called.\n    * @param {any[]} arguments - The values to be sent to your callback function when it is called.\n    * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.\n    */\n    create: function (delay, loop, repeatCount, callback, callbackContext, args) {\n\n        delay = Math.round(delay);\n\n        var tick = delay;\n\n        if (this._now === 0)\n        {\n            tick += this.game.time.time;\n        }\n        else\n        {\n            tick += this._now;\n        }\n\n        var event = new Phaser.TimerEvent(this, delay, tick, repeatCount, loop, callback, callbackContext, args);\n\n        this.events.push(event);\n\n        this.order();\n\n        this.expired = false;\n\n        return event;\n\n    },\n\n    /**\n    * Adds a new Event to this Timer.\n    *\n    * The event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.\n    * The delay is in relation to when the Timer starts, not the time it was added. If the Timer is already running the delay will be calculated based on the timers current time.\n    *\n    * Make sure to call {@link Phaser.Timer#start start} after adding all of the Events you require for this Timer.\n    *\n    * @method Phaser.Timer#add\n    * @param {integer} delay - The number of milliseconds, in {@link Phaser.Time game time}, before the timer event occurs.\n    * @param {function} callback - The callback that will be called when the timer event occurs.\n    * @param {object} callbackContext - The context in which the callback will be called.\n    * @param {...*} arguments - Additional arguments that will be supplied to the callback.\n    * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.\n    */\n    add: function (delay, callback, callbackContext) {\n\n        return this.create(delay, false, 0, callback, callbackContext, Array.prototype.slice.call(arguments, 3));\n\n    },\n\n    /**\n    * Adds a new TimerEvent that will always play through once and then repeat for the given number of iterations.\n    *\n    * The event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.\n    * The delay is in relation to when the Timer starts, not the time it was added.\n    * If the Timer is already running the delay will be calculated based on the timers current time.\n    *\n    * Make sure to call {@link Phaser.Timer#start start} after adding all of the Events you require for this Timer.\n    *\n    * @method Phaser.Timer#repeat\n    * @param {integer} delay - The number of milliseconds, in {@link Phaser.Time game time}, before the timer event occurs.\n    * @param {number} repeatCount - The number of times the event will repeat once is has finished playback. A repeatCount of 1 means it will repeat itself once, playing the event twice in total.\n    * @param {function} callback - The callback that will be called when the timer event occurs.\n    * @param {object} callbackContext - The context in which the callback will be called.\n    * @param {...*} arguments - Additional arguments that will be supplied to the callback.\n    * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.\n    */\n    repeat: function (delay, repeatCount, callback, callbackContext) {\n\n        return this.create(delay, false, repeatCount, callback, callbackContext, Array.prototype.slice.call(arguments, 4));\n\n    },\n\n    /**\n    * Adds a new looped Event to this Timer that will repeat forever or until the Timer is stopped.\n    *\n    * The event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.\n    * The delay is in relation to when the Timer starts, not the time it was added. If the Timer is already running the delay will be calculated based on the timers current time.\n    *\n    * Make sure to call {@link Phaser.Timer#start start} after adding all of the Events you require for this Timer.\n    *\n    * @method Phaser.Timer#loop\n    * @param {integer} delay - The number of milliseconds, in {@link Phaser.Time game time}, before the timer event occurs.\n    * @param {function} callback - The callback that will be called when the timer event occurs.\n    * @param {object} callbackContext - The context in which the callback will be called.\n    * @param {...*} arguments - Additional arguments that will be supplied to the callback.\n    * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.\n    */\n    loop: function (delay, callback, callbackContext) {\n\n        return this.create(delay, true, 0, callback, callbackContext, Array.prototype.slice.call(arguments, 3));\n\n    },\n\n    /**\n    * Starts this Timer running.\n    * @method Phaser.Timer#start\n    * @param {integer} [delay=0] - The number of milliseconds, in {@link Phaser.Time game time}, that should elapse before the Timer will start.\n    */\n    start: function (delay) {\n\n        if (this.running)\n        {\n            return;\n        }\n\n        this._started = this.game.time.time + (delay || 0);\n\n        this.running = true;\n\n        for (var i = 0; i < this.events.length; i++)\n        {\n            this.events[i].tick = this.events[i].delay + this._started;\n        }\n\n    },\n\n    /**\n    * Stops this Timer from running. Does not cause it to be destroyed if autoDestroy is set to true.\n    * @method Phaser.Timer#stop\n    * @param {boolean} [clearEvents=true] - If true all the events in Timer will be cleared, otherwise they will remain.\n    */\n    stop: function (clearEvents) {\n\n        this.running = false;\n\n        if (clearEvents === undefined) { clearEvents = true; }\n\n        if (clearEvents)\n        {\n            this.events.length = 0;\n        }\n\n    },\n\n    /**\n    * Removes a pending TimerEvent from the queue.\n    * @param {Phaser.TimerEvent} event - The event to remove from the queue.\n    * @method Phaser.Timer#remove\n    */\n    remove: function (event) {\n\n        for (var i = 0; i < this.events.length; i++)\n        {\n            if (this.events[i] === event)\n            {\n                this.events[i].pendingDelete = true;\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Orders the events on this Timer so they are in tick order.\n    * This is called automatically when new events are created.\n    * @method Phaser.Timer#order\n    * @protected\n    */\n    order: function () {\n\n        if (this.events.length > 0)\n        {\n            //  Sort the events so the one with the lowest tick is first\n            this.events.sort(this.sortHandler);\n\n            this.nextTick = this.events[0].tick;\n        }\n\n    },\n\n    /**\n    * Sort handler used by Phaser.Timer.order.\n    * @method Phaser.Timer#sortHandler\n    * @private\n    */\n    sortHandler: function (a, b) {\n\n        if (a.tick < b.tick)\n        {\n            return -1;\n        }\n        else if (a.tick > b.tick)\n        {\n            return 1;\n        }\n\n        return 0;\n\n    },\n\n    /**\n    * Clears any events from the Timer which have pendingDelete set to true and then resets the private _len and _i values.\n    *\n    * @method Phaser.Timer#clearPendingEvents\n    * @protected\n    */\n    clearPendingEvents: function () {\n\n        this._i = this.events.length;\n\n        while (this._i--)\n        {\n            if (this.events[this._i].pendingDelete)\n            {\n                this.events.splice(this._i, 1);\n            }\n        }\n\n        this._len = this.events.length;\n        this._i = 0;\n\n    },\n\n    /**\n    * The main Timer update event, called automatically by Phaser.Time.update.\n    *\n    * @method Phaser.Timer#update\n    * @protected\n    * @param {number} time - The time from the core game clock.\n    * @return {boolean} True if there are still events waiting to be dispatched, otherwise false if this Timer can be destroyed.\n    */\n    update: function (time) {\n\n        if (this.paused)\n        {\n            return true;\n        }\n\n        this.elapsed = time - this._now;\n        this._now = time;\n\n        //  spike-dislike\n        if (this.elapsed > this.timeCap)\n        {\n            //  For some reason the time between now and the last time the game was updated was larger than our timeCap.\n            //  This can happen if the Stage.disableVisibilityChange is true and you swap tabs, which makes the raf pause.\n            //  In this case we need to adjust the TimerEvents and nextTick.\n            this.adjustEvents(time - this.elapsed);\n        }\n\n        this._marked = 0;\n\n        //  Clears events marked for deletion and resets _len and _i to 0.\n        this.clearPendingEvents();\n\n        if (this.running && this._now >= this.nextTick && this._len > 0)\n        {\n            while (this._i < this._len && this.running)\n            {\n                if (this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete)\n                {\n                    //  (now + delay) - (time difference from last tick to now)\n                    this._newTick = (this._now + this.events[this._i].delay) - (this._now - this.events[this._i].tick);\n\n                    if (this._newTick < 0)\n                    {\n                        this._newTick = this._now + this.events[this._i].delay;\n                    }\n\n                    if (this.events[this._i].loop === true)\n                    {\n                        this.events[this._i].tick = this._newTick;\n                        this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);\n                    }\n                    else if (this.events[this._i].repeatCount > 0)\n                    {\n                        this.events[this._i].repeatCount--;\n                        this.events[this._i].tick = this._newTick;\n                        this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);\n                    }\n                    else\n                    {\n                        this._marked++;\n                        this.events[this._i].pendingDelete = true;\n                        this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);\n                    }\n\n                    this._i++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            //  Are there any events left?\n            if (this.events.length > this._marked)\n            {\n                this.order();\n            }\n            else\n            {\n                this.expired = true;\n                this.onComplete.dispatch(this);\n            }\n        }\n\n        if (this.expired && this.autoDestroy)\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n\n    },\n\n    /**\n    * Pauses the Timer and all events in the queue.\n    * @method Phaser.Timer#pause\n    */\n    pause: function () {\n\n        if (!this.running)\n        {\n            return;\n        }\n\n        this._codePaused = true;\n\n        if (this.paused)\n        {\n            return;\n        }\n\n        this._pauseStarted = this.game.time.time;\n\n        this.paused = true;\n\n    },\n\n    /**\n    * Internal pause/resume control - user code should use Timer.pause instead.\n    * @method Phaser.Timer#_pause\n    * @private\n    */\n    _pause: function () {\n\n        if (this.paused || !this.running)\n        {\n            return;\n        }\n\n        this._pauseStarted = this.game.time.time;\n\n        this.paused = true;\n\n    },\n\n    /**\n    * Adjusts the time of all pending events and the nextTick by the given baseTime.\n    *\n    * @method Phaser.Timer#adjustEvents\n    * @protected\n    */\n    adjustEvents: function (baseTime) {\n\n        for (var i = 0; i < this.events.length; i++)\n        {\n            if (!this.events[i].pendingDelete)\n            {\n                //  Work out how long there would have been from when the game paused until the events next tick\n                var t = this.events[i].tick - baseTime;\n\n                if (t < 0)\n                {\n                    t = 0;\n                }\n\n                //  Add the difference on to the time now\n                this.events[i].tick = this._now + t;\n            }\n        }\n\n        var d = this.nextTick - baseTime;\n\n        if (d < 0)\n        {\n            this.nextTick = this._now;\n        }\n        else\n        {\n            this.nextTick = this._now + d;\n        }\n\n    },\n\n    /**\n    * Resumes the Timer and updates all pending events.\n    *\n    * @method Phaser.Timer#resume\n    */\n    resume: function () {\n\n        if (!this.paused)\n        {\n            return;\n        }\n\n        var now = this.game.time.time;\n        this._pauseTotal += now - this._now;\n        this._now = now;\n\n        this.adjustEvents(this._pauseStarted);\n\n        this.paused = false;\n        this._codePaused = false;\n\n    },\n\n    /**\n    * Internal pause/resume control - user code should use Timer.resume instead.\n    * @method Phaser.Timer#_resume\n    * @private\n    */\n    _resume: function () {\n\n        if (this._codePaused)\n        {\n            return;\n        }\n        else\n        {\n            this.resume();\n        }\n\n    },\n\n    /**\n    * Removes all Events from this Timer and all callbacks linked to onComplete, but leaves the Timer running.    \n    * The onComplete callbacks won't be called.\n    *\n    * @method Phaser.Timer#removeAll\n    */\n    removeAll: function () {\n\n        this.onComplete.removeAll();\n        this.events.length = 0;\n        this._len = 0;\n        this._i = 0;\n\n    },\n\n    /**\n    * Destroys this Timer. Any pending Events are not dispatched.\n    * The onComplete callbacks won't be called.\n    *\n    * @method Phaser.Timer#destroy\n    */\n    destroy: function () {\n\n        this.onComplete.removeAll();\n        this.running = false;\n        this.events = [];\n        this._len = 0;\n        this._i = 0;\n\n    }\n\n};\n\n/**\n* @name Phaser.Timer#next\n* @property {number} next - The time at which the next event will occur.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"next\", {\n\n    get: function () {\n        return this.nextTick;\n    }\n\n});\n\n/**\n* @name Phaser.Timer#duration\n* @property {number} duration - The duration in ms remaining until the next event will occur.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"duration\", {\n\n    get: function () {\n\n        if (this.running && this.nextTick > this._now)\n        {\n            return this.nextTick - this._now;\n        }\n        else\n        {\n            return 0;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Timer#length\n* @property {number} length - The number of pending events in the queue.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"length\", {\n\n    get: function () {\n        return this.events.length;\n    }\n\n});\n\n/**\n* @name Phaser.Timer#ms\n* @property {number} ms - The duration in milliseconds that this Timer has been running for.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"ms\", {\n\n    get: function () {\n\n        if (this.running)\n        {\n            return this._now - this._started - this._pauseTotal;\n        }\n        else\n        {\n            return 0;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Timer#seconds\n* @property {number} seconds - The duration in seconds that this Timer has been running for.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"seconds\", {\n\n    get: function () {\n\n        if (this.running)\n        {\n            return this.ms * 0.001;\n        }\n        else\n        {\n            return 0;\n        }\n\n    }\n\n});\n\nPhaser.Timer.prototype.constructor = Phaser.Timer;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A TimerEvent is a single event that is processed by a Phaser.Timer.\n*\n* It consists of a delay, which is a value in milliseconds after which the event will fire.\n* When the event fires it calls a specific callback with the specified arguments.\n* \n* TimerEvents are removed by their parent timer once finished firing or repeating.\n* \n* Use {@link Phaser.Timer#add}, {@link Phaser.Timer#repeat}, or {@link Phaser.Timer#loop} methods to create a new event.\n*\n* @class Phaser.TimerEvent\n* @constructor\n* @param {Phaser.Timer} timer - The Timer object that this TimerEvent belongs to.\n* @param {number} delay - The delay in ms at which this TimerEvent fires.\n* @param {number} tick - The tick is the next game clock time that this event will fire at.\n* @param {number} repeatCount - If this TimerEvent repeats it will do so this many times.\n* @param {boolean} loop - True if this TimerEvent loops, otherwise false.\n* @param {function} callback - The callback that will be called when the TimerEvent occurs.\n* @param {object} callbackContext - The context in which the callback will be called.\n* @param {any[]} arguments - Additional arguments to be passed to the callback.\n*/\nPhaser.TimerEvent = function (timer, delay, tick, repeatCount, loop, callback, callbackContext, args) {\n\n    /**\n    * @property {Phaser.Timer} timer - The Timer object that this TimerEvent belongs to.\n    * @protected\n    * @readonly\n    */\n    this.timer = timer;\n\n    /**\n    * @property {number} delay - The delay in ms at which this TimerEvent fires.\n    */\n    this.delay = delay;\n\n    /**\n    * @property {number} tick - The tick is the next game clock time that this event will fire at.\n    */\n    this.tick = tick;\n\n    /**\n    * @property {number} repeatCount - If this TimerEvent repeats it will do so this many times.\n    */\n    this.repeatCount = repeatCount - 1;\n\n    /**\n    * @property {boolean} loop - True if this TimerEvent loops, otherwise false.\n    */\n    this.loop = loop;\n\n    /**\n    * @property {function} callback - The callback that will be called when the TimerEvent occurs.\n    */\n    this.callback = callback;\n\n    /**\n    * @property {object} callbackContext - The context in which the callback will be called.\n    */\n    this.callbackContext = callbackContext;\n\n    /**\n    * @property {any[]} arguments - Additional arguments to be passed to the callback.\n    */\n    this.args = args;\n\n    /**\n    * @property {boolean} pendingDelete - A flag that controls if the TimerEvent is pending deletion.\n    * @protected\n    */\n    this.pendingDelete = false;\n\n};\n\nPhaser.TimerEvent.prototype.constructor = Phaser.TimerEvent;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Animation Manager is used to add, play and update Phaser Animations.\n* Any Game Object such as Phaser.Sprite that supports animation contains a single AnimationManager instance.\n*\n* @class Phaser.AnimationManager\n* @constructor\n* @param {Phaser.Sprite} sprite - A reference to the Game Object that owns this AnimationManager.\n*/\nPhaser.AnimationManager = function (sprite) {\n\n    /**\n    * @property {Phaser.Sprite} sprite - A reference to the parent Sprite that owns this AnimationManager.\n    */\n    this.sprite = sprite;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = sprite.game;\n\n    /**\n    * The currently displayed Frame of animation, if any.\n    * This property is only set once an Animation starts playing. Until that point it remains set as `null`.\n    * \n    * @property {Phaser.Frame} currentFrame\n    * @default\n    */\n    this.currentFrame = null;\n\n    /**\n    * @property {Phaser.Animation} currentAnim - The currently displayed animation, if any.\n    * @default\n    */\n    this.currentAnim = null;\n\n    /**\n    * @property {boolean} updateIfVisible - Should the animation data continue to update even if the Sprite.visible is set to false.\n    * @default\n    */\n    this.updateIfVisible = true;\n\n    /**\n    * @property {boolean} isLoaded - Set to true once animation data has been loaded.\n    * @default\n    */\n    this.isLoaded = false;\n\n    /**\n    * @property {Phaser.FrameData} _frameData - A temp. var for holding the currently playing Animations FrameData.\n    * @private\n    * @default\n    */\n    this._frameData = null;\n\n    /**\n    * @property {object} _anims - An internal object that stores all of the Animation instances.\n    * @private\n    */\n    this._anims = {};\n\n    /**\n    * @property {object} _outputFrames - An internal object to help avoid gc.\n    * @private\n    */\n    this._outputFrames = [];\n\n};\n\nPhaser.AnimationManager.prototype = {\n\n    /**\n    * Loads FrameData into the internal temporary vars and resets the frame index to zero.\n    * This is called automatically when a new Sprite is created.\n    *\n    * @method Phaser.AnimationManager#loadFrameData\n    * @private\n    * @param {Phaser.FrameData} frameData - The FrameData set to load.\n    * @param {string|number} frame - The frame to default to.\n    * @return {boolean} Returns `true` if the frame data was loaded successfully, otherwise `false`\n    */\n    loadFrameData: function (frameData, frame) {\n\n        if (frameData === undefined)\n        {\n            return false;\n        }\n\n        if (this.isLoaded)\n        {\n            //   We need to update the frameData that the animations are using\n            for (var anim in this._anims)\n            {\n                this._anims[anim].updateFrameData(frameData);\n            }\n        }\n\n        this._frameData = frameData;\n\n        if (frame === undefined || frame === null)\n        {\n            this.frame = 0;\n        }\n        else\n        {\n            if (typeof frame === 'string')\n            {\n                this.frameName = frame;\n            }\n            else\n            {\n                this.frame = frame;\n            }\n        }\n\n        this.isLoaded = true;\n\n        return true;\n    },\n\n    /**\n    * Loads FrameData into the internal temporary vars and resets the frame index to zero.\n    * This is called automatically when a new Sprite is created.\n    *\n    * @method Phaser.AnimationManager#copyFrameData\n    * @private\n    * @param {Phaser.FrameData} frameData - The FrameData set to load.\n    * @param {string|number} frame - The frame to default to.\n    * @return {boolean} Returns `true` if the frame data was loaded successfully, otherwise `false`\n    */\n    copyFrameData: function (frameData, frame) {\n\n        this._frameData = frameData.clone();\n\n        if (this.isLoaded)\n        {\n            //   We need to update the frameData that the animations are using\n            for (var anim in this._anims)\n            {\n                this._anims[anim].updateFrameData(this._frameData);\n            }\n        }\n\n        if (frame === undefined || frame === null)\n        {\n            this.frame = 0;\n        }\n        else\n        {\n            if (typeof frame === 'string')\n            {\n                this.frameName = frame;\n            }\n            else\n            {\n                this.frame = frame;\n            }\n        }\n\n        this.isLoaded = true;\n\n        return true;\n    },\n\n    /**\n    * Adds a new animation under the given key. Optionally set the frames, frame rate and loop.\n    * Animations added in this way are played back with the play function.\n    *\n    * @method Phaser.AnimationManager#add\n    * @param {string} name - The unique (within this Sprite) name for the animation, i.e. \"run\", \"fire\", \"walk\".\n    * @param {Array} [frames=null] - An array of numbers/strings that correspond to the frames to add to this animation and in which order. e.g. [1, 2, 3] or ['run0', 'run1', run2]). If null then all frames will be used.\n    * @param {number} [frameRate=60] - The speed at which the animation should play. The speed is given in frames per second.\n    * @param {boolean} [loop=false] - Whether or not the animation is looped or just plays once.\n    * @param {boolean} [useNumericIndex=true] - Are the given frames using numeric indexes (default) or strings?\n    * @return {Phaser.Animation} The Animation object that was created.\n    */\n    add: function (name, frames, frameRate, loop, useNumericIndex) {\n\n        frames = frames || [];\n        frameRate = frameRate || 60;\n\n        if (loop === undefined) { loop = false; }\n\n        //  If they didn't set the useNumericIndex then let's at least try and guess it\n        if (useNumericIndex === undefined)\n        {\n            if (frames && typeof frames[0] === 'number')\n            {\n                useNumericIndex = true;\n            }\n            else\n            {\n                useNumericIndex = false;\n            }\n        }\n\n        this._outputFrames = [];\n\n        this._frameData.getFrameIndexes(frames, useNumericIndex, this._outputFrames);\n\n        this._anims[name] = new Phaser.Animation(this.game, this.sprite, name, this._frameData, this._outputFrames, frameRate, loop);\n\n        this.currentAnim = this._anims[name];\n\n        if (this.sprite.tilingTexture)\n        {\n            this.sprite.refreshTexture = true;\n        }\n\n        return this._anims[name];\n\n    },\n\n    /**\n    * Check whether the frames in the given array are valid and exist.\n    *\n    * @method Phaser.AnimationManager#validateFrames\n    * @param {Array} frames - An array of frames to be validated.\n    * @param {boolean} [useNumericIndex=true] - Validate the frames based on their numeric index (true) or string index (false)\n    * @return {boolean} True if all given Frames are valid, otherwise false.\n    */\n    validateFrames: function (frames, useNumericIndex) {\n\n        if (useNumericIndex === undefined) { useNumericIndex = true; }\n\n        for (var i = 0; i < frames.length; i++)\n        {\n            if (useNumericIndex === true)\n            {\n                if (frames[i] > this._frameData.total)\n                {\n                    return false;\n                }\n            }\n            else\n            {\n                if (this._frameData.checkFrameName(frames[i]) === false)\n                {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n\n    },\n\n    /**\n    * Play an animation based on the given key. The animation should previously have been added via `animations.add`\n    * \n    * If the requested animation is already playing this request will be ignored. \n    * If you need to reset an already running animation do so directly on the Animation object itself.\n    *\n    * @method Phaser.AnimationManager#play\n    * @param {string} name - The name of the animation to be played, e.g. \"fire\", \"walk\", \"jump\".\n    * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.\n    * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.\n    * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.\n    * @return {Phaser.Animation} A reference to playing Animation instance.\n    */\n    play: function (name, frameRate, loop, killOnComplete) {\n\n        if (this._anims[name])\n        {\n            if (this.currentAnim === this._anims[name])\n            {\n                if (this.currentAnim.isPlaying === false)\n                {\n                    this.currentAnim.paused = false;\n                    return this.currentAnim.play(frameRate, loop, killOnComplete);\n                }\n\n                return this.currentAnim;\n            }\n            else\n            {\n                if (this.currentAnim && this.currentAnim.isPlaying)\n                {\n                    this.currentAnim.stop();\n                }\n\n                this.currentAnim = this._anims[name];\n                this.currentAnim.paused = false;\n                this.currentFrame = this.currentAnim.currentFrame;\n                return this.currentAnim.play(frameRate, loop, killOnComplete);\n            }\n        }\n\n    },\n\n    /**\n    * Stop playback of an animation. If a name is given that specific animation is stopped, otherwise the current animation is stopped.\n    * The currentAnim property of the AnimationManager is automatically set to the animation given.\n    *\n    * @method Phaser.AnimationManager#stop\n    * @param {string} [name=null] - The name of the animation to be stopped, e.g. \"fire\". If none is given the currently running animation is stopped.\n    * @param {boolean} [resetFrame=false] - When the animation is stopped should the currentFrame be set to the first frame of the animation (true) or paused on the last frame displayed (false)\n    */\n    stop: function (name, resetFrame) {\n\n        if (resetFrame === undefined) { resetFrame = false; }\n\n        if (this.currentAnim && (typeof name !== 'string' || name === this.currentAnim.name))\n        {\n            this.currentAnim.stop(resetFrame);\n        }\n\n    },\n\n    /**\n    * The main update function is called by the Sprites update loop. It's responsible for updating animation frames and firing related events.\n    *\n    * @method Phaser.AnimationManager#update\n    * @protected\n    * @return {boolean} True if a new animation frame has been set, otherwise false.\n    */\n    update: function () {\n\n        if (this.updateIfVisible && !this.sprite.visible)\n        {\n            return false;\n        }\n\n        if (this.currentAnim && this.currentAnim.update())\n        {\n            this.currentFrame = this.currentAnim.currentFrame;\n            return true;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Advances by the given number of frames in the current animation, taking the loop value into consideration.\n    *\n    * @method Phaser.AnimationManager#next\n    * @param {number} [quantity=1] - The number of frames to advance.\n    */\n    next: function (quantity) {\n\n        if (this.currentAnim)\n        {\n            this.currentAnim.next(quantity);\n            this.currentFrame = this.currentAnim.currentFrame;\n        }\n\n    },\n\n    /**\n    * Moves backwards the given number of frames in the current animation, taking the loop value into consideration.\n    *\n    * @method Phaser.AnimationManager#previous\n    * @param {number} [quantity=1] - The number of frames to move back.\n    */\n    previous: function (quantity) {\n\n        if (this.currentAnim)\n        {\n            this.currentAnim.previous(quantity);\n            this.currentFrame = this.currentAnim.currentFrame;\n        }\n\n    },\n\n    /**\n    * Returns an animation that was previously added by name.\n    *\n    * @method Phaser.AnimationManager#getAnimation\n    * @param {string} name - The name of the animation to be returned, e.g. \"fire\".\n    * @return {Phaser.Animation} The Animation instance, if found, otherwise null.\n    */\n    getAnimation: function (name) {\n\n        if (typeof name === 'string')\n        {\n            if (this._anims[name])\n            {\n                return this._anims[name];\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Refreshes the current frame data back to the parent Sprite and also resets the texture data.\n    *\n    * @method Phaser.AnimationManager#refreshFrame\n    */\n    refreshFrame: function () {\n\n        //  TODO\n        // this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);\n\n    },\n\n    /**\n    * Destroys all references this AnimationManager contains.\n    * Iterates through the list of animations stored in this manager and calls destroy on each of them.\n    *\n    * @method Phaser.AnimationManager#destroy\n    */\n    destroy: function () {\n\n        var anim = null;\n\n        for (var anim in this._anims)\n        {\n            if (this._anims.hasOwnProperty(anim))\n            {\n                this._anims[anim].destroy();\n            }\n        }\n\n        this._anims = {};\n        this._outputFrames = [];\n        this._frameData = null;\n        this.currentAnim = null;\n        this.currentFrame = null;\n        this.sprite = null;\n        this.game = null;\n\n    }\n\n};\n\nPhaser.AnimationManager.prototype.constructor = Phaser.AnimationManager;\n\n/**\n* @name Phaser.AnimationManager#frameData\n* @property {Phaser.FrameData} frameData - The current animations FrameData.\n* @readonly\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'frameData', {\n\n    get: function () {\n        return this._frameData;\n    }\n\n});\n\n/**\n* @name Phaser.AnimationManager#frameTotal\n* @property {number} frameTotal - The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.\n* @readonly\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'frameTotal', {\n\n    get: function () {\n\n        return this._frameData.total;\n    }\n\n});\n\n/**\n* @name Phaser.AnimationManager#paused\n* @property {boolean} paused - Gets and sets the paused state of the current animation.\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'paused', {\n\n    get: function () {\n\n        return this.currentAnim.isPaused;\n\n    },\n\n    set: function (value) {\n\n        this.currentAnim.paused = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.AnimationManager#name\n* @property {string} name - Gets the current animation name, if set.\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'name', {\n\n    get: function () {\n\n        if (this.currentAnim)\n        {\n            return this.currentAnim.name;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.AnimationManager#frame\n* @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'frame', {\n\n    get: function () {\n\n        if (this.currentFrame)\n        {\n            return this.currentFrame.index;\n        }\n\n    },\n\n    set: function (value) {\n\n        if (typeof value === 'number' && this._frameData && this._frameData.getFrame(value) !== null)\n        {\n            this.currentFrame = this._frameData.getFrame(value);\n\n            if (this.currentFrame)\n            {\n                this.sprite.setFrame(this.currentFrame);\n            }\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.AnimationManager#frameName\n* @property {string} frameName - Gets or sets the current frame name and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'frameName', {\n\n    get: function () {\n\n        if (this.currentFrame)\n        {\n            return this.currentFrame.name;\n        }\n\n    },\n\n    set: function (value) {\n\n        if (typeof value === 'string' && this._frameData && this._frameData.getFrameByName(value) !== null)\n        {\n            this.currentFrame = this._frameData.getFrameByName(value);\n\n            if (this.currentFrame)\n            {\n                this._frameIndex = this.currentFrame.index;\n\n                this.sprite.setFrame(this.currentFrame);\n            }\n        }\n        else\n        {\n            console.warn('Cannot set frameName: ' + value);\n        }\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* An Animation instance contains a single animation and the controls to play it.\n*\n* It is created by the AnimationManager, consists of Animation.Frame objects and belongs to a single Game Object such as a Sprite.\n*\n* @class Phaser.Animation\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {Phaser.Sprite} parent - A reference to the owner of this Animation.\n* @param {string} name - The unique name for this animation, used in playback commands.\n* @param {Phaser.FrameData} frameData - The FrameData object that contains all frames used by this Animation.\n* @param {number[]|string[]} frames - An array of numbers or strings indicating which frames to play in which order.\n* @param {number} [frameRate=60] - The speed at which the animation should play. The speed is given in frames per second.\n* @param {boolean} [loop=false] - Whether or not the animation is looped or just plays once.\n*/\nPhaser.Animation = function (game, parent, name, frameData, frames, frameRate, loop) {\n\n    if (loop === undefined) { loop = false; }\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Sprite} _parent - A reference to the parent Sprite that owns this Animation.\n    * @private\n    */\n    this._parent = parent;\n\n    /**\n    * @property {Phaser.FrameData} _frameData - The FrameData the Animation uses.\n    * @private\n    */\n    this._frameData = frameData;\n\n    /**\n    * @property {string} name - The user defined name given to this Animation.\n    */\n    this.name = name;\n\n    /**\n    * @property {array} _frames\n    * @private\n    */\n    this._frames = [];\n    this._frames = this._frames.concat(frames);\n\n    /**\n    * @property {number} delay - The delay in ms between each frame of the Animation, based on the given frameRate.\n    */\n    this.delay = 1000 / frameRate;\n\n    /**\n    * @property {boolean} loop - The loop state of the Animation.\n    */\n    this.loop = loop;\n\n    /**\n    * @property {number} loopCount - The number of times the animation has looped since it was last started.\n    */\n    this.loopCount = 0;\n\n    /**\n    * @property {boolean} killOnComplete - Should the parent of this Animation be killed when the animation completes?\n    * @default\n    */\n    this.killOnComplete = false;\n\n    /**\n    * @property {boolean} isFinished - The finished state of the Animation. Set to true once playback completes, false during playback.\n    * @default\n    */\n    this.isFinished = false;\n\n    /**\n    * @property {boolean} isPlaying - The playing state of the Animation. Set to false once playback completes, true during playback.\n    * @default\n    */\n    this.isPlaying = false;\n\n    /**\n    * @property {boolean} isPaused - The paused state of the Animation.\n    * @default\n    */\n    this.isPaused = false;\n\n    /**\n    * @property {boolean} _pauseStartTime - The time the animation paused.\n    * @private\n    * @default\n    */\n    this._pauseStartTime = 0;\n\n    /**\n    * @property {number} _frameIndex\n    * @private\n    * @default\n    */\n    this._frameIndex = 0;\n\n    /**\n    * @property {number} _frameDiff\n    * @private\n    * @default\n    */\n    this._frameDiff = 0;\n\n    /**\n    * @property {number} _frameSkip\n    * @private\n    * @default\n    */\n    this._frameSkip = 1;\n\n    /**\n    * @property {Phaser.Frame} currentFrame - The currently displayed frame of the Animation.\n    */\n    this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n\n    /**\n    * @property {Phaser.Signal} onStart - This event is dispatched when this Animation starts playback.\n    */\n    this.onStart = new Phaser.Signal();\n\n    /**\n    * This event is dispatched when the Animation changes frame.\n    * By default this event is disabled due to its intensive nature. Enable it with: `Animation.enableUpdate = true`.\n    * Note that the event is only dispatched with the current frame. In a low-FPS environment Animations\n    * will automatically frame-skip to try and claw back time, so do not base your code on expecting to\n    * receive a perfectly sequential set of frames from this event.\n    * @property {Phaser.Signal|null} onUpdate\n    * @default\n    */\n    this.onUpdate = null;\n\n    /**\n    * @property {Phaser.Signal} onComplete - This event is dispatched when this Animation completes playback. If the animation is set to loop this is never fired, listen for onLoop instead.\n    */\n    this.onComplete = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onLoop - This event is dispatched when this Animation loops.\n    */\n    this.onLoop = new Phaser.Signal();\n\n    /**\n     * @property {boolean} isReversed - Indicates if the animation will play backwards.\n     * @default\n     */\n    this.isReversed = false;\n\n    //  Set-up some event listeners\n    this.game.onPause.add(this.onPause, this);\n    this.game.onResume.add(this.onResume, this);\n\n};\n\nPhaser.Animation.prototype = {\n\n    /**\n    * Plays this animation.\n    *\n    * @method Phaser.Animation#play\n    * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.\n    * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.\n    * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.\n    * @return {Phaser.Animation} - A reference to this Animation instance.\n    */\n    play: function (frameRate, loop, killOnComplete) {\n\n        if (typeof frameRate === 'number')\n        {\n            //  If they set a new frame rate then use it, otherwise use the one set on creation\n            this.delay = 1000 / frameRate;\n        }\n\n        if (typeof loop === 'boolean')\n        {\n            //  If they set a new loop value then use it, otherwise use the one set on creation\n            this.loop = loop;\n        }\n\n        if (typeof killOnComplete !== 'undefined')\n        {\n            //  Remove the parent sprite once the animation has finished?\n            this.killOnComplete = killOnComplete;\n        }\n\n        this.isPlaying = true;\n        this.isFinished = false;\n        this.paused = false;\n        this.loopCount = 0;\n\n        this._timeLastFrame = this.game.time.time;\n        this._timeNextFrame = this.game.time.time + this.delay;\n\n        this._frameIndex = this.isReversed ? this._frames.length - 1 : 0;\n        this.updateCurrentFrame(false, true);\n\n        this._parent.events.onAnimationStart$dispatch(this._parent, this);\n\n        this.onStart.dispatch(this._parent, this);\n\n        this._parent.animations.currentAnim = this;\n        this._parent.animations.currentFrame = this.currentFrame;\n\n        return this;\n\n    },\n\n    /**\n    * Sets this animation back to the first frame and restarts the animation.\n    *\n    * @method Phaser.Animation#restart\n    */\n    restart: function () {\n\n        this.isPlaying = true;\n        this.isFinished = false;\n        this.paused = false;\n        this.loopCount = 0;\n\n        this._timeLastFrame = this.game.time.time;\n        this._timeNextFrame = this.game.time.time + this.delay;\n\n        this._frameIndex = 0;\n\n        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n\n        this._parent.setFrame(this.currentFrame);\n\n        this._parent.animations.currentAnim = this;\n        this._parent.animations.currentFrame = this.currentFrame;\n\n        this.onStart.dispatch(this._parent, this);\n\n    },\n\n    /**\n    * Reverses the animation direction.\n    *\n    * @method Phaser.Animation#reverse\n    * @return {Phaser.Animation} The animation instance.\n    */\n    reverse: function () {\n\n        this.reversed = !this.reversed;\n\n        return this;\n\n    },\n\n    /**\n    * Reverses the animation direction for the current/next animation only\n    * Once the onComplete event is called this method will be called again and revert\n    * the reversed state.\n    *\n    * @method Phaser.Animation#reverseOnce\n    * @return {Phaser.Animation} The animation instance.\n    */\n    reverseOnce: function () {\n\n        this.onComplete.addOnce(this.reverse, this);\n\n        return this.reverse();\n\n    },\n\n    /**\n    * Sets this animations playback to a given frame with the given ID.\n    *\n    * @method Phaser.Animation#setFrame\n    * @param {string|number} [frameId] - The identifier of the frame to set. Can be the name of the frame, the sprite index of the frame, or the animation-local frame index.\n    * @param {boolean} [useLocalFrameIndex=false] - If you provide a number for frameId, should it use the numeric indexes of the frameData, or the 0-indexed frame index local to the animation.\n    */\n    setFrame: function(frameId, useLocalFrameIndex) {\n\n        var frameIndex;\n\n        if (useLocalFrameIndex === undefined)\n        {\n            useLocalFrameIndex = false;\n        }\n\n        //  Find the index to the desired frame.\n        if (typeof frameId === \"string\")\n        {\n            for (var i = 0; i < this._frames.length; i++)\n            {\n                if (this._frameData.getFrame(this._frames[i]).name === frameId)\n                {\n                    frameIndex = i;\n                }\n            }\n        }\n        else if (typeof frameId === \"number\")\n        {\n            if (useLocalFrameIndex)\n            {\n                frameIndex = frameId;\n            }\n            else\n            {\n                for (var i = 0; i < this._frames.length; i++)\n                {\n                    if (this._frames[i] === frameId)\n                    {\n                        frameIndex = i;\n                    }\n                }\n            }\n        }\n\n        if (frameIndex)\n        {\n            //  Set the current frame index to the found index. Subtract 1 so that it animates to the desired frame on update.\n            this._frameIndex = frameIndex - 1;\n\n            //  Make the animation update at next update\n            this._timeNextFrame = this.game.time.time;\n\n            this.update();\n        }\n\n    },\n\n    /**\n    * Stops playback of this animation and set it to a finished state. If a resetFrame is provided it will stop playback and set frame to the first in the animation.\n    * If `dispatchComplete` is true it will dispatch the complete events, otherwise they'll be ignored.\n    *\n    * @method Phaser.Animation#stop\n    * @param {boolean} [resetFrame=false] - If true after the animation stops the currentFrame value will be set to the first frame in this animation.\n    * @param {boolean} [dispatchComplete=false] - Dispatch the Animation.onComplete and parent.onAnimationComplete events?\n    */\n    stop: function (resetFrame, dispatchComplete) {\n\n        if (resetFrame === undefined) { resetFrame = false; }\n        if (dispatchComplete === undefined) { dispatchComplete = false; }\n\n        this.isPlaying = false;\n        this.isFinished = true;\n        this.paused = false;\n\n        if (resetFrame)\n        {\n            this.currentFrame = this._frameData.getFrame(this._frames[0]);\n            this._parent.setFrame(this.currentFrame);\n        }\n\n        if (dispatchComplete)\n        {\n            this._parent.events.onAnimationComplete$dispatch(this._parent, this);\n            this.onComplete.dispatch(this._parent, this);\n        }\n\n    },\n\n    /**\n    * Called when the Game enters a paused state.\n    *\n    * @method Phaser.Animation#onPause\n    */\n    onPause: function () {\n\n        if (this.isPlaying)\n        {\n            this._frameDiff = this._timeNextFrame - this.game.time.time;\n        }\n\n    },\n\n    /**\n    * Called when the Game resumes from a paused state.\n    *\n    * @method Phaser.Animation#onResume\n    */\n    onResume: function () {\n\n        if (this.isPlaying)\n        {\n            this._timeNextFrame = this.game.time.time + this._frameDiff;\n        }\n\n    },\n\n    /**\n    * Updates this animation. Called automatically by the AnimationManager.\n    *\n    * @method Phaser.Animation#update\n    */\n    update: function () {\n\n        if (this.isPaused)\n        {\n            return false;\n        }\n\n        if (this.isPlaying && this.game.time.time >= this._timeNextFrame)\n        {\n            this._frameSkip = 1;\n\n            //  Lagging?\n            this._frameDiff = this.game.time.time - this._timeNextFrame;\n\n            this._timeLastFrame = this.game.time.time;\n\n            if (this._frameDiff > this.delay)\n            {\n                //  We need to skip a frame, work out how many\n                this._frameSkip = Math.floor(this._frameDiff / this.delay);\n                this._frameDiff -= (this._frameSkip * this.delay);\n            }\n\n            //  And what's left now?\n            this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff);\n\n            if (this.isReversed)\n            {\n                this._frameIndex -= this._frameSkip;\n            }\n            else\n            {\n                this._frameIndex += this._frameSkip;\n            }\n\n            if (!this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1)\n            {\n                if (this.loop)\n                {\n                    // Update current state before event callback\n                    this._frameIndex = Math.abs(this._frameIndex) % this._frames.length;\n\n                    if (this.isReversed)\n                    {\n                        this._frameIndex = this._frames.length - 1 - this._frameIndex;\n                    }\n\n                    this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n\n                    //  Instead of calling updateCurrentFrame we do it here instead\n                    if (this.currentFrame)\n                    {\n                        this._parent.setFrame(this.currentFrame);\n                    }\n\n                    this.loopCount++;\n                    this._parent.events.onAnimationLoop$dispatch(this._parent, this);\n                    this.onLoop.dispatch(this._parent, this);\n\n                    if (this.onUpdate)\n                    {\n                        this.onUpdate.dispatch(this, this.currentFrame);\n\n                        // False if the animation was destroyed from within a callback\n                        return !!this._frameData;\n                    }\n                    else\n                    {\n                        return true;\n                    }\n                }\n                else\n                {\n                    this.complete();\n                    return false;\n                }\n            }\n            else\n            {\n                return this.updateCurrentFrame(true);\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Changes the currentFrame per the _frameIndex, updates the display state,\n    * and triggers the update signal.\n    *\n    * Returns true if the current frame update was 'successful', false otherwise.\n    *\n    * @method Phaser.Animation#updateCurrentFrame\n    * @private\n    * @param {boolean} signalUpdate - If true the `Animation.onUpdate` signal will be dispatched.\n    * @param {boolean} fromPlay - Was this call made from the playing of a new animation?\n    * @return {boolean} True if the current frame was updated, otherwise false.\n    */\n    updateCurrentFrame: function (signalUpdate, fromPlay) {\n\n        if (fromPlay === undefined) { fromPlay = false; }\n\n        if (!this._frameData)\n        {\n            // The animation is already destroyed, probably from a callback\n            return false;\n        }\n\n        //  Previous index\n        var idx = this.currentFrame.index;\n\n        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n\n        if (this.currentFrame && (fromPlay || (!fromPlay && idx !== this.currentFrame.index)))\n        {\n            this._parent.setFrame(this.currentFrame);\n        }\n\n        if (this.onUpdate && signalUpdate)\n        {\n            this.onUpdate.dispatch(this, this.currentFrame);\n\n            // False if the animation was destroyed from within a callback\n            return !!this._frameData;\n        }\n        else\n        {\n            return true;\n        }\n\n    },\n\n    /**\n    * Advances by the given number of frames in the Animation, taking the loop value into consideration.\n    *\n    * @method Phaser.Animation#next\n    * @param {number} [quantity=1] - The number of frames to advance.\n    */\n    next: function (quantity) {\n\n        if (quantity === undefined) { quantity = 1; }\n\n        var frame = this._frameIndex + quantity;\n\n        if (frame >= this._frames.length)\n        {\n            if (this.loop)\n            {\n                frame %= this._frames.length;\n            }\n            else\n            {\n                frame = this._frames.length - 1;\n            }\n        }\n\n        if (frame !== this._frameIndex)\n        {\n            this._frameIndex = frame;\n            this.updateCurrentFrame(true);\n        }\n\n    },\n\n    /**\n    * Moves backwards the given number of frames in the Animation, taking the loop value into consideration.\n    *\n    * @method Phaser.Animation#previous\n    * @param {number} [quantity=1] - The number of frames to move back.\n    */\n    previous: function (quantity) {\n\n        if (quantity === undefined) { quantity = 1; }\n\n        var frame = this._frameIndex - quantity;\n\n        if (frame < 0)\n        {\n            if (this.loop)\n            {\n                frame = this._frames.length + frame;\n            }\n            else\n            {\n                frame++;\n            }\n        }\n\n        if (frame !== this._frameIndex)\n        {\n            this._frameIndex = frame;\n            this.updateCurrentFrame(true);\n        }\n\n    },\n\n    /**\n    * Changes the FrameData object this Animation is using.\n    *\n    * @method Phaser.Animation#updateFrameData\n    * @param {Phaser.FrameData} frameData - The FrameData object that contains all frames used by this Animation.\n    */\n    updateFrameData: function (frameData) {\n\n        this._frameData = frameData;\n        this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null;\n\n    },\n\n    /**\n    * Cleans up this animation ready for deletion. Nulls all values and references.\n    *\n    * @method Phaser.Animation#destroy\n    */\n    destroy: function () {\n\n        if (!this._frameData)\n        {\n            // Already destroyed\n            return;\n        }\n\n        this.game.onPause.remove(this.onPause, this);\n        this.game.onResume.remove(this.onResume, this);\n\n        this.game = null;\n        this._parent = null;\n        this._frames = null;\n        this._frameData = null;\n        this.currentFrame = null;\n        this.isPlaying = false;\n\n        this.onStart.dispose();\n        this.onLoop.dispose();\n        this.onComplete.dispose();\n\n        if (this.onUpdate)\n        {\n            this.onUpdate.dispose();\n        }\n\n    },\n\n    /**\n    * Called internally when the animation finishes playback.\n    * Sets the isPlaying and isFinished states and dispatches the onAnimationComplete event if it exists on the parent and local onComplete event.\n    *\n    * @method Phaser.Animation#complete\n    */\n    complete: function () {\n\n        this._frameIndex = this._frames.length - 1;\n        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n\n        this.isPlaying = false;\n        this.isFinished = true;\n        this.paused = false;\n\n        this._parent.events.onAnimationComplete$dispatch(this._parent, this);\n\n        this.onComplete.dispatch(this._parent, this);\n\n        if (this.killOnComplete)\n        {\n            this._parent.kill();\n        }\n\n    }\n\n};\n\nPhaser.Animation.prototype.constructor = Phaser.Animation;\n\n/**\n* @name Phaser.Animation#paused\n* @property {boolean} paused - Gets and sets the paused state of this Animation.\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'paused', {\n\n    get: function () {\n\n        return this.isPaused;\n\n    },\n\n    set: function (value) {\n\n        this.isPaused = value;\n\n        if (value)\n        {\n            //  Paused\n            this._pauseStartTime = this.game.time.time;\n        }\n        else\n        {\n            //  Un-paused\n            if (this.isPlaying)\n            {\n                this._timeNextFrame = this.game.time.time + this.delay;\n            }\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Animation#reversed\n* @property {boolean} reversed - Gets and sets the isReversed state of this Animation.\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'reversed', {\n\n    get: function () {\n\n        return this.isReversed;\n\n    },\n\n    set: function (value) {\n\n        this.isReversed = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Animation#frameTotal\n* @property {number} frameTotal - The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.\n* @readonly\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'frameTotal', {\n\n    get: function () {\n        return this._frames.length;\n    }\n\n});\n\n/**\n* @name Phaser.Animation#frame\n* @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'frame', {\n\n    get: function () {\n\n        if (this.currentFrame !== null)\n        {\n            return this.currentFrame.index;\n        }\n        else\n        {\n            return this._frameIndex;\n        }\n\n    },\n\n    set: function (value) {\n\n        this.currentFrame = this._frameData.getFrame(this._frames[value]);\n\n        if (this.currentFrame !== null)\n        {\n            this._frameIndex = value;\n            this._parent.setFrame(this.currentFrame);\n\n            if (this.onUpdate)\n            {\n                this.onUpdate.dispatch(this, this.currentFrame);\n            }\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Animation#speed\n* @property {number} speed - Gets or sets the current speed of the animation in frames per second. Changing this in a playing animation will take effect from the next frame. Value must be greater than 0.\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'speed', {\n\n    get: function () {\n\n        return 1000 / this.delay;\n\n    },\n\n    set: function (value) {\n\n        if (value > 0)\n        {\n            this.delay = 1000 / value;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Animation#enableUpdate\n* @property {boolean} enableUpdate - Gets or sets if this animation will dispatch the onUpdate events upon changing frame.\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'enableUpdate', {\n\n    get: function () {\n\n        return (this.onUpdate !== null);\n\n    },\n\n    set: function (value) {\n\n        if (value && this.onUpdate === null)\n        {\n            this.onUpdate = new Phaser.Signal();\n        }\n        else if (!value && this.onUpdate !== null)\n        {\n            this.onUpdate.dispose();\n            this.onUpdate = null;\n        }\n\n    }\n\n});\n\n/**\n* Really handy function for when you are creating arrays of animation data but it's using frame names and not numbers.\n* For example imagine you've got 30 frames named: 'explosion_0001-large' to 'explosion_0030-large'\n* You could use this function to generate those by doing: Phaser.Animation.generateFrameNames('explosion_', 1, 30, '-large', 4);\n*\n* @method Phaser.Animation.generateFrameNames\n* @static\n* @param {string} prefix - The start of the filename. If the filename was 'explosion_0001-large' the prefix would be 'explosion_'.\n* @param {number} start - The number to start sequentially counting from. If your frames are named 'explosion_0001' to 'explosion_0034' the start is 1.\n* @param {number} stop - The number to count to. If your frames are named 'explosion_0001' to 'explosion_0034' the stop value is 34.\n* @param {string} [suffix=''] - The end of the filename. If the filename was 'explosion_0001-large' the prefix would be '-large'.\n* @param {number} [zeroPad=0] - The number of zeros to pad the min and max values with. If your frames are named 'explosion_0001' to 'explosion_0034' then the zeroPad is 4.\n* @return {string[]} An array of framenames.\n*/\nPhaser.Animation.generateFrameNames = function (prefix, start, stop, suffix, zeroPad) {\n\n    if (suffix === undefined) { suffix = ''; }\n\n    var output = [];\n    var frame = '';\n\n    if (start < stop)\n    {\n        for (var i = start; i <= stop; i++)\n        {\n            if (typeof zeroPad === 'number')\n            {\n                //  str, len, pad, dir\n                frame = Phaser.Utils.pad(i.toString(), zeroPad, '0', 1);\n            }\n            else\n            {\n                frame = i.toString();\n            }\n\n            frame = prefix + frame + suffix;\n\n            output.push(frame);\n        }\n    }\n    else\n    {\n        for (var i = start; i >= stop; i--)\n        {\n            if (typeof zeroPad === 'number')\n            {\n                //  str, len, pad, dir\n                frame = Phaser.Utils.pad(i.toString(), zeroPad, '0', 1);\n            }\n            else\n            {\n                frame = i.toString();\n            }\n\n            frame = prefix + frame + suffix;\n\n            output.push(frame);\n        }\n    }\n\n    return output;\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Frame is a single frame of an animation and is part of a FrameData collection.\n*\n* @class Phaser.Frame\n* @constructor\n* @param {number} index - The index of this Frame within the FrameData set it is being added to.\n* @param {number} x - X position of the frame within the texture image.\n* @param {number} y - Y position of the frame within the texture image.\n* @param {number} width - Width of the frame within the texture image.\n* @param {number} height - Height of the frame within the texture image.\n* @param {string} name - The name of the frame. In Texture Atlas data this is usually set to the filename.\n*/\nPhaser.Frame = function (index, x, y, width, height, name) {\n\n    /**\n    * @property {number} index - The index of this Frame within the FrameData set it is being added to.\n    */\n    this.index = index;\n\n    /**\n    * @property {number} x - X position within the image to cut from.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - Y position within the image to cut from.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} width - Width of the frame.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - Height of the frame.\n    */\n    this.height = height;\n\n    /**\n    * @property {string} name - Useful for Texture Atlas files (is set to the filename value).\n    */\n    this.name = name;\n\n    /**\n    * @property {number} centerX - Center X position within the image to cut from.\n    */\n    this.centerX = Math.floor(width / 2);\n\n    /**\n    * @property {number} centerY - Center Y position within the image to cut from.\n    */\n    this.centerY = Math.floor(height / 2);\n\n    /**\n    * @property {number} distance - The distance from the top left to the bottom-right of this Frame.\n    */\n    this.distance = Phaser.Math.distance(0, 0, width, height);\n\n    /**\n    * @property {boolean} rotated - Rotated? (not yet implemented)\n    * @default\n    */\n    this.rotated = false;\n\n    /**\n    * @property {string} rotationDirection - Either 'cw' or 'ccw', rotation is always 90 degrees.\n    * @default 'cw'\n    */\n    this.rotationDirection = 'cw';\n\n    /**\n    * @property {boolean} trimmed - Was it trimmed when packed?\n    * @default\n    */\n    this.trimmed = false;\n\n    /**\n    * @property {number} sourceSizeW - Width of the original sprite before it was trimmed.\n    */\n    this.sourceSizeW = width;\n\n    /**\n    * @property {number} sourceSizeH - Height of the original sprite before it was trimmed.\n    */\n    this.sourceSizeH = height;\n\n    /**\n    * @property {number} spriteSourceSizeX - X position of the trimmed sprite inside original sprite.\n    * @default\n    */\n    this.spriteSourceSizeX = 0;\n\n    /**\n    * @property {number} spriteSourceSizeY - Y position of the trimmed sprite inside original sprite.\n    * @default\n    */\n    this.spriteSourceSizeY = 0;\n\n    /**\n    * @property {number} spriteSourceSizeW - Width of the trimmed sprite.\n    * @default\n    */\n    this.spriteSourceSizeW = 0;\n\n    /**\n    * @property {number} spriteSourceSizeH - Height of the trimmed sprite.\n    * @default\n    */\n    this.spriteSourceSizeH = 0;\n\n    /**\n    * @property {number} right - The right of the Frame (x + width).\n    */\n    this.right = this.x + this.width;\n\n    /**\n    * @property {number} bottom - The bottom of the frame (y + height).\n    */\n    this.bottom = this.y + this.height;\n\n};\n\nPhaser.Frame.prototype = {\n\n    /**\n    * Adjusts of all the Frame properties based on the given width and height values.\n    *\n    * @method Phaser.Frame#resize\n    * @param {integer} width - The new width of the Frame.\n    * @param {integer} height - The new height of the Frame.\n    */\n    resize: function (width, height) {\n\n        this.width = width;\n        this.height = height;\n        this.centerX = Math.floor(width / 2);\n        this.centerY = Math.floor(height / 2);\n        this.distance = Phaser.Math.distance(0, 0, width, height);\n        this.sourceSizeW = width;\n        this.sourceSizeH = height;\n        this.right = this.x + width;\n        this.bottom = this.y + height;\n\n    },\n\n    /**\n    * If the frame was trimmed when added to the Texture Atlas this records the trim and source data.\n    *\n    * @method Phaser.Frame#setTrim\n    * @param {boolean} trimmed - If this frame was trimmed or not.\n    * @param {number} actualWidth - The width of the frame before being trimmed.\n    * @param {number} actualHeight - The height of the frame before being trimmed.\n    * @param {number} destX - The destination X position of the trimmed frame for display.\n    * @param {number} destY - The destination Y position of the trimmed frame for display.\n    * @param {number} destWidth - The destination width of the trimmed frame for display.\n    * @param {number} destHeight - The destination height of the trimmed frame for display.\n    */\n    setTrim: function (trimmed, actualWidth, actualHeight, destX, destY, destWidth, destHeight) {\n\n        this.trimmed = trimmed;\n\n        if (trimmed)\n        {\n            this.sourceSizeW = actualWidth;\n            this.sourceSizeH = actualHeight;\n            this.centerX = Math.floor(actualWidth / 2);\n            this.centerY = Math.floor(actualHeight / 2);\n            this.spriteSourceSizeX = destX;\n            this.spriteSourceSizeY = destY;\n            this.spriteSourceSizeW = destWidth;\n            this.spriteSourceSizeH = destHeight;\n        }\n\n    },\n\n    /**\n     * Clones this Frame into a new Phaser.Frame object and returns it.\n     * Note that all properties are cloned, including the name, index and UUID.\n     *\n     * @method Phaser.Frame#clone\n     * @return {Phaser.Frame} An exact copy of this Frame object.\n     */\n    clone: function () {\n\n        var output = new Phaser.Frame(this.index, this.x, this.y, this.width, this.height, this.name);\n\n        for (var prop in this)\n        {\n            if (this.hasOwnProperty(prop))\n            {\n                output[prop] = this[prop];\n            }\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Returns a Rectangle set to the dimensions of this Frame.\n    *\n    * @method Phaser.Frame#getRect\n    * @param {Phaser.Rectangle} [out] - A rectangle to copy the frame dimensions to.\n    * @return {Phaser.Rectangle} A rectangle.\n    */\n    getRect: function (out) {\n\n        if (out === undefined)\n        {\n            out = new Phaser.Rectangle(this.x, this.y, this.width, this.height);\n        }\n        else\n        {\n            out.setTo(this.x, this.y, this.width, this.height);\n        }\n\n        return out;\n\n    }\n\n};\n\nPhaser.Frame.prototype.constructor = Phaser.Frame;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* FrameData is a container for Frame objects, which are the internal representation of animation data in Phaser.\n*\n* @class Phaser.FrameData\n* @constructor\n*/\nPhaser.FrameData = function () {\n\n    /**\n    * @property {Array} _frames - Local array of frames.\n    * @private\n    */\n    this._frames = [];\n\n    /**\n    * @property {Array} _frameNames - Local array of frame names for name to index conversions.\n    * @private\n    */\n    this._frameNames = [];\n\n};\n\nPhaser.FrameData.prototype = {\n\n    /**\n    * Adds a new Frame to this FrameData collection. Typically called by the Animation.Parser and not directly.\n    *\n    * @method Phaser.FrameData#addFrame\n    * @param {Phaser.Frame} frame - The frame to add to this FrameData set.\n    * @return {Phaser.Frame} The frame that was just added.\n    */\n    addFrame: function (frame) {\n\n        frame.index = this._frames.length;\n\n        this._frames.push(frame);\n\n        if (frame.name !== '')\n        {\n            this._frameNames[frame.name] = frame.index;\n        }\n\n        return frame;\n\n    },\n\n    /**\n    * Get a Frame by its numerical index.\n    *\n    * @method Phaser.FrameData#getFrame\n    * @param {number} index - The index of the frame you want to get.\n    * @return {Phaser.Frame} The frame, if found.\n    */\n    getFrame: function (index) {\n\n        if (index >= this._frames.length)\n        {\n            index = 0;\n        }\n\n        return this._frames[index];\n\n    },\n\n    /**\n    * Get a Frame by its frame name.\n    *\n    * @method Phaser.FrameData#getFrameByName\n    * @param {string} name - The name of the frame you want to get.\n    * @return {Phaser.Frame} The frame, if found.\n    */\n    getFrameByName: function (name) {\n\n        if (typeof this._frameNames[name] === 'number')\n        {\n            return this._frames[this._frameNames[name]];\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Check if there is a Frame with the given name.\n    *\n    * @method Phaser.FrameData#checkFrameName\n    * @param {string} name - The name of the frame you want to check.\n    * @return {boolean} True if the frame is found, otherwise false.\n    */\n    checkFrameName: function (name) {\n\n        if (this._frameNames[name] == null)\n        {\n            return false;\n        }\n\n        return true;\n\n    },\n\n    /**\n     * Makes a copy of this FrameData including copies (not references) to all of the Frames it contains.\n     *\n     * @method Phaser.FrameData#clone\n     * @return {Phaser.FrameData} A clone of this object, including clones of the Frame objects it contains.\n     */\n    clone: function () {\n\n        var output = new Phaser.FrameData();\n\n        //  No input array, so we loop through all frames\n        for (var i = 0; i < this._frames.length; i++)\n        {\n            output._frames.push(this._frames[i].clone());\n        }\n\n        for (var p in this._frameNames)\n        {\n            if (this._frameNames.hasOwnProperty(p))\n            {\n                output._frameNames.push(this._frameNames[p]);\n            }\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Returns a range of frames based on the given start and end frame indexes and returns them in an Array.\n    *\n    * @method Phaser.FrameData#getFrameRange\n    * @param {number} start - The starting frame index.\n    * @param {number} end - The ending frame index.\n    * @param {Array} [output] - If given the results will be appended to the end of this array otherwise a new array will be created.\n    * @return {Array} An array of Frames between the start and end index values, or an empty array if none were found.\n    */\n    getFrameRange: function (start, end, output) {\n\n        if (output === undefined) { output = []; }\n\n        for (var i = start; i <= end; i++)\n        {\n            output.push(this._frames[i]);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Returns all of the Frames in this FrameData set where the frame index is found in the input array.\n    * The frames are returned in the output array, or if none is provided in a new Array object.\n    *\n    * @method Phaser.FrameData#getFrames\n    * @param {Array} [frames] - An Array containing the indexes of the frames to retrieve. If the array is empty or undefined then all frames in the FrameData are returned.\n    * @param {boolean} [useNumericIndex=true] - Are the given frames using numeric indexes (default) or strings? (false)\n    * @param {Array} [output] - If given the results will be appended to the end of this array otherwise a new array will be created.\n    * @return {Array} An array of all Frames in this FrameData set matching the given names or IDs.\n    */\n    getFrames: function (frames, useNumericIndex, output) {\n\n        if (useNumericIndex === undefined) { useNumericIndex = true; }\n        if (output === undefined) { output = []; }\n\n        if (frames === undefined || frames.length === 0)\n        {\n            //  No input array, so we loop through all frames\n            for (var i = 0; i < this._frames.length; i++)\n            {\n                //  We only need the indexes\n                output.push(this._frames[i]);\n            }\n        }\n        else\n        {\n            //  Input array given, loop through that instead\n            for (var i = 0; i < frames.length; i++)\n            {\n                //  Does the input array contain names or indexes?\n                if (useNumericIndex)\n                {\n                    //  The actual frame\n                    output.push(this.getFrame(frames[i]));\n                }\n                else\n                {\n                    //  The actual frame\n                    output.push(this.getFrameByName(frames[i]));\n                }\n            }\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Returns all of the Frame indexes in this FrameData set.\n    * The frames indexes are returned in the output array, or if none is provided in a new Array object.\n    *\n    * @method Phaser.FrameData#getFrameIndexes\n    * @param {Array} [frames] - An Array containing the indexes of the frames to retrieve. If undefined or the array is empty then all frames in the FrameData are returned.\n    * @param {boolean} [useNumericIndex=true] - Are the given frames using numeric indexes (default) or strings? (false)\n    * @param {Array} [output] - If given the results will be appended to the end of this array otherwise a new array will be created.\n    * @return {Array} An array of all Frame indexes matching the given names or IDs.\n    */\n    getFrameIndexes: function (frames, useNumericIndex, output) {\n\n        if (useNumericIndex === undefined) { useNumericIndex = true; }\n        if (output === undefined) { output = []; }\n\n        if (frames === undefined || frames.length === 0)\n        {\n            //  No frames array, so we loop through all frames\n            for (var i = 0; i < this._frames.length; i++)\n            {\n                output.push(this._frames[i].index);\n            }\n        }\n        else\n        {\n            //  Input array given, loop through that instead\n            for (var i = 0; i < frames.length; i++)\n            {\n                //  Does the frames array contain names or indexes?\n                if (useNumericIndex && this._frames[frames[i]])\n                {\n                    output.push(this._frames[frames[i]].index);\n                }\n                else\n                {\n                    if (this.getFrameByName(frames[i]))\n                    {\n                        output.push(this.getFrameByName(frames[i]).index);\n                    }\n                }\n            }\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Destroys this FrameData collection by nulling the _frames and _frameNames arrays.\n    *\n    * @method Phaser.FrameData#destroy\n    */\n    destroy: function () {\n\n        this._frames = null;\n        this._frameNames = null;\n\n    }\n\n};\n\nPhaser.FrameData.prototype.constructor = Phaser.FrameData;\n\n/**\n* @name Phaser.FrameData#total\n* @property {number} total - The total number of frames in this FrameData set.\n* @readonly\n*/\nObject.defineProperty(Phaser.FrameData.prototype, \"total\", {\n\n    get: function () {\n        return this._frames.length;\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Responsible for parsing sprite sheet and JSON data into the internal FrameData format that Phaser uses for animations.\n*\n* @class Phaser.AnimationParser\n* @static\n*/\nPhaser.AnimationParser = {\n\n    /**\n    * Parse a Sprite Sheet and extract the animation frame data from it.\n    *\n    * @method Phaser.AnimationParser.spriteSheet\n    * @param {Phaser.Game} game - A reference to the currently running game.\n    * @param {string|Image} key - The Game.Cache asset key of the Sprite Sheet image or an actual HTML Image element.\n    * @param {number} frameWidth - The fixed width of each frame of the animation.\n    * @param {number} frameHeight - The fixed height of each frame of the animation.\n    * @param {number} [frameMax=-1] - The total number of animation frames to extract from the Sprite Sheet. The default value of -1 means \"extract all frames\".\n    * @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.\n    * @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\n    * @return {Phaser.FrameData} A FrameData object containing the parsed frames.\n    */\n    spriteSheet: function (game, key, frameWidth, frameHeight, frameMax, margin, spacing) {\n\n        var img = key;\n\n        if (typeof key === 'string')\n        {\n            img = game.cache.getImage(key);\n        }\n\n        if (img === null)\n        {\n            return null;\n        }\n\n        var width = img.width;\n        var height = img.height;\n\n        if (frameWidth <= 0)\n        {\n            frameWidth = Math.floor(-width / Math.min(-1, frameWidth));\n        }\n\n        if (frameHeight <= 0)\n        {\n            frameHeight = Math.floor(-height / Math.min(-1, frameHeight));\n        }\n\n        var row = Math.floor((width - margin) / (frameWidth + spacing));\n        var column = Math.floor((height - margin) / (frameHeight + spacing));\n        var total = row * column;\n\n        if (frameMax !== -1)\n        {\n            total = frameMax;\n        }\n\n        //  Zero or smaller than frame sizes?\n        if (width === 0 || height === 0 || width < frameWidth || height < frameHeight || total === 0)\n        {\n            console.warn(\"Phaser.AnimationParser.spriteSheet: '\" + key + \"'s width/height zero or width/height < given frameWidth/frameHeight\");\n            return null;\n        }\n\n        //  Let's create some frames then\n        var data = new Phaser.FrameData();\n        var x = margin;\n        var y = margin;\n\n        for (var i = 0; i < total; i++)\n        {\n            data.addFrame(new Phaser.Frame(i, x, y, frameWidth, frameHeight, ''));\n\n            x += frameWidth + spacing;\n\n            if (x + frameWidth > width)\n            {\n                x = margin;\n                y += frameHeight + spacing;\n            }\n        }\n\n        return data;\n\n    },\n\n    /**\n    * Parse the JSON data and extract the animation frame data from it.\n    *\n    * @method Phaser.AnimationParser.JSONData\n    * @param {Phaser.Game} game - A reference to the currently running game.\n    * @param {object} json - The JSON data from the Texture Atlas. Must be in Array format.\n    * @return {Phaser.FrameData} A FrameData object containing the parsed frames.\n    */\n    JSONData: function (game, json) {\n\n        //  Malformed?\n        if (!json['frames'])\n        {\n            console.warn(\"Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array\");\n            console.log(json);\n            return;\n        }\n\n        //  Let's create some frames then\n        var data = new Phaser.FrameData();\n\n        //  By this stage frames is a fully parsed array\n        var frames = json['frames'];\n        var newFrame;\n\n        for (var i = 0; i < frames.length; i++)\n        {\n            newFrame = data.addFrame(new Phaser.Frame(\n                i,\n                frames[i].frame.x,\n                frames[i].frame.y,\n                frames[i].frame.w,\n                frames[i].frame.h,\n                frames[i].filename\n            ));\n\n            if (frames[i].trimmed)\n            {\n                newFrame.setTrim(\n                    frames[i].trimmed,\n                    frames[i].sourceSize.w,\n                    frames[i].sourceSize.h,\n                    frames[i].spriteSourceSize.x,\n                    frames[i].spriteSourceSize.y,\n                    frames[i].spriteSourceSize.w,\n                    frames[i].spriteSourceSize.h\n                );\n            }\n        }\n\n        return data;\n\n    },\n\n    /**\n    * Parse the JSON data and extract the animation frame data from it.\n    *\n    * @method Phaser.AnimationParser.JSONDataPyxel\n    * @param {Phaser.Game} game - A reference to the currently running game.\n    * @param {object} json - The JSON data from the Texture Atlas. Must be in Pyxel JSON format.\n    * @return {Phaser.FrameData} A FrameData object containing the parsed frames.\n    */\n    JSONDataPyxel: function (game, json) {\n\n        //  Malformed? There are a few keys to check here.\n        var signature = ['layers', 'tilewidth','tileheight','tileswide', 'tileshigh'];\n\n        signature.forEach( function(key) {\n            if (!json[key])\n            {\n                console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing \"' + key + '\" key.');\n                console.log(json);\n                return;\n            }\n        });\n\n        // For this purpose, I only care about parsing tilemaps with a single layer.\n        if (json['layers'].length !== 1)\n        {\n            console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.');\n            console.log(json);\n            return;\n        }\n\n        var data = new Phaser.FrameData();\n\n        var tileheight = json['tileheight'];\n        var tilewidth = json['tilewidth'];\n\n        var frames = json['layers'][0]['tiles'];\n        var newFrame;\n\n        for (var i = 0; i < frames.length; i++)\n        {\n            newFrame = data.addFrame(new Phaser.Frame(\n                i,\n                frames[i].x,\n                frames[i].y,\n                tilewidth,\n                tileheight,\n                \"frame_\" + i  // No names are included in pyxel tilemap data.\n            ));\n\n            // No trim data is included.\n            newFrame.setTrim(false);\n        }\n\n        return data;\n\n    },\n\n    /**\n    * Parse the JSON data and extract the animation frame data from it.\n    *\n    * @method Phaser.AnimationParser.JSONDataHash\n    * @param {Phaser.Game} game - A reference to the currently running game.\n    * @param {object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.\n    * @return {Phaser.FrameData} A FrameData object containing the parsed frames.\n    */\n    JSONDataHash: function (game, json) {\n\n        //  Malformed?\n        if (!json['frames'])\n        {\n            console.warn(\"Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object\");\n            console.log(json);\n            return;\n        }\n\n        //  Let's create some frames then\n        var data = new Phaser.FrameData();\n\n        //  By this stage frames is a fully parsed array\n        var frames = json['frames'];\n        var newFrame;\n        var i = 0;\n\n        for (var key in frames)\n        {\n            newFrame = data.addFrame(new Phaser.Frame(\n                i,\n                frames[key].frame.x,\n                frames[key].frame.y,\n                frames[key].frame.w,\n                frames[key].frame.h,\n                key\n            ));\n\n            if (frames[key].trimmed)\n            {\n                newFrame.setTrim(\n                    frames[key].trimmed,\n                    frames[key].sourceSize.w,\n                    frames[key].sourceSize.h,\n                    frames[key].spriteSourceSize.x,\n                    frames[key].spriteSourceSize.y,\n                    frames[key].spriteSourceSize.w,\n                    frames[key].spriteSourceSize.h\n                );\n            }\n\n            i++;\n        }\n\n        return data;\n\n    },\n\n    /**\n    * Parse the XML data and extract the animation frame data from it.\n    *\n    * @method Phaser.AnimationParser.XMLData\n    * @param {Phaser.Game} game - A reference to the currently running game.\n    * @param {object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.\n    * @return {Phaser.FrameData} A FrameData object containing the parsed frames.\n    */\n    XMLData: function (game, xml) {\n\n        //  Malformed?\n        if (!xml.getElementsByTagName('TextureAtlas'))\n        {\n            console.warn(\"Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag\");\n            return;\n        }\n\n        //  Let's create some frames then\n        var data = new Phaser.FrameData();\n        var frames = xml.getElementsByTagName('SubTexture');\n        var newFrame;\n\n        var name;\n        var frame;\n        var x;\n        var y;\n        var width;\n        var height;\n        var frameX;\n        var frameY;\n        var frameWidth;\n        var frameHeight;\n\n        for (var i = 0; i < frames.length; i++)\n        {\n            frame = frames[i].attributes;\n\n            name = frame.name.value;\n            x = parseInt(frame.x.value, 10);\n            y = parseInt(frame.y.value, 10);\n            width = parseInt(frame.width.value, 10);\n            height = parseInt(frame.height.value, 10);\n\n            frameX = null;\n            frameY = null;\n\n            if (frame.frameX)\n            {\n                frameX = Math.abs(parseInt(frame.frameX.value, 10));\n                frameY = Math.abs(parseInt(frame.frameY.value, 10));\n                frameWidth = parseInt(frame.frameWidth.value, 10);\n                frameHeight = parseInt(frame.frameHeight.value, 10);\n            }\n\n            newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name));\n\n            //  Trimmed?\n            if (frameX !== null || frameY !== null)\n            {\n                newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);\n            }\n        }\n\n        return data;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser has one single cache in which it stores all assets.\n*\n* The cache is split up into sections, such as images, sounds, video, json, etc. All assets are stored using\n* a unique string-based key as their identifier. Assets stored in different areas of the cache can have the\n* same key, for example 'playerWalking' could be used as the key for both a sprite sheet and an audio file,\n* because they are unique data types.\n*\n* The cache is automatically populated by the Phaser.Loader. When you use the loader to pull in external assets\n* such as images they are automatically placed into their respective cache. Most common Game Objects, such as\n* Sprites and Videos automatically query the cache to extract the assets they need on instantiation.\n*\n* You can access the cache from within a State via `this.cache`. From here you can call any public method it has,\n* including adding new entries to it, deleting them or querying them.\n*\n* Understand that almost without exception when you get an item from the cache it will return a reference to the\n* item stored in the cache, not a copy of it. Therefore if you retrieve an item and then modify it, the original\n* object in the cache will also be updated, even if you don't put it back into the cache again.\n*\n* By default when you change State the cache is _not_ cleared, although there is an option to clear it should\n* your game require it. In a typical game set-up the cache is populated once after the main game has loaded and\n* then used as an asset store.\n*\n* @class Phaser.Cache\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Cache = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * Automatically resolve resource URLs to absolute paths for use with the Cache.getURL method.\n    * @property {boolean} autoResolveURL\n    */\n    this.autoResolveURL = false;\n\n    /**\n    * The main cache object into which all resources are placed.\n    * @property {object} _cache\n    * @private\n    */\n    this._cache = {\n        canvas: {},\n        image: {},\n        texture: {},\n        sound: {},\n        video: {},\n        text: {},\n        json: {},\n        xml: {},\n        physics: {},\n        tilemap: {},\n        binary: {},\n        bitmapData: {},\n        bitmapFont: {},\n        shader: {},\n        renderTexture: {}\n    };\n\n    /**\n    * @property {object} _urlMap - Maps URLs to resources.\n    * @private\n    */\n    this._urlMap = {};\n\n    /**\n    * @property {Image} _urlResolver - Used to resolve URLs to the absolute path.\n    * @private\n    */\n    this._urlResolver = new Image();\n\n    /**\n    * @property {string} _urlTemp - Temporary variable to hold a resolved url.\n    * @private\n    */\n    this._urlTemp = null;\n\n    /**\n    * @property {Phaser.Signal} onSoundUnlock - This event is dispatched when the sound system is unlocked via a touch event on cellular devices.\n    */\n    this.onSoundUnlock = new Phaser.Signal();\n\n    /**\n    * @property {array} _cacheMap - Const to cache object look-up array.\n    * @private\n    */\n    this._cacheMap = [];\n\n    this._cacheMap[Phaser.Cache.CANVAS] = this._cache.canvas;\n    this._cacheMap[Phaser.Cache.IMAGE] = this._cache.image;\n    this._cacheMap[Phaser.Cache.TEXTURE] = this._cache.texture;\n    this._cacheMap[Phaser.Cache.SOUND] = this._cache.sound;\n    this._cacheMap[Phaser.Cache.TEXT] = this._cache.text;\n    this._cacheMap[Phaser.Cache.PHYSICS] = this._cache.physics;\n    this._cacheMap[Phaser.Cache.TILEMAP] = this._cache.tilemap;\n    this._cacheMap[Phaser.Cache.BINARY] = this._cache.binary;\n    this._cacheMap[Phaser.Cache.BITMAPDATA] = this._cache.bitmapData;\n    this._cacheMap[Phaser.Cache.BITMAPFONT] = this._cache.bitmapFont;\n    this._cacheMap[Phaser.Cache.JSON] = this._cache.json;\n    this._cacheMap[Phaser.Cache.XML] = this._cache.xml;\n    this._cacheMap[Phaser.Cache.VIDEO] = this._cache.video;\n    this._cacheMap[Phaser.Cache.SHADER] = this._cache.shader;\n    this._cacheMap[Phaser.Cache.RENDER_TEXTURE] = this._cache.renderTexture;\n\n    this.addDefaultImage();\n    this.addMissingImage();\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.CANVAS = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.IMAGE = 2;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.TEXTURE = 3;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.SOUND = 4;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.TEXT = 5;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.PHYSICS = 6;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.TILEMAP = 7;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.BINARY = 8;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.BITMAPDATA = 9;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.BITMAPFONT = 10;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.JSON = 11;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.XML = 12;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.VIDEO = 13;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.SHADER = 14;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.RENDER_TEXTURE = 15;\n\n/**\n* The default image used for a texture when no other is specified.\n* @constant\n* @type {PIXI.Texture}\n*/\nPhaser.Cache.DEFAULT = null;\n\n/**\n* The default image used for a texture when the source image is missing.\n* @constant\n* @type {PIXI.Texture}\n*/\nPhaser.Cache.MISSING = null;\n\nPhaser.Cache.prototype = {\n\n    //////////////////\n    //  Add Methods //\n    //////////////////\n\n    /**\n    * Add a new canvas object in to the cache.\n    *\n    * @method Phaser.Cache#addCanvas\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {HTMLCanvasElement} canvas - The Canvas DOM element.\n    * @param {CanvasRenderingContext2D} [context] - The context of the canvas element. If not specified it will default go `getContext('2d')`.\n    */\n    addCanvas: function (key, canvas, context) {\n\n        if (context === undefined) { context = canvas.getContext('2d'); }\n\n        this._cache.canvas[key] = { canvas: canvas, context: context };\n\n    },\n\n    /**\n    * Adds an Image file into the Cache. The file must have already been loaded, typically via Phaser.Loader, but can also have been loaded into the DOM.\n    * If an image already exists in the cache with the same key then it is removed and destroyed, and the new image inserted in its place.\n    *\n    * @method Phaser.Cache#addImage\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra image data.\n    * @return {object} The full image object that was added to the cache.\n    */\n    addImage: function (key, url, data) {\n\n        if (this.checkImageKey(key))\n        {\n            this.removeImage(key);\n        }\n\n        var img = {\n            key: key,\n            url: url,\n            data: data,\n            base: new PIXI.BaseTexture(data),\n            frame: new Phaser.Frame(0, 0, 0, data.width, data.height, key),\n            frameData: new Phaser.FrameData()\n        };\n\n        img.frameData.addFrame(new Phaser.Frame(0, 0, 0, data.width, data.height, url));\n\n        this._cache.image[key] = img;\n\n        this._resolveURL(url, img);\n\n        if (key === '__default')\n        {\n            Phaser.Cache.DEFAULT = new PIXI.Texture(img.base);\n        }\n        else if (key === '__missing')\n        {\n            Phaser.Cache.MISSING = new PIXI.Texture(img.base);\n        }\n\n        return img;\n\n    },\n\n    /**\n    * Adds a default image to be used in special cases such as WebGL Filters.\n    * It uses the special reserved key of `__default`.\n    * This method is called automatically when the Cache is created.\n    * This image is skipped when `Cache.destroy` is called due to its internal requirements.\n    *\n    * @method Phaser.Cache#addDefaultImage\n    * @protected\n    */\n    addDefaultImage: function () {\n\n        var img = new Image();\n\n        img.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==\";\n\n        var obj = this.addImage('__default', null, img);\n\n        //  Because we don't want to invalidate the sprite batch for an invisible texture\n        obj.base.skipRender = true;\n\n        //  Make it easily available within the rest of Phaser / Pixi\n        Phaser.Cache.DEFAULT = new PIXI.Texture(obj.base);\n\n    },\n\n    /**\n    * Adds an image to be used when a key is wrong / missing.\n    * It uses the special reserved key of `__missing`.\n    * This method is called automatically when the Cache is created.\n    * This image is skipped when `Cache.destroy` is called due to its internal requirements.\n    *\n    * @method Phaser.Cache#addMissingImage\n    * @protected\n    */\n    addMissingImage: function () {\n\n        var img = new Image();\n\n        img.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==\";\n\n        var obj = this.addImage('__missing', null, img);\n\n        //  Make it easily available within the rest of Phaser / Pixi\n        Phaser.Cache.MISSING = new PIXI.Texture(obj.base);\n\n    },\n\n    /**\n    * Adds a Sound file into the Cache. The file must have already been loaded, typically via Phaser.Loader.\n    *\n    * @method Phaser.Cache#addSound\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra sound data.\n    * @param {boolean} webAudio - True if the file is using web audio.\n    * @param {boolean} audioTag - True if the file is using legacy HTML audio.\n    */\n    addSound: function (key, url, data, webAudio, audioTag) {\n\n        if (webAudio === undefined) { webAudio = true; audioTag = false; }\n        if (audioTag === undefined) { webAudio = false; audioTag = true; }\n\n        var decoded = false;\n\n        if (audioTag)\n        {\n            decoded = true;\n        }\n\n        this._cache.sound[key] = {\n            url: url,\n            data: data,\n            isDecoding: false,\n            decoded: decoded,\n            webAudio: webAudio,\n            audioTag: audioTag,\n            locked: this.game.sound.touchLocked\n        };\n\n        this._resolveURL(url, this._cache.sound[key]);\n\n    },\n\n    /**\n    * Add a new text data.\n    *\n    * @method Phaser.Cache#addText\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra text data.\n    */\n    addText: function (key, url, data) {\n\n        this._cache.text[key] = { url: url, data: data };\n\n        this._resolveURL(url, this._cache.text[key]);\n\n    },\n\n    /**\n    * Add a new physics data object to the Cache.\n    *\n    * @method Phaser.Cache#addPhysicsData\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} JSONData - The physics data object (a JSON file).\n    * @param {number} format - The format of the physics data.\n    */\n    addPhysicsData: function (key, url, JSONData, format) {\n\n        this._cache.physics[key] = { url: url, data: JSONData, format: format };\n\n        this._resolveURL(url, this._cache.physics[key]);\n\n    },\n\n    /**\n    * Add a new tilemap to the Cache.\n    *\n    * @method Phaser.Cache#addTilemap\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} mapData - The tilemap data object (either a CSV or JSON file).\n    * @param {number} format - The format of the tilemap data.\n    */\n    addTilemap: function (key, url, mapData, format) {\n\n        this._cache.tilemap[key] = { url: url, data: mapData, format: format };\n\n        this._resolveURL(url, this._cache.tilemap[key]);\n\n    },\n\n    /**\n    * Add a binary object in to the cache.\n    *\n    * @method Phaser.Cache#addBinary\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {object} binaryData - The binary object to be added to the cache.\n    */\n    addBinary: function (key, binaryData) {\n\n        this._cache.binary[key] = binaryData;\n\n    },\n\n    /**\n    * Add a BitmapData object to the cache.\n    *\n    * @method Phaser.Cache#addBitmapData\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {Phaser.BitmapData} bitmapData - The BitmapData object to be addded to the cache.\n    * @param {Phaser.FrameData|null} [frameData=(auto create)] - Optional FrameData set associated with the given BitmapData. If not specified (or `undefined`) a new FrameData object is created containing the Bitmap's Frame. If `null` is supplied then no FrameData will be created.\n    * @return {Phaser.BitmapData} The BitmapData object to be addded to the cache.\n    */\n    addBitmapData: function (key, bitmapData, frameData) {\n\n        bitmapData.key = key;\n\n        if (frameData === undefined)\n        {\n            frameData = new Phaser.FrameData();\n            frameData.addFrame(bitmapData.textureFrame);\n        }\n\n        this._cache.bitmapData[key] = { data: bitmapData, frameData: frameData };\n\n        return bitmapData;\n\n    },\n\n    /**\n    * Add a new Bitmap Font to the Cache.\n    *\n    * @method Phaser.Cache#addBitmapFont\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra font data.\n    * @param {object} atlasData - Texture atlas frames data.\n    * @param {string} [atlasType='xml'] - The format of the texture atlas ( 'json' or 'xml' ).\n    * @param {number} [xSpacing=0] - If you'd like to add additional horizontal spacing between the characters then set the pixel value here.\n    * @param {number} [ySpacing=0] - If you'd like to add additional vertical spacing between the lines then set the pixel value here.\n    */\n    addBitmapFont: function (key, url, data, atlasData, atlasType, xSpacing, ySpacing) {\n\n        var obj = {\n            url: url,\n            data: data,\n            font: null,\n            base: new PIXI.BaseTexture(data)\n        };\n\n        if (xSpacing === undefined) { xSpacing = 0; }\n        if (ySpacing === undefined) { ySpacing = 0; }\n\n        if (atlasType === 'json')\n        {\n            obj.font = Phaser.LoaderParser.jsonBitmapFont(atlasData, obj.base, xSpacing, ySpacing);\n        }\n        else\n        {\n            obj.font = Phaser.LoaderParser.xmlBitmapFont(atlasData, obj.base, xSpacing, ySpacing);\n        }\n\n        this._cache.bitmapFont[key] = obj;\n\n        this._resolveURL(url, obj);\n\n    },\n\n    /**\n    * Add a new json object into the cache.\n    *\n    * @method Phaser.Cache#addJSON\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra json data.\n    */\n    addJSON: function (key, url, data) {\n\n        this._cache.json[key] = { url: url, data: data };\n\n        this._resolveURL(url, this._cache.json[key]);\n\n    },\n\n    /**\n    * Add a new xml object into the cache.\n    *\n    * @method Phaser.Cache#addXML\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra text data.\n    */\n    addXML: function (key, url, data) {\n\n        this._cache.xml[key] = { url: url, data: data };\n\n        this._resolveURL(url, this._cache.xml[key]);\n\n    },\n\n    /**\n    * Adds a Video file into the Cache. The file must have already been loaded, typically via Phaser.Loader.\n    *\n    * @method Phaser.Cache#addVideo\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra video data.\n    * @param {boolean} isBlob - True if the file was preloaded via xhr and the data parameter is a Blob. false if a Video tag was created instead.\n    */\n    addVideo: function (key, url, data, isBlob) {\n\n        this._cache.video[key] = { url: url, data: data, isBlob: isBlob, locked: true };\n\n        this._resolveURL(url, this._cache.video[key]);\n\n    },\n\n    /**\n    * Adds a Fragment Shader in to the Cache. The file must have already been loaded, typically via Phaser.Loader.\n    *\n    * @method Phaser.Cache#addShader\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra shader data.\n    */\n    addShader: function (key, url, data) {\n\n        this._cache.shader[key] = { url: url, data: data };\n\n        this._resolveURL(url, this._cache.shader[key]);\n\n    },\n\n    /**\n    * Add a new Phaser.RenderTexture in to the cache.\n    *\n    * @method Phaser.Cache#addRenderTexture\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {Phaser.RenderTexture} texture - The texture to use as the base of the RenderTexture.\n    */\n    addRenderTexture: function (key, texture) {\n\n        this._cache.renderTexture[key] = { texture: texture, frame: new Phaser.Frame(0, 0, 0, texture.width, texture.height, '', '') };\n\n    },\n\n    /**\n    * Add a new sprite sheet in to the cache.\n    *\n    * @method Phaser.Cache#addSpriteSheet\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra sprite sheet data.\n    * @param {number} frameWidth - Width of the sprite sheet.\n    * @param {number} frameHeight - Height of the sprite sheet.\n    * @param {number} [frameMax=-1] - How many frames stored in the sprite sheet. If -1 then it divides the whole sheet evenly.\n    * @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.\n    * @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\n    */\n    addSpriteSheet: function (key, url, data, frameWidth, frameHeight, frameMax, margin, spacing) {\n\n        if (frameMax === undefined) { frameMax = -1; }\n        if (margin === undefined) { margin = 0; }\n        if (spacing === undefined) { spacing = 0; }\n\n        var obj = {\n            key: key,\n            url: url,\n            data: data,\n            frameWidth: frameWidth,\n            frameHeight: frameHeight,\n            margin: margin,\n            spacing: spacing,\n            base: new PIXI.BaseTexture(data),\n            frameData: Phaser.AnimationParser.spriteSheet(this.game, data, frameWidth, frameHeight, frameMax, margin, spacing)\n        };\n\n        this._cache.image[key] = obj;\n\n        this._resolveURL(url, obj);\n\n    },\n\n    /**\n    * Add a new texture atlas to the Cache.\n    *\n    * @method Phaser.Cache#addTextureAtlas\n    * @param {string} key - The key that this asset will be stored in the cache under. This should be unique within this cache.\n    * @param {string} url - The URL the asset was loaded from. If the asset was not loaded externally set to `null`.\n    * @param {object} data - Extra texture atlas data.\n    * @param {object} atlasData  - Texture atlas frames data.\n    * @param {number} format - The format of the texture atlas.\n    */\n    addTextureAtlas: function (key, url, data, atlasData, format) {\n\n        var obj = {\n            key: key,\n            url: url,\n            data: data,\n            base: new PIXI.BaseTexture(data)\n        };\n\n        if (format === Phaser.Loader.TEXTURE_ATLAS_XML_STARLING)\n        {\n            obj.frameData = Phaser.AnimationParser.XMLData(this.game, atlasData, key);\n        }\n        else if (format === Phaser.Loader.TEXTURE_ATLAS_JSON_PYXEL)\n        {\n            obj.frameData = Phaser.AnimationParser.JSONDataPyxel(this.game, atlasData, key);\n        }\n        else\n        {\n            //  Let's just work it out from the frames array\n            if (Array.isArray(atlasData.frames))\n            {\n                obj.frameData = Phaser.AnimationParser.JSONData(this.game, atlasData, key);\n            }\n            else\n            {\n                obj.frameData = Phaser.AnimationParser.JSONDataHash(this.game, atlasData, key);\n            }\n        }\n\n        this._cache.image[key] = obj;\n\n        this._resolveURL(url, obj);\n\n    },\n\n    ////////////////////////////\n    //  Sound Related Methods //\n    ////////////////////////////\n\n    /**\n    * Reload a Sound file from the server.\n    *\n    * @method Phaser.Cache#reloadSound\n    * @param {string} key - The key of the asset within the cache.\n    */\n    reloadSound: function (key) {\n\n        var _this = this;\n\n        var sound = this.getSound(key);\n\n        if (sound)\n        {\n            sound.data.src = sound.url;\n\n            sound.data.addEventListener('canplaythrough', function () {\n                return _this.reloadSoundComplete(key);\n            }, false);\n\n            sound.data.load();\n        }\n\n    },\n\n    /**\n    * Fires the onSoundUnlock event when the sound has completed reloading.\n    *\n    * @method Phaser.Cache#reloadSoundComplete\n    * @param {string} key - The key of the asset within the cache.\n    */\n    reloadSoundComplete: function (key) {\n\n        var sound = this.getSound(key);\n\n        if (sound)\n        {\n            sound.locked = false;\n            this.onSoundUnlock.dispatch(key);\n        }\n\n    },\n\n    /**\n    * Updates the sound object in the cache.\n    *\n    * @method Phaser.Cache#updateSound\n    * @param {string} key - The key of the asset within the cache.\n    */\n    updateSound: function (key, property, value) {\n\n        var sound = this.getSound(key);\n\n        if (sound)\n        {\n            sound[property] = value;\n        }\n\n    },\n\n    /**\n    * Add a new decoded sound.\n    *\n    * @method Phaser.Cache#decodedSound\n    * @param {string} key - The key of the asset within the cache.\n    * @param {object} data - Extra sound data.\n    */\n    decodedSound: function (key, data) {\n\n        var sound = this.getSound(key);\n\n        sound.data = data;\n        sound.decoded = true;\n        sound.isDecoding = false;\n\n    },\n\n    /**\n    * Check if the given sound has finished decoding.\n    *\n    * @method Phaser.Cache#isSoundDecoded\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} The decoded state of the Sound object.\n    */\n    isSoundDecoded: function (key) {\n\n        var sound = this.getItem(key, Phaser.Cache.SOUND, 'isSoundDecoded');\n\n        if (sound)\n        {\n            return sound.decoded;\n        }\n\n    },\n\n    /**\n    * Check if the given sound is ready for playback.\n    * A sound is considered ready when it has finished decoding and the device is no longer touch locked.\n    *\n    * @method Phaser.Cache#isSoundReady\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the sound is decoded and the device is not touch locked.\n    */\n    isSoundReady: function (key) {\n\n        var sound = this.getItem(key, Phaser.Cache.SOUND, 'isSoundDecoded');\n\n        if (sound)\n        {\n            return (sound.decoded && !this.game.sound.touchLocked);\n        }\n\n    },\n\n    ////////////////////////\n    //  Check Key Methods //\n    ////////////////////////\n\n    /**\n    * Checks if a key for the given cache object type exists.\n    *\n    * @method Phaser.Cache#checkKey\n    * @param {integer} cache - The cache to search. One of the Cache consts such as `Phaser.Cache.IMAGE` or `Phaser.Cache.SOUND`.\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists, otherwise false.\n    */\n    checkKey: function (cache, key) {\n\n        if (this._cacheMap[cache][key])\n        {\n            return true;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Checks if the given URL has been loaded into the Cache.\n    * This method will only work if Cache.autoResolveURL was set to `true` before any preloading took place.\n    * The method will make a DOM src call to the URL given, so please be aware of this for certain file types, such as Sound files on Firefox\n    * which may cause double-load instances.\n    *\n    * @method Phaser.Cache#checkURL\n    * @param {string} url - The url to check for in the cache.\n    * @return {boolean} True if the url exists, otherwise false.\n    */\n    checkURL: function (url) {\n\n        if (this._urlMap[this._resolveURL(url)])\n        {\n            return true;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Checks if the given key exists in the Canvas Cache.\n    *\n    * @method Phaser.Cache#checkCanvasKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkCanvasKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.CANVAS, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Image Cache. Note that this also includes Texture Atlases, Sprite Sheets and Retro Fonts.\n    *\n    * @method Phaser.Cache#checkImageKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkImageKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.IMAGE, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Texture Cache.\n    *\n    * @method Phaser.Cache#checkTextureKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkTextureKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.TEXTURE, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Sound Cache.\n    *\n    * @method Phaser.Cache#checkSoundKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkSoundKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.SOUND, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Text Cache.\n    *\n    * @method Phaser.Cache#checkTextKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkTextKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.TEXT, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Physics Cache.\n    *\n    * @method Phaser.Cache#checkPhysicsKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkPhysicsKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.PHYSICS, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Tilemap Cache.\n    *\n    * @method Phaser.Cache#checkTilemapKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkTilemapKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.TILEMAP, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Binary Cache.\n    *\n    * @method Phaser.Cache#checkBinaryKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkBinaryKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.BINARY, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the BitmapData Cache.\n    *\n    * @method Phaser.Cache#checkBitmapDataKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkBitmapDataKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.BITMAPDATA, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the BitmapFont Cache.\n    *\n    * @method Phaser.Cache#checkBitmapFontKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkBitmapFontKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.BITMAPFONT, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the JSON Cache.\n    *\n    * @method Phaser.Cache#checkJSONKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkJSONKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.JSON, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the XML Cache.\n    *\n    * @method Phaser.Cache#checkXMLKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkXMLKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.XML, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Video Cache.\n    *\n    * @method Phaser.Cache#checkVideoKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkVideoKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.VIDEO, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Fragment Shader Cache.\n    *\n    * @method Phaser.Cache#checkShaderKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkShaderKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.SHADER, key);\n\n    },\n\n    /**\n    * Checks if the given key exists in the Render Texture Cache.\n    *\n    * @method Phaser.Cache#checkRenderTextureKey\n    * @param {string} key - The key of the asset within the cache.\n    * @return {boolean} True if the key exists in the cache, otherwise false.\n    */\n    checkRenderTextureKey: function (key) {\n\n        return this.checkKey(Phaser.Cache.RENDER_TEXTURE, key);\n\n    },\n\n    ////////////////\n    //  Get Items //\n    ////////////////\n\n    /**\n    * Get an item from a cache based on the given key and property.\n    *\n    * This method is mostly used internally by other Cache methods such as `getImage` but is exposed\n    * publicly for your own use as well.\n    *\n    * @method Phaser.Cache#getItem\n    * @param {string} key - The key of the asset within the cache.\n    * @param {integer} cache - The cache to search. One of the Cache consts such as `Phaser.Cache.IMAGE` or `Phaser.Cache.SOUND`.\n    * @param {string} [method] - The string name of the method calling getItem. Can be empty, in which case no console warning is output.\n    * @param {string} [property] - If you require a specific property from the cache item, specify it here.\n    * @return {object} The cached item if found, otherwise `null`. If the key is invalid and `method` is set then a console.warn is output.\n    */\n    getItem: function (key, cache, method, property) {\n\n        if (!this.checkKey(cache, key))\n        {\n            if (method)\n            {\n                console.warn('Phaser.Cache.' + method + ': Key \"' + key + '\" not found in Cache.');\n            }\n        }\n        else\n        {\n            if (property === undefined)\n            {\n                return this._cacheMap[cache][key];\n            }\n            else\n            {\n                return this._cacheMap[cache][key][property];\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Gets a Canvas object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getCanvas\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {object} The canvas object or `null` if no item could be found matching the given key.\n    */\n    getCanvas: function (key) {\n\n        return this.getItem(key, Phaser.Cache.CANVAS, 'getCanvas', 'canvas');\n\n    },\n\n    /**\n    * Gets a Image object from the cache. This returns a DOM Image object, not a Phaser.Image object.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * Only the Image cache is searched, which covers images loaded via Loader.image, Sprite Sheets and Texture Atlases.\n    *\n    * If you need the image used by a bitmap font or similar then please use those respective 'get' methods.\n    *\n    * @method Phaser.Cache#getImage\n    * @param {string} [key] - The key of the asset to retrieve from the cache. If not given or null it will return a default image. If given but not found in the cache it will throw a warning and return the missing image.\n    * @param {boolean} [full=false] - If true the full image object will be returned, if false just the HTML Image object is returned.\n    * @return {Image} The Image object if found in the Cache, otherwise `null`. If `full` was true then a JavaScript object is returned.\n    */\n    getImage: function (key, full) {\n\n        if (key === undefined || key === null)\n        {\n            key = '__default';\n        }\n\n        if (full === undefined) { full = false; }\n\n        var img = this.getItem(key, Phaser.Cache.IMAGE, 'getImage');\n\n        if (img === null)\n        {\n            img = this.getItem('__missing', Phaser.Cache.IMAGE, 'getImage');\n        }\n\n        if (full)\n        {\n            return img;\n        }\n        else\n        {\n            return img.data;\n        }\n\n    },\n\n    /**\n    * Get a single texture frame by key.\n    *\n    * You'd only do this to get the default Frame created for a non-atlas / spritesheet image.\n    *\n    * @method Phaser.Cache#getTextureFrame\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {Phaser.Frame} The frame data.\n    */\n    getTextureFrame: function (key) {\n\n        return this.getItem(key, Phaser.Cache.TEXTURE, 'getTextureFrame', 'frame');\n\n    },\n\n    /**\n    * Gets a Phaser.Sound object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getSound\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {Phaser.Sound} The sound object.\n    */\n    getSound: function (key) {\n\n        return this.getItem(key, Phaser.Cache.SOUND, 'getSound');\n\n    },\n\n    /**\n    * Gets a raw Sound data object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getSoundData\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {object} The sound data.\n    */\n    getSoundData: function (key) {\n\n        return this.getItem(key, Phaser.Cache.SOUND, 'getSoundData', 'data');\n\n    },\n\n    /**\n    * Gets a Text object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getText\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {object} The text data.\n    */\n    getText: function (key) {\n\n        return this.getItem(key, Phaser.Cache.TEXT, 'getText', 'data');\n\n    },\n\n    /**\n    * Gets a Physics Data object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * You can get either the entire data set, a single object or a single fixture of an object from it.\n    *\n    * @method Phaser.Cache#getPhysicsData\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @param {string} [object=null] - If specified it will return just the physics object that is part of the given key, if null it will return them all.\n    * @param {string} fixtureKey - Fixture key of fixture inside an object. This key can be set per fixture with the Phaser Exporter.\n    * @return {object} The requested physics object data if found.\n    */\n    getPhysicsData: function (key, object, fixtureKey) {\n\n        var data = this.getItem(key, Phaser.Cache.PHYSICS, 'getPhysicsData', 'data');\n\n        if (data === null || object === undefined || object === null)\n        {\n            return data;\n        }\n        else\n        {\n            if (data[object])\n            {\n                var fixtures = data[object];\n\n                //  Try to find a fixture by its fixture key if given\n                if (fixtures && fixtureKey)\n                {\n                    for (var fixture in fixtures)\n                    {\n                        //  This contains the fixture data of a polygon or a circle\n                        fixture = fixtures[fixture];\n\n                        //  Test the key\n                        if (fixture.fixtureKey === fixtureKey)\n                        {\n                            return fixture;\n                        }\n                    }\n\n                    //  We did not find the requested fixture\n                    console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: \"' + fixtureKey + ' in ' + key + '\"');\n                }\n                else\n                {\n                    return fixtures;\n                }\n            }\n            else\n            {\n                console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: \"' + key + ' / ' + object + '\"');\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Gets a raw Tilemap data object from the cache. This will be in either CSV or JSON format.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getTilemapData\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {object} The raw tilemap data in CSV or JSON format.\n    */\n    getTilemapData: function (key) {\n\n        return this.getItem(key, Phaser.Cache.TILEMAP, 'getTilemapData');\n\n    },\n\n    /**\n    * Gets a binary object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getBinary\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {object} The binary data object.\n    */\n    getBinary: function (key) {\n\n        return this.getItem(key, Phaser.Cache.BINARY, 'getBinary');\n\n    },\n\n    /**\n    * Gets a BitmapData object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getBitmapData\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {Phaser.BitmapData} The requested BitmapData object if found, or null if not.\n    */\n    getBitmapData: function (key) {\n\n        return this.getItem(key, Phaser.Cache.BITMAPDATA, 'getBitmapData', 'data');\n\n    },\n\n    /**\n    * Gets a Bitmap Font object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getBitmapFont\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {Phaser.BitmapFont} The requested BitmapFont object if found, or null if not.\n    */\n    getBitmapFont: function (key) {\n\n        return this.getItem(key, Phaser.Cache.BITMAPFONT, 'getBitmapFont');\n\n    },\n\n    /**\n    * Gets a JSON object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * You can either return the object by reference (the default), or return a clone\n    * of it by setting the `clone` argument to `true`.\n    *\n    * @method Phaser.Cache#getJSON\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @param {boolean} [clone=false] - Return a clone of the original object (true) or a reference to it? (false)\n    * @return {object} The JSON object, or an Array if the key points to an Array property. If the property wasn't found, it returns null.\n    */\n    getJSON: function (key, clone) {\n\n        var data = this.getItem(key, Phaser.Cache.JSON, 'getJSON', 'data');\n\n        if (data)\n        {\n            if (clone)\n            {\n                return Phaser.Utils.extend(true, Array.isArray(data) ? [] : {}, data);\n            }\n            else\n            {\n                return data;\n            }\n        }\n        else\n        {\n            return null;\n        }\n\n    },\n\n    /**\n    * Gets an XML object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getXML\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {object} The XML object.\n    */\n    getXML: function (key) {\n\n        return this.getItem(key, Phaser.Cache.XML, 'getXML', 'data');\n\n    },\n\n    /**\n    * Gets a Phaser.Video object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getVideo\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {Phaser.Video} The video object.\n    */\n    getVideo: function (key) {\n\n        return this.getItem(key, Phaser.Cache.VIDEO, 'getVideo');\n\n    },\n\n    /**\n    * Gets a fragment shader object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getShader\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {string} The shader object.\n    */\n    getShader: function (key) {\n\n        return this.getItem(key, Phaser.Cache.SHADER, 'getShader', 'data');\n\n    },\n\n    /**\n    * Gets a RenderTexture object from the cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getRenderTexture\n    * @param {string} key - The key of the asset to retrieve from the cache.\n    * @return {Object} The object with Phaser.RenderTexture and Phaser.Frame.\n    */\n    getRenderTexture: function (key) {\n\n        return this.getItem(key, Phaser.Cache.RENDER_TEXTURE, 'getRenderTexture');\n\n    },\n\n    ////////////////////////////\n    //  Frame Related Methods //\n    ////////////////////////////\n\n    /**\n    * Gets a PIXI.BaseTexture by key from the given Cache.\n    *\n    * @method Phaser.Cache#getBaseTexture\n    * @param {string} key - Asset key of the image for which you want the BaseTexture for.\n    * @param {integer} [cache=Phaser.Cache.IMAGE] - The cache to search for the item in.\n    * @return {PIXI.BaseTexture} The BaseTexture object.\n    */\n    getBaseTexture: function (key, cache) {\n\n        if (cache === undefined) { cache = Phaser.Cache.IMAGE; }\n\n        return this.getItem(key, cache, 'getBaseTexture', 'base');\n\n    },\n\n    /**\n    * Get a single frame by key. You'd only do this to get the default Frame created for a non-atlas/spritesheet image.\n    *\n    * @method Phaser.Cache#getFrame\n    * @param {string} key - Asset key of the frame data to retrieve from the Cache.\n    * @param {integer} [cache=Phaser.Cache.IMAGE] - The cache to search for the item in.\n    * @return {Phaser.Frame} The frame data.\n    */\n    getFrame: function (key, cache) {\n\n        if (cache === undefined) { cache = Phaser.Cache.IMAGE; }\n\n        return this.getItem(key, cache, 'getFrame', 'frame');\n\n    },\n\n    /**\n    * Get the total number of frames contained in the FrameData object specified by the given key.\n    *\n    * @method Phaser.Cache#getFrameCount\n    * @param {string} key - Asset key of the FrameData you want.\n    * @param {integer} [cache=Phaser.Cache.IMAGE] - The cache to search for the item in.\n    * @return {number} Then number of frames. 0 if the image is not found.\n    */\n    getFrameCount: function (key, cache) {\n\n        var data = this.getFrameData(key, cache);\n\n        if (data)\n        {\n            return data.total;\n        }\n        else\n        {\n            return 0;\n        }\n\n    },\n\n    /**\n    * Gets a Phaser.FrameData object from the Image Cache.\n    *\n    * The object is looked-up based on the key given.\n    *\n    * Note: If the object cannot be found a `console.warn` message is displayed.\n    *\n    * @method Phaser.Cache#getFrameData\n    * @param {string} key - Asset key of the frame data to retrieve from the Cache.\n    * @param {integer} [cache=Phaser.Cache.IMAGE] - The cache to search for the item in.\n    * @return {Phaser.FrameData} The frame data.\n    */\n    getFrameData: function (key, cache) {\n\n        if (cache === undefined) { cache = Phaser.Cache.IMAGE; }\n\n        return this.getItem(key, cache, 'getFrameData', 'frameData');\n\n    },\n\n    /**\n    * Check if the FrameData for the given key exists in the Image Cache.\n    *\n    * @method Phaser.Cache#hasFrameData\n    * @param {string} key - Asset key of the frame data to retrieve from the Cache.\n    * @param {integer} [cache=Phaser.Cache.IMAGE] - The cache to search for the item in.\n    * @return {boolean} True if the given key has frameData in the cache, otherwise false.\n    */\n    hasFrameData: function (key, cache) {\n\n        if (cache === undefined) { cache = Phaser.Cache.IMAGE; }\n\n        return (this.getItem(key, cache, '', 'frameData') !== null);\n\n    },\n\n    /**\n    * Replaces a set of frameData with a new Phaser.FrameData object.\n    *\n    * @method Phaser.Cache#updateFrameData\n    * @param {string} key - The unique key by which you will reference this object.\n    * @param {number} frameData - The new FrameData.\n    * @param {integer} [cache=Phaser.Cache.IMAGE] - The cache to search. One of the Cache consts such as `Phaser.Cache.IMAGE` or `Phaser.Cache.SOUND`.\n    */\n    updateFrameData: function (key, frameData, cache) {\n\n        if (cache === undefined) { cache = Phaser.Cache.IMAGE; }\n\n        if (this._cacheMap[cache][key])\n        {\n            this._cacheMap[cache][key].frameData = frameData;\n        }\n\n    },\n\n    /**\n    * Get a single frame out of a frameData set by key.\n    *\n    * @method Phaser.Cache#getFrameByIndex\n    * @param {string} key - Asset key of the frame data to retrieve from the Cache.\n    * @param {number} index - The index of the frame you want to get.\n    * @param {integer} [cache=Phaser.Cache.IMAGE] - The cache to search. One of the Cache consts such as `Phaser.Cache.IMAGE` or `Phaser.Cache.SOUND`.\n    * @return {Phaser.Frame} The frame object.\n    */\n    getFrameByIndex: function (key, index, cache) {\n\n        var data = this.getFrameData(key, cache);\n\n        if (data)\n        {\n            return data.getFrame(index);\n        }\n        else\n        {\n            return null;\n        }\n\n    },\n\n    /**\n    * Get a single frame out of a frameData set by key.\n    *\n    * @method Phaser.Cache#getFrameByName\n    * @param {string} key - Asset key of the frame data to retrieve from the Cache.\n    * @param {string} name - The name of the frame you want to get.\n    * @param {integer} [cache=Phaser.Cache.IMAGE] - The cache to search. One of the Cache consts such as `Phaser.Cache.IMAGE` or `Phaser.Cache.SOUND`.\n    * @return {Phaser.Frame} The frame object.\n    */\n    getFrameByName: function (key, name, cache) {\n\n        var data = this.getFrameData(key, cache);\n\n        if (data)\n        {\n            return data.getFrameByName(name);\n        }\n        else\n        {\n            return null;\n        }\n\n    },\n\n    /**\n    * Get a cached object by the URL.\n    * This only returns a value if you set Cache.autoResolveURL to `true` *before* starting the preload of any assets.\n    * Be aware that every call to this function makes a DOM src query, so use carefully and double-check for implications in your target browsers/devices.\n    *\n    * @method Phaser.Cache#getURL\n    * @param {string} url - The url for the object loaded to get from the cache.\n    * @return {object} The cached object.\n    */\n    getURL: function (url) {\n\n        var url = this._resolveURL(url);\n\n        if (url)\n        {\n            return this._urlMap[url];\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getUrl: Invalid url: \"' + url  + '\" or Cache.autoResolveURL was false');\n            return null;\n        }\n\n    },\n\n    /**\n    * Gets all keys used in the requested Cache.\n    *\n    * @method Phaser.Cache#getKeys\n    * @param {integer} [cache=Phaser.Cache.IMAGE] - The Cache you wish to get the keys from. Can be any of the Cache consts such as `Phaser.Cache.IMAGE`, `Phaser.Cache.SOUND` etc.\n    * @return {Array} The array of keys in the requested cache.\n    */\n    getKeys: function (cache) {\n\n        if (cache === undefined) { cache = Phaser.Cache.IMAGE; }\n\n        var out = [];\n\n        if (this._cacheMap[cache])\n        {\n            for (var key in this._cacheMap[cache])\n            {\n                if (key !== '__default' && key !== '__missing')\n                {\n                    out.push(key);\n                }\n            }\n        }\n\n        return out;\n\n    },\n\n    /////////////////////\n    //  Remove Methods //\n    /////////////////////\n\n    /**\n    * Removes a canvas from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeCanvas\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeCanvas: function (key) {\n\n        delete this._cache.canvas[key];\n\n    },\n\n    /**\n    * Removes an image from the cache.\n    *\n    * You can optionally elect to destroy it as well. This calls BaseTexture.destroy on it.\n    *\n    * Note that this only removes it from the Phaser Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeImage\n    * @param {string} key - Key of the asset you want to remove.\n    * @param {boolean} [destroyBaseTexture=true] - Should the BaseTexture behind this image also be destroyed?\n    */\n    removeImage: function (key, destroyBaseTexture) {\n\n        if (destroyBaseTexture === undefined) { destroyBaseTexture = true; }\n\n        var img = this.getImage(key, true);\n\n        if (destroyBaseTexture && img.base)\n        {\n            img.base.destroy();\n        }\n\n        delete this._cache.image[key];\n\n    },\n\n    /**\n    * Removes a sound from the cache.\n    *\n    * If any `Phaser.Sound` objects use the audio file in the cache that you remove with this method, they will\n    * _automatically_ destroy themselves. If you wish to have full control over when Sounds are destroyed then\n    * you must finish your house-keeping and destroy them all yourself first, before calling this method.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeSound\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeSound: function (key) {\n\n        delete this._cache.sound[key];\n\n    },\n\n    /**\n    * Removes a text file from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeText\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeText: function (key) {\n\n        delete this._cache.text[key];\n\n    },\n\n    /**\n    * Removes a physics data file from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removePhysics\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removePhysics: function (key) {\n\n        delete this._cache.physics[key];\n\n    },\n\n    /**\n    * Removes a tilemap from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeTilemap\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeTilemap: function (key) {\n\n        delete this._cache.tilemap[key];\n\n    },\n\n    /**\n    * Removes a binary file from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeBinary\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeBinary: function (key) {\n\n        delete this._cache.binary[key];\n\n    },\n\n    /**\n    * Removes a bitmap data from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeBitmapData\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeBitmapData: function (key) {\n\n        delete this._cache.bitmapData[key];\n\n    },\n\n    /**\n    * Removes a bitmap font from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeBitmapFont\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeBitmapFont: function (key) {\n\n        delete this._cache.bitmapFont[key];\n\n    },\n\n    /**\n    * Removes a json object from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeJSON\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeJSON: function (key) {\n\n        delete this._cache.json[key];\n\n    },\n\n    /**\n    * Removes a xml object from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeXML\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeXML: function (key) {\n\n        delete this._cache.xml[key];\n\n    },\n\n    /**\n    * Removes a video from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeVideo\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeVideo: function (key) {\n\n        delete this._cache.video[key];\n\n    },\n\n    /**\n    * Removes a shader from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeShader\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeShader: function (key) {\n\n        delete this._cache.shader[key];\n\n    },\n\n    /**\n    * Removes a Render Texture from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeRenderTexture\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeRenderTexture: function (key) {\n\n        delete this._cache.renderTexture[key];\n\n    },\n\n    /**\n    * Removes a Sprite Sheet from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeSpriteSheet\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeSpriteSheet: function (key) {\n\n        delete this._cache.spriteSheet[key];\n\n    },\n\n    /**\n    * Removes a Texture Atlas from the cache.\n    *\n    * Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\n    * then it will persist in memory.\n    *\n    * @method Phaser.Cache#removeTextureAtlas\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeTextureAtlas: function (key) {\n\n        delete this._cache.atlas[key];\n\n    },\n\n    /**\n    * Empties out all of the GL Textures from Images stored in the cache.\n    * This is called automatically when the WebGL context is lost and then restored.\n    *\n    * @method Phaser.Cache#clearGLTextures\n    * @protected\n    */\n    clearGLTextures: function () {\n\n        for (var key in this._cache.image)\n        {\n            this._cache.image[key].base._glTextures = [];\n        }\n\n    },\n\n    /**\n    * Resolves a URL to its absolute form and stores it in Cache._urlMap as long as Cache.autoResolveURL is set to `true`.\n    * This is then looked-up by the Cache.getURL and Cache.checkURL calls.\n    *\n    * @method Phaser.Cache#_resolveURL\n    * @private\n    * @param {string} url - The URL to resolve. This is appended to Loader.baseURL.\n    * @param {object} [data] - The data associated with the URL to be stored to the URL Map.\n    * @return {string} The resolved URL.\n    */\n    _resolveURL: function (url, data) {\n\n        if (!this.autoResolveURL)\n        {\n            return null;\n        }\n\n        this._urlResolver.src = this.game.load.baseURL + url;\n\n        this._urlTemp = this._urlResolver.src;\n\n        //  Ensure no request is actually made\n        this._urlResolver.src = '';\n\n        //  Record the URL to the map\n        if (data)\n        {\n            this._urlMap[this._urlTemp] = data;\n        }\n\n        return this._urlTemp;\n\n    },\n\n    /**\n    * Clears the cache. Removes every local cache object reference.\n    * If an object in the cache has a `destroy` method it will also be called.\n    *\n    * @method Phaser.Cache#destroy\n    */\n    destroy: function () {\n\n        for (var i = 0; i < this._cacheMap.length; i++)\n        {\n            var cache = this._cacheMap[i];\n\n            for (var key in cache)\n            {\n                if (key !== '__default' && key !== '__missing')\n                {\n                    if (cache[key]['destroy'])\n                    {\n                        cache[key].destroy();\n                    }\n\n                    delete cache[key];\n                }\n            }\n        }\n\n        this._urlMap = null;\n        this._urlResolver = null;\n        this._urlTemp = null;\n\n    }\n\n};\n\nPhaser.Cache.prototype.constructor = Phaser.Cache;\n\n/* jshint wsh:true */\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.\n*\n* The loader uses a combination of tag loading (eg. Image elements) and XHR and provides progress and completion callbacks.\n*\n* Parallel loading (see {@link #enableParallel}) is supported and enabled by default.\n* Load-before behavior of parallel resources is controlled by synchronization points as discussed in {@link #withSyncPoint}.\n*\n* Texture Atlases can be created with tools such as [Texture Packer](https://www.codeandweb.com/texturepacker/phaser) and\n* [Shoebox](http://renderhjs.net/shoebox/)\n*\n* @class Phaser.Loader\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Loader = function (game) {\n\n    /**\n    * Local reference to game.\n    * @property {Phaser.Game} game\n    * @protected\n    */\n    this.game = game;\n\n    /**\n    * Local reference to the Phaser.Cache.\n    * @property {Phaser.Cache} cache\n    * @protected\n    */\n    this.cache = game.cache;\n\n    /**\n    * If true all calls to Loader.reset will be ignored. Useful if you need to create a load queue before swapping to a preloader state.\n    * @property {boolean} resetLocked\n    * @default\n    */\n    this.resetLocked = false;\n\n    /**\n    * True if the Loader is in the process of loading the queue.\n    * @property {boolean} isLoading\n    * @default\n    */\n    this.isLoading = false;\n\n    /**\n    * True if all assets in the queue have finished loading.\n    * @property {boolean} hasLoaded\n    * @default\n    */\n    this.hasLoaded = false;\n\n    /**\n    * You can optionally link a progress sprite with {@link Phaser.Loader#setPreloadSprite setPreloadSprite}.\n    *\n    * This property is an object containing: sprite, rect, direction, width and height\n    *\n    * @property {?object} preloadSprite\n    * @protected\n    */\n    this.preloadSprite = null;\n\n    /**\n    * The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.\n    * @property {boolean|string} crossOrigin\n    * @default\n    */\n    this.crossOrigin = false;\n\n    /**\n    * If you want to append a URL before the path of any asset you can set this here.\n    * Useful if allowing the asset base url to be configured outside of the game code.\n    * The string _must_ end with a \"/\".\n    *\n    * @property {string} baseURL\n    */\n    this.baseURL = '';\n\n    /**\n    * The value of `path`, if set, is placed before any _relative_ file path given. For example:\n    *\n    * `load.path = \"images/sprites/\";\n    * load.image(\"ball\", \"ball.png\");\n    * load.image(\"tree\", \"level1/oaktree.png\");\n    * load.image(\"boom\", \"http://server.com/explode.png\");`\n    *\n    * Would load the `ball` file from `images/sprites/ball.png` and the tree from\n    * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL\n    * given as it's an absolute URL.\n    *\n    * Please note that the path is added before the filename but *after* the baseURL (if set.)\n    *\n    * The string _must_ end with a \"/\".\n    *\n    * @property {string} path\n    */\n    this.path = '';\n\n    /**\n    * Used to map the application mime-types to to the Accept header in XHR requests.\n    * If you don't require these mappings, or they cause problems on your server, then\n    * remove them from the headers object and the XHR request will not try to use them.\n    *\n    * This object can also be used to set the `X-Requested-With` header to \n    * `XMLHttpRequest` (or any other value you need). To enable this do:\n    *\n    * `this.load.headers.requestedWith = 'XMLHttpRequest'`\n    *\n    * before adding anything to the Loader. The XHR loader will then call:\n    *\n    * `setRequestHeader('X-Requested-With', this.headers['requestedWith'])`\n    * \n    * @property {object} headers\n    * @default\n    */\n    this.headers = {\n        \"requestedWith\": false,\n        \"json\": \"application/json\",\n        \"xml\": \"application/xml\"\n    };\n\n    /**\n     * This event is dispatched when the loading process starts: before the first file has been requested,\n    * but after all the initial packs have been loaded.\n    *\n    * @property {Phaser.Signal} onLoadStart\n    */\n    this.onLoadStart = new Phaser.Signal();\n\n    /**\n    * This event is dispatched when the final file in the load queue has either loaded or failed.\n    *\n    * @property {Phaser.Signal} onLoadComplete\n    */\n    this.onLoadComplete = new Phaser.Signal();\n\n    /**\n    * This event is dispatched when an asset pack has either loaded or failed to load.\n    *\n    * This is called when the asset pack manifest file has loaded and successfully added its contents to the loader queue.\n    *\n    * Params: `(pack key, success?, total packs loaded, total packs)`\n    *\n    * @property {Phaser.Signal} onPackComplete\n    */\n    this.onPackComplete = new Phaser.Signal();\n\n    /**\n    * This event is dispatched immediately before a file starts loading.\n    * It's possible the file may fail (eg. download error, invalid format) after this event is sent.\n    *\n    * Params: `(progress, file key, file url)`\n    *\n    * @property {Phaser.Signal} onFileStart\n    */\n    this.onFileStart = new Phaser.Signal();\n\n    /**\n    * This event is dispatched when a file has either loaded or failed to load.\n    *\n    * Any function bound to this will receive the following parameters:\n    *\n    * progress, file key, success?, total loaded files, total files\n    *\n    * Where progress is a number between 1 and 100 (inclusive) representing the percentage of the load.\n    *\n    * @property {Phaser.Signal} onFileComplete\n    */\n    this.onFileComplete = new Phaser.Signal();\n\n    /**\n    * This event is dispatched when a file (or pack) errors as a result of the load request.\n    *\n    * For files it will be triggered before `onFileComplete`. For packs it will be triggered before `onPackComplete`.\n    *\n    * Params: `(file key, file)`\n    *\n    * @property {Phaser.Signal} onFileError\n    */\n    this.onFileError = new Phaser.Signal();\n\n    /**\n    * If true and if the browser supports XDomainRequest, it will be used in preference for XHR.\n    *\n    * This is only relevant for IE 9 and should _only_ be enabled for IE 9 clients when required by the server/CDN.\n    *\n    * @property {boolean} useXDomainRequest\n    * @deprecated This is only relevant for IE 9.\n    */\n    this.useXDomainRequest = false;\n\n    /**\n    * @private\n    * @property {boolean} _warnedAboutXDomainRequest - Control number of warnings for using XDR outside of IE 9.\n    */\n    this._warnedAboutXDomainRequest = false;\n\n    /**\n    * If true (the default) then parallel downloading will be enabled.\n    *\n    * To disable all parallel downloads this must be set to false prior to any resource being loaded.\n    *\n    * @property {boolean} enableParallel\n    */\n    this.enableParallel = true;\n\n    /**\n    * The number of concurrent / parallel resources to try and fetch at once.\n    *\n    * Many current browsers limit 6 requests per domain; this is slightly conservative.\n    *\n    * @property {integer} maxParallelDownloads\n    * @protected\n    */\n    this.maxParallelDownloads = 4;\n\n    /**\n    * A counter: if more than zero, files will be automatically added as a synchronization point.\n    * @property {integer} _withSyncPointDepth;\n    */\n    this._withSyncPointDepth = 0;\n\n    /**\n    * Contains all the information for asset files (including packs) to load.\n    *\n    * File/assets are only removed from the list after all loading completes.\n    *\n    * @property {file[]} _fileList\n    * @private\n    */\n    this._fileList = [];\n\n    /**\n    * Inflight files (or packs) that are being fetched/processed.\n    *\n    * This means that if there are any files in the flight queue there should still be processing\n    * going on; it should only be empty before or after loading.\n    *\n    * The files in the queue may have additional properties added to them,\n    * including `requestObject` which is normally the associated XHR.\n    *\n    * @property {file[]} _flightQueue\n    * @private\n    */\n    this._flightQueue = [];\n\n    /**\n    * The offset into the fileList past all the complete (loaded or error) entries.\n    *\n    * @property {integer} _processingHead\n    * @private\n    */\n    this._processingHead = 0;\n\n    /**\n    * True when the first file (not pack) has loading started.\n    * This used to to control dispatching `onLoadStart` which happens after any initial packs are loaded.\n    *\n    * @property {boolean} _initialPacksLoaded\n    * @private\n    */\n    this._fileLoadStarted = false;\n\n    /**\n    * Total packs seen - adjusted when a pack is added.\n    * @property {integer} _totalPackCount\n    * @private\n    */\n    this._totalPackCount = 0;\n\n    /**\n    * Total files seen - adjusted when a file is added.\n    * @property {integer} _totalFileCount\n    * @private\n    */\n    this._totalFileCount = 0;\n\n    /**\n    * Total packs loaded - adjusted just prior to `onPackComplete`.\n    * @property {integer} _loadedPackCount\n    * @private\n    */\n    this._loadedPackCount = 0;\n\n    /**\n    * Total files loaded - adjusted just prior to `onFileComplete`.\n    * @property {integer} _loadedFileCount\n    * @private\n    */\n    this._loadedFileCount = 0;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.TEXTURE_ATLAS_JSON_HASH = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.TEXTURE_ATLAS_XML_STARLING = 2;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.PHYSICS_LIME_CORONA_JSON = 3;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.PHYSICS_PHASER_JSON = 4;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5;\n\nPhaser.Loader.prototype = {\n\n    /**\n    * Set a Sprite to be a \"preload\" sprite by passing it to this method.\n    *\n    * A \"preload\" sprite will have its width or height crop adjusted based on the percentage of the loader in real-time.\n    * This allows you to easily make loading bars for games.\n    *\n    * The sprite will automatically be made visible when calling this.\n    *\n    * @method Phaser.Loader#setPreloadSprite\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite or image that will be cropped during the load.\n    * @param {number} [direction=0] - A value of zero means the sprite will be cropped horizontally, a value of 1 means its will be cropped vertically.\n    */\n    setPreloadSprite: function (sprite, direction) {\n\n        direction = direction || 0;\n\n        this.preloadSprite = { sprite: sprite, direction: direction, width: sprite.width, height: sprite.height, rect: null };\n\n        if (direction === 0)\n        {\n            //  Horizontal rect\n            this.preloadSprite.rect = new Phaser.Rectangle(0, 0, 1, sprite.height);\n        }\n        else\n        {\n            //  Vertical rect\n            this.preloadSprite.rect = new Phaser.Rectangle(0, 0, sprite.width, 1);\n        }\n\n        sprite.crop(this.preloadSprite.rect);\n\n        sprite.visible = true;\n\n    },\n\n    /**\n    * Called automatically by ScaleManager when the game resizes in RESIZE scalemode.\n    *\n    * This can be used to adjust the preloading sprite size, eg.\n    *\n    * @method Phaser.Loader#resize\n    * @protected\n    */\n    resize: function () {\n\n        if (this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height)\n        {\n            this.preloadSprite.rect.height = this.preloadSprite.sprite.height;\n        }\n\n    },\n\n    /**\n    * Check whether a file/asset with a specific key is queued to be loaded.\n    *\n    * To access a loaded asset use Phaser.Cache, eg. {@link Phaser.Cache#checkImageKey}\n    *\n    * @method Phaser.Loader#checkKeyExists\n    * @param {string} type - The type asset you want to check.\n    * @param {string} key - Key of the asset you want to check.\n    * @return {boolean} Return true if exists, otherwise return false.\n    */\n    checkKeyExists: function (type, key) {\n\n        return this.getAssetIndex(type, key) > -1;\n\n    },\n\n    /**\n    * Get the queue-index of the file/asset with a specific key.\n    *\n    * Only assets in the download file queue will be found.\n    *\n    * @method Phaser.Loader#getAssetIndex\n    * @param {string} type - The type asset you want to check.\n    * @param {string} key - Key of the asset you want to check.\n    * @return {number} The index of this key in the filelist, or -1 if not found.\n    *     The index may change and should only be used immediately following this call\n    */\n    getAssetIndex: function (type, key) {\n\n        var bestFound = -1;\n\n        for (var i = 0; i < this._fileList.length; i++)\n        {\n            var file = this._fileList[i];\n\n            if (file.type === type && file.key === key)\n            {\n                bestFound = i;\n\n                // An already loaded/loading file may be superceded.\n                if (!file.loaded && !file.loading)\n                {\n                    break;\n                }\n            }\n        }\n\n        return bestFound;\n\n    },\n\n    /**\n    * Find a file/asset with a specific key.\n    *\n    * Only assets in the download file queue will be found.\n    *\n    * @method Phaser.Loader#getAsset\n    * @param {string} type - The type asset you want to check.\n    * @param {string} key - Key of the asset you want to check.\n    * @return {any} Returns an object if found that has 2 properties: `index` and `file`; otherwise a non-true value is returned.\n    *     The index may change and should only be used immediately following this call.\n    */\n    getAsset: function (type, key) {\n\n        var fileIndex = this.getAssetIndex(type, key);\n\n        if (fileIndex > -1)\n        {\n            return { index: fileIndex, file: this._fileList[fileIndex] };\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Reset the loader and clear any queued assets. If `Loader.resetLocked` is true this operation will abort.\n    *\n    * This will abort any loading and clear any queued assets.\n    *\n    * Optionally you can clear any associated events.\n    *\n    * @method Phaser.Loader#reset\n    * @protected\n    * @param {boolean} [hard=false] - If true then the preload sprite and other artifacts may also be cleared.\n    * @param {boolean} [clearEvents=false] - If true then the all Loader signals will have removeAll called on them.\n    */\n    reset: function (hard, clearEvents) {\n\n        if (clearEvents === undefined) { clearEvents = false; }\n\n        if (this.resetLocked)\n        {\n            return;\n        }\n\n        if (hard)\n        {\n            this.preloadSprite = null;\n        }\n\n        this.isLoading = false;\n\n        this._processingHead = 0;\n        this._fileList.length = 0;\n        this._flightQueue.length = 0;\n\n        this._fileLoadStarted = false;\n        this._totalFileCount = 0;\n        this._totalPackCount = 0;\n        this._loadedPackCount = 0;\n        this._loadedFileCount = 0;\n\n        if (clearEvents)\n        {\n            this.onLoadStart.removeAll();\n            this.onLoadComplete.removeAll();\n            this.onPackComplete.removeAll();\n            this.onFileStart.removeAll();\n            this.onFileComplete.removeAll();\n            this.onFileError.removeAll();\n        }\n\n    },\n\n    /**\n    * Internal function that adds a new entry to the file list. Do not call directly.\n    *\n    * @method Phaser.Loader#addToFileList\n    * @protected\n    * @param {string} type - The type of resource to add to the list (image, audio, xml, etc).\n    * @param {string} key - The unique Cache ID key of this resource.\n    * @param {string} [url] - The URL the asset will be loaded from.\n    * @param {object} [properties=(none)] - Any additional properties needed to load the file. These are added directly to the added file object and overwrite any defaults.\n    * @param {boolean} [overwrite=false] - If true then this will overwrite a file asset of the same type/key. Otherwise it will only add a new asset. If overwrite is true, and the asset is already being loaded (or has been loaded), then it is appended instead.\n    * @param {string} [extension] - If no URL is given the Loader will sometimes auto-generate the URL based on the key, using this as the extension.\n    * @return {Phaser.Loader} This instance of the Phaser Loader.\n    */\n    addToFileList: function (type, key, url, properties, overwrite, extension) {\n\n        if (overwrite === undefined) { overwrite = false; }\n\n        if (key === undefined || key === '')\n        {\n            console.warn(\"Phaser.Loader: Invalid or no key given of type \" + type);\n            return this;\n        }\n\n        if (url === undefined || url === null)\n        {\n            if (extension)\n            {\n                url = key + extension;\n            }\n            else\n            {\n                console.warn(\"Phaser.Loader: No URL given for file type: \" + type + \" key: \" + key);\n                return this;\n            }\n        }\n\n        var file = {\n            type: type,\n            key: key,\n            path: this.path,\n            url: url,\n            syncPoint: this._withSyncPointDepth > 0,\n            data: null,\n            loading: false,\n            loaded: false,\n            error: false\n        };\n\n        if (properties)\n        {\n            for (var prop in properties)\n            {\n                file[prop] = properties[prop];\n            }\n        }\n\n        var fileIndex = this.getAssetIndex(type, key);\n\n        if (overwrite && fileIndex > -1)\n        {\n            var currentFile = this._fileList[fileIndex];\n\n            if (!currentFile.loading && !currentFile.loaded)\n            {\n                this._fileList[fileIndex] = file;\n            }\n            else\n            {\n                this._fileList.push(file);\n                this._totalFileCount++;\n            }\n        }\n        else if (fileIndex === -1)\n        {\n            this._fileList.push(file);\n            this._totalFileCount++;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Internal function that replaces an existing entry in the file list with a new one. Do not call directly.\n    *\n    * @method Phaser.Loader#replaceInFileList\n    * @protected\n    * @param {string} type - The type of resource to add to the list (image, audio, xml, etc).\n    * @param {string} key - The unique Cache ID key of this resource.\n    * @param {string} url - The URL the asset will be loaded from.\n    * @param {object} properties - Any additional properties needed to load the file.\n    */\n    replaceInFileList: function (type, key, url, properties) {\n\n        return this.addToFileList(type, key, url, properties, true);\n\n    },\n\n    /**\n    * Add a JSON resource pack ('packfile') to the Loader.\n    *\n    * A packfile is a JSON file that contains a list of assets to the be loaded.\n    * Please see the example 'loader/asset pack' in the Phaser Examples repository.\n    *\n    * Packs are always put before the first non-pack file that is not loaded / loading.\n    *\n    * This means that all packs added before any loading has started are added to the front\n    * of the file queue, in the order added.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * The URL of the packfile can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * @method Phaser.Loader#pack\n    * @param {string} key - Unique asset key of this resource pack.\n    * @param {string} [url] - URL of the Asset Pack JSON file. If you wish to pass a json object instead set this to null and pass the object as the data parameter.\n    * @param {object} [data] - The Asset Pack JSON data. Use this to pass in a json data object rather than loading it from a URL. TODO\n    * @param {object} [callbackContext=(loader)] - Some Loader operations, like Binary and Script require a context for their callbacks. Pass the context here.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    pack: function (key, url, data, callbackContext) {\n\n        if (url === undefined) { url = null; }\n        if (data === undefined) { data = null; }\n        if (callbackContext === undefined) { callbackContext = null; }\n\n        if (!url && !data)\n        {\n            console.warn('Phaser.Loader.pack - Both url and data are null. One must be set.');\n\n            return this;\n        }\n\n        var pack = {\n            type: 'packfile',\n            key: key,\n            url: url,\n            path: this.path,\n            syncPoint: true,\n            data: null,\n            loading: false,\n            loaded: false,\n            error: false,\n            callbackContext: callbackContext\n        };\n\n        //  A data object has been given\n        if (data)\n        {\n            if (typeof data === 'string')\n            {\n                data = JSON.parse(data);\n            }\n\n            pack.data = data || {};\n\n            //  Already consider 'loaded'\n            pack.loaded = true;\n        }\n\n        // Add before first non-pack/no-loaded ~ last pack from start prior to loading\n        // (Read one past for splice-to-end)\n        for (var i = 0; i < this._fileList.length + 1; i++)\n        {\n            var file = this._fileList[i];\n\n            if (!file || (!file.loaded && !file.loading && file.type !== 'packfile'))\n            {\n                this._fileList.splice(i, 0, pack);\n                this._totalPackCount++;\n                break;\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Adds an Image to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the image via `Cache.getImage(key)`\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n    * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension.\n    * If you do not desire this action then provide a URL.\n    *\n    * @method Phaser.Loader#image\n    * @param {string} key - Unique asset key of this image file.\n    * @param {string} [url] - URL of an image file. If undefined or `null` the url will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n    * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    image: function (key, url, overwrite) {\n\n        return this.addToFileList('image', key, url, undefined, overwrite, '.png');\n\n    },\n\n    /**\n    * Adds an array of images to the current load queue.\n    *\n    * It works by passing each element of the array to the Loader.image method.\n    *\n    * The files are **not** loaded immediately after calling this method. The files are added to the queue ready to be loaded when the loader starts.\n    *\n    * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\n    *\n    * The keys must be unique Strings. They are used to add the files to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the images via `Cache.getImage(key)`\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n    * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension.\n    * If you do not desire this action then provide a URL.\n    *\n    * @method Phaser.Loader#images\n    * @param {array} keys - An array of unique asset keys of the image files.\n    * @param {array} [urls] - Optional array of URLs. If undefined or `null` the url will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\". If provided the URLs array length must match the keys array length.\n    * @return {Phaser.Loader} This Loader instance.\n     */\n    images: function (keys, urls) {\n\n        if (Array.isArray(urls))\n        {\n            for (var i = 0; i < keys.length; i++)\n            {\n                this.image(keys[i], urls[i]);\n            }\n        }\n        else\n        {\n            for (var i = 0; i < keys.length; i++)\n            {\n                this.image(keys[i]);\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Adds a Text file to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getText(key)`\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n    * and no URL is given then the Loader will set the URL to be \"alien.txt\". It will always add `.txt` as the extension.\n    * If you do not desire this action then provide a URL.\n    *\n    * @method Phaser.Loader#text\n    * @param {string} key - Unique asset key of the text file.\n    * @param {string} [url] - URL of the text file. If undefined or `null` the url will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\n    * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    text: function (key, url, overwrite) {\n\n        return this.addToFileList('text', key, url, undefined, overwrite, '.txt');\n\n    },\n\n    /**\n    * Adds a JSON file to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getJSON(key)`. JSON files are automatically parsed upon load.\n    * If you need to control when the JSON is parsed then use `Loader.text` instead and parse the text file as needed.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n    * and no URL is given then the Loader will set the URL to be \"alien.json\". It will always add `.json` as the extension.\n    * If you do not desire this action then provide a URL.\n    *\n    * @method Phaser.Loader#json\n    * @param {string} key - Unique asset key of the json file.\n    * @param {string} [url] - URL of the JSON file. If undefined or `null` the url will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\n    * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    json: function (key, url, overwrite) {\n\n        return this.addToFileList('json', key, url, undefined, overwrite, '.json');\n\n    },\n\n    /**\n    * Adds a fragment shader file to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getShader(key)`.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"blur\"\n    * and no URL is given then the Loader will set the URL to be \"blur.frag\". It will always add `.frag` as the extension.\n    * If you do not desire this action then provide a URL.\n    *\n    * @method Phaser.Loader#shader\n    * @param {string} key - Unique asset key of the fragment file.\n    * @param {string} [url] - URL of the fragment file. If undefined or `null` the url will be set to `<key>.frag`, i.e. if `key` was \"blur\" then the URL will be \"blur.frag\".\n    * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    shader: function (key, url, overwrite) {\n\n        return this.addToFileList('shader', key, url, undefined, overwrite, '.frag');\n\n    },\n\n    /**\n    * Adds an XML file to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getXML(key)`.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n    * and no URL is given then the Loader will set the URL to be \"alien.xml\". It will always add `.xml` as the extension.\n    * If you do not desire this action then provide a URL.\n    *\n    * @method Phaser.Loader#xml\n    * @param {string} key - Unique asset key of the xml file.\n    * @param {string} [url] - URL of the XML file. If undefined or `null` the url will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\n    * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    xml: function (key, url, overwrite) {\n\n        return this.addToFileList('xml', key, url, undefined, overwrite, '.xml');\n\n    },\n\n    /**\n    * Adds a JavaScript file to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * The key must be a unique String.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n    * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension.\n    * If you do not desire this action then provide a URL.\n    *\n    * Upon successful load the JavaScript is automatically turned into a script tag and executed, so be careful what you load!\n    *\n    * A callback, which will be invoked as the script tag has been created, can also be specified.\n    * The callback must return relevant `data`.\n    *\n    * @method Phaser.Loader#script\n    * @param {string} key - Unique asset key of the script file.\n    * @param {string} [url] - URL of the JavaScript file. If undefined or `null` the url will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\n    * @param {function} [callback=(none)] - Optional callback that will be called after the script tag has loaded, so you can perform additional processing.\n    * @param {object} [callbackContext=(loader)] - The context under which the callback will be applied. If not specified it will use the Phaser Loader as the context.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    script: function (key, url, callback, callbackContext) {\n\n        if (callback === undefined) { callback = false; }\n\n        if (callback !== false && callbackContext === undefined) { callbackContext = this; }\n\n        return this.addToFileList('script', key, url, { syncPoint: true, callback: callback, callbackContext: callbackContext }, false, '.js');\n\n    },\n\n    /**\n    * Adds a binary file to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getBinary(key)`.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n    * and no URL is given then the Loader will set the URL to be \"alien.bin\". It will always add `.bin` as the extension.\n    * If you do not desire this action then provide a URL.\n    *\n    * It will be loaded via xhr with a responseType of \"arraybuffer\". You can specify an optional callback to process the file after load.\n    * When the callback is called it will be passed 2 parameters: the key of the file and the file data.\n    *\n    * WARNING: If a callback is specified the data will be set to whatever it returns. Always return the data object, even if you didn't modify it.\n    *\n    * @method Phaser.Loader#binary\n    * @param {string} key - Unique asset key of the binary file.\n    * @param {string} [url] - URL of the binary file. If undefined or `null` the url will be set to `<key>.bin`, i.e. if `key` was \"alien\" then the URL will be \"alien.bin\".\n    * @param {function} [callback=(none)] - Optional callback that will be passed the file after loading, so you can perform additional processing on it.\n    * @param {object} [callbackContext] - The context under which the callback will be applied. If not specified it will use the callback itself as the context.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    binary: function (key, url, callback, callbackContext) {\n\n        if (callback === undefined) { callback = false; }\n\n        // Why is the default callback context the ..callback?\n        if (callback !== false && callbackContext === undefined) { callbackContext = callback; }\n\n        return this.addToFileList('binary', key, url, { callback: callback, callbackContext: callbackContext }, false, '.bin');\n\n    },\n\n    /**\n    * Adds a Sprite Sheet to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * To clarify the terminology that Phaser uses: A Sprite Sheet is an image containing frames, usually of an animation, that are all equal\n    * dimensions and often in sequence. For example if the frame size is 32x32 then every frame in the sprite sheet will be that size.\n    * Sometimes (outside of Phaser) the term \"sprite sheet\" is used to refer to a texture atlas.\n    * A Texture Atlas works by packing together images as best it can, using whatever frame sizes it likes, often with cropping and trimming\n    * the frames in the process. Software such as Texture Packer, Flash CC or Shoebox all generate texture atlases, not sprite sheets.\n    * If you've got an atlas then use `Loader.atlas` instead.\n    *\n    * The key must be a unique String. It is used to add the image to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getImage(key)`. Sprite sheets, being image based, live in the same Cache as all other Images.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n    * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension.\n    * If you do not desire this action then provide a URL.\n    *\n    * @method Phaser.Loader#spritesheet\n    * @param {string} key - Unique asset key of the sheet file.\n    * @param {string} url - URL of the sprite sheet file. If undefined or `null` the url will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n    * @param {number} frameWidth - Width in pixels of a single frame in the sprite sheet.\n    * @param {number} frameHeight - Height in pixels of a single frame in the sprite sheet.\n    * @param {number} [frameMax=-1] - How many frames in this sprite sheet. If not specified it will divide the whole image into frames.\n    * @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.\n    * @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    spritesheet: function (key, url, frameWidth, frameHeight, frameMax, margin, spacing) {\n\n        if (frameMax === undefined) { frameMax = -1; }\n        if (margin === undefined) { margin = 0; }\n        if (spacing === undefined) { spacing = 0; }\n\n        return this.addToFileList('spritesheet', key, url, { frameWidth: frameWidth, frameHeight: frameHeight, frameMax: frameMax, margin: margin, spacing: spacing }, false, '.png');\n\n    },\n\n    /**\n    * Adds an audio file to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getSound(key)`.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * Mobile warning: There are some mobile devices (certain iPad 2 and iPad Mini revisions) that cannot play 48000 Hz audio.\n    * When they try to play the audio becomes extremely distorted and buzzes, eventually crashing the sound system.\n    * The solution is to use a lower encoding rate such as 44100 Hz.\n    *\n    * @method Phaser.Loader#audio\n    * @param {string} key - Unique asset key of the audio file.\n    * @param {string|string[]|object[]} urls - Either a single string or an array of URIs or pairs of `{uri: .., type: ..}`.\n    *    If an array is specified then the first URI (or URI + mime pair) that is device-compatible will be selected.\n    *    For example: `\"jump.mp3\"`, `['jump.mp3', 'jump.ogg', 'jump.m4a']`, or `[{uri: \"data:<opus_resource>\", type: 'opus'}, 'fallback.mp3']`.\n    *    BLOB and DATA URIs can be used but only support automatic detection when used in the pair form; otherwise the format must be manually checked before adding the resource.\n    * @param {boolean} [autoDecode=true] - When using Web Audio the audio files can either be decoded at load time or run-time.\n    *    Audio files can't be played until they are decoded and, if specified, this enables immediate decoding. Decoding is a non-blocking async process, however it consumes huge amounts of CPU time on mobiles especially.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    audio: function (key, urls, autoDecode) {\n\n        if (this.game.sound.noAudio)\n        {\n            return this;\n        }\n\n        if (autoDecode === undefined) { autoDecode = true; }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        return this.addToFileList('audio', key, urls, { buffer: null, autoDecode: autoDecode });\n\n    },\n\n    /**\n    * Adds an audio sprite file to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Audio Sprites are a combination of audio files and a JSON configuration.\n    *\n    * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite\n    *\n    * Retrieve the file via `Cache.getSoundData(key)`.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * @method Phaser.Loader#audioSprite\n    * @param {string} key - Unique asset key of the audio file.\n    * @param {Array|string} urls - An array containing the URLs of the audio files, i.e.: [ 'audiosprite.mp3', 'audiosprite.ogg', 'audiosprite.m4a' ] or a single string containing just one URL.\n    * @param {string} [jsonURL=null] - The URL of the audiosprite configuration JSON object. If you wish to pass the data directly set this parameter to null.\n    * @param {string|object} [jsonData=null] - A JSON object or string containing the audiosprite configuration data. This is ignored if jsonURL is not null.\n    * @param {boolean} [autoDecode=true] - When using Web Audio the audio files can either be decoded at load time or run-time.\n    *    Audio files can't be played until they are decoded and, if specified, this enables immediate decoding. Decoding is a non-blocking async process, however it consumes huge amounts of CPU time on mobiles especially.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    audioSprite: function (key, urls, jsonURL, jsonData, autoDecode) {\n\n        if (this.game.sound.noAudio)\n        {\n            return this;\n        }\n\n        if (jsonURL === undefined) { jsonURL = null; }\n        if (jsonData === undefined) { jsonData = null; }\n        if (autoDecode === undefined) { autoDecode = true; }\n\n        this.audio(key, urls, autoDecode);\n\n        if (jsonURL)\n        {\n            this.json(key + '-audioatlas', jsonURL);\n        }\n        else if (jsonData)\n        {\n            if (typeof jsonData === 'string')\n            {\n                jsonData = JSON.parse(jsonData);\n            }\n\n            this.cache.addJSON(key + '-audioatlas', '', jsonData);\n        }\n        else\n        {\n            console.warn('Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object');\n        }\n\n        return this;\n\n    },\n\n    /**\n    * A legacy alias for Loader.audioSprite. Please see that method for documentation.\n    *\n    * @method Phaser.Loader#audiosprite\n    * @param {string} key - Unique asset key of the audio file.\n    * @param {Array|string} urls - An array containing the URLs of the audio files, i.e.: [ 'audiosprite.mp3', 'audiosprite.ogg', 'audiosprite.m4a' ] or a single string containing just one URL.\n    * @param {string} [jsonURL=null] - The URL of the audiosprite configuration JSON object. If you wish to pass the data directly set this parameter to null.\n    * @param {string|object} [jsonData=null] - A JSON object or string containing the audiosprite configuration data. This is ignored if jsonURL is not null.\n    * @param {boolean} [autoDecode=true] - When using Web Audio the audio files can either be decoded at load time or run-time.\n    *    Audio files can't be played until they are decoded and, if specified, this enables immediate decoding. Decoding is a non-blocking async process, however it consumes huge amounts of CPU time on mobiles especially.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    audiosprite: function (key, urls, jsonURL, jsonData, autoDecode) {\n\n        return this.audioSprite(key, urls, jsonURL, jsonData, autoDecode);\n\n    },\n\n    /**\n    * Adds a video file to the current load queue.\n    *\n    * The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getVideo(key)`.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * You don't need to preload a video in order to play it in your game. See `Video.createVideoFromURL` for details.\n    *\n    * @method Phaser.Loader#video\n    * @param {string} key - Unique asset key of the video file.\n    * @param {string|string[]|object[]} urls - Either a single string or an array of URIs or pairs of `{uri: .., type: ..}`.\n    *    If an array is specified then the first URI (or URI + mime pair) that is device-compatible will be selected.\n    *    For example: `\"boom.mp4\"`, `['boom.mp4', 'boom.ogg', 'boom.webm']`, or `[{uri: \"data:<opus_resource>\", type: 'opus'}, 'fallback.mp4']`.\n    *    BLOB and DATA URIs can be used but only support automatic detection when used in the pair form; otherwise the format must be manually checked before adding the resource.\n    * @param {string} [loadEvent='canplaythrough'] - This sets the Video source event to listen for before the load is considered complete.\n    *    'canplaythrough' implies the video has downloaded enough, and bandwidth is high enough that it can be played to completion.\n    *    'canplay' implies the video has downloaded enough to start playing, but not necessarily to finish.\n    *    'loadeddata' just makes sure that the video meta data and first frame have downloaded. Phaser uses this value automatically if the\n    *    browser is detected as being Firefox and no `loadEvent` is given, otherwise it defaults to `canplaythrough`.\n    * @param {boolean} [asBlob=false] - Video files can either be loaded via the creation of a video element which has its src property set.\n    *    Or they can be loaded via xhr, stored as binary data in memory and then converted to a Blob. This isn't supported in IE9 or Android 2.\n    *    If you need to have the same video playing at different times across multiple Sprites then you need to load it as a Blob.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    video: function (key, urls, loadEvent, asBlob) {\n\n        if (loadEvent === undefined)\n        {\n            if (this.game.device.firefox)\n            {\n                loadEvent = 'loadeddata';\n            }\n            else\n            {\n                loadEvent = 'canplaythrough';\n            }\n        }\n\n        if (asBlob === undefined) { asBlob = false; }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        return this.addToFileList('video', key, urls, { buffer: null, asBlob: asBlob, loadEvent: loadEvent });\n\n    },\n\n    /**\n    * Adds a Tile Map data file to the current load queue.\n    *\n    * Phaser can load data in two different formats: CSV and Tiled JSON.\n    * \n    * Tiled is a free software package, specifically for creating tilemaps, and is available from http://www.mapeditor.org\n    *\n    * You can choose to either load the data externally, by providing a URL to a json file.\n    * Or you can pass in a JSON object or String via the `data` parameter.\n    * If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n    *\n    * If a URL is provided the file is **not** loaded immediately after calling this method, but is added to the load queue.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getTilemapData(key)`. JSON files are automatically parsed upon load.\n    * If you need to control when the JSON is parsed then use `Loader.text` instead and parse the text file as needed.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified and no data is given then the Loader will take the key and create a filename from that.\n    * For example if the key is \"level1\" and no URL or data is given then the Loader will set the URL to be \"level1.json\".\n    * If you set the format to be Tilemap.CSV it will set the URL to be \"level1.csv\" instead.\n    *\n    * If you do not desire this action then provide a URL or data object.\n    *\n    * @method Phaser.Loader#tilemap\n    * @param {string} key - Unique asset key of the tilemap data.\n    * @param {string} [url] - URL of the tile map file. If undefined or `null` and no data is given the url will be set to `<key>.json`, i.e. if `key` was \"level1\" then the URL will be \"level1.json\".\n    * @param {object|string} [data] - An optional JSON data object. If given then the url is ignored and this JSON object is used for map data instead.\n    * @param {number} [format=Phaser.Tilemap.CSV] - The format of the map data. Either Phaser.Tilemap.CSV or Phaser.Tilemap.TILED_JSON.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    tilemap: function (key, url, data, format) {\n\n        if (url === undefined) { url = null; }\n        if (data === undefined) { data = null; }\n        if (format === undefined) { format = Phaser.Tilemap.CSV; }\n\n        if (!url && !data)\n        {\n            if (format === Phaser.Tilemap.CSV)\n            {\n                url = key + '.csv';\n            }\n            else\n            {\n                url = key + '.json';\n            }\n        }\n\n        //  A map data object has been given\n        if (data)\n        {\n            switch (format)\n            {\n                //  A csv string or object has been given\n                case Phaser.Tilemap.CSV:\n                    break;\n\n                //  A json string or object has been given\n                case Phaser.Tilemap.TILED_JSON:\n\n                    if (typeof data === 'string')\n                    {\n                        data = JSON.parse(data);\n                    }\n                    break;\n            }\n\n            this.cache.addTilemap(key, null, data, format);\n        }\n        else\n        {\n            this.addToFileList('tilemap', key, url, { format: format });\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Adds a physics data file to the current load queue.\n    *\n    * The data must be in `Lime + Corona` JSON format. [Physics Editor](https://www.codeandweb.com) by code'n'web exports in this format natively.\n    *\n    * You can choose to either load the data externally, by providing a URL to a json file.\n    * Or you can pass in a JSON object or String via the `data` parameter.\n    * If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n    *\n    * If a URL is provided the file is **not** loaded immediately after calling this method, but is added to the load queue.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getJSON(key)`. JSON files are automatically parsed upon load.\n    * If you need to control when the JSON is parsed then use `Loader.text` instead and parse the text file as needed.\n    *\n    * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the URL isn't specified and no data is given then the Loader will take the key and create a filename from that.\n    * For example if the key is \"alien\" and no URL or data is given then the Loader will set the URL to be \"alien.json\".\n    * It will always use `.json` as the extension.\n    *\n    * If you do not desire this action then provide a URL or data object.\n    *\n    * @method Phaser.Loader#physics\n    * @param {string} key - Unique asset key of the physics json data.\n    * @param {string} [url] - URL of the physics data file. If undefined or `null` and no data is given the url will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\n    * @param {object|string} [data] - An optional JSON data object. If given then the url is ignored and this JSON object is used for physics data instead.\n    * @param {string} [format=Phaser.Physics.LIME_CORONA_JSON] - The format of the physics data.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    physics: function (key, url, data, format) {\n\n        if (url === undefined) { url = null; }\n        if (data === undefined) { data = null; }\n        if (format === undefined) { format = Phaser.Physics.LIME_CORONA_JSON; }\n\n        if (!url && !data)\n        {\n            url = key + '.json';\n        }\n\n        //  A map data object has been given\n        if (data)\n        {\n            if (typeof data === 'string')\n            {\n                data = JSON.parse(data);\n            }\n\n            this.cache.addPhysicsData(key, null, data, format);\n        }\n        else\n        {\n            this.addToFileList('physics', key, url, { format: format });\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Adds Bitmap Font files to the current load queue.\n    *\n    * To create the Bitmap Font files you can use:\n    *\n    * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/\n    * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\n    * Littera (Web-based, free): http://kvazars.com/littera/\n    *\n    * You can choose to either load the data externally, by providing a URL to an xml file.\n    * Or you can pass in an XML object or String via the `xmlData` parameter.\n    * If you pass a String the data is automatically run through `Loader.parseXML` and then immediately added to the Phaser.Cache.\n    *\n    * If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getBitmapFont(key)`. XML files are automatically parsed upon load.\n    * If you need to control when the XML is parsed then use `Loader.text` instead and parse the XML file as needed.\n    *\n    * The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the textureURL isn't specified then the Loader will take the key and create a filename from that.\n    * For example if the key is \"megaFont\" and textureURL is null then the Loader will set the URL to be \"megaFont.png\".\n    * The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\n    * set the atlasURL to be the key. For example if the key is \"megaFont\" the atlasURL will be set to \"megaFont.xml\".\n    *\n    * If you do not desire this action then provide URLs and / or a data object.\n    *\n    * @method Phaser.Loader#bitmapFont\n    * @param {string} key - Unique asset key of the bitmap font.\n    * @param {string} textureURL -  URL of the Bitmap Font texture file. If undefined or `null` the url will be set to `<key>.png`, i.e. if `key` was \"megaFont\" then the URL will be \"megaFont.png\".\n    * @param {string} atlasURL - URL of the Bitmap Font atlas file (xml/json). If undefined or `null` AND `atlasData` is null, the url will be set to `<key>.xml`, i.e. if `key` was \"megaFont\" then the URL will be \"megaFont.xml\".\n    * @param {object} atlasData - An optional Bitmap Font atlas in string form (stringified xml/json).\n    * @param {number} [xSpacing=0] - If you'd like to add additional horizontal spacing between the characters then set the pixel value here.\n    * @param {number} [ySpacing=0] - If you'd like to add additional vertical spacing between the lines then set the pixel value here.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    bitmapFont: function (key, textureURL, atlasURL, atlasData, xSpacing, ySpacing) {\n\n        if (textureURL === undefined || textureURL === null)\n        {\n            textureURL = key + '.png';\n        }\n\n        if (atlasURL === undefined) { atlasURL = null; }\n        if (atlasData === undefined) { atlasData = null; }\n\n        if (atlasURL === null && atlasData === null)\n        {\n            atlasURL = key + '.xml';\n        }\n\n        if (xSpacing === undefined) { xSpacing = 0; }\n        if (ySpacing === undefined) { ySpacing = 0; }\n\n        //  A URL to a json/xml atlas has been given\n        if (atlasURL)\n        {\n            this.addToFileList('bitmapfont', key, textureURL, { atlasURL: atlasURL, xSpacing: xSpacing, ySpacing: ySpacing });\n        }\n        else\n        {\n            //  A stringified xml/json atlas has been given\n            if (typeof atlasData === 'string')\n            {\n                var json, xml;\n\n                try\n                {\n                    json = JSON.parse(atlasData);\n                }\n                catch ( e )\n                {\n                    xml = this.parseXml(atlasData);\n                }\n\n                if (!xml && !json)\n                {\n                    throw new Error(\"Phaser.Loader. Invalid Bitmap Font atlas given\");\n                }\n\n                this.addToFileList('bitmapfont', key, textureURL, { atlasURL: null, atlasData: json || xml,\n                    atlasType: (!!json ? 'json' : 'xml'), xSpacing: xSpacing, ySpacing: ySpacing });\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Adds a Texture Atlas file to the current load queue.\n    *\n    * Unlike `Loader.atlasJSONHash` this call expects the atlas data to be in a JSON Array format.\n    *\n    * To create the Texture Atlas you can use tools such as:\n    *\n    * [Texture Packer](https://www.codeandweb.com/texturepacker/phaser)\n    * [Shoebox](http://renderhjs.net/shoebox/)\n    *\n    * If using Texture Packer we recommend you enable \"Trim sprite names\".\n    * If your atlas software has an option to \"rotate\" the resulting frames, you must disable it.\n    *\n    * You can choose to either load the data externally, by providing a URL to a json file.\n    * Or you can pass in a JSON object or String via the `atlasData` parameter.\n    * If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n    *\n    * If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getImage(key)`. JSON files are automatically parsed upon load.\n    * If you need to control when the JSON is parsed then use `Loader.text` instead and parse the JSON file as needed.\n    *\n    * The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the textureURL isn't specified then the Loader will take the key and create a filename from that.\n    * For example if the key is \"player\" and textureURL is null then the Loader will set the URL to be \"player.png\".\n    * The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\n    * set the atlasURL to be the key. For example if the key is \"player\" the atlasURL will be set to \"player.json\".\n    *\n    * If you do not desire this action then provide URLs and / or a data object.\n    *\n    * @method Phaser.Loader#atlasJSONArray\n    * @param {string} key - Unique asset key of the texture atlas file.\n    * @param {string} [textureURL] - URL of the texture atlas image file. If undefined or `null` the url will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n    * @param {string} [atlasURL] - URL of the texture atlas data file. If undefined or `null` and no atlasData is given, the url will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\n    * @param {object} [atlasData] - A JSON data object. You don't need this if the data is being loaded from a URL.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    atlasJSONArray: function (key, textureURL, atlasURL, atlasData) {\n\n        return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY);\n\n    },\n\n    /**\n    * Adds a Texture Atlas file to the current load queue.\n    *\n    * Unlike `Loader.atlas` this call expects the atlas data to be in a JSON Hash format.\n    *\n    * To create the Texture Atlas you can use tools such as:\n    *\n    * [Texture Packer](https://www.codeandweb.com/texturepacker/phaser)\n    * [Shoebox](http://renderhjs.net/shoebox/)\n    *\n    * If using Texture Packer we recommend you enable \"Trim sprite names\".\n    * If your atlas software has an option to \"rotate\" the resulting frames, you must disable it.\n    *\n    * You can choose to either load the data externally, by providing a URL to a json file.\n    * Or you can pass in a JSON object or String via the `atlasData` parameter.\n    * If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n    *\n    * If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getImage(key)`. JSON files are automatically parsed upon load.\n    * If you need to control when the JSON is parsed then use `Loader.text` instead and parse the JSON file as needed.\n    *\n    * The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the textureURL isn't specified then the Loader will take the key and create a filename from that.\n    * For example if the key is \"player\" and textureURL is null then the Loader will set the URL to be \"player.png\".\n    * The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\n    * set the atlasURL to be the key. For example if the key is \"player\" the atlasURL will be set to \"player.json\".\n    *\n    * If you do not desire this action then provide URLs and / or a data object.\n    *\n    * @method Phaser.Loader#atlasJSONHash\n    * @param {string} key - Unique asset key of the texture atlas file.\n    * @param {string} [textureURL] - URL of the texture atlas image file. If undefined or `null` the url will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n    * @param {string} [atlasURL] - URL of the texture atlas data file. If undefined or `null` and no atlasData is given, the url will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\n    * @param {object} [atlasData] - A JSON data object. You don't need this if the data is being loaded from a URL.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    atlasJSONHash: function (key, textureURL, atlasURL, atlasData) {\n\n        return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_HASH);\n\n    },\n\n    /**\n    * Adds a Texture Atlas file to the current load queue.\n    *\n    * This call expects the atlas data to be in the Starling XML data format.\n    *\n    * To create the Texture Atlas you can use tools such as:\n    *\n    * [Texture Packer](https://www.codeandweb.com/texturepacker/phaser)\n    * [Shoebox](http://renderhjs.net/shoebox/)\n    *\n    * If using Texture Packer we recommend you enable \"Trim sprite names\".\n    * If your atlas software has an option to \"rotate\" the resulting frames, you must disable it.\n    *\n    * You can choose to either load the data externally, by providing a URL to an xml file.\n    * Or you can pass in an XML object or String via the `atlasData` parameter.\n    * If you pass a String the data is automatically run through `Loader.parseXML` and then immediately added to the Phaser.Cache.\n    *\n    * If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getImage(key)`. XML files are automatically parsed upon load.\n    * If you need to control when the XML is parsed then use `Loader.text` instead and parse the XML file as needed.\n    *\n    * The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the textureURL isn't specified then the Loader will take the key and create a filename from that.\n    * For example if the key is \"player\" and textureURL is null then the Loader will set the URL to be \"player.png\".\n    * The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\n    * set the atlasURL to be the key. For example if the key is \"player\" the atlasURL will be set to \"player.xml\".\n    *\n    * If you do not desire this action then provide URLs and / or a data object.\n    *\n    * @method Phaser.Loader#atlasXML\n    * @param {string} key - Unique asset key of the texture atlas file.\n    * @param {string} [textureURL] - URL of the texture atlas image file. If undefined or `null` the url will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n    * @param {string} [atlasURL] - URL of the texture atlas data file. If undefined or `null` and no atlasData is given, the url will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\n    * @param {object} [atlasData] - An XML data object. You don't need this if the data is being loaded from a URL.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    atlasXML: function (key, textureURL, atlasURL, atlasData) {\n\n        if (atlasURL === undefined) { atlasURL = null; }\n        if (atlasData === undefined) { atlasData = null; }\n\n        if (!atlasURL && !atlasData)\n        {\n            atlasURL = key + '.xml';\n        }\n\n        return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_XML_STARLING);\n\n    },\n\n    /**\n    * Adds a Texture Atlas file to the current load queue.\n    *\n    * To create the Texture Atlas you can use tools such as:\n    *\n    * [Texture Packer](https://www.codeandweb.com/texturepacker/phaser)\n    * [Shoebox](http://renderhjs.net/shoebox/)\n    *\n    * If using Texture Packer we recommend you enable \"Trim sprite names\".\n    * If your atlas software has an option to \"rotate\" the resulting frames, you must disable it.\n    *\n    * You can choose to either load the data externally, by providing a URL to a json file.\n    * Or you can pass in a JSON object or String via the `atlasData` parameter.\n    * If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n    *\n    * If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n    *\n    * The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n    *\n    * Retrieve the file via `Cache.getImage(key)`. JSON files are automatically parsed upon load.\n    * If you need to control when the JSON is parsed then use `Loader.text` instead and parse the JSON file as needed.\n    *\n    * The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n    *\n    * If the textureURL isn't specified then the Loader will take the key and create a filename from that.\n    * For example if the key is \"player\" and textureURL is null then the Loader will set the URL to be \"player.png\".\n    * The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\n    * set the atlasURL to be the key. For example if the key is \"player\" the atlasURL will be set to \"player.json\".\n    *\n    * If you do not desire this action then provide URLs and / or a data object.\n    *\n    * @method Phaser.Loader#atlas\n    * @param {string} key - Unique asset key of the texture atlas file.\n    * @param {string} [textureURL] - URL of the texture atlas image file. If undefined or `null` the url will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n    * @param {string} [atlasURL] - URL of the texture atlas data file. If undefined or `null` and no atlasData is given, the url will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\n    * @param {object} [atlasData] - A JSON or XML data object. You don't need this if the data is being loaded from a URL.\n    * @param {number} [format] - The format of the data. Can be Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY (the default), Phaser.Loader.TEXTURE_ATLAS_JSON_HASH or Phaser.Loader.TEXTURE_ATLAS_XML_STARLING.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    atlas: function (key, textureURL, atlasURL, atlasData, format) {\n\n        if (textureURL === undefined || textureURL === null)\n        {\n            textureURL = key + '.png';\n        }\n\n        if (atlasURL === undefined) { atlasURL = null; }\n        if (atlasData === undefined) { atlasData = null; }\n        if (format === undefined) { format = Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY; }\n\n        if (!atlasURL && !atlasData)\n        {\n            if (format === Phaser.Loader.TEXTURE_ATLAS_XML_STARLING)\n            {\n                atlasURL = key + '.xml';\n            }\n            else\n            {\n                atlasURL = key + '.json';\n            }\n        }\n\n        //  A URL to a json/xml file has been given\n        if (atlasURL)\n        {\n            this.addToFileList('textureatlas', key, textureURL, { atlasURL: atlasURL, format: format });\n        }\n        else\n        {\n            switch (format)\n            {\n                //  A json string or object has been given\n                case Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY:\n\n                    if (typeof atlasData === 'string')\n                    {\n                        atlasData = JSON.parse(atlasData);\n                    }\n                    break;\n\n                //  An xml string or object has been given\n                case Phaser.Loader.TEXTURE_ATLAS_XML_STARLING:\n\n                    if (typeof atlasData === 'string')\n                    {\n                        var xml = this.parseXml(atlasData);\n\n                        if (!xml)\n                        {\n                            throw new Error(\"Phaser.Loader. Invalid Texture Atlas XML given\");\n                        }\n\n                        atlasData = xml;\n                    }\n                    break;\n            }\n\n            this.addToFileList('textureatlas', key, textureURL, { atlasURL: null, atlasData: atlasData, format: format });\n\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Add a synchronization point to the assets/files added within the supplied callback.\n    *\n    * A synchronization point denotes that an asset _must_ be completely loaded before\n    * subsequent assets can be loaded. An asset marked as a sync-point does not need to wait\n    * for previous assets to load (unless they are sync-points). Resources, such as packs, may still\n    * be downloaded around sync-points, as long as they do not finalize loading.\n    *\n    * @method Phaser.Loader#withSyncPoints\n    * @param {function} callback - The callback is invoked and is supplied with a single argument: the loader.\n    * @param {object} [callbackContext=(loader)] - Context for the callback.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    withSyncPoint: function (callback, callbackContext) {\n\n        this._withSyncPointDepth++;\n\n        try {\n            callback.call(callbackContext || this, this);\n        } finally {\n            this._withSyncPointDepth--;\n        }\n\n        return this;\n    },\n\n    /**\n    * Add a synchronization point to a specific file/asset in the load queue.\n    *\n    * This has no effect on already loaded assets.\n    *\n    * @method Phaser.Loader#addSyncPoint\n    * @param {string} type - The type of resource to turn into a sync point (image, audio, xml, etc).\n    * @param {string} key - Key of the file you want to turn into a sync point.\n    * @return {Phaser.Loader} This Loader instance.\n    * @see {@link Phaser.Loader#withSyncPoint withSyncPoint}\n    */\n    addSyncPoint: function (type, key) {\n\n        var asset = this.getAsset(type, key);\n\n        if (asset)\n        {\n            asset.file.syncPoint = true;\n        }\n\n        return this;\n    },\n\n    /**\n    * Remove a file/asset from the loading queue.\n    *\n    * A file that is loaded or has started loading cannot be removed.\n    *\n    * @method Phaser.Loader#removeFile\n    * @protected\n    * @param {string} type - The type of resource to add to the list (image, audio, xml, etc).\n    * @param {string} key - Key of the file you want to remove.\n    */\n    removeFile: function (type, key) {\n\n        var asset = this.getAsset(type, key);\n\n        if (asset)\n        {\n            if (!asset.loaded && !asset.loading)\n            {\n                this._fileList.splice(asset.index, 1);\n            }\n        }\n\n    },\n\n    /**\n    * Remove all file loading requests - this is _insufficient_ to stop current loading. Use `reset` instead.\n    *\n    * @method Phaser.Loader#removeAll\n    * @protected\n    */\n    removeAll: function () {\n\n        this._fileList.length = 0;\n        this._flightQueue.length = 0;\n\n    },\n\n    /**\n    * Start loading the assets. Normally you don't need to call this yourself as the StateManager will do so.\n    *\n    * @method Phaser.Loader#start\n    */\n    start: function () {\n\n        if (this.isLoading)\n        {\n            return;\n        }\n\n        this.hasLoaded = false;\n        this.isLoading = true;\n\n        this.updateProgress();\n\n        this.processLoadQueue();\n\n    },\n\n    /**\n    * Process the next item(s) in the file/asset queue.\n    *\n    * Process the queue and start loading enough items to fill up the inflight queue.\n    *\n    * If a sync-file is encountered then subsequent asset processing is delayed until it completes.\n    * The exception to this rule is that packfiles can be downloaded (but not processed) even if\n    * there appear other sync files (ie. packs) - this enables multiple packfiles to be fetched in parallel.\n    * such as during the start phaser.\n    *\n    * @method Phaser.Loader#processLoadQueue\n    * @private\n    */\n    processLoadQueue: function () {\n\n        if (!this.isLoading)\n        {\n            console.warn('Phaser.Loader - active loading canceled / reset');\n            this.finishedLoading(true);\n            return;\n        }\n\n        // Empty the flight queue as applicable\n        for (var i = 0; i < this._flightQueue.length; i++)\n        {\n            var file = this._flightQueue[i];\n\n            if (file.loaded || file.error)\n            {\n                this._flightQueue.splice(i, 1);\n                i--;\n\n                file.loading = false;\n                file.requestUrl = null;\n                file.requestObject = null;\n\n                if (file.error)\n                {\n                    this.onFileError.dispatch(file.key, file);\n                }\n\n                if (file.type !== 'packfile')\n                {\n                    this._loadedFileCount++;\n                    this.onFileComplete.dispatch(this.progress, file.key, !file.error, this._loadedFileCount, this._totalFileCount);\n                }\n                else if (file.type === 'packfile' && file.error)\n                {\n                    // Non-error pack files are handled when processing the file queue\n                    this._loadedPackCount++;\n                    this.onPackComplete.dispatch(file.key, !file.error, this._loadedPackCount, this._totalPackCount);\n                }\n\n            }\n        }\n\n        // When true further non-pack file downloads are suppressed\n        var syncblock = false;\n\n        var inflightLimit = this.enableParallel ? Phaser.Math.clamp(this.maxParallelDownloads, 1, 12) : 1;\n\n        for (var i = this._processingHead; i < this._fileList.length; i++)\n        {\n            var file = this._fileList[i];\n\n            // Pack is fetched (ie. has data) and is currently at the start of the process queue.\n            if (file.type === 'packfile' && !file.error && file.loaded && i === this._processingHead)\n            {\n                // Processing the pack / adds more files\n                this.processPack(file);\n\n                this._loadedPackCount++;\n                this.onPackComplete.dispatch(file.key, !file.error, this._loadedPackCount, this._totalPackCount);\n            }\n\n            if (file.loaded || file.error)\n            {\n                // Item at the start of file list finished, can skip it in future\n                if (i === this._processingHead)\n                {\n                    this._processingHead = i + 1;\n                }\n            }\n            else if (!file.loading && this._flightQueue.length < inflightLimit)\n            {\n                // -> not loaded/failed, not loading\n                if (file.type === 'packfile' && !file.data)\n                {\n                    // Fetches the pack data: the pack is processed above as it reaches queue-start.\n                    // (Packs do not trigger onLoadStart or onFileStart.)\n                    this._flightQueue.push(file);\n                    file.loading = true;\n\n                    this.loadFile(file);\n                }\n                else if (!syncblock)\n                {\n                    if (!this._fileLoadStarted)\n                    {\n                        this._fileLoadStarted = true;\n                        this.onLoadStart.dispatch();\n                    }\n\n                    this._flightQueue.push(file);\n                    file.loading = true;\n                    this.onFileStart.dispatch(this.progress, file.key, file.url);\n\n                    this.loadFile(file);\n                }\n            }\n\n            if (!file.loaded && file.syncPoint)\n            {\n                syncblock = true;\n            }\n\n            // Stop looking if queue full - or if syncblocked and there are no more packs.\n            // (As only packs can be loaded around a syncblock)\n            if (this._flightQueue.length >= inflightLimit ||\n                (syncblock && this._loadedPackCount === this._totalPackCount))\n            {\n                break;\n            }\n        }\n\n        this.updateProgress();\n\n        // True when all items in the queue have been advanced over\n        // (There should be no inflight items as they are complete - loaded/error.)\n        if (this._processingHead >= this._fileList.length)\n        {\n            this.finishedLoading();\n        }\n        else if (!this._flightQueue.length)\n        {\n            // Flight queue is empty but file list is not done being processed.\n            // This indicates a critical internal error with no known recovery.\n            console.warn(\"Phaser.Loader - aborting: processing queue empty, loading may have stalled\");\n\n            var _this = this;\n\n            setTimeout(function () {\n                _this.finishedLoading(true);\n            }, 2000);\n        }\n\n    },\n\n    /**\n    * The loading is all finished.\n    *\n    * @method Phaser.Loader#finishedLoading\n    * @private\n    * @param {boolean} [abnormal=true] - True if the loading finished abnormally.\n    */\n    finishedLoading: function (abnormal) {\n\n        if (this.hasLoaded)\n        {\n            return;\n        }\n\n        this.hasLoaded = true;\n        this.isLoading = false;\n\n        // If there were no files make sure to trigger the event anyway, for consistency\n        if (!abnormal && !this._fileLoadStarted)\n        {\n            this._fileLoadStarted = true;\n            this.onLoadStart.dispatch();\n        }\n\n        this.onLoadComplete.dispatch();\n\n        this.game.state.loadComplete();\n\n        this.reset();\n\n    },\n\n    /**\n    * Informs the loader that the given file resource has been fetched and processed;\n    * or such a request has failed.\n    *\n    * @method Phaser.Loader#asyncComplete\n    * @private\n    * @param {object} file\n    * @param {string} [error=''] - The error message, if any. No message implies no error.\n    */\n    asyncComplete: function (file, errorMessage) {\n\n        if (errorMessage === undefined) { errorMessage = ''; }\n\n        file.loaded = true;\n        file.error = !!errorMessage;\n\n        if (errorMessage)\n        {\n            file.errorMessage = errorMessage;\n\n            console.warn('Phaser.Loader - ' + file.type + '[' + file.key + ']' + ': ' + errorMessage);\n            // debugger;\n        }\n\n        this.processLoadQueue();\n\n    },\n\n    /**\n    * Process pack data. This will usually modify the file list.\n    *\n    * @method Phaser.Loader#processPack\n    * @private\n    * @param {object} pack\n    */\n    processPack: function (pack) {\n\n        var packData = pack.data[pack.key];\n\n        if (!packData)\n        {\n            console.warn('Phaser.Loader - ' + pack.key + ': pack has data, but not for pack key');\n            return;\n        }\n\n        for (var i = 0; i < packData.length; i++)\n        {\n            var file = packData[i];\n\n            switch (file.type)\n            {\n                case \"image\":\n                    this.image(file.key, file.url, file.overwrite);\n                    break;\n\n                case \"text\":\n                    this.text(file.key, file.url, file.overwrite);\n                    break;\n\n                case \"json\":\n                    this.json(file.key, file.url, file.overwrite);\n                    break;\n\n                case \"xml\":\n                    this.xml(file.key, file.url, file.overwrite);\n                    break;\n\n                case \"script\":\n                    this.script(file.key, file.url, file.callback, pack.callbackContext || this);\n                    break;\n\n                case \"binary\":\n                    this.binary(file.key, file.url, file.callback, pack.callbackContext || this);\n                    break;\n\n                case \"spritesheet\":\n                    this.spritesheet(file.key, file.url, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);\n                    break;\n\n                case \"video\":\n                    this.video(file.key, file.urls);\n                    break;\n\n                case \"audio\":\n                    this.audio(file.key, file.urls, file.autoDecode);\n                    break;\n\n                case \"audiosprite\":\n                    this.audiosprite(file.key, file.urls, file.jsonURL, file.jsonData, file.autoDecode);\n                    break;\n\n                case \"tilemap\":\n                    this.tilemap(file.key, file.url, file.data, Phaser.Tilemap[file.format]);\n                    break;\n\n                case \"physics\":\n                    this.physics(file.key, file.url, file.data, Phaser.Loader[file.format]);\n                    break;\n\n                case \"bitmapFont\":\n                    this.bitmapFont(file.key, file.textureURL, file.atlasURL, file.atlasData, file.xSpacing, file.ySpacing);\n                    break;\n\n                case \"atlasJSONArray\":\n                    this.atlasJSONArray(file.key, file.textureURL, file.atlasURL, file.atlasData);\n                    break;\n\n                case \"atlasJSONHash\":\n                    this.atlasJSONHash(file.key, file.textureURL, file.atlasURL, file.atlasData);\n                    break;\n\n                case \"atlasXML\":\n                    this.atlasXML(file.key, file.textureURL, file.atlasURL, file.atlasData);\n                    break;\n\n                case \"atlas\":\n                    this.atlas(file.key, file.textureURL, file.atlasURL, file.atlasData, Phaser.Loader[file.format]);\n                    break;\n\n                case \"shader\":\n                    this.shader(file.key, file.url, file.overwrite);\n                    break;\n            }\n        }\n\n    },\n\n    /**\n    * Transforms the asset URL.\n    *\n    * The default implementation prepends the baseURL if the url doesn't begin with http or //\n    *\n    * @method Phaser.Loader#transformUrl\n    * @protected\n    * @param {string} url - The url to transform.\n    * @param {object} file - The file object being transformed.\n    * @return {string} The transformed url. In rare cases where the url isn't specified it will return false instead.\n    */\n    transformUrl: function (url, file) {\n\n        if (!url)\n        {\n            return false;\n        }\n\n        if (url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/))\n        {\n            return url;\n        }\n        else\n        {\n            return this.baseURL + file.path + url;\n        }\n\n    },\n\n    /**\n    * Start fetching a resource.\n    *\n    * All code paths, async or otherwise, from this function must return to `asyncComplete`.\n    *\n    * @method Phaser.Loader#loadFile\n    * @private\n    * @param {object} file\n    */\n    loadFile: function (file) {\n\n        //  Image or Data?\n        switch (file.type)\n        {\n            case 'packfile':\n                this.xhrLoad(file, this.transformUrl(file.url, file), 'text', this.fileComplete);\n                break;\n\n            case 'image':\n            case 'spritesheet':\n            case 'textureatlas':\n            case 'bitmapfont':\n                this.loadImageTag(file);\n                break;\n\n            case 'audio':\n                file.url = this.getAudioURL(file.url);\n\n                if (file.url)\n                {\n                    //  WebAudio or Audio Tag?\n                    if (this.game.sound.usingWebAudio)\n                    {\n                        this.xhrLoad(file, this.transformUrl(file.url, file), 'arraybuffer', this.fileComplete);\n                    }\n                    else if (this.game.sound.usingAudioTag)\n                    {\n                        this.loadAudioTag(file);\n                    }\n                }\n                else\n                {\n                    this.fileError(file, null, 'No supported audio URL specified or device does not have audio playback support');\n                }\n                break;\n\n            case 'video':\n                file.url = this.getVideoURL(file.url);\n\n                if (file.url)\n                {\n                    if (file.asBlob)\n                    {\n                        this.xhrLoad(file, this.transformUrl(file.url, file), 'blob', this.fileComplete);\n                    }\n                    else\n                    {\n                        this.loadVideoTag(file);\n                    }\n                }\n                else\n                {\n                    this.fileError(file, null, 'No supported video URL specified or device does not have video playback support');\n                }\n                break;\n\n            case 'json':\n\n                this.xhrLoad(file, this.transformUrl(file.url, file), 'text', this.jsonLoadComplete);\n                break;\n\n            case 'xml':\n\n                this.xhrLoad(file, this.transformUrl(file.url, file), 'text', this.xmlLoadComplete);\n                break;\n\n            case 'tilemap':\n\n                if (file.format === Phaser.Tilemap.TILED_JSON)\n                {\n                    this.xhrLoad(file, this.transformUrl(file.url, file), 'text', this.jsonLoadComplete);\n                }\n                else if (file.format === Phaser.Tilemap.CSV)\n                {\n                    this.xhrLoad(file, this.transformUrl(file.url, file), 'text', this.csvLoadComplete);\n                }\n                else\n                {\n                    this.asyncComplete(file, \"invalid Tilemap format: \" + file.format);\n                }\n                break;\n\n            case 'text':\n            case 'script':\n            case 'shader':\n            case 'physics':\n                this.xhrLoad(file, this.transformUrl(file.url, file), 'text', this.fileComplete);\n                break;\n\n            case 'binary':\n                this.xhrLoad(file, this.transformUrl(file.url, file), 'arraybuffer', this.fileComplete);\n                break;\n        }\n\n    },\n\n    /**\n    * Continue async loading through an Image tag.\n    * @private\n    */\n    loadImageTag: function (file) {\n\n        var _this = this;\n\n        file.data = new Image();\n        file.data.name = file.key;\n\n        if (this.crossOrigin)\n        {\n            file.data.crossOrigin = this.crossOrigin;\n        }\n\n        file.data.onload = function () {\n            if (file.data.onload)\n            {\n                file.data.onload = null;\n                file.data.onerror = null;\n                _this.fileComplete(file);\n            }\n        };\n\n        file.data.onerror = function () {\n            if (file.data.onload)\n            {\n                file.data.onload = null;\n                file.data.onerror = null;\n                _this.fileError(file);\n            }\n        };\n\n        file.data.src = this.transformUrl(file.url, file);\n\n        // Image is immediately-available/cached\n        if (file.data.complete && file.data.width && file.data.height)\n        {\n            file.data.onload = null;\n            file.data.onerror = null;\n            this.fileComplete(file);\n        }\n\n    },\n\n    /**\n    * Continue async loading through a Video tag.\n    * @private\n    */\n    loadVideoTag: function (file) {\n\n        var _this = this;\n\n        file.data = document.createElement(\"video\");\n        file.data.name = file.key;\n        file.data.controls = false;\n        file.data.autoplay = false;\n\n        var videoLoadEvent = function () {\n\n            file.data.removeEventListener(file.loadEvent, videoLoadEvent, false);\n            file.data.onerror = null;\n            file.data.canplay = true;\n            Phaser.GAMES[_this.game.id].load.fileComplete(file);\n\n        };\n\n        file.data.onerror = function () {\n            file.data.removeEventListener(file.loadEvent, videoLoadEvent, false);\n            file.data.onerror = null;\n            file.data.canplay = false;\n            _this.fileError(file);\n        };\n\n        file.data.addEventListener(file.loadEvent, videoLoadEvent, false);\n\n        file.data.src = this.transformUrl(file.url, file);\n        file.data.load();\n\n    },\n\n    /**\n    * Continue async loading through an Audio tag.\n    * @private\n    */\n    loadAudioTag: function (file) {\n\n        var _this = this;\n\n        if (this.game.sound.touchLocked)\n        {\n            //  If audio is locked we can't do this yet, so need to queue this load request. Bum.\n            file.data = new Audio();\n            file.data.name = file.key;\n            file.data.preload = 'auto';\n            file.data.src = this.transformUrl(file.url, file);\n\n            this.fileComplete(file);\n        }\n        else\n        {\n            file.data = new Audio();\n            file.data.name = file.key;\n\n            var playThroughEvent = function () {\n                file.data.removeEventListener('canplaythrough', playThroughEvent, false);\n                file.data.onerror = null;\n                _this.fileComplete(file);\n            };\n\n            file.data.onerror = function () {\n                file.data.removeEventListener('canplaythrough', playThroughEvent, false);\n                file.data.onerror = null;\n                _this.fileError(file);\n            };\n\n            file.data.preload = 'auto';\n            file.data.src = this.transformUrl(file.url, file);\n            file.data.addEventListener('canplaythrough', playThroughEvent, false);\n            file.data.load();\n        }\n\n    },\n\n    /**\n    * Starts the xhr loader.\n    *\n    * This is designed specifically to use with asset file processing.\n    *\n    * @method Phaser.Loader#xhrLoad\n    * @private\n    * @param {object} file - The file/pack to load.\n    * @param {string} url - The URL of the file.\n    * @param {string} type - The xhr responseType.\n    * @param {function} onload - The function to call on success. Invoked in `this` context and supplied with `(file, xhr)` arguments.\n    * @param {function} [onerror=fileError]  The function to call on error. Invoked in `this` context and supplied with `(file, xhr)` arguments.\n    */\n    xhrLoad: function (file, url, type, onload, onerror) {\n\n        if (this.useXDomainRequest && window.XDomainRequest)\n        {\n            this.xhrLoadWithXDR(file, url, type, onload, onerror);\n            return;\n        }\n\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, true);\n        xhr.responseType = type;\n\n        if (this.headers['requestedWith'] !== false)\n        {\n            xhr.setRequestHeader('X-Requested-With', this.headers['requestedWith']);\n        }\n\n        if (this.headers[file.type])\n        {\n            xhr.setRequestHeader('Accept', this.headers[file.type]);\n        }\n\n        onerror = onerror || this.fileError;\n\n        var _this = this;\n\n        xhr.onload = function () {\n\n            try {\n                if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599) { // Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.\n                    return onerror.call(_this, file, xhr);\n                }\n                else {\n                    return onload.call(_this, file, xhr);\n                }\n            } catch (e) {\n\n                //  If this was the last file in the queue and an error is thrown in the create method\n                //  then it's caught here, so be sure we don't carry on processing it\n\n                if (!_this.hasLoaded)\n                {\n                    _this.asyncComplete(file, e.message || 'Exception');\n                }\n                else\n                {\n                    if (window['console'])\n                    {\n                        console.error(e);\n                    }\n                }\n            }\n        };\n\n        xhr.onerror = function () {\n\n            try {\n\n                return onerror.call(_this, file, xhr);\n\n            } catch (e) {\n\n                if (!_this.hasLoaded)\n                {\n                    _this.asyncComplete(file, e.message || 'Exception');\n                }\n                else\n                {\n                    if (window['console'])\n                    {\n                        console.error(e);\n                    }\n                }\n\n            }\n        };\n\n        file.requestObject = xhr;\n        file.requestUrl = url;\n\n        xhr.send();\n\n    },\n\n    /**\n    * Starts the xhr loader - using XDomainRequest.\n    * This should _only_ be used with IE 9. Phaser does not support IE 8 and XDR is deprecated in IE 10.\n    *\n    * This is designed specifically to use with asset file processing.\n    *\n    * @method Phaser.Loader#xhrLoad\n    * @private\n    * @param {object} file - The file/pack to load.\n    * @param {string} url - The URL of the file.\n    * @param {string} type - The xhr responseType.\n    * @param {function} onload - The function to call on success. Invoked in `this` context and supplied with `(file, xhr)` arguments.\n    * @param {function} [onerror=fileError]  The function to call on error. Invoked in `this` context and supplied with `(file, xhr)` arguments.\n    * @deprecated This is only relevant for IE 9.\n    */\n    xhrLoadWithXDR: function (file, url, type, onload, onerror) {\n\n        // Special IE9 magic .. only\n        if (!this._warnedAboutXDomainRequest &&\n            (!this.game.device.ie || this.game.device.ieVersion >= 10))\n        {\n            this._warnedAboutXDomainRequest = true;\n            console.warn(\"Phaser.Loader - using XDomainRequest outside of IE 9\");\n        }\n\n        // Ref: http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n        var xhr = new window.XDomainRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = type;\n\n        // XDomainRequest has a few quirks. Occasionally it will abort requests\n        // A way to avoid this is to make sure ALL callbacks are set even if not used\n        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n        xhr.timeout = 3000;\n\n        onerror = onerror || this.fileError;\n\n        var _this = this;\n\n        xhr.onerror = function () {\n            try {\n                return onerror.call(_this, file, xhr);\n            } catch (e) {\n                _this.asyncComplete(file, e.message || 'Exception');\n            }\n        };\n\n        xhr.ontimeout = function () {\n            try {\n                return onerror.call(_this, file, xhr);\n            } catch (e) {\n                _this.asyncComplete(file, e.message || 'Exception');\n            }\n        };\n\n        xhr.onprogress = function() {};\n\n        xhr.onload = function () {\n            try {\n                if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599) { // Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.\n                    return onerror.call(_this, file, xhr);\n                }\n                else {\n                    return onload.call(_this, file, xhr);\n                }\n                return onload.call(_this, file, xhr);\n            } catch (e) {\n                _this.asyncComplete(file, e.message || 'Exception');\n            }\n        };\n\n        file.requestObject = xhr;\n        file.requestUrl = url;\n\n        //  Note: The xdr.send() call is wrapped in a timeout to prevent an issue with the interface where some requests are lost\n        //  if multiple XDomainRequests are being sent at the same time.\n        setTimeout(function () {\n            xhr.send();\n        }, 0);\n\n    },\n\n    /**\n    * Give a bunch of URLs, return the first URL that has an extension this device thinks it can play.\n    *\n    * It is assumed that the device can play \"blob:\" or \"data:\" URIs - There is no mime-type checking on data URIs.\n    *\n    * @method Phaser.Loader#getVideoURL\n    * @private\n    * @param {object[]|string[]} urls - See {@link #video} for format.\n    * @return {string} The URL to try and fetch; or null.\n    */\n    getVideoURL: function (urls) {\n\n        for (var i = 0; i < urls.length; i++)\n        {\n            var url = urls[i];\n            var videoType;\n\n            if (url.uri) // {uri: .., type: ..} pair\n            {\n                videoType = url.type;\n                url = url.uri;\n\n                if (this.game.device.canPlayVideo(videoType))\n                {\n                    return url;\n                }\n            }\n            else\n            {\n                // Assume direct-data URI can be played if not in a paired form; select immediately\n                if (url.indexOf(\"blob:\") === 0 || url.indexOf(\"data:\") === 0)\n                {\n                    return url;\n                }\n\n                if (url.indexOf(\"?\") >= 0) // Remove query from URL\n                {\n                    url = url.substr(0, url.indexOf(\"?\"));\n                }\n\n                var extension = url.substr((Math.max(0, url.lastIndexOf(\".\")) || Infinity) + 1);\n\n                videoType = extension.toLowerCase();\n\n                if (this.game.device.canPlayVideo(videoType))\n                {\n                    return urls[i];\n                }\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Give a bunch of URLs, return the first URL that has an extension this device thinks it can play.\n    *\n    * It is assumed that the device can play \"blob:\" or \"data:\" URIs - There is no mime-type checking on data URIs.\n    *\n    * @method Phaser.Loader#getAudioURL\n    * @private\n    * @param {object[]|string[]} urls - See {@link #audio} for format.\n    * @return {string} The URL to try and fetch; or null.\n    */\n    getAudioURL: function (urls) {\n\n        if (this.game.sound.noAudio)\n        {\n            return null;\n        }\n\n        for (var i = 0; i < urls.length; i++)\n        {\n            var url = urls[i];\n            var audioType;\n\n            if (url.uri) // {uri: .., type: ..} pair\n            {\n                audioType = url.type;\n                url = url.uri;\n\n                if (this.game.device.canPlayAudio(audioType))\n                {\n                    return url;\n                }\n            }\n            else\n            {\n                // Assume direct-data URI can be played if not in a paired form; select immediately\n                if (url.indexOf(\"blob:\") === 0 || url.indexOf(\"data:\") === 0)\n                {\n                    return url;\n                }\n\n                if (url.indexOf(\"?\") >= 0) // Remove query from URL\n                {\n                    url = url.substr(0, url.indexOf(\"?\"));\n                }\n\n                var extension = url.substr((Math.max(0, url.lastIndexOf(\".\")) || Infinity) + 1);\n\n                audioType = extension.toLowerCase();\n\n                if (this.game.device.canPlayAudio(audioType))\n                {\n                    return urls[i];\n                }\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Error occurred when loading a file.\n    *\n    * @method Phaser.Loader#fileError\n    * @private\n    * @param {object} file\n    * @param {?XMLHttpRequest} xhr - XHR request, unspecified if loaded via other means (eg. tags)\n    * @param {string} reason\n    */\n    fileError: function (file, xhr, reason) {\n\n        var url = file.requestUrl || this.transformUrl(file.url, file);\n        var message = 'error loading asset from URL ' + url;\n\n        if (!reason && xhr)\n        {\n            reason = xhr.status;\n        }\n\n        if (reason)\n        {\n            message = message + ' (' + reason + ')';\n        }\n\n        this.asyncComplete(file, message);\n\n    },\n\n    /**\n    * Called when a file/resources had been downloaded and needs to be processed further.\n    *\n    * @method Phaser.Loader#fileComplete\n    * @private\n    * @param {object} file - File loaded\n    * @param {?XMLHttpRequest} xhr - XHR request, unspecified if loaded via other means (eg. tags)\n    */\n    fileComplete: function (file, xhr) {\n\n        var loadNext = true;\n\n        switch (file.type)\n        {\n            case 'packfile':\n\n                // Pack data must never be false-ish after it is fetched without error\n                var data = JSON.parse(xhr.responseText);\n                file.data = data || {};\n                break;\n\n            case 'image':\n\n                this.cache.addImage(file.key, file.url, file.data);\n                break;\n\n            case 'spritesheet':\n\n                this.cache.addSpriteSheet(file.key, file.url, file.data, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);\n                break;\n\n            case 'textureatlas':\n\n                if (file.atlasURL == null)\n                {\n                    this.cache.addTextureAtlas(file.key, file.url, file.data, file.atlasData, file.format);\n                }\n                else\n                {\n                    //  Load the JSON or XML before carrying on with the next file\n                    loadNext = false;\n\n                    if (file.format === Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY || file.format === Phaser.Loader.TEXTURE_ATLAS_JSON_HASH || file.format === Phaser.Loader.TEXTURE_ATLAS_JSON_PYXEL)\n                    {\n                        this.xhrLoad(file, this.transformUrl(file.atlasURL, file), 'text', this.jsonLoadComplete);\n                    }\n                    else if (file.format === Phaser.Loader.TEXTURE_ATLAS_XML_STARLING)\n                    {\n                        this.xhrLoad(file, this.transformUrl(file.atlasURL, file), 'text', this.xmlLoadComplete);\n                    }\n                    else\n                    {\n                        throw new Error(\"Phaser.Loader. Invalid Texture Atlas format: \" + file.format);\n                    }\n                }\n                break;\n\n            case 'bitmapfont':\n\n                if (!file.atlasURL)\n                {\n                    this.cache.addBitmapFont(file.key, file.url, file.data, file.atlasData, file.atlasType, file.xSpacing, file.ySpacing);\n                }\n                else\n                {\n                    //  Load the XML before carrying on with the next file\n                    loadNext = false;\n                    this.xhrLoad(file, this.transformUrl(file.atlasURL, file), 'text', function (file, xhr) {\n                        var json;\n\n                        try\n                        {\n                            // Try to parse as JSON, if it fails, then it's hopefully XML\n                            json = JSON.parse(xhr.responseText);\n                        }\n                        catch (e) {}\n\n                        if (!!json)\n                        {\n                            file.atlasType = 'json';\n                            this.jsonLoadComplete(file, xhr);\n                        }\n                        else\n                        {\n                            file.atlasType = 'xml';\n                            this.xmlLoadComplete(file, xhr);\n                        }\n                    });\n                }\n                break;\n\n            case 'video':\n\n                if (file.asBlob)\n                {\n                    try\n                    {\n                        file.data = xhr.response;\n                    }\n                    catch (e)\n                    {\n                        throw new Error(\"Phaser.Loader. Unable to parse video file as Blob: \" + file.key);\n                    }\n                }\n\n                this.cache.addVideo(file.key, file.url, file.data, file.asBlob);\n                break;\n\n            case 'audio':\n\n                if (this.game.sound.usingWebAudio)\n                {\n                    file.data = xhr.response;\n\n                    this.cache.addSound(file.key, file.url, file.data, true, false);\n\n                    if (file.autoDecode)\n                    {\n                        this.game.sound.decode(file.key);\n                    }\n                }\n                else\n                {\n                    this.cache.addSound(file.key, file.url, file.data, false, true);\n                }\n                break;\n\n            case 'text':\n                file.data = xhr.responseText;\n                this.cache.addText(file.key, file.url, file.data);\n                break;\n\n            case 'shader':\n                file.data = xhr.responseText;\n                this.cache.addShader(file.key, file.url, file.data);\n                break;\n\n            case 'physics':\n                var data = JSON.parse(xhr.responseText);\n                this.cache.addPhysicsData(file.key, file.url, data, file.format);\n                break;\n\n            case 'script':\n                file.data = document.createElement('script');\n                file.data.language = 'javascript';\n                file.data.type = 'text/javascript';\n                file.data.defer = false;\n                file.data.text = xhr.responseText;\n                document.head.appendChild(file.data);\n                if (file.callback)\n                {\n                    file.data = file.callback.call(file.callbackContext, file.key, xhr.responseText);\n                }\n                break;\n\n            case 'binary':\n                if (file.callback)\n                {\n                    file.data = file.callback.call(file.callbackContext, file.key, xhr.response);\n                }\n                else\n                {\n                    file.data = xhr.response;\n                }\n\n                this.cache.addBinary(file.key, file.data);\n\n                break;\n        }\n\n        if (loadNext)\n        {\n            this.asyncComplete(file);\n        }\n\n    },\n\n    /**\n    * Successfully loaded a JSON file - only used for certain types.\n    *\n    * @method Phaser.Loader#jsonLoadComplete\n    * @private\n    * @param {object} file - File associated with this request\n    * @param {XMLHttpRequest} xhr\n    */\n    jsonLoadComplete: function (file, xhr) {\n\n        var data = JSON.parse(xhr.responseText);\n\n        if (file.type === 'tilemap')\n        {\n            this.cache.addTilemap(file.key, file.url, data, file.format);\n        }\n        else if (file.type === 'bitmapfont')\n        {\n            this.cache.addBitmapFont(file.key, file.url, file.data, data, file.atlasType, file.xSpacing, file.ySpacing);\n        }\n        else if (file.type === 'json')\n        {\n            this.cache.addJSON(file.key, file.url, data);\n        }\n        else\n        {\n            this.cache.addTextureAtlas(file.key, file.url, file.data, data, file.format);\n        }\n\n        this.asyncComplete(file);\n    },\n\n    /**\n    * Successfully loaded a CSV file - only used for certain types.\n    *\n    * @method Phaser.Loader#csvLoadComplete\n    * @private\n    * @param {object} file - File associated with this request\n    * @param {XMLHttpRequest} xhr\n    */\n    csvLoadComplete: function (file, xhr) {\n\n        var data = xhr.responseText;\n\n        this.cache.addTilemap(file.key, file.url, data, file.format);\n\n        this.asyncComplete(file);\n\n    },\n\n    /**\n    * Successfully loaded an XML file - only used for certain types.\n    *\n    * @method Phaser.Loader#xmlLoadComplete\n    * @private\n    * @param {object} file - File associated with this request\n    * @param {XMLHttpRequest} xhr\n    */\n    xmlLoadComplete: function (file, xhr) {\n\n        // Always try parsing the content as XML, regardless of actually response type\n        var data = xhr.responseText;\n        var xml = this.parseXml(data);\n\n        if (!xml)\n        {\n            var responseType = xhr.responseType || xhr.contentType; // contentType for MS-XDomainRequest\n            console.warn('Phaser.Loader - ' + file.key + ': invalid XML (' + responseType + ')');\n            this.asyncComplete(file, \"invalid XML\");\n            return;\n        }\n\n        if (file.type === 'bitmapfont')\n        {\n            this.cache.addBitmapFont(file.key, file.url, file.data, xml, file.atlasType, file.xSpacing, file.ySpacing);\n        }\n        else if (file.type === 'textureatlas')\n        {\n            this.cache.addTextureAtlas(file.key, file.url, file.data, xml, file.format);\n        }\n        else if (file.type === 'xml')\n        {\n            this.cache.addXML(file.key, file.url, xml);\n        }\n\n        this.asyncComplete(file);\n\n    },\n\n    /**\n    * Parses string data as XML.\n    *\n    * @method Phaser.Loader#parseXml\n    * @private\n    * @param {string} data - The XML text to parse\n    * @return {?XMLDocument} Returns the xml document, or null if such could not parsed to a valid document.\n    */\n    parseXml: function (data) {\n\n        var xml;\n\n        try\n        {\n            if (window['DOMParser'])\n            {\n                var domparser = new DOMParser();\n                xml = domparser.parseFromString(data, \"text/xml\");\n            }\n            else\n            {\n                xml = new ActiveXObject(\"Microsoft.XMLDOM\");\n                // Why is this 'false'?\n                xml.async = 'false';\n                xml.loadXML(data);\n            }\n        }\n        catch (e)\n        {\n            xml = null;\n        }\n\n        if (!xml || !xml.documentElement || xml.getElementsByTagName(\"parsererror\").length)\n        {\n            return null;\n        }\n        else\n        {\n            return xml;\n        }\n\n    },\n\n    /**\n    * Update the loading sprite progress.\n    *\n    * @method Phaser.Loader#nextFile\n    * @private\n    * @param {object} previousFile\n    * @param {boolean} success - Whether the previous asset loaded successfully or not.\n    */\n    updateProgress: function () {\n\n        if (this.preloadSprite)\n        {\n            if (this.preloadSprite.direction === 0)\n            {\n                this.preloadSprite.rect.width = Math.floor((this.preloadSprite.width / 100) * this.progress);\n            }\n            else\n            {\n                this.preloadSprite.rect.height = Math.floor((this.preloadSprite.height / 100) * this.progress);\n            }\n\n            if (this.preloadSprite.sprite)\n            {\n                this.preloadSprite.sprite.updateCrop();\n            }\n            else\n            {\n                //  We seem to have lost our sprite - maybe it was destroyed?\n                this.preloadSprite = null;\n            }\n        }\n\n    },\n\n    /**\n    * Returns the number of files that have already been loaded, even if they errored.\n    *\n    * @method Phaser.Loader#totalLoadedFiles\n    * @protected\n    * @return {number} The number of files that have already been loaded (even if they errored)\n    */\n    totalLoadedFiles: function () {\n\n        return this._loadedFileCount;\n\n    },\n\n    /**\n    * Returns the number of files still waiting to be processed in the load queue. This value decreases as each file in the queue is loaded.\n    *\n    * @method Phaser.Loader#totalQueuedFiles\n    * @protected\n    * @return {number} The number of files that still remain in the load queue.\n    */\n    totalQueuedFiles: function () {\n\n        return this._totalFileCount - this._loadedFileCount;\n\n    },\n\n    /**\n    * Returns the number of asset packs that have already been loaded, even if they errored.\n    *\n    * @method Phaser.Loader#totalLoadedPacks\n    * @protected\n    * @return {number} The number of asset packs that have already been loaded (even if they errored)\n    */\n    totalLoadedPacks: function () {\n\n        return this._totalPackCount;\n\n    },\n\n    /**\n    * Returns the number of asset packs still waiting to be processed in the load queue. This value decreases as each pack in the queue is loaded.\n    *\n    * @method Phaser.Loader#totalQueuedPacks\n    * @protected\n    * @return {number} The number of asset packs that still remain in the load queue.\n    */\n    totalQueuedPacks: function () {\n\n        return this._totalPackCount - this._loadedPackCount;\n\n    }\n\n};\n\n/**\n* The non-rounded load progress value (from 0.0 to 100.0).\n*\n* A general indicator of the progress.\n* It is possible for the progress to decrease, after `onLoadStart`, if more files are dynamically added.\n*\n* @name Phaser.Loader#progressFloat\n* @property {number}\n*/\nObject.defineProperty(Phaser.Loader.prototype, \"progressFloat\", {\n\n    get: function () {\n        var progress = (this._loadedFileCount / this._totalFileCount) * 100;\n        return Phaser.Math.clamp(progress || 0, 0, 100);\n    }\n\n});\n\n/**\n* The rounded load progress percentage value (from 0 to 100). See {@link Phaser.Loader#progressFloat}.\n*\n* @name Phaser.Loader#progress\n* @property {integer}\n*/\nObject.defineProperty(Phaser.Loader.prototype, \"progress\", {\n\n    get: function () {\n        return Math.round(this.progressFloat);\n    }\n\n});\n\nPhaser.Loader.prototype.constructor = Phaser.Loader;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.LoaderParser parses data objects from Phaser.Loader that need more preparation before they can be inserted into the Cache.\n*\n* @class Phaser.LoaderParser\n*/\nPhaser.LoaderParser = {\n\n    /**\n    * Alias for xmlBitmapFont, for backwards compatibility.\n    * \n    * @method Phaser.LoaderParser.bitmapFont\n    * @param {object} xml - XML data you want to parse.\n    * @param {PIXI.BaseTexture} baseTexture - The BaseTexture this font uses.\n    * @param {number} [xSpacing=0] - Additional horizontal spacing between the characters.\n    * @param {number} [ySpacing=0] - Additional vertical spacing between the characters.\n    * @return {object} The parsed Bitmap Font data.\n    */\n    bitmapFont: function (xml, baseTexture, xSpacing, ySpacing) {\n\n        return this.xmlBitmapFont(xml, baseTexture, xSpacing, ySpacing);\n\n    },\n\n    /**\n    * Parse a Bitmap Font from an XML file.\n    *\n    * @method Phaser.LoaderParser.xmlBitmapFont\n    * @param {object} xml - XML data you want to parse.\n    * @param {PIXI.BaseTexture} baseTexture - The BaseTexture this font uses.\n    * @param {number} [xSpacing=0] - Additional horizontal spacing between the characters.\n    * @param {number} [ySpacing=0] - Additional vertical spacing between the characters.\n    * @return {object} The parsed Bitmap Font data.\n    */\n    xmlBitmapFont: function (xml, baseTexture, xSpacing, ySpacing) {\n\n        var data = {};\n        var info = xml.getElementsByTagName('info')[0];\n        var common = xml.getElementsByTagName('common')[0];\n\n        data.font = info.getAttribute('face');\n        data.size = parseInt(info.getAttribute('size'), 10);\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) + ySpacing;\n        data.chars = {};\n\n        var letters = xml.getElementsByTagName('char');\n\n        for (var i = 0; i < letters.length; i++)\n        {\n            var charCode = parseInt(letters[i].getAttribute('id'), 10);\n\n            data.chars[charCode] = {\n                x: parseInt(letters[i].getAttribute('x'), 10),\n                y: parseInt(letters[i].getAttribute('y'), 10),\n                width: parseInt(letters[i].getAttribute('width'), 10),\n                height: parseInt(letters[i].getAttribute('height'), 10),\n                xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),\n                yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),\n                xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10) + xSpacing,\n                kerning: {}\n            };\n        }\n\n        var kernings = xml.getElementsByTagName('kerning');\n\n        for (i = 0; i < kernings.length; i++)\n        {\n            var first = parseInt(kernings[i].getAttribute('first'), 10);\n            var second = parseInt(kernings[i].getAttribute('second'), 10);\n            var amount = parseInt(kernings[i].getAttribute('amount'), 10);\n\n            data.chars[second].kerning[first] = amount;\n        }\n\n        return this.finalizeBitmapFont(baseTexture, data);\n\n    },\n\n    /**\n    * Parse a Bitmap Font from a JSON file.\n    *\n    * @method Phaser.LoaderParser.jsonBitmapFont\n    * @param {object} json - JSON data you want to parse.\n    * @param {PIXI.BaseTexture} baseTexture - The BaseTexture this font uses.\n    * @param {number} [xSpacing=0] - Additional horizontal spacing between the characters.\n    * @param {number} [ySpacing=0] - Additional vertical spacing between the characters.\n    * @return {object} The parsed Bitmap Font data.\n    */\n    jsonBitmapFont: function (json, baseTexture, xSpacing, ySpacing) {\n\n        var data = {\n            font: json.font.info._face,\n            size: parseInt(json.font.info._size, 10),\n            lineHeight: parseInt(json.font.common._lineHeight, 10) + ySpacing,\n            chars: {}\n        };\n\n        json.font.chars[\"char\"].forEach(\n\n            function parseChar(letter) {\n\n                var charCode = parseInt(letter._id, 10);\n\n                data.chars[charCode] = {\n                    x: parseInt(letter._x, 10),\n                    y: parseInt(letter._y, 10),\n                    width: parseInt(letter._width, 10),\n                    height: parseInt(letter._height, 10),\n                    xOffset: parseInt(letter._xoffset, 10),\n                    yOffset: parseInt(letter._yoffset, 10),\n                    xAdvance: parseInt(letter._xadvance, 10) + xSpacing,\n                    kerning: {}\n                };\n            }\n\n        );\n\n        if (json.font.kernings && json.font.kernings.kerning) {\n\n            json.font.kernings.kerning.forEach(\n\n                function parseKerning(kerning) {\n\n                    data.chars[kerning._second].kerning[kerning._first] = parseInt(kerning._amount, 10);\n\n                }\n\n            );\n\n        }\n\n        return this.finalizeBitmapFont(baseTexture, data);\n\n    },\n\n    /**\n    * Finalize Bitmap Font parsing.\n    *\n    * @method Phaser.LoaderParser.finalizeBitmapFont\n    * @private\n    * @param {PIXI.BaseTexture} baseTexture - The BaseTexture this font uses.\n    * @param {object} bitmapFontData - Pre-parsed bitmap font data.\n    * @return {object} The parsed Bitmap Font data.\n    */\n    finalizeBitmapFont: function (baseTexture, bitmapFontData) {\n\n        Object.keys(bitmapFontData.chars).forEach(\n\n            function addTexture(charCode) {\n\n                var letter = bitmapFontData.chars[charCode];\n\n                letter.texture = new PIXI.Texture(baseTexture, new Phaser.Rectangle(letter.x, letter.y, letter.width, letter.height));\n\n            }\n\n        );\n\n        return bitmapFontData;\n\n    }\n};\n\n/**\n * @author       Jeremy Dowell <jeremy@codevinsky.com>\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2016 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n/**\n * Audio Sprites are a combination of audio files and a JSON configuration.\n * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite\n *\n * @class Phaser.AudioSprite\n * @constructor\n * @param {Phaser.Game} game - Reference to the current game instance.\n * @param {string} key - Asset key for the sound.\n */\nPhaser.AudioSprite = function (game, key) {\n\n    /**\n    * A reference to the currently running Game.\n    * @property {Phaser.Game} game\n    */\n    this.game = game;\n\n    /**\n     * Asset key for the Audio Sprite.\n     * @property {string} key\n     */\n    this.key = key;\n\n    /**\n     * JSON audio atlas object.\n     * @property {object} config\n     */\n    this.config = this.game.cache.getJSON(key + '-audioatlas');\n\n    /**\n     * If a sound is set to auto play, this holds the marker key of it.\n     * @property {string} autoplayKey\n     */\n    this.autoplayKey = null;\n\n    /**\n     * Is a sound set to autoplay or not?\n     * @property {boolean} autoplay\n     * @default\n     */\n    this.autoplay = false;\n\n    /**\n     * An object containing the Phaser.Sound objects for the Audio Sprite.\n     * @property {object} sounds\n     */\n    this.sounds = {};\n\n    for (var k in this.config.spritemap)\n    {\n        var marker = this.config.spritemap[k];\n        var sound = this.game.add.sound(this.key);\n        \n        sound.addMarker(k, marker.start, (marker.end - marker.start), null, marker.loop);\n        \n        this.sounds[k] = sound;\n    }\n\n    if (this.config.autoplay)\n    {\n        this.autoplayKey = this.config.autoplay;\n        this.play(this.autoplayKey);\n        this.autoplay = this.sounds[this.autoplayKey];\n    }\n\n};\n\nPhaser.AudioSprite.prototype = {\n\n    /**\n     * Play a sound with the given name.\n     * \n     * @method Phaser.AudioSprite#play\n     * @param {string} [marker] - The name of sound to play\n     * @param {number} [volume=1] - Volume of the sound you want to play. If none is given it will use the volume given to the Sound when it was created (which defaults to 1 if none was specified).\n     * @return {Phaser.Sound} This sound instance.\n     */\n    play: function (marker, volume) {\n\n        if (volume === undefined) { volume = 1; }\n\n        return this.sounds[marker].play(marker, null, volume);\n\n    },\n\n    /**\n     * Stop a sound with the given name.\n     * \n     * @method Phaser.AudioSprite#stop\n     * @param {string} [marker=''] - The name of sound to stop. If none is given it will stop all sounds in the audio sprite.\n     */\n    stop: function (marker) {\n\n        if (!marker)\n        {\n            for (var key in this.sounds)\n            {\n                this.sounds[key].stop();\n            }\n        }\n        else\n        {\n            this.sounds[marker].stop();\n        }\n\n    },\n\n    /**\n     * Get a sound with the given name.\n     * \n     * @method Phaser.AudioSprite#get\n     * @param {string} marker - The name of sound to get.\n     * @return {Phaser.Sound} The sound instance.\n     */\n    get: function(marker) {\n\n        return this.sounds[marker];\n\n    }\n\n};\n\nPhaser.AudioSprite.prototype.constructor = Phaser.AudioSprite;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Sound class constructor.\n*\n* @class Phaser.Sound\n* @constructor\n* @param {Phaser.Game} game - Reference to the current game instance.\n* @param {string} key - Asset key for the sound.\n* @param {number} [volume=1] - Default value for the volume, between 0 and 1.\n* @param {boolean} [loop=false] - Whether or not the sound will loop.\n*/\nPhaser.Sound = function (game, key, volume, loop, connect) {\n\n    if (volume === undefined) { volume = 1; }\n    if (loop === undefined) { loop = false; }\n    if (connect === undefined) { connect = game.sound.connectToMaster; }\n\n    /**\n    * A reference to the currently running Game.\n    * @property {Phaser.Game} game\n    */\n    this.game = game;\n\n    /**\n    * @property {string} name - Name of the sound.\n    */\n    this.name = key;\n\n    /**\n    * @property {string} key - Asset key for the sound.\n    */\n    this.key = key;\n\n    /**\n    * @property {boolean} loop - Whether or not the sound or current sound marker will loop.\n    */\n    this.loop = loop;\n\n    /**\n    * @property {object} markers - The sound markers.\n    */\n    this.markers = {};\n\n    /**\n    * @property {AudioContext} context - Reference to the AudioContext instance.\n    */\n    this.context = null;\n\n    /**\n    * @property {boolean} autoplay - Boolean indicating whether the sound should start automatically.\n    */\n    this.autoplay = false;\n\n    /**\n    * @property {number} totalDuration - The total duration of the sound in seconds.\n    */\n    this.totalDuration = 0;\n\n    /**\n    * @property {number} startTime - The time the Sound starts at (typically 0 unless starting from a marker)\n    * @default\n    */\n    this.startTime = 0;\n\n    /**\n    * @property {number} currentTime - The current time the sound is at.\n    */\n    this.currentTime = 0;\n\n    /**\n    * @property {number} duration - The duration of the current sound marker in seconds.\n    */\n    this.duration = 0;\n\n    /**\n    * @property {number} durationMS - The duration of the current sound marker in ms.\n    */\n    this.durationMS = 0;\n\n    /**\n    * @property {number} position - The position of the current sound marker.\n    */\n    this.position = 0;\n\n    /**\n    * @property {number} stopTime - The time the sound stopped.\n    */\n    this.stopTime = 0;\n\n    /**\n    * @property {boolean} paused - true if the sound is paused, otherwise false.\n    * @default\n    */\n    this.paused = false;\n\n    /**\n    * @property {number} pausedPosition - The position the sound had reached when it was paused.\n    */\n    this.pausedPosition = 0;\n\n    /**\n    * @property {number} pausedTime - The game time at which the sound was paused.\n    */\n    this.pausedTime = 0;\n\n    /**\n    * @property {boolean} isPlaying - true if the sound is currently playing, otherwise false.\n    * @default\n    */\n    this.isPlaying = false;\n\n    /**\n    * @property {string} currentMarker - The string ID of the currently playing marker, if any.\n    * @default\n    */\n    this.currentMarker = '';\n\n    /**\n    * @property {Phaser.Tween} fadeTween - The tween that fades the audio, set via Sound.fadeIn and Sound.fadeOut.\n    */\n    this.fadeTween = null;\n\n    /**\n    * @property {boolean} pendingPlayback - true if the sound file is pending playback\n    * @readonly\n    */\n    this.pendingPlayback = false;\n\n    /**\n    * @property {boolean} override - if true when you play this sound it will always start from the beginning.\n    * @default\n    */\n    this.override = false;\n\n    /**\n    * @property {boolean} allowMultiple - This will allow you to have multiple instances of this Sound playing at once. This is only useful when running under Web Audio, and we recommend you implement a local pooling system to not flood the sound channels.\n    * @default\n    */\n    this.allowMultiple = false;\n\n    /**\n    * @property {boolean} usingWebAudio - true if this sound is being played with Web Audio.\n    * @readonly\n    */\n    this.usingWebAudio = this.game.sound.usingWebAudio;\n\n    /**\n    * @property {boolean} usingAudioTag - true if the sound is being played via the Audio tag.\n    */\n    this.usingAudioTag = this.game.sound.usingAudioTag;\n\n    /**\n    * @property {object} externalNode - If defined this Sound won't connect to the SoundManager master gain node, but will instead connect to externalNode.\n    */\n    this.externalNode = null;\n\n    /**\n    * @property {object} masterGainNode - The master gain node in a Web Audio system.\n    */\n    this.masterGainNode = null;\n\n    /**\n    * @property {object} gainNode - The gain node in a Web Audio system.\n    */\n    this.gainNode = null;\n\n    /**\n    * @property {object} _sound - Internal var.\n    * @private\n    */\n    this._sound = null;\n\n    if (this.usingWebAudio)\n    {\n        this.context = this.game.sound.context;\n        this.masterGainNode = this.game.sound.masterGain;\n\n        if (this.context.createGain === undefined)\n        {\n            this.gainNode = this.context.createGainNode();\n        }\n        else\n        {\n            this.gainNode = this.context.createGain();\n        }\n\n        this.gainNode.gain.value = volume * this.game.sound.volume;\n\n        if (connect)\n        {\n            this.gainNode.connect(this.masterGainNode);\n        }\n    }\n    else if (this.usingAudioTag)\n    {\n        if (this.game.cache.getSound(key) && this.game.cache.isSoundReady(key))\n        {\n            this._sound = this.game.cache.getSoundData(key);\n            this.totalDuration = 0;\n\n            if (this._sound.duration)\n            {\n                this.totalDuration = this._sound.duration;\n            }\n        }\n        else\n        {\n            this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this);\n        }\n    }\n\n    /**\n    * @property {Phaser.Signal} onDecoded - The onDecoded event is dispatched when the sound has finished decoding (typically for mp3 files)\n    */\n    this.onDecoded = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onPlay - The onPlay event is dispatched each time this sound is played.\n    */\n    this.onPlay = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onPause - The onPause event is dispatched when this sound is paused.\n    */\n    this.onPause = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onResume - The onResume event is dispatched when this sound is resumed from a paused state.\n    */\n    this.onResume = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onLoop - The onLoop event is dispatched when this sound loops during playback.\n    */\n    this.onLoop = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onStop - The onStop event is dispatched when this sound stops playback.\n    */\n    this.onStop = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onMute - The onMute event is dispatched when this sound is muted.\n    */\n    this.onMute = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onMarkerComplete - The onMarkerComplete event is dispatched when a marker within this sound completes playback.\n    */\n    this.onMarkerComplete = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onFadeComplete - The onFadeComplete event is dispatched when this sound finishes fading either in or out.\n    */\n    this.onFadeComplete = new Phaser.Signal();\n\n    /**\n    * @property {number} _volume - The global audio volume. A value between 0 (silence) and 1 (full volume).\n    * @private\n    */\n    this._volume = volume;\n\n    /**\n    * @property {any} _buffer - Decoded data buffer / Audio tag.\n    * @private\n    */\n    this._buffer = null;\n\n    /**\n    * @property {boolean} _muted - Boolean indicating whether the sound is muted or not.\n    * @private\n    */\n    this._muted = false;\n\n    /**\n    * @property {number} _tempMarker - Internal marker var.\n    * @private\n    */\n    this._tempMarker = 0;\n\n    /**\n    * @property {number} _tempPosition - Internal marker var.\n    * @private\n    */\n    this._tempPosition = 0;\n\n    /**\n    * @property {number} _tempVolume - Internal marker var.\n    * @private\n    */\n    this._tempVolume = 0;\n\n    /**\n    * @property {number} _tempPause - Internal marker var.\n    * @private\n    */\n    this._tempPause = 0;\n\n    /**\n    * @property {number} _muteVolume - Internal cache var.\n    * @private\n    */\n    this._muteVolume = 0;\n\n    /**\n    * @property {boolean} _tempLoop - Internal cache var.\n    * @private\n    */\n    this._tempLoop = 0;\n\n    /**\n    * @property {boolean} _paused - Was this sound paused via code or a game event?\n    * @private\n    */\n    this._paused = false;\n\n    /**\n    * @property {boolean} _onDecodedEventDispatched - Was the onDecoded event dispatched?\n    * @private\n    */\n    this._onDecodedEventDispatched = false;\n\n};\n\nPhaser.Sound.prototype = {\n\n    /**\n    * Called automatically when this sound is unlocked.\n    * @method Phaser.Sound#soundHasUnlocked\n    * @param {string} key - The Phaser.Cache key of the sound file to check for decoding.\n    * @protected\n    */\n    soundHasUnlocked: function (key) {\n\n        if (key === this.key)\n        {\n            this._sound = this.game.cache.getSoundData(this.key);\n            this.totalDuration = this._sound.duration;\n        }\n\n    },\n\n    /**\n    * Adds a marker into the current Sound. A marker is represented by a unique key and a start time and duration.\n    * This allows you to bundle multiple sounds together into a single audio file and use markers to jump between them for playback.\n    *\n    * @method Phaser.Sound#addMarker\n    * @param {string} name - A unique name for this marker, i.e. 'explosion', 'gunshot', etc.\n    * @param {number} start - The start point of this marker in the audio file, given in seconds. 2.5 = 2500ms, 0.5 = 500ms, etc.\n    * @param {number} [duration=1] - The duration of the marker in seconds. 2.5 = 2500ms, 0.5 = 500ms, etc.\n    * @param {number} [volume=1] - The volume the sound will play back at, between 0 (silent) and 1 (full volume).\n    * @param {boolean} [loop=false] - Sets if the sound will loop or not.\n    */\n    addMarker: function (name, start, duration, volume, loop) {\n\n        if (duration === undefined || duration === null) { duration = 1; }\n        if (volume === undefined || volume === null) { volume = 1; }\n        if (loop === undefined) { loop = false; }\n\n        this.markers[name] = {\n            name: name,\n            start: start,\n            stop: start + duration,\n            volume: volume,\n            duration: duration,\n            durationMS: duration * 1000,\n            loop: loop\n        };\n\n    },\n\n    /**\n    * Removes a marker from the sound.\n    * @method Phaser.Sound#removeMarker\n    * @param {string} name - The key of the marker to remove.\n    */\n    removeMarker: function (name) {\n\n        delete this.markers[name];\n\n    },\n\n    /**\n    * Called automatically by the AudioContext when the sound stops playing.\n    * Doesn't get called if the sound is set to loop or is a section of an Audio Sprite.\n    * \n    * @method Phaser.Sound#onEndedHandler\n    * @protected\n    */\n    onEndedHandler: function () {\n\n        this._sound.onended = null;\n        this.isPlaying = false;\n        this.currentTime = this.durationMS;\n        this.stop();\n\n    },\n\n    /**\n    * Called automatically by Phaser.SoundManager.\n    * @method Phaser.Sound#update\n    * @protected\n    */\n    update: function () {\n\n        if (!this.game.cache.checkSoundKey(this.key))\n        {\n            this.destroy();\n            return;\n        }\n\n        if (this.isDecoded && !this._onDecodedEventDispatched)\n        {\n            this.onDecoded.dispatch(this);\n            this._onDecodedEventDispatched = true;\n        }\n\n        if (this.pendingPlayback && this.game.cache.isSoundReady(this.key))\n        {\n            this.pendingPlayback = false;\n            this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop);\n        }\n\n        if (this.isPlaying)\n        {\n            this.currentTime = this.game.time.time - this.startTime;\n\n            if (this.currentTime >= this.durationMS)\n            {\n                if (this.usingWebAudio)\n                {\n                    if (this.loop)\n                    {\n                        //  won't work with markers, needs to reset the position\n                        this.onLoop.dispatch(this);\n\n                        //  Gets reset by the play function\n                        this.isPlaying = false;\n\n                        if (this.currentMarker === '')\n                        {\n                            this.currentTime = 0;\n                            this.startTime = this.game.time.time;\n                            this.isPlaying = true; // play not called again in this case\n                        }\n                        else\n                        {\n                            this.onMarkerComplete.dispatch(this.currentMarker, this);\n                            this.play(this.currentMarker, 0, this.volume, true, true);\n                        }\n                    }\n                    else\n                    {\n                        //  Stop if we're using an audio marker, otherwise we let onended handle it\n                        if (this.currentMarker !== '')\n                        {\n                            this.stop();\n                        }\n                    }\n                }\n                else\n                {\n                    if (this.loop)\n                    {\n                        this.onLoop.dispatch(this);\n\n                        if (this.currentMarker === '')\n                        {\n                            this.currentTime = 0;\n                            this.startTime = this.game.time.time;\n                        }\n\n                        //  Gets reset by the play function\n                        this.isPlaying = false;\n\n                        this.play(this.currentMarker, 0, this.volume, true, true);\n                    }\n                    else\n                    {\n                        this.stop();\n                    }\n                }\n            }\n        }\n    },\n\n    /**\n     * Loops this entire sound. If you need to loop a section of it then use Sound.play and the marker and loop parameters.\n     *\n     * @method Phaser.Sound#loopFull\n     * @param {number} [volume=1] - Volume of the sound you want to play. If none is given it will use the volume given to the Sound when it was created (which defaults to 1 if none was specified).\n     * @return {Phaser.Sound} This sound instance.\n     */\n    loopFull: function (volume) {\n\n        return this.play(null, 0, volume, true);\n\n    },\n\n    /**\n    * Play this sound, or a marked section of it.\n    * \n    * @method Phaser.Sound#play\n    * @param {string} [marker=''] - If you want to play a marker then give the key here, otherwise leave blank to play the full sound.\n    * @param {number} [position=0] - The starting position to play the sound from - this is ignored if you provide a marker.\n    * @param {number} [volume=1] - Volume of the sound you want to play. If none is given it will use the volume given to the Sound when it was created (which defaults to 1 if none was specified).\n    * @param {boolean} [loop=false] - Loop when finished playing? If not using a marker / audio sprite the looping will be done via the WebAudio loop property, otherwise it's time based.\n    * @param {boolean} [forceRestart=true] - If the sound is already playing you can set forceRestart to restart it from the beginning.\n    * @return {Phaser.Sound} This sound instance.\n    */\n    play: function (marker, position, volume, loop, forceRestart) {\n\n        if (marker === undefined || marker === false || marker === null) { marker = ''; }\n        if (forceRestart === undefined) { forceRestart = true; }\n\n        if (this.isPlaying && !this.allowMultiple && !forceRestart && !this.override)\n        {\n            //  Use Restart instead\n            return this;\n        }\n\n        if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || forceRestart))\n        {\n            if (this.usingWebAudio)\n            {\n                if (this._sound.stop === undefined)\n                {\n                    this._sound.noteOff(0);\n                }\n                else\n                {\n                    try {\n                        this._sound.stop(0);\n                    }\n                    catch (e) {\n                    }\n                }\n\n                if (this.externalNode)\n                {\n                    this._sound.disconnect(this.externalNode);\n                }\n                else if (this.gainNode)\n                {\n                    this._sound.disconnect(this.gainNode);\n                }\n            }\n            else if (this.usingAudioTag)\n            {\n                this._sound.pause();\n                this._sound.currentTime = 0;\n            }\n\n            this.isPlaying = false;\n        }\n\n        if (marker === '' && Object.keys(this.markers).length > 0)\n        {\n            //  If they didn't specify a marker but this is an audio sprite, \n            //  we should never play the entire thing\n            return this;\n        }\n\n        if (marker !== '')\n        {\n            if (this.markers[marker])\n            {\n                this.currentMarker = marker;\n\n                //  Playing a marker? Then we default to the marker values\n                this.position = this.markers[marker].start;\n                this.volume = this.markers[marker].volume;\n                this.loop = this.markers[marker].loop;\n                this.duration = this.markers[marker].duration;\n                this.durationMS = this.markers[marker].durationMS;\n\n                if (typeof volume !== 'undefined')\n                {\n                    this.volume = volume;\n                }\n\n                if (typeof loop !== 'undefined')\n                {\n                    this.loop = loop;\n                }\n\n                this._tempMarker = marker;\n                this._tempPosition = this.position;\n                this._tempVolume = this.volume;\n                this._tempLoop = this.loop;\n            }\n            else\n            {\n                console.warn(\"Phaser.Sound.play: audio marker \" + marker + \" doesn't exist\");\n                return this;\n            }\n        }\n        else\n        {\n            position = position || 0;\n\n            if (volume === undefined) { volume = this._volume; }\n            if (loop === undefined) { loop = this.loop; }\n\n            this.position = Math.max(0, position);\n            this.volume = volume;\n            this.loop = loop;\n            this.duration = 0;\n            this.durationMS = 0;\n\n            this._tempMarker = marker;\n            this._tempPosition = position;\n            this._tempVolume = volume;\n            this._tempLoop = loop;\n        }\n\n        if (this.usingWebAudio)\n        {\n            //  Does the sound need decoding?\n            if (this.game.cache.isSoundDecoded(this.key))\n            {\n                this._sound = this.context.createBufferSource();\n\n                if (this.externalNode)\n                {\n                    this._sound.connect(this.externalNode);\n                }\n                else\n                {\n                    this._sound.connect(this.gainNode);\n                }\n\n                this._buffer = this.game.cache.getSoundData(this.key);\n                this._sound.buffer = this._buffer;\n\n                if (this.loop && marker === '')\n                {\n                    this._sound.loop = true;\n                }\n\n                if (!this.loop && marker === '')\n                {\n                    this._sound.onended = this.onEndedHandler.bind(this);\n                }\n\n                this.totalDuration = this._sound.buffer.duration;\n\n                if (this.duration === 0)\n                {\n                    this.duration = this.totalDuration;\n                    this.durationMS = Math.ceil(this.totalDuration * 1000);\n                }\n\n                //  Useful to cache this somewhere perhaps?\n                if (this._sound.start === undefined)\n                {\n                    this._sound.noteGrainOn(0, this.position, this.duration);\n                }\n                else\n                {\n                    if (this.loop && marker === '')\n                    {\n                        this._sound.start(0, 0);\n                    }\n                    else\n                    {\n                        this._sound.start(0, this.position, this.duration);\n                    }\n                }\n\n                this.isPlaying = true;\n                this.startTime = this.game.time.time;\n                this.currentTime = 0;\n                this.stopTime = this.startTime + this.durationMS;\n                this.onPlay.dispatch(this);\n            }\n            else\n            {\n                this.pendingPlayback = true;\n\n                if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === false)\n                {\n                    this.game.sound.decode(this.key, this);\n                }\n            }\n        }\n        else\n        {\n            if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked)\n            {\n                this.game.cache.reloadSound(this.key);\n                this.pendingPlayback = true;\n            }\n            else\n            {\n                if (this._sound && (this.game.device.cocoonJS || this._sound.readyState === 4))\n                {\n                    this._sound.play();\n                    //  This doesn't become available until you call play(), wonderful ...\n                    this.totalDuration = this._sound.duration;\n\n                    if (this.duration === 0)\n                    {\n                        this.duration = this.totalDuration;\n                        this.durationMS = this.totalDuration * 1000;\n                    }\n\n                    this._sound.currentTime = this.position;\n                    this._sound.muted = this._muted;\n\n                    if (this._muted || this.game.sound.mute)\n                    {\n                        this._sound.volume = 0;\n                    }\n                    else\n                    {\n                        this._sound.volume = this._volume;\n                    }\n\n                    this.isPlaying = true;\n                    this.startTime = this.game.time.time;\n                    this.currentTime = 0;\n                    this.stopTime = this.startTime + this.durationMS;\n\n                    this.onPlay.dispatch(this);\n                }\n                else\n                {\n                    this.pendingPlayback = true;\n                }\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Restart the sound, or a marked section of it.\n    *\n    * @method Phaser.Sound#restart\n    * @param {string} [marker=''] - If you want to play a marker then give the key here, otherwise leave blank to play the full sound.\n    * @param {number} [position=0] - The starting position to play the sound from - this is ignored if you provide a marker.\n    * @param {number} [volume=1] - Volume of the sound you want to play.\n    * @param {boolean} [loop=false] - Loop when it finished playing?\n    */\n    restart: function (marker, position, volume, loop) {\n\n        marker = marker || '';\n        position = position || 0;\n        volume = volume || 1;\n        if (loop === undefined) { loop = false; }\n\n        this.play(marker, position, volume, loop, true);\n\n    },\n\n    /**\n    * Pauses the sound.\n    *\n    * @method Phaser.Sound#pause\n    */\n    pause: function () {\n\n        if (this.isPlaying && this._sound)\n        {\n            this.paused = true;\n            this.pausedPosition = this.currentTime;\n            this.pausedTime = this.game.time.time;\n            this._tempPause = this._sound.currentTime;\n            this.onPause.dispatch(this);\n            this.stop();\n        }\n\n    },\n\n    /**\n    * Resumes the sound.\n    *\n    * @method Phaser.Sound#resume\n    */\n    resume: function () {\n\n        if (this.paused && this._sound)\n        {\n            if (this.usingWebAudio)\n            {\n                var p = Math.max(0, this.position + (this.pausedPosition / 1000));\n\n                this._sound = this.context.createBufferSource();\n                this._sound.buffer = this._buffer;\n\n                if (this.externalNode)\n                {\n                    this._sound.connect(this.externalNode);\n                }\n                else\n                {\n                    this._sound.connect(this.gainNode);\n                }\n\n                if (this.loop)\n                {\n                    this._sound.loop = true;\n                }\n\n                if (!this.loop && this.currentMarker === '')\n                {\n                    this._sound.onended = this.onEndedHandler.bind(this);\n                }\n\n                var duration = this.duration - (this.pausedPosition / 1000);\n\n                if (this._sound.start === undefined)\n                {\n                    this._sound.noteGrainOn(0, p, duration);\n                    //this._sound.noteOn(0); // the zero is vitally important, crashes iOS6 without it\n                }\n                else\n                {\n                    if (this.loop && this.game.device.chrome)\n                    {\n                        //  Handle chrome bug: https://code.google.com/p/chromium/issues/detail?id=457099\n                        if (this.game.device.chromeVersion === 42)\n                        {\n                            this._sound.start(0);\n                        }\n                        else\n                        {\n                            this._sound.start(0, p);\n                        }\n                    }\n                    else\n                    {\n                        this._sound.start(0, p, duration);\n                    }\n                }\n            }\n            else\n            {\n                this._sound.currentTime = this._tempPause;\n                this._sound.play();\n            }\n\n            this.isPlaying = true;\n            this.paused = false;\n            this.startTime += (this.game.time.time - this.pausedTime);\n            this.onResume.dispatch(this);\n        }\n\n    },\n\n    /**\n    * Stop playing this sound.\n    *\n    * @method Phaser.Sound#stop\n    */\n    stop: function () {\n\n        if (this.isPlaying && this._sound)\n        {\n            if (this.usingWebAudio)\n            {\n                if (this._sound.stop === undefined)\n                {\n                    this._sound.noteOff(0);\n                }\n                else\n                {\n                    try {\n                        this._sound.stop(0);\n                    }\n                    catch (e)\n                    {\n                        //  Thanks Android 4.4\n                    }\n                }\n\n                if (this.externalNode)\n                {\n                    this._sound.disconnect(this.externalNode);\n                }\n                else if (this.gainNode)\n                {\n                    this._sound.disconnect(this.gainNode);\n                }\n            }\n            else if (this.usingAudioTag)\n            {\n                this._sound.pause();\n                this._sound.currentTime = 0;\n            }\n        }\n\n        this.pendingPlayback = false;\n        this.isPlaying = false;\n\n        if (!this.paused)\n        {\n            var prevMarker = this.currentMarker;\n\n            if (this.currentMarker !== '')\n            {\n                this.onMarkerComplete.dispatch(this.currentMarker, this);\n            }\n\n            this.currentMarker = '';\n\n            if (this.fadeTween !== null)\n            {\n                this.fadeTween.stop();\n            }\n\n            this.onStop.dispatch(this, prevMarker);\n        }\n\n    },\n\n    /**\n    * Starts this sound playing (or restarts it if already doing so) and sets the volume to zero.\n    * Then increases the volume from 0 to 1 over the duration specified.\n    *\n    * At the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter,\n    * and the final volume (1) as the second parameter.\n    *\n    * @method Phaser.Sound#fadeIn\n    * @param {number} [duration=1000] - The time in milliseconds over which the Sound should fade in.\n    * @param {boolean} [loop=false] - Should the Sound be set to loop? Note that this doesn't cause the fade to repeat.\n    * @param {string} [marker=(current marker)] - The marker to start at; defaults to the current (last played) marker. To start playing from the beginning specify specify a marker of `''`.\n    */\n    fadeIn: function (duration, loop, marker) {\n\n        if (loop === undefined) { loop = false; }\n        if (marker === undefined) { marker = this.currentMarker; }\n\n        if (this.paused)\n        {\n            return;\n        }\n\n        this.play(marker, 0, 0, loop);\n\n        this.fadeTo(duration, 1);\n\n    },\n    \n    /**\n    * Decreases the volume of this Sound from its current value to 0 over the duration specified.\n    * At the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter,\n    * and the final volume (0) as the second parameter.\n    *\n    * @method Phaser.Sound#fadeOut\n    * @param {number} [duration=1000] - The time in milliseconds over which the Sound should fade out.\n    */\n    fadeOut: function (duration) {\n\n        this.fadeTo(duration, 0);\n\n    },\n\n    /**\n    * Fades the volume of this Sound from its current value to the given volume over the duration specified.\n    * At the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter, \n    * and the final volume (volume) as the second parameter.\n    *\n    * @method Phaser.Sound#fadeTo\n    * @param {number} [duration=1000] - The time in milliseconds during which the Sound should fade out.\n    * @param {number} [volume] - The volume which the Sound should fade to. This is a value between 0 and 1.\n    */\n    fadeTo: function (duration, volume) {\n\n        if (!this.isPlaying || this.paused || volume === this.volume)\n        {\n            return;\n        }\n\n        if (duration === undefined) { duration = 1000; }\n\n        if (volume === undefined)\n        {\n            console.warn(\"Phaser.Sound.fadeTo: No Volume Specified.\");\n            return;\n        }\n\n        this.fadeTween = this.game.add.tween(this).to( { volume: volume }, duration, Phaser.Easing.Linear.None, true);\n\n        this.fadeTween.onComplete.add(this.fadeComplete, this);\n\n    },\n\n    /**\n    * Internal handler for Sound.fadeIn, Sound.fadeOut and Sound.fadeTo.\n    *\n    * @method Phaser.Sound#fadeComplete\n    * @private\n    */\n    fadeComplete: function () {\n\n        this.onFadeComplete.dispatch(this, this.volume);\n\n        if (this.volume === 0)\n        {\n            this.stop();\n        }\n\n    },\n\n    /**\n    * Called automatically by SoundManager.volume.\n    *\n    * Sets the volume of AudioTag Sounds as a percentage of the Global Volume.\n    *\n    * You should not normally call this directly.\n    *\n    * @method Phaser.Sound#updateGlobalVolume\n    * @protected\n    * @param {float} globalVolume - The global SoundManager volume.\n    */\n    updateGlobalVolume: function (globalVolume) {\n\n        //  this._volume is the % of the global volume this sound should be played at\n\n        if (this.usingAudioTag && this._sound)\n        {\n            this._sound.volume = globalVolume * this._volume;\n        }\n\n    },\n\n    /**\n    * Destroys this sound and all associated events and removes it from the SoundManager.\n    *\n    * @method Phaser.Sound#destroy\n    * @param {boolean} [remove=true] - If true this Sound is automatically removed from the SoundManager.\n    */\n    destroy: function (remove) {\n\n        if (remove === undefined) { remove = true; }\n\n        this.stop();\n\n        if (remove)\n        {\n            this.game.sound.remove(this);\n        }\n        else\n        {\n            this.markers = {};\n            this.context = null;\n            this._buffer = null;\n            this.externalNode = null;\n\n            this.onDecoded.dispose();\n            this.onPlay.dispose();\n            this.onPause.dispose();\n            this.onResume.dispose();\n            this.onLoop.dispose();\n            this.onStop.dispose();\n            this.onMute.dispose();\n            this.onMarkerComplete.dispose();\n        }\n\n    }\n\n};\n\nPhaser.Sound.prototype.constructor = Phaser.Sound;\n\n/**\n* @name Phaser.Sound#isDecoding\n* @property {boolean} isDecoding - Returns true if the sound file is still decoding.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sound.prototype, \"isDecoding\", {\n\n    get: function () {\n        return this.game.cache.getSound(this.key).isDecoding;\n    }\n\n});\n\n/**\n* @name Phaser.Sound#isDecoded\n* @property {boolean} isDecoded - Returns true if the sound file has decoded.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sound.prototype, \"isDecoded\", {\n\n    get: function () {\n        return this.game.cache.isSoundDecoded(this.key);\n    }\n\n});\n\n/**\n* @name Phaser.Sound#mute\n* @property {boolean} mute - Gets or sets the muted state of this sound.\n*/\nObject.defineProperty(Phaser.Sound.prototype, \"mute\", {\n\n    get: function () {\n\n        return (this._muted || this.game.sound.mute);\n\n    },\n\n    set: function (value) {\n\n        value = value || false;\n\n        if (value === this._muted)\n        {\n            return;\n        }\n\n        if (value)\n        {\n            this._muted = true;\n            this._muteVolume = this._tempVolume;\n\n            if (this.usingWebAudio)\n            {\n                this.gainNode.gain.value = 0;\n            }\n            else if (this.usingAudioTag && this._sound)\n            {\n                this._sound.volume = 0;\n            }\n        }\n        else\n        {\n            this._muted = false;\n\n            if (this.usingWebAudio)\n            {\n                this.gainNode.gain.value = this._muteVolume;\n            }\n            else if (this.usingAudioTag && this._sound)\n            {\n                this._sound.volume = this._muteVolume;\n            }\n        }\n\n        this.onMute.dispatch(this);\n\n    }\n\n});\n\n/**\n* @name Phaser.Sound#volume\n* @property {number} volume - Gets or sets the volume of this sound, a value between 0 and 1. The value given is clamped to the range 0 to 1.\n*/\nObject.defineProperty(Phaser.Sound.prototype, \"volume\", {\n\n    get: function () {\n        return this._volume;\n    },\n\n    set: function (value) {\n\n        //  Causes an Index size error in Firefox if you don't clamp the value\n        if (this.game.device.firefox && this.usingAudioTag)\n        {\n            value = this.game.math.clamp(value, 0, 1);\n        }\n\n        if (this._muted)\n        {\n            this._muteVolume = value;\n            return;\n        }\n\n        this._tempVolume = value;\n        this._volume = value;\n\n        if (this.usingWebAudio)\n        {\n            this.gainNode.gain.value = value;\n        }\n        else if (this.usingAudioTag && this._sound)\n        {\n            this._sound.volume = value;\n        }\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Sound Manager is responsible for playing back audio via either the Legacy HTML Audio tag or via Web Audio if the browser supports it.\n* Note: On Firefox 25+ on Linux if you have media.gstreamer disabled in about:config then it cannot play back mp3 or m4a files.\n* The audio file type and the encoding of those files are extremely important. Not all browsers can play all audio formats.\n* There is a good guide to what's supported here: http://hpr.dogphilosophy.net/test/\n*\n* If you are reloading a Phaser Game on a page that never properly refreshes (such as in an AngularJS project) then you will quickly run out\n* of AudioContext nodes. If this is the case create a global var called PhaserGlobal on the window object before creating the game. The active\n* AudioContext will then be saved to window.PhaserGlobal.audioContext when the Phaser game is destroyed, and re-used when it starts again.\n*\n* Mobile warning: There are some mobile devices (certain iPad 2 and iPad Mini revisions) that cannot play 48000 Hz audio.\n* When they try to play the audio becomes extremely distorted and buzzes, eventually crashing the sound system.\n* The solution is to use a lower encoding rate such as 44100 Hz. Sometimes the audio context will\n* be created with a sampleRate of 48000. If this happens and audio distorts you should re-create the context.\n*\n* @class Phaser.SoundManager\n* @constructor\n* @param {Phaser.Game} game - Reference to the current game instance.\n*/\nPhaser.SoundManager = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Signal} onSoundDecode - The event dispatched when a sound decodes (typically only for mp3 files)\n    */\n    this.onSoundDecode = new Phaser.Signal();\n\n    /**\n    * This signal is dispatched whenever the global volume changes. The new volume is passed as the only parameter to your callback.\n    * @property {Phaser.Signal} onVolumeChange\n    */\n    this.onVolumeChange = new Phaser.Signal();\n\n    /**\n    * This signal is dispatched when the SoundManager is globally muted, either directly via game code or as a result of the game pausing.\n    * @property {Phaser.Signal} onMute\n    */\n    this.onMute = new Phaser.Signal();\n\n    /**\n    * This signal is dispatched when the SoundManager is globally un-muted, either directly via game code or as a result of the game resuming from a pause.\n    * @property {Phaser.Signal} onUnMute\n    */\n    this.onUnMute = new Phaser.Signal();\n\n    /**\n    * @property {AudioContext} context - The AudioContext being used for playback.\n    * @default\n    */\n    this.context = null;\n\n    /**\n    * @property {boolean} usingWebAudio - True the SoundManager and device are both using Web Audio.\n    * @readonly\n    */\n    this.usingWebAudio = false;\n\n    /**\n    * @property {boolean} usingAudioTag - True the SoundManager and device are both using the Audio tag instead of Web Audio.\n    * @readonly\n    */\n    this.usingAudioTag = false;\n\n    /**\n    * @property {boolean} noAudio - True if audio been disabled via the PhaserGlobal (useful if you need to use a 3rd party audio library) or the device doesn't support any audio.\n    * @default\n    */\n    this.noAudio = false;\n\n    /**\n    * @property {boolean} connectToMaster - Used in conjunction with Sound.externalNode this allows you to stop a Sound node being connected to the SoundManager master gain node.\n    * @default\n    */\n    this.connectToMaster = true;\n\n    /**\n    * @property {boolean} touchLocked - true if the audio system is currently locked awaiting a touch event.\n    * @default\n    */\n    this.touchLocked = false;\n\n    /**\n    * @property {number} channels - The number of audio channels to use in playback.\n    * @default\n    */\n    this.channels = 32;\n\n    /**\n    * Set to true to have all sound muted when the Phaser game pauses (such as on loss of focus),\n    * or set to false to keep audio playing, regardless of the game pause state. You may need to\n    * do this should you wish to control audio muting via external DOM buttons or similar.\n    * @property {boolean} muteOnPause \n    * @default\n    */\n    this.muteOnPause = true;\n\n    /**\n    * @property {boolean} _codeMuted - Internal mute tracking var.\n    * @private\n    * @default\n    */\n    this._codeMuted = false;\n\n    /**\n    * @property {boolean} _muted - Internal mute tracking var.\n    * @private\n    * @default\n    */\n    this._muted = false;\n\n    /**\n    * @property {AudioContext} _unlockSource - Internal unlock tracking var.\n    * @private\n    * @default\n    */\n    this._unlockSource = null;\n\n    /**\n    * @property {number} _volume - The global audio volume. A value between 0 (silence) and 1 (full volume).\n    * @private\n    * @default\n    */\n    this._volume = 1;\n\n    /**\n    * @property {array} _sounds - An array containing all the sounds\n    * @private\n    */\n    this._sounds = [];\n\n    /**\n    * @property {Phaser.ArraySet} _watchList - An array set containing all the sounds being monitored for decoding status.\n    * @private\n    */\n    this._watchList = new Phaser.ArraySet();\n\n    /**\n    * @property {boolean} _watching - Is the SoundManager monitoring the watchList?\n    * @private\n    */\n    this._watching = false;\n\n    /**\n    * @property {function} _watchCallback - The callback to invoke once the watchlist is clear.\n    * @private\n    */\n    this._watchCallback = null;\n\n    /**\n    * @property {object} _watchContext - The context in which to call the watchlist callback.\n    * @private\n    */\n    this._watchContext = null;\n\n};\n\nPhaser.SoundManager.prototype = {\n\n    /**\n    * Initialises the sound manager.\n    * @method Phaser.SoundManager#boot\n    * @protected\n    */\n    boot: function () {\n\n        if (this.game.device.iOS && this.game.device.webAudio === false)\n        {\n            this.channels = 1;\n        }\n\n        //  PhaserGlobal overrides\n        if (window['PhaserGlobal'])\n        {\n            //  Check to see if all audio playback is disabled (i.e. handled by a 3rd party class)\n            if (window['PhaserGlobal'].disableAudio === true)\n            {\n                this.noAudio = true;\n                this.touchLocked = false;\n                return;\n            }\n\n            //  Check if the Web Audio API is disabled (for testing Audio Tag playback during development)\n            if (window['PhaserGlobal'].disableWebAudio === true)\n            {\n                this.usingAudioTag = true;\n                this.touchLocked = false;\n                return;\n            }\n        }\n\n        if (window['PhaserGlobal'] && window['PhaserGlobal'].audioContext)\n        {\n            this.context = window['PhaserGlobal'].audioContext;\n        }\n        else\n        {\n            if (!!window['AudioContext'])\n            {\n                try {\n                    this.context = new window['AudioContext']();\n                } catch (error) {\n                    this.context = null;\n                    this.usingWebAudio = false;\n                    this.touchLocked = false;\n                }\n            }\n            else if (!!window['webkitAudioContext'])\n            {\n                try {\n                    this.context = new window['webkitAudioContext']();\n                } catch (error) {\n                    this.context = null;\n                    this.usingWebAudio = false;\n                    this.touchLocked = false;\n                }\n            }\n        }\n\n        if (this.context === null)\n        {\n            //  No Web Audio support - how about legacy Audio?\n            if (window['Audio'] === undefined)\n            {\n                this.noAudio = true;\n                return;\n            }\n            else\n            {\n                this.usingAudioTag = true;\n            }\n        }\n        else\n        {\n            this.usingWebAudio = true;\n\n            if (this.context.createGain === undefined)\n            {\n                this.masterGain = this.context.createGainNode();\n            }\n            else\n            {\n                this.masterGain = this.context.createGain();\n            }\n\n            this.masterGain.gain.value = 1;\n            this.masterGain.connect(this.context.destination);\n        }\n\n        if (!this.noAudio)\n        {\n            //  On mobile we need a native touch event before we can play anything, so capture it here\n            if (!this.game.device.cocoonJS && this.game.device.iOS || (window['PhaserGlobal'] && window['PhaserGlobal'].fakeiOSTouchLock))\n            {\n                this.setTouchLock();\n            }\n        }\n\n    },\n\n    /**\n    * Sets the Input Manager touch callback to be SoundManager.unlock.\n    * Required for iOS audio device unlocking. Mostly just used internally.\n    *\n    * @method Phaser.SoundManager#setTouchLock\n    */\n    setTouchLock: function () {\n\n        if (this.noAudio || (window['PhaserGlobal'] && window['PhaserGlobal'].disableAudio === true))\n        {\n            return;\n        }\n\n        if (this.game.device.iOSVersion > 8)\n        {\n            this.game.input.touch.addTouchLockCallback(this.unlock, this, true);\n        }\n        else\n        {\n            this.game.input.touch.addTouchLockCallback(this.unlock, this);\n        }\n\n        this.touchLocked = true;\n\n    },\n\n    /**\n    * Enables the audio, usually after the first touch.\n    *\n    * @method Phaser.SoundManager#unlock\n    * @return {boolean} True if the callback should be removed, otherwise false.\n    */\n    unlock: function () {\n\n        if (this.noAudio || !this.touchLocked || this._unlockSource !== null)\n        {\n            return true;\n        }\n\n        //  Global override (mostly for Audio Tag testing)\n        if (this.usingAudioTag)\n        {\n            this.touchLocked = false;\n            this._unlockSource = null;\n        }\n        else if (this.usingWebAudio)\n        {\n            // Create empty buffer and play it\n            // The SoundManager.update loop captures the state of it and then resets touchLocked to false\n\n            var buffer = this.context.createBuffer(1, 1, 22050);\n            this._unlockSource = this.context.createBufferSource();\n            this._unlockSource.buffer = buffer;\n            this._unlockSource.connect(this.context.destination);\n\n            if (this._unlockSource.start === undefined)\n            {\n                this._unlockSource.noteOn(0);\n            }\n            else\n            {\n                this._unlockSource.start(0);\n            }\n        }\n\n        //  We can remove the event because we've done what we needed (started the unlock sound playing)\n        return true;\n\n    },\n\n    /**\n    * Stops all the sounds in the game.\n    *\n    * @method Phaser.SoundManager#stopAll\n    */\n    stopAll: function () {\n\n        if (this.noAudio)\n        {\n            return;\n        }\n\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i])\n            {\n                this._sounds[i].stop();\n            }\n        }\n\n    },\n\n    /**\n    * Pauses all the sounds in the game.\n    *\n    * @method Phaser.SoundManager#pauseAll\n    */\n    pauseAll: function () {\n\n        if (this.noAudio)\n        {\n            return;\n        }\n\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i])\n            {\n                this._sounds[i].pause();\n            }\n        }\n\n    },\n\n    /**\n    * Resumes every sound in the game.\n    *\n    * @method Phaser.SoundManager#resumeAll\n    */\n    resumeAll: function () {\n\n        if (this.noAudio)\n        {\n            return;\n        }\n\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i])\n            {\n                this._sounds[i].resume();\n            }\n        }\n\n    },\n\n    /**\n    * Decode a sound by its asset key.\n    *\n    * @method Phaser.SoundManager#decode\n    * @param {string} key - Assets key of the sound to be decoded.\n    * @param {Phaser.Sound} [sound] - Its buffer will be set to decoded data.\n    */\n    decode: function (key, sound) {\n\n        sound = sound || null;\n\n        var soundData = this.game.cache.getSoundData(key);\n\n        if (soundData)\n        {\n            if (this.game.cache.isSoundDecoded(key) === false)\n            {\n                this.game.cache.updateSound(key, 'isDecoding', true);\n\n                var _this = this;\n\n                try {\n                    this.context.decodeAudioData(soundData, function (buffer) {\n\n                        if (buffer)\n                        {\n                            _this.game.cache.decodedSound(key, buffer);\n                            _this.onSoundDecode.dispatch(key, sound);\n                        }\n                    });\n                }\n                catch (e) {}\n            }\n        }\n\n    },\n\n    /**\n     * This method allows you to give the SoundManager a list of Sound files, or keys, and a callback.\n     * Once all of the Sound files have finished decoding the callback will be invoked.\n     * The amount of time spent decoding depends on the codec used and file size.\n     * If all of the files given have already decoded the callback is triggered immediately.\n     *\n     * @method Phaser.SoundManager#setDecodedCallback\n     * @param {string|array} files - An array containing either Phaser.Sound objects or their key strings as found in the Phaser.Cache.\n     * @param {Function} callback - The callback which will be invoked once all files have finished decoding.\n     * @param {Object} callbackContext - The context in which the callback will run.\n     */\n    setDecodedCallback: function (files, callback, callbackContext) {\n\n        if (typeof files === 'string')\n        {\n            files = [ files ];\n        }\n\n        this._watchList.reset();\n\n        for (var i = 0; i < files.length; i++)\n        {\n            if (files[i] instanceof Phaser.Sound)\n            {\n                if (!this.game.cache.isSoundDecoded(files[i].key))\n                {\n                    this._watchList.add(files[i].key);\n                }\n            }\n            else if (!this.game.cache.isSoundDecoded(files[i]))\n            {\n                this._watchList.add(files[i]);\n            }\n        }\n\n        //  All decoded already?\n        if (this._watchList.total === 0)\n        {\n            this._watching = false;\n            callback.call(callbackContext);\n        }\n        else\n        {\n            this._watching = true;\n            this._watchCallback = callback;\n            this._watchContext = callbackContext;\n        }\n\n    },\n\n    /**\n    * Updates every sound in the game, checks for audio unlock on mobile and monitors the decoding watch list.\n    *\n    * @method Phaser.SoundManager#update\n    * @protected\n    */\n    update: function () {\n\n        if (this.noAudio)\n        {\n            return;\n        }\n\n        if (this.touchLocked && this._unlockSource !== null && (this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE))\n        {\n            this.touchLocked = false;\n            this._unlockSource = null;\n        }\n\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            this._sounds[i].update();\n        }\n\n        if (this._watching)\n        {\n            var key = this._watchList.first;\n\n            while (key)\n            {\n                if (this.game.cache.isSoundDecoded(key))\n                {\n                    this._watchList.remove(key);\n                }\n\n                key = this._watchList.next;\n            }\n\n            if (this._watchList.total === 0)\n            {\n                this._watching = false;\n                this._watchCallback.call(this._watchContext);\n            }\n        }\n\n    },\n\n    /**\n    * Adds a new Sound into the SoundManager.\n    *\n    * @method Phaser.SoundManager#add\n    * @param {string} key - Asset key for the sound.\n    * @param {number} [volume=1] - Default value for the volume.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The new sound instance.\n    */\n    add: function (key, volume, loop, connect) {\n\n        if (volume === undefined) { volume = 1; }\n        if (loop === undefined) { loop = false; }\n        if (connect === undefined) { connect = this.connectToMaster; }\n\n        var sound = new Phaser.Sound(this.game, key, volume, loop, connect);\n\n        this._sounds.push(sound);\n\n        return sound;\n\n    },\n\n    /**\n     * Adds a new AudioSprite into the SoundManager.\n     *\n     * @method Phaser.SoundManager#addSprite\n     * @param {string} key - Asset key for the sound.\n     * @return {Phaser.AudioSprite} The new AudioSprite instance.\n     */\n    addSprite: function(key) {\n\n        var audioSprite = new Phaser.AudioSprite(this.game, key);\n\n        return audioSprite;\n\n    },\n\n    /**\n    * Removes a Sound from the SoundManager. The removed Sound is destroyed before removal.\n    *\n    * @method Phaser.SoundManager#remove\n    * @param {Phaser.Sound} sound - The sound object to remove.\n    * @return {boolean} True if the sound was removed successfully, otherwise false.\n    */\n    remove: function (sound) {\n\n        var i = this._sounds.length;\n\n        while (i--)\n        {\n            if (this._sounds[i] === sound)\n            {\n                this._sounds[i].destroy(false);\n                this._sounds.splice(i, 1);\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Removes all Sounds from the SoundManager that have an asset key matching the given value.\n    * The removed Sounds are destroyed before removal.\n    *\n    * @method Phaser.SoundManager#removeByKey\n    * @param {string} key - The key to match when removing sound objects.\n    * @return {number} The number of matching sound objects that were removed.\n    */\n    removeByKey: function (key) {\n\n        var i = this._sounds.length;\n        var removed = 0;\n\n        while (i--)\n        {\n            if (this._sounds[i].key === key)\n            {\n                this._sounds[i].destroy(false);\n                this._sounds.splice(i, 1);\n                removed++;\n            }\n        }\n\n        return removed;\n\n    },\n\n    /**\n    * Adds a new Sound into the SoundManager and starts it playing.\n    *\n    * @method Phaser.SoundManager#play\n    * @param {string} key - Asset key for the sound.\n    * @param {number} [volume=1] - Default value for the volume.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @return {Phaser.Sound} The new sound instance.\n    */\n    play: function (key, volume, loop) {\n\n        if (this.noAudio)\n        {\n            return;\n        }\n\n        var sound = this.add(key, volume, loop);\n\n        sound.play();\n\n        return sound;\n\n    },\n\n    /**\n    * Internal mute handler called automatically by the SoundManager.mute setter.\n    *\n    * @method Phaser.SoundManager#setMute\n    * @private\n    */\n    setMute: function () {\n\n        if (this._muted)\n        {\n            return;\n        }\n\n        this._muted = true;\n\n        if (this.usingWebAudio)\n        {\n            this._muteVolume = this.masterGain.gain.value;\n            this.masterGain.gain.value = 0;\n        }\n\n        //  Loop through sounds\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i].usingAudioTag)\n            {\n                this._sounds[i].mute = true;\n            }\n        }\n\n        this.onMute.dispatch();\n\n    },\n\n    /**\n    * Internal mute handler called automatically by the SoundManager.mute setter.\n    *\n    * @method Phaser.SoundManager#unsetMute\n    * @private\n    */\n    unsetMute: function () {\n\n        if (!this._muted || this._codeMuted)\n        {\n            return;\n        }\n\n        this._muted = false;\n\n        if (this.usingWebAudio)\n        {\n            this.masterGain.gain.value = this._muteVolume;\n        }\n\n        //  Loop through sounds\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i].usingAudioTag)\n            {\n                this._sounds[i].mute = false;\n            }\n        }\n\n        this.onUnMute.dispatch();\n\n    },\n\n    /**\n    * Stops all the sounds in the game, then destroys them and finally clears up any callbacks.\n    *\n    * @method Phaser.SoundManager#destroy\n    */\n    destroy: function () {\n\n        this.stopAll();\n\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i])\n            {\n                this._sounds[i].destroy();\n            }\n        }\n\n        this._sounds = [];\n\n        this.onSoundDecode.dispose();\n\n        if (this.context)\n        {\n            if (window['PhaserGlobal'])\n            {\n                //  Store this in the PhaserGlobal window var, if set, to allow for re-use if the game is created again without the page refreshing\n                window['PhaserGlobal'].audioContext = this.context;\n            }\n            else\n            {\n                if (this.context.close)\n                {\n                    this.context.close();\n                }\n            }\n        }\n\n    }\n\n};\n\nPhaser.SoundManager.prototype.constructor = Phaser.SoundManager;\n\n/**\n* @name Phaser.SoundManager#mute\n* @property {boolean} mute - Gets or sets the muted state of the SoundManager. This effects all sounds in the game.\n*/\nObject.defineProperty(Phaser.SoundManager.prototype, \"mute\", {\n\n    get: function () {\n\n        return this._muted;\n\n    },\n\n    set: function (value) {\n\n        value = value || false;\n\n        if (value)\n        {\n            if (this._muted)\n            {\n                return;\n            }\n\n            this._codeMuted = true;\n            this.setMute();\n        }\n        else\n        {\n            if (!this._muted)\n            {\n                return;\n            }\n\n            this._codeMuted = false;\n            this.unsetMute();\n        }\n    }\n\n});\n\n/**\n* @name Phaser.SoundManager#volume\n* @property {number} volume - Gets or sets the global volume of the SoundManager, a value between 0 and 1. The value given is clamped to the range 0 to 1.\n*/\nObject.defineProperty(Phaser.SoundManager.prototype, \"volume\", {\n\n    get: function () {\n\n        return this._volume;\n\n    },\n\n    set: function (value) {\n\n        if (value < 0)\n        {\n            value = 0;\n        }\n        else if (value > 1)\n        {\n            value = 1;\n        }\n\n        if (this._volume !== value)\n        {\n            this._volume = value;\n\n            if (this.usingWebAudio)\n            {\n                this.masterGain.gain.value = value;\n            }\n            else\n            {\n                //  Loop through the sound cache and change the volume of all html audio tags\n                for (var i = 0; i < this._sounds.length; i++)\n                {\n                    if (this._sounds[i].usingAudioTag)\n                    {\n                        this._sounds[i].updateGlobalVolume(value);\n                    }\n                }\n            }\n\n            this.onVolumeChange.dispatch(value);\n        }\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @classdesc\n* The ScaleManager object handles the the scaling, resizing, and alignment of the\n* Game size and the game Display canvas.\n*\n* The Game size is the logical size of the game; the Display canvas has size as an HTML element.\n*\n* The calculations of these are heavily influenced by the bounding Parent size which is the computed\n* dimensions of the Display canvas's Parent container/element - the _effective CSS rules of the\n* canvas's Parent element play an important role_ in the operation of the ScaleManager. \n*\n* The Display canvas - or Game size, depending {@link #scaleMode} - is updated to best utilize the Parent size.\n* When in Fullscreen mode or with {@link #parentIsWindow} the Parent size is that of the visual viewport (see {@link Phaser.ScaleManager#getParentBounds getParentBounds}).\n*\n* Parent and Display canvas containment guidelines:\n*\n* - Style the Parent element (of the game canvas) to control the Parent size and\n*   thus the Display canvas's size and layout.\n*\n* - The Parent element's CSS styles should _effectively_ apply maximum (and minimum) bounding behavior.\n*\n* - The Parent element should _not_ apply a padding as this is not accounted for.\n*   If a padding is required apply it to the Parent's parent or apply a margin to the Parent.\n*   If you need to add a border, margin or any other CSS around your game container, then use a parent element and\n*   apply the CSS to this instead, otherwise you'll be constantly resizing the shape of the game container.\n*\n* - The Display canvas layout CSS styles (i.e. margins, size) should not be altered/specified as\n*   they may be updated by the ScaleManager.\n*\n* @description\n* Create a new ScaleManager object - this is done automatically by {@link Phaser.Game}\n*\n* The `width` and `height` constructor parameters can either be a number which represents pixels or a string that represents a percentage: e.g. `800` (for 800 pixels) or `\"80%\"` for 80%.\n*\n* @class\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number|string} width - The width of the game. See above.\n* @param {number|string} height - The height of the game. See above.\n*/\nPhaser.ScaleManager = function (game, width, height) {\n\n    /**\n    * A reference to the currently running game.\n    * @property {Phaser.Game} game\n    * @protected\n    * @readonly\n    */\n    this.game = game;\n\n    /**\n    * Provides access to some cross-device DOM functions.\n    * @property {Phaser.DOM} dom\n    * @protected\n    * @readonly\n    */\n    this.dom = Phaser.DOM;\n\n    /**\n    * _EXPERIMENTAL:_ A responsive grid on which you can align game objects.\n    * @property {Phaser.FlexGrid} grid\n    * @public\n    */\n    this.grid = null;\n\n    /**\n    * Target width (in pixels) of the Display canvas.\n    * @property {number} width\n    * @readonly\n    */\n    this.width = 0;\n\n    /**\n    * Target height (in pixels) of the Display canvas.\n    * @property {number} height\n    * @readonly\n    */\n    this.height = 0;\n\n    /**\n    * Minimum width the canvas should be scaled to (in pixels).\n    * Change with {@link #setMinMax}.\n    * @property {?number} minWidth\n    * @readonly\n    * @protected\n    */\n    this.minWidth = null;\n\n    /**\n    * Maximum width the canvas should be scaled to (in pixels).\n    * If null it will scale to whatever width the browser can handle.\n    * Change with {@link #setMinMax}.\n    * @property {?number} maxWidth\n    * @readonly\n    * @protected\n    */\n    this.maxWidth = null;\n\n    /**\n    * Minimum height the canvas should be scaled to (in pixels).\n    * Change with {@link #setMinMax}.\n    * @property {?number} minHeight\n    * @readonly\n    * @protected\n    */\n    this.minHeight = null;\n\n    /**\n    * Maximum height the canvas should be scaled to (in pixels).\n    * If null it will scale to whatever height the browser can handle.\n    * Change with {@link #setMinMax}.\n    * @property {?number} maxHeight\n    * @readonly\n    * @protected\n    */\n    this.maxHeight = null;\n\n    /**\n    * The offset coordinates of the Display canvas from the top-left of the browser window.\n    * The is used internally by Phaser.Pointer (for Input) and possibly other types.\n    * @property {Phaser.Point} offset\n    * @readonly\n    * @protected\n    */\n    this.offset = new Phaser.Point();\n\n    /**\n    * If true, the game should only run in a landscape orientation.\n    * Change with {@link #forceOrientation}.\n    * @property {boolean} forceLandscape\n    * @readonly\n    * @default\n    * @protected\n    */\n    this.forceLandscape = false;\n\n    /**\n    * If true, the game should only run in a portrait \n    * Change with {@link #forceOrientation}.\n    * @property {boolean} forcePortrait\n    * @readonly\n    * @default\n    * @protected\n    */\n    this.forcePortrait = false;\n\n    /**\n    * True if {@link #forceLandscape} or {@link #forcePortrait} are set and do not agree with the browser orientation.\n    *\n    * This value is not updated immediately.\n    *\n    * @property {boolean} incorrectOrientation    \n    * @readonly\n    * @protected\n    */\n    this.incorrectOrientation = false;\n\n    /**\n    * See {@link #pageAlignHorizontally}.\n    * @property {boolean} _pageAlignHorizontally\n    * @private\n    */\n    this._pageAlignHorizontally = false;\n\n    /**\n    * See {@link #pageAlignVertically}.\n    * @property {boolean} _pageAlignVertically\n    * @private\n    */\n    this._pageAlignVertically = false;\n\n    /**\n    * This signal is dispatched when the orientation changes _or_ the validity of the current orientation changes.\n    * \n    * The signal is supplied with the following arguments:\n    * - `scale` - the ScaleManager object\n    * - `prevOrientation`, a string - The previous orientation as per {@link Phaser.ScaleManager#screenOrientation screenOrientation}.\n    * - `wasIncorrect`, a boolean - True if the previous orientation was last determined to be incorrect.\n    *\n    * Access the current orientation and validity with `scale.screenOrientation` and `scale.incorrectOrientation`.\n    * Thus the following tests can be done:\n    *\n    *     // The orientation itself changed:\n    *     scale.screenOrientation !== prevOrientation\n    *     // The orientation just became incorrect:\n    *     scale.incorrectOrientation && !wasIncorrect\n    *\n    * It is possible that this signal is triggered after {@link #forceOrientation} so the orientation\n    * correctness changes even if the orientation itself does not change.\n    *\n    * This is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.\n    *\n    * @property {Phaser.Signal} onOrientationChange\n    * @public\n    */\n    this.onOrientationChange = new Phaser.Signal();\n\n    /**\n    * This signal is dispatched when the browser enters an incorrect orientation, as defined by {@link #forceOrientation}.\n    *\n    * This is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.\n    *\n    * @property {Phaser.Signal} enterIncorrectOrientation\n    * @public\n    */\n    this.enterIncorrectOrientation = new Phaser.Signal();\n\n    /**\n    * This signal is dispatched when the browser leaves an incorrect orientation, as defined by {@link #forceOrientation}.\n    *\n    * This is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.\n    *\n    * @property {Phaser.Signal} leaveIncorrectOrientation\n    * @public\n    */\n    this.leaveIncorrectOrientation = new Phaser.Signal();\n\n    /**\n    * This boolean provides you with a way to determine if the browser is in Full Screen\n    * mode (via the Full Screen API), and Phaser was the one responsible for activating it.\n    *\n    * It's possible that ScaleManager.isFullScreen returns `true` even if Phaser wasn't the\n    * one that made the browser go full-screen, so this flag lets you determine that.\n    * \n    * @property {boolean} hasPhaserSetFullScreen\n    * @default\n    */\n    this.hasPhaserSetFullScreen = false;\n\n    /**\n    * If specified, this is the DOM element on which the Fullscreen API enter request will be invoked.\n    * The target element must have the correct CSS styling and contain the Display canvas.\n    *\n    * The elements style will be modified (ie. the width and height might be set to 100%)\n    * but it will not be added to, removed from, or repositioned within the DOM.\n    * An attempt is made to restore relevant style changes when fullscreen mode is left.\n    *\n    * For pre-2.2.0 behavior set `game.scale.fullScreenTarget = game.canvas`.\n    *\n    * @property {?DOMElement} fullScreenTarget\n    * @default\n    */\n    this.fullScreenTarget = null;\n\n    /**\n    * The fullscreen target, as created by {@link #createFullScreenTarget}.\n    * This is not set if {@link #fullScreenTarget} is used and is cleared when fullscreen mode ends.\n    * @property {?DOMElement} _createdFullScreenTarget\n    * @private\n    */\n    this._createdFullScreenTarget = null;\n\n    /**\n    * This signal is dispatched when fullscreen mode is ready to be initialized but\n    * before the fullscreen request.\n    *\n    * The signal is passed two arguments: `scale` (the ScaleManager), and an object in the form `{targetElement: DOMElement}`.\n    *\n    * The `targetElement` is the {@link #fullScreenTarget} element,\n    * if such is assigned, or a new element created by {@link #createFullScreenTarget}.\n    *\n    * Custom CSS styling or resets can be applied to `targetElement` as required.\n    *\n    * If `targetElement` is _not_ the same element as {@link #fullScreenTarget}:\n    * - After initialization the Display canvas is moved onto the `targetElement` for\n    *   the duration of the fullscreen mode, and restored to it's original DOM location when fullscreen is exited.\n    * - The `targetElement` is moved/re-parented within the DOM and may have its CSS styles updated.\n    *\n    * The behavior of a pre-assigned target element is covered in {@link Phaser.ScaleManager#fullScreenTarget fullScreenTarget}.\n    *\n    * @property {Phaser.Signal} onFullScreenInit\n    * @public\n    */\n    this.onFullScreenInit = new Phaser.Signal();\n\n    /**\n    * This signal is dispatched when the browser enters or leaves fullscreen mode, if supported.\n    *\n    * The signal is supplied with a single argument: `scale` (the ScaleManager). Use `scale.isFullScreen` to determine\n    * if currently running in Fullscreen mode.\n    *\n    * @property {Phaser.Signal} onFullScreenChange\n    * @public    \n    */\n    this.onFullScreenChange = new Phaser.Signal();\n\n    /**\n    * This signal is dispatched when the browser fails to enter fullscreen mode;\n    * or if the device does not support fullscreen mode and `startFullScreen` is invoked.\n    *\n    * The signal is supplied with a single argument: `scale` (the ScaleManager).\n    *\n    * @property {Phaser.Signal} onFullScreenError\n    * @public\n    */\n    this.onFullScreenError = new Phaser.Signal();\n\n    /**\n    * The _last known_ orientation of the screen, as defined in the Window Screen Web API.\n    * See {@link Phaser.DOM.getScreenOrientation} for possible values.\n    *\n    * @property {string} screenOrientation\n    * @readonly\n    * @public\n    */\n    this.screenOrientation = this.dom.getScreenOrientation();\n\n    /**\n    * The _current_ scale factor based on the game dimensions vs. the scaled dimensions.\n    * @property {Phaser.Point} scaleFactor\n    * @readonly\n    */\n    this.scaleFactor = new Phaser.Point(1, 1);\n\n    /**\n    * The _current_ inversed scale factor. The displayed dimensions divided by the game dimensions.\n    * @property {Phaser.Point} scaleFactorInversed\n    * @readonly\n    * @protected\n    */\n    this.scaleFactorInversed = new Phaser.Point(1, 1);\n\n    /**\n    * The Display canvas is aligned by adjusting the margins; the last margins are stored here.\n    *\n    * @property {Bounds-like} margin\n    * @readonly\n    * @protected\n    */\n    this.margin = {left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0};\n\n    /**\n    * The bounds of the scaled game. The x/y will match the offset of the canvas element and the width/height the scaled width and height.\n    * @property {Phaser.Rectangle} bounds\n    * @readonly\n    */\n    this.bounds = new Phaser.Rectangle();\n\n    /**\n    * The aspect ratio of the scaled Display canvas.\n    * @property {number} aspectRatio\n    * @readonly\n    */\n    this.aspectRatio = 0;\n\n    /**\n    * The aspect ratio of the original game dimensions.\n    * @property {number} sourceAspectRatio\n    * @readonly\n    */\n    this.sourceAspectRatio = 0;\n\n    /**\n    * The native browser events from Fullscreen API changes.\n    * @property {any} event\n    * @readonly\n    * @private\n    */\n    this.event = null;\n\n    /**\n    * The edges on which to constrain the game Display/canvas in _addition_ to the restrictions of the parent container.\n    *\n    * The properties are strings and can be '', 'visual', 'layout', or 'layout-soft'.\n    * - If 'visual', the edge will be constrained to the Window / displayed screen area\n    * - If 'layout', the edge will be constrained to the CSS Layout bounds\n    * - An invalid value is treated as 'visual'\n    *\n    * @member\n    * @property {string} bottom\n    * @property {string} right\n    * @default\n    */\n    this.windowConstraints = {\n        right: 'layout',\n        bottom: ''\n    };\n\n    /**\n    * Various compatibility settings.\n    * A value of \"(auto)\" indicates the setting is configured based on device and runtime information.\n    *\n    * A {@link #refresh} may need to be performed after making changes.\n    *\n    * @protected\n    * \n    * @property {boolean} [supportsFullScreen=(auto)] - True only if fullscreen support will be used. (Changing to fullscreen still might not work.)\n    *\n    * @property {boolean} [orientationFallback=(auto)] - See {@link Phaser.DOM.getScreenOrientation}.\n    *\n    * @property {boolean} [noMargins=false] - If true then the Display canvas's margins will not be updated anymore: existing margins must be manually cleared. Disabling margins prevents automatic canvas alignment/centering, possibly in fullscreen.\n    *\n    * @property {?Phaser.Point} [scrollTo=(auto)] - If specified the window will be scrolled to this position on every refresh.\n    *\n    * @property {boolean} [forceMinimumDocumentHeight=false] - If enabled the document elements minimum height is explicitly set on updates.\n    *    The height set varies by device and may either be the height of the window or the viewport.\n    *\n    * @property {boolean} [canExpandParent=true] - If enabled then SHOW_ALL and USER_SCALE modes can try and expand the parent element. It may be necessary for the parent element to impose CSS width/height restrictions.\n    *\n    * @property {string} [clickTrampoline=(auto)] - On certain browsers (eg. IE) FullScreen events need to be triggered via 'click' events.\n    *     A value of 'when-not-mouse' uses a click trampoline when a pointer that is not the primary mouse is used.\n    *     Any other string value (including the empty string) prevents using click trampolines.\n    *     For more details on click trampolines see {@link Phaser.Pointer#addClickTrampoline}.\n    */\n    this.compatibility = {\n        supportsFullScreen: false,\n        orientationFallback: null,\n        noMargins: false,\n        scrollTo: null,\n        forceMinimumDocumentHeight: false,\n        canExpandParent: true,\n        clickTrampoline: ''\n    };\n\n    /**\n    * Scale mode to be used when not in fullscreen.\n    * @property {number} _scaleMode\n    * @private\n    */\n    this._scaleMode = Phaser.ScaleManager.NO_SCALE;\n\n    /*\n    * Scale mode to be used in fullscreen.\n    * @property {number} _fullScreenScaleMode\n    * @private\n    */\n    this._fullScreenScaleMode = Phaser.ScaleManager.NO_SCALE;\n\n    /**\n    * If the parent container of the Game canvas is the browser window itself (i.e. document.body),\n    * rather than another div, this should set to `true`.\n    *\n    * The {@link #parentNode} property is generally ignored while this is in effect.\n    *\n    * @property {boolean} parentIsWindow\n    */\n    this.parentIsWindow = false;\n\n    /**\n    * The _original_ DOM element for the parent of the Display canvas.\n    * This may be different in fullscreen - see {@link #createFullScreenTarget}.\n    *\n    * This should only be changed after moving the Game canvas to a different DOM parent.\n    *\n    * @property {?DOMElement} parentNode\n    */\n    this.parentNode = null;\n\n    /**\n    * The scale of the game in relation to its parent container.\n    * @property {Phaser.Point} parentScaleFactor\n    * @readonly\n    */\n    this.parentScaleFactor = new Phaser.Point(1, 1);\n\n    /**\n    * The maximum time (in ms) between dimension update checks for the Canvas's parent element (or window).\n    * Update checks normally happen quicker in response to other events.\n    *\n    * @property {integer} trackParentInterval\n    * @default\n    * @protected\n    * @see {@link Phaser.ScaleManager#refresh refresh}\n    */\n    this.trackParentInterval = 2000;\n\n    /**\n    * This signal is dispatched when the size of the Display canvas changes _or_ the size of the Game changes. \n    * When invoked this is done _after_ the Canvas size/position have been updated.\n    *\n    * This signal is _only_ called when a change occurs and a reflow may be required.\n    * For example, if the canvas does not change sizes because of CSS settings (such as min-width)\n    * then this signal will _not_ be triggered.\n    *\n    * Use this to handle responsive game layout options.\n    *\n    * This is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.\n    *\n    * @property {Phaser.Signal} onSizeChange\n    * @todo Formalize the arguments, if any, supplied to this signal.\n    */\n    this.onSizeChange = new Phaser.Signal();\n\n    /**\n    * The callback that will be called each the parent container resizes.\n    * @property {function} onResize\n    * @private\n    */\n    this.onResize = null;\n\n    /**\n    * The context in which the {@link #onResize} callback will be called.\n    * @property {object} onResizeContext\n    * @private\n    */\n    this.onResizeContext = null;\n\n    /**\n    * @property {integer} _pendingScaleMode - Used to retain the scale mode if set from config before Boot.\n    * @private\n    */\n    this._pendingScaleMode = null;\n\n    /**\n    * Information saved when fullscreen mode is started.\n    * @property {?object} _fullScreenRestore\n    * @private\n    */\n    this._fullScreenRestore = null;\n\n    /**\n    * The _actual_ game dimensions, as initially set or set by {@link #setGameSize}.\n    * @property {Phaser.Rectangle} _gameSize\n    * @private\n    */\n    this._gameSize = new Phaser.Rectangle();\n\n    /**\n    * The user-supplied scale factor, used with the USER_SCALE scaling mode.\n    * @property {Phaser.Point} _userScaleFactor\n    * @private\n    */\n    this._userScaleFactor = new Phaser.Point(1, 1);\n\n    /**\n    * The user-supplied scale trim, used with the USER_SCALE scaling mode.\n    * @property {Phaser.Point} _userScaleTrim\n    * @private\n    */\n    this._userScaleTrim = new Phaser.Point(0, 0);\n\n    /**\n    * The last time the bounds were checked in `preUpdate`.\n    * @property {number} _lastUpdate\n    * @private\n    */\n    this._lastUpdate = 0;\n\n    /**\n    * Size checks updates are delayed according to the throttle.\n    * The throttle increases to `trackParentInterval` over time and is used to more\n    * rapidly detect changes in certain browsers (eg. IE) while providing back-off safety.\n    * @property {integer} _updateThrottle\n    * @private\n    */\n    this._updateThrottle = 0;\n\n    /**\n    * The minimum throttle allowed until it has slowed down sufficiently.\n    * @property {integer} _updateThrottleReset   \n    * @private\n    */\n    this._updateThrottleReset = 100;\n\n    /**\n    * The cached result of the parent (possibly window) bounds; used to invalidate sizing.\n    * @property {Phaser.Rectangle} _parentBounds\n    * @private\n    */\n    this._parentBounds = new Phaser.Rectangle();\n\n    /**\n    * Temporary bounds used for internal work to cut down on new objects created.\n    * @property {Phaser.Rectangle} _parentBounds\n    * @private\n    */\n    this._tempBounds = new Phaser.Rectangle();\n\n    /**\n    * The Canvas size at which the last onSizeChange signal was triggered.\n    * @property {Phaser.Rectangle} _lastReportedCanvasSize\n    * @private\n    */\n    this._lastReportedCanvasSize = new Phaser.Rectangle();\n\n    /**\n    * The Game size at which the last onSizeChange signal was triggered.\n    * @property {Phaser.Rectangle} _lastReportedGameSize\n    * @private\n    */\n    this._lastReportedGameSize = new Phaser.Rectangle();\n\n    /**\n    * @property {boolean} _booted - ScaleManager booted state.\n    * @private\n    */\n    this._booted = false;\n\n    if (game.config)\n    {\n        this.parseConfig(game.config);\n    }\n\n    this.setupScale(width, height);\n\n};\n\n/**\n* A scale mode that stretches content to fill all available space - see {@link Phaser.ScaleManager#scaleMode scaleMode}.\n*\n* @constant\n* @type {integer}\n*/\nPhaser.ScaleManager.EXACT_FIT = 0;\n\n/**\n* A scale mode that prevents any scaling - see {@link Phaser.ScaleManager#scaleMode scaleMode}.\n*\n* @constant\n* @type {integer}\n*/\nPhaser.ScaleManager.NO_SCALE = 1;\n\n/**\n* A scale mode that shows the entire game while maintaining proportions - see {@link Phaser.ScaleManager#scaleMode scaleMode}.\n*\n* @constant\n* @type {integer}\n*/\nPhaser.ScaleManager.SHOW_ALL = 2;\n\n/**\n* A scale mode that causes the Game size to change - see {@link Phaser.ScaleManager#scaleMode scaleMode}.\n*\n* @constant\n* @type {integer}\n*/\nPhaser.ScaleManager.RESIZE = 3;\n\n/**\n* A scale mode that allows a custom scale factor - see {@link Phaser.ScaleManager#scaleMode scaleMode}.\n*\n* @constant\n* @type {integer}\n*/\nPhaser.ScaleManager.USER_SCALE = 4;\n\nPhaser.ScaleManager.prototype = {\n\n    /**\n    * Start the ScaleManager.\n    * \n    * @method Phaser.ScaleManager#boot\n    * @protected\n    */\n    boot: function () {\n\n        // Configure device-dependent compatibility\n\n        var compat = this.compatibility;\n        \n        compat.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS;\n\n        //  We can't do anything about the status bars in iPads, web apps or desktops\n        if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop)\n        {\n            if (this.game.device.android && !this.game.device.chrome)\n            {\n                compat.scrollTo = new Phaser.Point(0, 1);\n            }\n            else\n            {\n                compat.scrollTo = new Phaser.Point(0, 0);\n            }\n        }\n\n        if (this.game.device.desktop)\n        {\n            compat.orientationFallback = 'screen';\n            compat.clickTrampoline = 'when-not-mouse';\n        }\n        else\n        {\n            compat.orientationFallback = '';\n            compat.clickTrampoline = '';\n        }\n\n        // Configure event listeners\n\n        var _this = this;\n\n        this._orientationChange = function(event) {\n            return _this.orientationChange(event);\n        };\n\n        this._windowResize = function(event) {\n            return _this.windowResize(event);\n        };\n\n        // This does not appear to be on the standards track\n        window.addEventListener('orientationchange', this._orientationChange, false);\n        window.addEventListener('resize', this._windowResize, false);\n\n        if (this.compatibility.supportsFullScreen)\n        {\n            this._fullScreenChange = function(event) {\n                return _this.fullScreenChange(event);\n            };\n\n            this._fullScreenError = function(event) {\n                return _this.fullScreenError(event);\n            };\n\n            document.addEventListener('webkitfullscreenchange', this._fullScreenChange, false);\n            document.addEventListener('mozfullscreenchange', this._fullScreenChange, false);\n            document.addEventListener('MSFullscreenChange', this._fullScreenChange, false);\n            document.addEventListener('fullscreenchange', this._fullScreenChange, false);\n\n            document.addEventListener('webkitfullscreenerror', this._fullScreenError, false);\n            document.addEventListener('mozfullscreenerror', this._fullScreenError, false);\n            document.addEventListener('MSFullscreenError', this._fullScreenError, false);\n            document.addEventListener('fullscreenerror', this._fullScreenError, false);\n        }\n\n        this.game.onResume.add(this._gameResumed, this);\n\n        // Initialize core bounds\n\n        this.dom.getOffset(this.game.canvas, this.offset);\n\n        this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);\n\n        this.setGameSize(this.game.width, this.game.height);\n\n        // Don't use updateOrientationState so events are not fired\n        this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback);\n\n        if (Phaser.FlexGrid)\n        {\n            this.grid = new Phaser.FlexGrid(this, this.width, this.height);\n        }\n\n        this._booted = true;\n\n        if (this._pendingScaleMode !== null)\n        {\n            this.scaleMode = this._pendingScaleMode;\n            this._pendingScaleMode = null;\n        }\n\n    },\n\n    /**\n    * Load configuration settings.\n    * \n    * @method Phaser.ScaleManager#parseConfig\n    * @protected\n    * @param {object} config - The game configuration object.\n    */\n    parseConfig: function (config) {\n\n        if (config['scaleMode'] !== undefined)\n        {\n            if (this._booted)\n            {\n                this.scaleMode = config['scaleMode'];\n            }\n            else\n            {\n                this._pendingScaleMode = config['scaleMode'];\n            }\n        }\n\n        if (config['fullScreenScaleMode'] !== undefined)\n        {\n            this.fullScreenScaleMode = config['fullScreenScaleMode'];\n        }\n\n        if (config['fullScreenTarget'])\n        {\n            this.fullScreenTarget = config['fullScreenTarget'];\n        }\n\n    },\n\n    /**\n    * Calculates and sets the game dimensions based on the given width and height.\n    *\n    * This should _not_ be called when in fullscreen mode.\n    * \n    * @method Phaser.ScaleManager#setupScale\n    * @protected\n    * @param {number|string} width - The width of the game.\n    * @param {number|string} height - The height of the game.\n    */\n    setupScale: function (width, height) {\n\n        var target;\n        var rect = new Phaser.Rectangle();\n\n        if (this.game.parent !== '')\n        {\n            if (typeof this.game.parent === 'string')\n            {\n                // hopefully an element ID\n                target = document.getElementById(this.game.parent);\n            }\n            else if (this.game.parent && this.game.parent.nodeType === 1)\n            {\n                // quick test for a HTMLelement\n                target = this.game.parent;\n            }\n        }\n\n        // Fallback, covers an invalid ID and a non HTMLelement object\n        if (!target)\n        {\n            //  Use the full window\n            this.parentNode = null;\n            this.parentIsWindow = true;\n\n            rect.width = this.dom.visualBounds.width;\n            rect.height = this.dom.visualBounds.height;\n\n            this.offset.set(0, 0);\n        }\n        else\n        {\n            this.parentNode = target;\n            this.parentIsWindow = false;\n\n            this.getParentBounds(this._parentBounds);\n\n            rect.width = this._parentBounds.width;\n            rect.height = this._parentBounds.height;\n\n            this.offset.set(this._parentBounds.x, this._parentBounds.y);\n        }\n\n        var newWidth = 0;\n        var newHeight = 0;\n\n        if (typeof width === 'number')\n        {\n            newWidth = width;\n        }\n        else\n        {\n            //  Percentage based\n            this.parentScaleFactor.x = parseInt(width, 10) / 100;\n            newWidth = rect.width * this.parentScaleFactor.x;\n        }\n\n        if (typeof height === 'number')\n        {\n            newHeight = height;\n        }\n        else\n        {\n            //  Percentage based\n            this.parentScaleFactor.y = parseInt(height, 10) / 100;\n            newHeight = rect.height * this.parentScaleFactor.y;\n        }\n\n        newWidth = Math.floor(newWidth);\n        newHeight = Math.floor(newHeight);\n\n        this._gameSize.setTo(0, 0, newWidth, newHeight);\n\n        this.updateDimensions(newWidth, newHeight, false);\n\n    },\n\n    /**\n    * Invoked when the game is resumed.\n    * \n    * @method Phaser.ScaleManager#_gameResumed\n    * @private\n    */\n    _gameResumed: function () {\n\n        this.queueUpdate(true);\n\n    },\n\n    /**\n    * Set the actual Game size.\n    * Use this instead of directly changing `game.width` or `game.height`.\n    *\n    * The actual physical display (Canvas element size) depends on various settings including\n    * - Scale mode\n    * - Scaling factor\n    * - Size of Canvas's parent element or CSS rules such as min-height/max-height;\n    * - The size of the Window\n    *\n    * @method Phaser.ScaleManager#setGameSize\n    * @public\n    * @param {integer} width - _Game width_, in pixels.\n    * @param {integer} height - _Game height_, in pixels.\n    */\n    setGameSize: function (width, height) {\n\n        this._gameSize.setTo(0, 0, width, height);\n        \n        if (this.currentScaleMode !== Phaser.ScaleManager.RESIZE)\n        {\n            this.updateDimensions(width, height, true);\n        }\n\n        this.queueUpdate(true);\n\n    },\n\n    /**\n    * Set a User scaling factor used in the USER_SCALE scaling mode.\n    *\n    * The target canvas size is computed by:\n    *\n    *     canvas.width = (game.width * hScale) - hTrim\n    *     canvas.height = (game.height * vScale) - vTrim\n    *\n    * This method can be used in the {@link Phaser.ScaleManager#setResizeCallback resize callback}.\n    *\n    * @method Phaser.ScaleManager#setUserScale\n    * @param {number} hScale - Horizontal scaling factor.\n    * @param {numer} vScale - Vertical scaling factor.\n    * @param {integer} [hTrim=0] - Horizontal trim, applied after scaling.\n    * @param {integer} [vTrim=0] - Vertical trim, applied after scaling.\n    */\n    setUserScale: function (hScale, vScale, hTrim, vTrim) {\n\n        this._userScaleFactor.setTo(hScale, vScale);\n        this._userScaleTrim.setTo(hTrim | 0, vTrim | 0);\n        this.queueUpdate(true);\n\n    },\n\n    /**\n    * Sets the callback that will be invoked before sizing calculations.\n    *\n    * This is the appropriate place to call {@link #setUserScale} if needing custom dynamic scaling.\n    *\n    * The callback is supplied with two arguments `scale` and `parentBounds` where `scale` is the ScaleManager\n    * and `parentBounds`, a Phaser.Rectangle, is the size of the Parent element.\n    *\n    * This callback\n    * - May be invoked even though the parent container or canvas sizes have not changed\n    * - Unlike {@link #onSizeChange}, it runs _before_ the canvas is guaranteed to be updated\n    * - Will be invoked from `preUpdate`, _even when_ the game is paused    \n    *\n    * See {@link #onSizeChange} for a better way of reacting to layout updates.\n    * \n    * @method Phaser.ScaleManager#setResizeCallback\n    * @public\n    * @param {function} callback - The callback that will be called each time a window.resize event happens or if set, the parent container resizes.\n    * @param {object} context - The context in which the callback will be called.\n    */\n    setResizeCallback: function (callback, context) {\n\n        this.onResize = callback;\n        this.onResizeContext = context;\n\n    },\n\n    /**\n    * Signals a resize - IF the canvas or Game size differs from the last signal.\n    *\n    * This also triggers updates on {@link #grid} (FlexGrid) and, if in a RESIZE mode, `game.state` (StateManager).\n    *\n    * @method Phaser.ScaleManager#signalSizeChange\n    * @private\n    */\n    signalSizeChange: function () {\n\n        if (!Phaser.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) ||\n            !Phaser.Rectangle.sameDimensions(this.game, this._lastReportedGameSize))\n        {\n            var width = this.width;\n            var height = this.height;\n\n            this._lastReportedCanvasSize.setTo(0, 0, width, height);\n            this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height);\n\n            if (this.grid)\n            {\n                this.grid.onResize(width, height);\n            }\n\n            this.onSizeChange.dispatch(this, width, height);\n\n            // Per StateManager#onResizeCallback, it only occurs when in RESIZE mode.\n            if (this.currentScaleMode === Phaser.ScaleManager.RESIZE)\n            {\n                this.game.state.resize(width, height);\n                this.game.load.resize(width, height);\n            }\n        }\n\n    },\n\n    /**\n    * Set the min and max dimensions for the Display canvas.\n    * \n    * _Note:_ The min/max dimensions are only applied in some cases\n    * - When the device is not in an incorrect orientation; or\n    * - The scale mode is EXACT_FIT when not in fullscreen\n    *\n    * @method Phaser.ScaleManager#setMinMax\n    * @public\n    * @param {number} minWidth - The minimum width the game is allowed to scale down to.\n    * @param {number} minHeight - The minimum height the game is allowed to scale down to.\n    * @param {number} [maxWidth] - The maximum width the game is allowed to scale up to; only changed if specified.\n    * @param {number} [maxHeight] - The maximum height the game is allowed to scale up to; only changed if specified.\n    * @todo These values are only sometimes honored.\n    */\n    setMinMax: function (minWidth, minHeight, maxWidth, maxHeight) {\n\n        this.minWidth = minWidth;\n        this.minHeight = minHeight;\n\n        if (typeof maxWidth !== 'undefined')\n        {\n            this.maxWidth = maxWidth;\n        }\n\n        if (typeof maxHeight !== 'undefined')\n        {\n            this.maxHeight = maxHeight;\n        }\n\n    },\n\n    /**\n    * The ScaleManager.preUpdate is called automatically by the core Game loop.\n    * \n    * @method Phaser.ScaleManager#preUpdate\n    * @protected\n    */\n    preUpdate: function () {\n\n        if (this.game.time.time < (this._lastUpdate + this._updateThrottle))\n        {\n            return;\n        }\n\n        var prevThrottle = this._updateThrottle;\n        this._updateThrottleReset = prevThrottle >= 400 ? 0 : 100;\n\n        this.dom.getOffset(this.game.canvas, this.offset);\n\n        var prevWidth = this._parentBounds.width;\n        var prevHeight = this._parentBounds.height;\n        var bounds = this.getParentBounds(this._parentBounds);\n\n        var boundsChanged = bounds.width !== prevWidth || bounds.height !== prevHeight;\n\n        // Always invalidate on a newly detected orientation change\n        var orientationChanged = this.updateOrientationState();\n\n        if (boundsChanged || orientationChanged)\n        {\n            if (this.onResize)\n            {\n                this.onResize.call(this.onResizeContext, this, bounds);\n            }\n\n            this.updateLayout();\n\n            this.signalSizeChange();\n        }\n\n        // Next throttle, eg. 25, 50, 100, 200..\n        var throttle = this._updateThrottle * 2;\n\n        // Don't let an update be too eager about resetting the throttle.\n        if (this._updateThrottle < prevThrottle)\n        {\n            throttle = Math.min(prevThrottle, this._updateThrottleReset);\n        }\n\n        this._updateThrottle = Phaser.Math.clamp(throttle, 25, this.trackParentInterval);\n        this._lastUpdate = this.game.time.time;\n\n    },\n\n    /**\n    * Update method while paused.\n    *\n    * @method Phaser.ScaleManager#pauseUpdate\n    * @private\n    */\n    pauseUpdate: function () {\n\n        this.preUpdate();\n\n        // Updates at slowest.\n        this._updateThrottle = this.trackParentInterval;\n        \n    },\n\n    /**\n    * Update the dimensions taking the parent scaling factor into account.\n    *\n    * @method Phaser.ScaleManager#updateDimensions\n    * @private\n    * @param {number} width - The new width of the parent container.\n    * @param {number} height - The new height of the parent container.\n    * @param {boolean} resize - True if the renderer should be resized, otherwise false to just update the internal vars.\n    */\n    updateDimensions: function (width, height, resize) {\n\n        this.width = width * this.parentScaleFactor.x;\n        this.height = height * this.parentScaleFactor.y;\n\n        this.game.width = this.width;\n        this.game.height = this.height;\n\n        this.sourceAspectRatio = this.width / this.height;\n        this.updateScalingAndBounds();\n\n        if (resize)\n        {\n            //  Resize the renderer (which in turn resizes the Display canvas!)\n            this.game.renderer.resize(this.width, this.height);\n\n            //  The Camera can never be smaller than the Game size\n            this.game.camera.setSize(this.width, this.height);\n\n            //  This should only happen if the world is smaller than the new canvas size\n            this.game.world.resize(this.width, this.height);\n        }\n\n    },\n\n    /**\n    * Update relevant scaling values based on the ScaleManager dimension and game dimensions,\n    * which should already be set. This does not change {@link #sourceAspectRatio}.\n    * \n    * @method Phaser.ScaleManager#updateScalingAndBounds\n    * @private\n    */\n    updateScalingAndBounds: function () {\n\n        this.scaleFactor.x = this.game.width / this.width;\n        this.scaleFactor.y = this.game.height / this.height;\n\n        this.scaleFactorInversed.x = this.width / this.game.width;\n        this.scaleFactorInversed.y = this.height / this.game.height;\n\n        this.aspectRatio = this.width / this.height;\n\n        // This can be invoked in boot pre-canvas\n        if (this.game.canvas)\n        {\n            this.dom.getOffset(this.game.canvas, this.offset);\n        }\n\n        this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);\n\n        // Can be invoked in boot pre-input\n        if (this.game.input && this.game.input.scale)\n        {\n            this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y);\n        }\n\n    },\n\n    /**\n    * Force the game to run in only one orientation.\n    *\n    * This enables generation of incorrect orientation signals and affects resizing but does not otherwise rotate or lock the orientation.\n    *\n    * Orientation checks are performed via the Screen Orientation API, if available in browser. This means it will check your monitor\n    * orientation on desktop, or your device orientation on mobile, rather than comparing actual game dimensions. If you need to check the \n    * viewport dimensions instead and bypass the Screen Orientation API then set: `ScaleManager.compatibility.orientationFallback = 'viewport'`\n    * \n    * @method Phaser.ScaleManager#forceOrientation\n    * @public\n    * @param {boolean} forceLandscape - true if the game should run in landscape mode only.\n    * @param {boolean} [forcePortrait=false] - true if the game should run in portrait mode only.\n    */\n    forceOrientation: function (forceLandscape, forcePortrait) {\n\n        if (forcePortrait === undefined) { forcePortrait = false; }\n\n        this.forceLandscape = forceLandscape;\n        this.forcePortrait = forcePortrait;\n\n        this.queueUpdate(true);\n\n    },\n\n    /**\n    * Classify the orientation, per `getScreenOrientation`.\n    * \n    * @method Phaser.ScaleManager#classifyOrientation\n    * @private\n    * @param {string} orientation - The orientation string, e.g. 'portrait-primary'.\n    * @return {?string} The classified orientation: 'portrait', 'landscape`, or null.\n    */\n    classifyOrientation: function (orientation) {\n\n        if (orientation === 'portrait-primary' || orientation === 'portrait-secondary')\n        {\n            return 'portrait';\n        }\n        else if (orientation === 'landscape-primary' || orientation === 'landscape-secondary')\n        {\n            return 'landscape';\n        }\n        else\n        {\n            return null;\n        }\n\n    },\n\n    /**\n    * Updates the current orientation and dispatches orientation change events.\n    * \n    * @method Phaser.ScaleManager#updateOrientationState\n    * @private\n    * @return {boolean} True if the orientation state changed which means a forced update is likely required.\n    */\n    updateOrientationState: function () {\n\n        var previousOrientation = this.screenOrientation;\n        var previouslyIncorrect = this.incorrectOrientation;\n        \n        this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback);\n\n        this.incorrectOrientation = (this.forceLandscape && !this.isLandscape) ||\n            (this.forcePortrait && !this.isPortrait);\n\n        var changed = previousOrientation !== this.screenOrientation;\n        var correctnessChanged = previouslyIncorrect !== this.incorrectOrientation;\n\n        if (correctnessChanged)\n        {\n            if (this.incorrectOrientation)\n            {\n                this.enterIncorrectOrientation.dispatch();\n            }\n            else\n            {\n                this.leaveIncorrectOrientation.dispatch();\n            }\n        }\n\n        if (changed || correctnessChanged)\n        {\n            this.onOrientationChange.dispatch(this, previousOrientation, previouslyIncorrect);\n        }\n\n        return changed || correctnessChanged;\n\n    },\n\n    /**\n    * window.orientationchange event handler.\n    * \n    * @method Phaser.ScaleManager#orientationChange\n    * @private\n    * @param {Event} event - The orientationchange event data.\n    */\n    orientationChange: function (event) {\n\n        this.event = event;\n\n        this.queueUpdate(true);\n\n    },\n\n    /**\n    * window.resize event handler.\n    * \n    * @method Phaser.ScaleManager#windowResize\n    * @private\n    * @param {Event} event - The resize event data.\n    */\n    windowResize: function (event) {\n\n        this.event = event;\n\n        this.queueUpdate(true);\n\n    },\n\n    /**\n    * Scroll to the top - in some environments. See `compatibility.scrollTo`.\n    * \n    * @method Phaser.ScaleManager#scrollTop\n    * @private\n    */\n    scrollTop: function () {\n\n        var scrollTo = this.compatibility.scrollTo;\n\n        if (scrollTo)\n        {\n            window.scrollTo(scrollTo.x, scrollTo.y);\n        }\n\n    },\n\n    /**\n    * The \"refresh\" methods informs the ScaleManager that a layout refresh is required.\n    *\n    * The ScaleManager automatically queues a layout refresh (eg. updates the Game size or Display canvas layout)\n    * when the browser is resized, the orientation changes, or when there is a detected change\n    * of the Parent size. Refreshing is also done automatically when public properties,\n    * such as {@link #scaleMode}, are updated or state-changing methods are invoked.\n    *\n    * The \"refresh\" method _may_ need to be used in a few (rare) situtations when\n    *\n    * - a device change event is not correctly detected; or\n    * - the Parent size changes (and an immediate reflow is desired); or\n    * - the ScaleManager state is updated by non-standard means; or\n    * - certain {@link #compatibility} properties are manually changed.\n    *\n    * The queued layout refresh is not immediate but will run promptly in an upcoming `preRender`.\n    * \n    * @method Phaser.ScaleManager#refresh\n    * @public\n    */\n    refresh: function () {\n\n        this.scrollTop();\n        this.queueUpdate(true);\n\n    },\n\n    /**\n    * Updates the game / canvas position and size.\n    *\n    * @method Phaser.ScaleManager#updateLayout\n    * @private\n    */\n    updateLayout: function () {\n\n        var scaleMode = this.currentScaleMode;\n\n        if (scaleMode === Phaser.ScaleManager.RESIZE)\n        {\n            this.reflowGame();\n            return;\n        }\n\n        this.scrollTop();\n\n        if (this.compatibility.forceMinimumDocumentHeight)\n        {\n            // (This came from older code, by why is it here?)\n            // Set minimum height of content to new window height\n            document.documentElement.style.minHeight = window.innerHeight + 'px';\n        }\n        \n        if (this.incorrectOrientation)\n        {\n            this.setMaximum();\n        }\n        else\n        {\n            if (scaleMode === Phaser.ScaleManager.EXACT_FIT)\n            {\n                this.setExactFit();\n            }\n            else if (scaleMode === Phaser.ScaleManager.SHOW_ALL)\n            {\n                if (!this.isFullScreen && this.boundingParent &&\n                    this.compatibility.canExpandParent)\n                {\n                    // Try to expand parent out, but choosing maximizing dimensions.                    \n                    // Then select minimize dimensions which should then honor parent\n                    // maximum bound applications.\n                    this.setShowAll(true);\n                    this.resetCanvas();\n                    this.setShowAll();\n                }\n                else\n                {\n                    this.setShowAll();\n                }\n            }\n            else if (scaleMode === Phaser.ScaleManager.NO_SCALE)\n            {\n                this.width = this.game.width;\n                this.height = this.game.height;\n            }\n            else if (scaleMode === Phaser.ScaleManager.USER_SCALE)\n            {\n                this.width = (this.game.width * this._userScaleFactor.x) - this._userScaleTrim.x;\n                this.height = (this.game.height * this._userScaleFactor.y) - this._userScaleTrim.y;\n            }\n        }\n\n        if (!this.compatibility.canExpandParent &&\n            (scaleMode === Phaser.ScaleManager.SHOW_ALL || scaleMode === Phaser.ScaleManager.USER_SCALE))\n        {\n            var bounds = this.getParentBounds(this._tempBounds);\n            this.width = Math.min(this.width, bounds.width);\n            this.height = Math.min(this.height, bounds.height);\n        }\n\n        // Always truncate / force to integer\n        this.width = this.width | 0;\n        this.height = this.height | 0;\n\n        this.reflowCanvas();\n\n    },\n\n    /**\n    * Returns the computed Parent size/bounds that the Display canvas is allowed/expected to fill.\n    *\n    * If in fullscreen mode or without parent (see {@link #parentIsWindow}),\n    * this will be the bounds of the visual viewport itself.\n    *\n    * This function takes the {@link #windowConstraints} into consideration - if the parent is partially outside\n    * the viewport then this function may return a smaller than expected size.\n    *\n    * Values are rounded to the nearest pixel.\n    *\n    * @method Phaser.ScaleManager#getParentBounds\n    * @protected\n    * @param {Phaser.Rectangle} [target=(new Rectangle)] - The rectangle to update; a new one is created as needed.\n    * @return {Phaser.Rectangle} The established parent bounds.\n    */\n    getParentBounds: function (target) {\n\n        var bounds = target || new Phaser.Rectangle();\n        var parentNode = this.boundingParent;\n        var visualBounds = this.dom.visualBounds;\n        var layoutBounds = this.dom.layoutBounds;\n\n        if (!parentNode)\n        {\n            bounds.setTo(0, 0, visualBounds.width, visualBounds.height);\n        }\n        else\n        {\n            // Ref. http://msdn.microsoft.com/en-us/library/hh781509(v=vs.85).aspx for getBoundingClientRect\n            var clientRect = parentNode.getBoundingClientRect();\n            var parentRect = (parentNode.offsetParent) ? parentNode.offsetParent.getBoundingClientRect() : parentNode.getBoundingClientRect();\n\n            bounds.setTo(clientRect.left - parentRect.left, clientRect.top - parentRect.top, clientRect.width, clientRect.height);\n\n            var wc = this.windowConstraints;\n\n            if (wc.right)\n            {\n                var windowBounds = wc.right === 'layout' ? layoutBounds : visualBounds;\n                bounds.right = Math.min(bounds.right, windowBounds.width);\n            }\n\n            if (wc.bottom)\n            {\n                var windowBounds = wc.bottom === 'layout' ? layoutBounds : visualBounds;\n                bounds.bottom = Math.min(bounds.bottom, windowBounds.height);\n            }\n        }\n\n        bounds.setTo(\n            Math.round(bounds.x), Math.round(bounds.y),\n            Math.round(bounds.width), Math.round(bounds.height));\n\n        return bounds;\n\n    },\n\n    /**\n    * Update the canvas position/margins - for alignment within the parent container.\n    *\n    * The canvas margins _must_ be reset/cleared prior to invoking this.\n    *\n    * @method Phaser.ScaleManager#alignCanvas\n    * @private\n    * @param {boolean} horizontal - Align horizontally?\n    * @param {boolean} vertical - Align vertically?\n    */\n    alignCanvas: function (horizontal, vertical) {\n\n        var parentBounds = this.getParentBounds(this._tempBounds);\n        var canvas = this.game.canvas;\n        var margin = this.margin;\n\n        if (horizontal)\n        {\n            margin.left = margin.right = 0;\n\n            var canvasBounds = canvas.getBoundingClientRect();\n\n            if (this.width < parentBounds.width && !this.incorrectOrientation)\n            {\n                var currentEdge = canvasBounds.left - parentBounds.x;\n                var targetEdge = (parentBounds.width / 2) - (this.width / 2);\n\n                targetEdge = Math.max(targetEdge, 0);\n\n                var offset = targetEdge - currentEdge;\n\n                margin.left = Math.round(offset);\n            }\n\n            canvas.style.marginLeft = margin.left + 'px';\n\n            if (margin.left !== 0)\n            {\n                margin.right = -(parentBounds.width - canvasBounds.width - margin.left);\n                canvas.style.marginRight = margin.right + 'px';\n            }\n        }\n\n        if (vertical)\n        {\n            margin.top = margin.bottom = 0;\n\n            var canvasBounds = canvas.getBoundingClientRect();\n            \n            if (this.height < parentBounds.height && !this.incorrectOrientation)\n            {\n                var currentEdge = canvasBounds.top - parentBounds.y;\n                var targetEdge = (parentBounds.height / 2) - (this.height / 2);\n\n                targetEdge = Math.max(targetEdge, 0);\n                \n                var offset = targetEdge - currentEdge;\n                margin.top = Math.round(offset);\n            }\n\n            canvas.style.marginTop = margin.top + 'px';\n\n            if (margin.top !== 0)\n            {\n                margin.bottom = -(parentBounds.height - canvasBounds.height - margin.top);\n                canvas.style.marginBottom = margin.bottom + 'px';\n            }\n        }\n\n        // Silly backwards compatibility..\n        margin.x = margin.left;\n        margin.y = margin.top;\n\n    },\n\n    /**\n    * Updates the Game state / size.\n    *\n    * The canvas margins may always be adjusted, even if alignment is not in effect.\n    * \n    * @method Phaser.ScaleManager#reflowGame\n    * @private\n    */\n    reflowGame: function () {\n\n        this.resetCanvas('', '');\n\n        var bounds = this.getParentBounds(this._tempBounds);\n        this.updateDimensions(bounds.width, bounds.height, true);\n\n    },\n\n    /**\n    * Updates the Display canvas size.\n    *\n    * The canvas margins may always be adjusted, even alignment is not in effect.\n    * \n    * @method Phaser.ScaleManager#reflowCanvas\n    * @private\n    */\n    reflowCanvas: function () {\n\n        if (!this.incorrectOrientation)\n        {\n            this.width = Phaser.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width);\n            this.height = Phaser.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height);\n        }\n\n        this.resetCanvas();\n\n        if (!this.compatibility.noMargins)\n        {\n            if (this.isFullScreen && this._createdFullScreenTarget)\n            {\n                this.alignCanvas(true, true);\n            }\n            else\n            {\n                this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically);\n            }\n        }\n\n        this.updateScalingAndBounds();\n\n    },\n\n    /**\n    * \"Reset\" the Display canvas and set the specified width/height.\n    *\n    * @method Phaser.ScaleManager#resetCanvas\n    * @private\n    * @param {string} [cssWidth=(current width)] - The css width to set.\n    * @param {string} [cssHeight=(current height)] - The css height to set.\n    */\n    resetCanvas: function (cssWidth, cssHeight) {\n\n        if (cssWidth === undefined) { cssWidth = this.width + 'px'; }\n        if (cssHeight === undefined) { cssHeight = this.height + 'px'; }\n\n        var canvas = this.game.canvas;\n\n        if (!this.compatibility.noMargins)\n        {\n            canvas.style.marginLeft = '';\n            canvas.style.marginTop = '';\n            canvas.style.marginRight = '';\n            canvas.style.marginBottom = '';\n        }\n\n        canvas.style.width = cssWidth;\n        canvas.style.height = cssHeight;\n\n    },\n\n    /**\n    * Queues/marks a size/bounds check as needing to occur (from `preUpdate`).\n    *\n    * @method Phaser.ScaleManager#queueUpdate\n    * @private\n    * @param {boolean} force - If true resets the parent bounds to ensure the check is dirty.\n    */\n    queueUpdate: function (force) {\n\n        if (force)\n        {\n            this._parentBounds.width = 0;\n            this._parentBounds.height = 0;\n        }\n\n        this._updateThrottle = this._updateThrottleReset;\n\n    },\n\n    /**\n    * Reset internal data/state.\n    *\n    * @method Phaser.ScaleManager#reset\n    * @private\n    */\n    reset: function (clearWorld) {\n\n        if (clearWorld && this.grid)\n        {\n            this.grid.reset();\n        }\n\n    },\n\n    /**\n    * Updates the width/height to that of the window.\n    * \n    * @method Phaser.ScaleManager#setMaximum\n    * @private\n    */\n    setMaximum: function () {\n\n        this.width = this.dom.visualBounds.width;\n        this.height = this.dom.visualBounds.height;\n\n    },\n\n    /**\n    * Updates the width/height such that the game is scaled proportionally.\n    * \n    * @method Phaser.ScaleManager#setShowAll\n    * @private\n    * @param {boolean} expanding - If true then the maximizing dimension is chosen.\n    */\n    setShowAll: function (expanding) {\n\n        var bounds = this.getParentBounds(this._tempBounds);\n        var width = bounds.width;\n        var height = bounds.height;\n\n        var multiplier;\n\n        if (expanding)\n        {\n            multiplier = Math.max((height / this.game.height), (width / this.game.width));\n        }\n        else\n        {\n            multiplier = Math.min((height / this.game.height), (width / this.game.width));\n        }\n\n        this.width = Math.round(this.game.width * multiplier);\n        this.height = Math.round(this.game.height * multiplier);\n\n    },\n\n    /**\n    * Updates the width/height such that the game is stretched to the available size.\n    * Honors {@link #maxWidth} and {@link #maxHeight} when _not_ in fullscreen.\n    *\n    * @method Phaser.ScaleManager#setExactFit\n    * @private\n    */\n    setExactFit: function () {\n\n        var bounds = this.getParentBounds(this._tempBounds);\n\n        this.width = bounds.width;\n        this.height = bounds.height;\n\n        if (this.isFullScreen)\n        {\n            // Max/min not honored fullscreen\n            return;\n        }\n\n        if (this.maxWidth)\n        {\n            this.width = Math.min(this.width, this.maxWidth);\n        }\n\n        if (this.maxHeight)\n        {\n            this.height = Math.min(this.height, this.maxHeight);\n        }\n\n    },\n\n    /**\n    * Creates a fullscreen target. This is called automatically as as needed when entering\n    * fullscreen mode and the resulting element is supplied to {@link #onFullScreenInit}.\n    *\n    * Use {@link #onFullScreenInit} to customize the created object.\n    *\n    * @method Phaser.ScaleManager#createFullScreenTarget\n    * @protected\n    */\n    createFullScreenTarget: function () {\n\n        var fsTarget = document.createElement('div');\n\n        fsTarget.style.margin = '0';\n        fsTarget.style.padding = '0';\n        fsTarget.style.background = '#000';\n\n        return fsTarget;\n\n    },\n\n    /**\n    * Start the browsers fullscreen mode - this _must_ be called from a user input Pointer or Mouse event.\n    *\n    * The Fullscreen API must be supported by the browser for this to work - it is not the same as setting\n    * the game size to fill the browser window. See {@link Phaser.ScaleManager#compatibility compatibility.supportsFullScreen} to check if the current\n    * device is reported to support fullscreen mode.\n    *\n    * The {@link #fullScreenFailed} signal will be dispatched if the fullscreen change request failed or the game does not support the Fullscreen API.\n    *\n    * @method Phaser.ScaleManager#startFullScreen\n    * @public\n    * @param {boolean} [antialias] - Changes the anti-alias feature of the canvas before jumping in to fullscreen (false = retain pixel art, true = smooth art). If not specified then no change is made. Only works in CANVAS mode.\n    * @param {boolean} [allowTrampoline=undefined] - Internal argument. If `false` click trampolining is suppressed.\n    * @return {boolean} Returns true if the device supports fullscreen mode and fullscreen mode was attempted to be started. (It might not actually start, wait for the signals.)\n    */\n    startFullScreen: function (antialias, allowTrampoline) {\n\n        if (this.isFullScreen)\n        {\n            return false;\n        }\n\n        if (!this.compatibility.supportsFullScreen)\n        {\n            // Error is called in timeout to emulate the real fullscreenerror event better\n            var _this = this;\n\n            setTimeout(function () {\n                _this.fullScreenError();\n            }, 10);\n\n            return;\n        }\n\n        if (this.compatibility.clickTrampoline === 'when-not-mouse')\n        {\n            var input = this.game.input;\n\n            if (input.activePointer &&\n                input.activePointer !== input.mousePointer &&\n                (allowTrampoline || allowTrampoline !== false))\n            {\n                input.activePointer.addClickTrampoline(\"startFullScreen\", this.startFullScreen, this, [antialias, false]);\n                return;\n            }\n        }\n\n        if (antialias !== undefined && this.game.renderType === Phaser.CANVAS)\n        {\n            this.game.stage.smoothed = antialias;\n        }\n\n        var fsTarget = this.fullScreenTarget;\n        \n        if (!fsTarget)\n        {\n            this.cleanupCreatedTarget();\n\n            this._createdFullScreenTarget = this.createFullScreenTarget();\n            fsTarget = this._createdFullScreenTarget;\n        }\n\n        var initData = {\n            targetElement: fsTarget\n        };\n\n        this.hasPhaserSetFullScreen = true;\n\n        this.onFullScreenInit.dispatch(this, initData);\n\n        if (this._createdFullScreenTarget)\n        {\n            // Move the Display canvas inside of the target and add the target to the DOM\n            // (The target has to be added for the Fullscreen API to work.)\n            var canvas = this.game.canvas;\n            var parent = canvas.parentNode;\n            parent.insertBefore(fsTarget, canvas);\n            fsTarget.appendChild(canvas);\n        }\n\n        if (this.game.device.fullscreenKeyboard)\n        {\n            fsTarget[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT);\n        }\n        else\n        {\n            fsTarget[this.game.device.requestFullscreen]();\n        }\n\n        return true;\n\n    },\n\n    /**\n    * Stops / exits fullscreen mode, if active.\n    *\n    * @method Phaser.ScaleManager#stopFullScreen\n    * @public\n    * @return {boolean} Returns true if the browser supports fullscreen mode and fullscreen mode will be exited.\n    */\n    stopFullScreen: function () {\n\n        if (!this.isFullScreen || !this.compatibility.supportsFullScreen)\n        {\n            return false;\n        }\n\n        this.hasPhaserSetFullScreen = false;\n\n        document[this.game.device.cancelFullscreen]();\n\n        return true;\n\n    },\n\n    /**\n    * Cleans up the previous fullscreen target, if such was automatically created.\n    * This ensures the canvas is restored to its former parent, assuming the target didn't move.\n    *\n    * @method Phaser.ScaleManager#cleanupCreatedTarget\n    * @private\n    */\n    cleanupCreatedTarget: function () {\n\n        var fsTarget = this._createdFullScreenTarget;\n\n        if (fsTarget && fsTarget.parentNode)\n        {\n            // Make sure to cleanup synthetic target for sure;\n            // swap the canvas back to the parent.\n            var parent = fsTarget.parentNode;\n            parent.insertBefore(this.game.canvas, fsTarget);\n            parent.removeChild(fsTarget);\n        }\n\n        this._createdFullScreenTarget = null;\n\n    },\n\n    /**\n    * Used to prepare/restore extra fullscreen mode settings.\n    * (This does move any elements within the DOM tree.)\n    *\n    * @method Phaser.ScaleManager#prepScreenMode\n    * @private\n    * @param {boolean} enteringFullscreen - True if _entering_ fullscreen, false if _leaving_.\n    */\n    prepScreenMode: function (enteringFullscreen) {\n\n        var createdTarget = !!this._createdFullScreenTarget;\n        var fsTarget = this._createdFullScreenTarget || this.fullScreenTarget;\n\n        if (enteringFullscreen)\n        {\n            if (createdTarget || this.fullScreenScaleMode === Phaser.ScaleManager.EXACT_FIT)\n            {\n                // Resize target, as long as it's not the canvas\n                if (fsTarget !== this.game.canvas)\n                {\n                    this._fullScreenRestore = {\n                        targetWidth: fsTarget.style.width,\n                        targetHeight: fsTarget.style.height\n                    };\n\n                    fsTarget.style.width = '100%';\n                    fsTarget.style.height = '100%';\n                }\n            }\n        }\n        else\n        {\n            // Have restore information\n            if (this._fullScreenRestore)\n            {\n                fsTarget.style.width = this._fullScreenRestore.targetWidth;\n                fsTarget.style.height = this._fullScreenRestore.targetHeight;\n\n                this._fullScreenRestore = null;\n            }\n\n            // Always reset to game size\n            this.updateDimensions(this._gameSize.width, this._gameSize.height, true);\n            this.resetCanvas();\n        }\n\n    },\n\n    /**\n    * Called automatically when the browser enters of leaves fullscreen mode.\n    *\n    * @method Phaser.ScaleManager#fullScreenChange\n    * @private\n    * @param {Event} [event=undefined] - The fullscreenchange event\n    */\n    fullScreenChange: function (event) {\n\n        this.event = event;\n\n        if (this.isFullScreen)\n        {\n            this.prepScreenMode(true);\n\n            this.updateLayout();\n            this.queueUpdate(true);\n        }\n        else\n        {\n            this.prepScreenMode(false);\n\n            this.cleanupCreatedTarget();\n\n            this.updateLayout();\n            this.queueUpdate(true);\n        }\n\n        this.onFullScreenChange.dispatch(this, this.width, this.height);\n\n    },\n\n    /**\n    * Called automatically when the browser fullscreen request fails;\n    * or called when a fullscreen request is made on a device for which it is not supported.\n    *\n    * @method Phaser.ScaleManager#fullScreenError\n    * @private\n    * @param {Event} [event=undefined] - The fullscreenerror event; undefined if invoked on a device that does not support the Fullscreen API.\n    */\n    fullScreenError: function (event) {\n\n        this.event = event;\n\n        this.cleanupCreatedTarget();\n\n        console.warn('Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API');\n\n        this.onFullScreenError.dispatch(this);\n\n    },\n\n    /**\n    * Takes a Sprite or Image object and scales it to fit the given dimensions.\n    * Scaling happens proportionally without distortion to the sprites texture.\n    * The letterBox parameter controls if scaling will produce a letter-box effect or zoom the\n    * sprite until it fills the given values. Note that with letterBox set to false the scaled sprite may spill out over either\n    * the horizontal or vertical sides of the target dimensions. If you wish to stop this you can crop the Sprite.\n    *\n    * @method Phaser.ScaleManager#scaleSprite\n    * @protected\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite we want to scale.\n    * @param {integer} [width] - The target width that we want to fit the sprite in to. If not given it defaults to ScaleManager.width.\n    * @param {integer} [height] - The target height that we want to fit the sprite in to. If not given it defaults to ScaleManager.height.\n    * @param {boolean} [letterBox=false] - True if we want the `fitted` mode. Otherwise, the function uses the `zoom` mode.\n    * @return {Phaser.Sprite|Phaser.Image} The scaled sprite.\n    */\n    scaleSprite: function (sprite, width, height, letterBox) {\n\n        if (width === undefined) { width = this.width; }\n        if (height === undefined) { height = this.height; }\n        if (letterBox === undefined) { letterBox = false; }\n\n        if (!sprite || !sprite['scale'])\n        {\n            return sprite;\n        }\n\n        sprite.scale.x = 1;\n        sprite.scale.y = 1;\n\n        if ((sprite.width <= 0) || (sprite.height <= 0) || (width <= 0) || (height <= 0))\n        {\n            return sprite;\n        }\n\n        var scaleX1 = width;\n        var scaleY1 = (sprite.height * width) / sprite.width;\n\n        var scaleX2 = (sprite.width * height) / sprite.height;\n        var scaleY2 = height;\n\n        var scaleOnWidth = (scaleX2 > width);\n\n        if (scaleOnWidth)\n        {\n            scaleOnWidth = letterBox;\n        }\n        else\n        {\n            scaleOnWidth = !letterBox;\n        }\n\n        if (scaleOnWidth)\n        {\n            sprite.width = Math.floor(scaleX1);\n            sprite.height = Math.floor(scaleY1);\n        }\n        else\n        {\n            sprite.width = Math.floor(scaleX2);\n            sprite.height = Math.floor(scaleY2);\n        }\n\n        //  Enable at some point?\n        // sprite.x = Math.floor((width - sprite.width) / 2);\n        // sprite.y = Math.floor((height - sprite.height) / 2);\n\n        return sprite;\n\n    },\n\n    /**\n    * Destroys the ScaleManager and removes any event listeners.\n    * This should probably only be called when the game is destroyed.\n    *\n    * @method Phaser.ScaleManager#destroy\n    * @protected\n    */\n    destroy: function () {\n\n        this.game.onResume.remove(this._gameResumed, this);\n\n        window.removeEventListener('orientationchange', this._orientationChange, false);\n        window.removeEventListener('resize', this._windowResize, false);\n\n        if (this.compatibility.supportsFullScreen)\n        {\n            document.removeEventListener('webkitfullscreenchange', this._fullScreenChange, false);\n            document.removeEventListener('mozfullscreenchange', this._fullScreenChange, false);\n            document.removeEventListener('MSFullscreenChange', this._fullScreenChange, false);\n            document.removeEventListener('fullscreenchange', this._fullScreenChange, false);\n\n            document.removeEventListener('webkitfullscreenerror', this._fullScreenError, false);\n            document.removeEventListener('mozfullscreenerror', this._fullScreenError, false);\n            document.removeEventListener('MSFullscreenError', this._fullScreenError, false);\n            document.removeEventListener('fullscreenerror', this._fullScreenError, false);\n        }\n\n    }\n\n};\n\nPhaser.ScaleManager.prototype.constructor = Phaser.ScaleManager;\n\n/**\n* The DOM element that is considered the Parent bounding element, if any.\n*\n* This `null` if {@link #parentIsWindow} is true or if fullscreen mode is entered and {@link #fullScreenTarget} is specified.\n* It will also be null if there is no game canvas or if the game canvas has no parent.\n*\n* @name Phaser.ScaleManager#boundingParent\n* @property {?DOMElement} boundingParent\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"boundingParent\", {\n\n    get: function () {\n\n        if (this.parentIsWindow ||\n            (this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget))\n        {\n            return null;\n        }\n\n        var parentNode = this.game.canvas && this.game.canvas.parentNode;\n\n        return parentNode || null;\n\n    }\n\n});\n\n/**\n* The scaling method used by the ScaleManager when not in fullscreen.\n* \n* <dl>\n*   <dt>{@link Phaser.ScaleManager.NO_SCALE}</dt>\n*   <dd>\n*       The Game display area will not be scaled - even if it is too large for the canvas/screen.\n*       This mode _ignores_ any applied scaling factor and displays the canvas at the Game size.\n*   </dd>\n*   <dt>{@link Phaser.ScaleManager.EXACT_FIT}</dt>\n*   <dd>\n*       The Game display area will be _stretched_ to fill the entire size of the canvas's parent element and/or screen.\n*       Proportions are not maintained.\n*   </dd>\n*   <dt>{@link Phaser.ScaleManager.SHOW_ALL}</dt>\n*   <dd>\n*       Show the entire game display area while _maintaining_ the original aspect ratio.\n*   </dd>\n*   <dt>{@link Phaser.ScaleManager.RESIZE}</dt>\n*   <dd>\n*       The dimensions of the game display area are changed to match the size of the parent container.\n*       That is, this mode _changes the Game size_ to match the display size.\n*       <p>\n*       Any manually set Game size (see {@link #setGameSize}) is ignored while in effect.\n*   </dd>\n*   <dt>{@link Phaser.ScaleManager.USER_SCALE}</dt>\n*   <dd>\n*       The game Display is scaled according to the user-specified scale set by {@link Phaser.ScaleManager#setUserScale setUserScale}.\n*       <p>\n*       This scale can be adjusted in the {@link Phaser.ScaleManager#setResizeCallback resize callback}\n*       for flexible custom-sizing needs.\n*   </dd>\n* </dl>\n*\n* @name Phaser.ScaleManager#scaleMode\n* @property {integer} scaleMode\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"scaleMode\", {\n\n    get: function () {\n\n        return this._scaleMode;\n\n    },\n\n    set: function (value) {\n\n        if (value !== this._scaleMode)\n        {\n            if (!this.isFullScreen)\n            {\n                this.updateDimensions(this._gameSize.width, this._gameSize.height, true);\n                this.queueUpdate(true);\n            }\n\n            this._scaleMode = value;\n        }\n\n        return this._scaleMode;\n\n    }\n\n});\n\n/**\n* The scaling method used by the ScaleManager when in fullscreen.\n*\n* See {@link Phaser.ScaleManager#scaleMode scaleMode} for the different modes allowed.\n*\n* @name Phaser.ScaleManager#fullScreenScaleMode\n* @property {integer} fullScreenScaleMode\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"fullScreenScaleMode\", {\n\n    get: function () {\n\n        return this._fullScreenScaleMode;\n\n    },\n\n    set: function (value) {\n\n        if (value !== this._fullScreenScaleMode)\n        {\n            // If in fullscreen then need a wee bit more work\n            if (this.isFullScreen)\n            {\n                this.prepScreenMode(false);\n                this._fullScreenScaleMode = value;\n                this.prepScreenMode(true);\n\n                this.queueUpdate(true);\n            }\n            else\n            {\n                this._fullScreenScaleMode = value;\n            }\n        }\n\n        return this._fullScreenScaleMode;\n\n    }\n\n});\n\n/**\n* Returns the current scale mode - for normal or fullscreen operation.\n*\n* See {@link Phaser.ScaleManager#scaleMode scaleMode} for the different modes allowed.\n*\n* @name Phaser.ScaleManager#currentScaleMode\n* @property {number} currentScaleMode\n* @protected\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"currentScaleMode\", {\n\n    get: function () {\n\n        return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode;\n\n    }\n\n});\n\n/**\n* When enabled the Display canvas will be horizontally-aligned _in the Parent container_ (or {@link Phaser.ScaleManager#parentIsWindow window}).\n*\n* To align horizontally across the page the Display canvas should be added directly to page;\n* or the parent container should itself be horizontally aligned.\n*\n* Horizontal alignment is not applicable with the {@link .RESIZE} scaling mode.\n*\n* @name Phaser.ScaleManager#pageAlignHorizontally\n* @property {boolean} pageAlignHorizontally\n* @default false\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"pageAlignHorizontally\", {\n\n    get: function () {\n\n        return this._pageAlignHorizontally;\n\n    },\n\n    set: function (value) {\n\n        if (value !== this._pageAlignHorizontally)\n        {\n            this._pageAlignHorizontally = value;\n            this.queueUpdate(true);\n        }\n\n    }\n\n});\n\n/**\n* When enabled the Display canvas will be vertically-aligned _in the Parent container_ (or {@link Phaser.ScaleManager#parentIsWindow window}).\n*\n* To align vertically the Parent element should have a _non-collapsible_ height, such that it will maintain\n* a height _larger_ than the height of the contained Game canvas - the game canvas will then be scaled vertically\n* _within_ the remaining available height dictated by the Parent element.\n*\n* One way to prevent the parent from collapsing is to add an absolute \"min-height\" CSS property to the parent element.\n* If specifying a relative \"min-height/height\" or adjusting margins, the Parent height must still be non-collapsible (see note).\n*\n* _Note_: In version 2.2 the minimum document height is _not_ automatically set to the viewport/window height.\n* To automatically update the minimum document height set {@link Phaser.ScaleManager#compatibility compatibility.forceMinimumDocumentHeight} to true.\n*\n* Vertical alignment is not applicable with the {@link .RESIZE} scaling mode.\n*\n* @name Phaser.ScaleManager#pageAlignVertically\n* @property {boolean} pageAlignVertically\n* @default false\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"pageAlignVertically\", {\n\n    get: function () {\n\n        return this._pageAlignVertically;\n\n    },\n\n    set: function (value) {\n\n        if (value !== this._pageAlignVertically)\n        {\n            this._pageAlignVertically = value;\n            this.queueUpdate(true);\n        }\n\n    }\n\n});\n\n/**\n* Returns true if the browser is in fullscreen mode, otherwise false.\n* @name Phaser.ScaleManager#isFullScreen\n* @property {boolean} isFullScreen\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"isFullScreen\", {\n\n    get: function () {\n        return !!(document['fullscreenElement'] ||\n            document['webkitFullscreenElement'] ||\n            document['mozFullScreenElement'] ||\n            document['msFullscreenElement']);\n    }\n\n});\n\n/**\n* Returns true if the screen orientation is in portrait mode.\n*\n* @name Phaser.ScaleManager#isPortrait\n* @property {boolean} isPortrait\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"isPortrait\", {\n\n    get: function () {\n        return this.classifyOrientation(this.screenOrientation) === 'portrait';\n    }\n\n});\n\n/**\n* Returns true if the screen orientation is in landscape mode.\n*\n* @name Phaser.ScaleManager#isLandscape\n* @property {boolean} isLandscape\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"isLandscape\", {\n\n    get: function () {\n        return this.classifyOrientation(this.screenOrientation) === 'landscape';\n    }\n\n});\n\n/**\n* Returns true if the game dimensions are portrait (height > width).\n* This is especially useful to check when using the RESIZE scale mode \n* but wanting to maintain game orientation on desktop browsers, \n* where typically the screen orientation will always be landscape regardless of the browser viewport.\n*\n* @name Phaser.ScaleManager#isGamePortrait\n* @property {boolean} isGamePortrait\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"isGamePortrait\", {\n\n    get: function () {\n        return (this.height > this.width);\n    }\n\n});\n\n/**\n* Returns true if the game dimensions are landscape (width > height).\n* This is especially useful to check when using the RESIZE scale mode \n* but wanting to maintain game orientation on desktop browsers, \n* where typically the screen orientation will always be landscape regardless of the browser viewport.\n*\n* @name Phaser.ScaleManager#isGameLandscape\n* @property {boolean} isGameLandscape\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"isGameLandscape\", {\n\n    get: function () {\n        return (this.width > this.height);\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A collection of methods for displaying debug information about game objects.\n*\n* If your game is running in Canvas mode, then you should invoke all of the Debug methods from\n* your games `render` function. This is because they are drawn directly onto the game canvas\n* itself, so if you call any debug methods outside of `render` they are likely to be overwritten\n* by the game itself.\n* \n* If your game is running in WebGL then Debug will create a Sprite that is placed at the top of the Stage display list and bind a canvas texture\n* to it, which must be uploaded every frame. Be advised: this is very expensive, especially in browsers like Firefox. So please only enable Debug\n* in WebGL mode if you really need it (or your desktop can cope with it well) and disable it for production!\n*\n* @class Phaser.Utils.Debug\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Utils.Debug = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Image} sprite - If debugging in WebGL mode we need this.\n    */\n    this.sprite = null;\n\n    /**\n    * @property {Phaser.BitmapData} bmd - In WebGL mode this BitmapData contains a copy of the debug canvas.\n    */\n    this.bmd = null;\n\n    /**\n    * @property {HTMLCanvasElement} canvas - The canvas to which Debug calls draws.\n    */\n    this.canvas = null;\n\n    /**\n    * @property {CanvasRenderingContext2D} context - The 2d context of the canvas.\n    */\n    this.context = null;\n\n    /**\n    * @property {string} font - The font that the debug information is rendered in.\n    * @default '14px Courier'\n    */\n    this.font = '14px Courier';\n\n    /**\n    * @property {number} columnWidth - The spacing between columns.\n    */\n    this.columnWidth = 100;\n\n    /**\n    * @property {number} lineHeight - The line height between the debug text.\n    */\n    this.lineHeight = 16;\n\n    /**\n    * @property {boolean} renderShadow - Should the text be rendered with a slight shadow? Makes it easier to read on different types of background.\n    */\n    this.renderShadow = true;\n\n    /**\n    * @property {number} currentX - The current X position the debug information will be rendered at.\n    * @default\n    */\n    this.currentX = 0;\n\n    /**\n    * @property {number} currentY - The current Y position the debug information will be rendered at.\n    * @default\n    */\n    this.currentY = 0;\n\n    /**\n    * @property {number} currentAlpha - The alpha of the Debug context, set before all debug information is rendered to it.\n    * @default\n    */\n    this.currentAlpha = 1;\n\n    /**\n    * @property {boolean} dirty - Does the canvas need re-rendering?\n    */\n    this.dirty = false;\n\n};\n\nPhaser.Utils.Debug.prototype = {\n\n    /**\n    * Internal method that boots the debug displayer.\n    *\n    * @method Phaser.Utils.Debug#boot\n    * @protected\n    */\n    boot: function () {\n\n        if (this.game.renderType === Phaser.CANVAS)\n        {\n            this.context = this.game.context;\n        }\n        else\n        {\n            this.bmd = new Phaser.BitmapData(this.game, '__DEBUG', this.game.width, this.game.height, true);\n            this.sprite = this.game.make.image(0, 0, this.bmd);\n            this.game.stage.addChild(this.sprite);\n\n            this.game.scale.onSizeChange.add(this.resize, this);\n\n            this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height);\n            this.context = this.canvas.getContext('2d');\n        }\n\n    },\n\n    /**\n    * Internal method that resizes the BitmapData and Canvas.\n    * Called by ScaleManager.onSizeChange only in WebGL mode.\n    *\n    * @method Phaser.Utils.Debug#resize\n    * @protected\n    * @param {Phaser.ScaleManager} scaleManager - The Phaser ScaleManager.\n    * @param {number} width - The new width of the game.\n    * @param {number} height - The new height of the game.\n    */\n    resize: function (scaleManager, width, height) {\n\n        this.bmd.resize(width, height);\n\n        this.canvas.width = width;\n        this.canvas.height = height;\n\n    },\n\n    /**\n    * Internal method that clears the canvas (if a Sprite) ready for a new debug session.\n    *\n    * @method Phaser.Utils.Debug#preUpdate\n    * @protected\n    */\n    preUpdate: function () {\n\n        if (this.dirty && this.sprite)\n        {\n            this.bmd.clear();\n            this.bmd.draw(this.canvas, 0, 0);\n\n            this.context.clearRect(0, 0, this.game.width, this.game.height);\n            this.dirty = false;\n        }\n\n    },\n\n    /**\n    * Clears the Debug canvas.\n    *\n    * @method Phaser.Utils.Debug#reset\n    */\n    reset: function () {\n\n        if (this.context)\n        {\n            this.context.clearRect(0, 0, this.game.width, this.game.height);\n        }\n\n        if (this.sprite)\n        {\n            this.bmd.clear();\n        }\n\n    },\n\n    /**\n    * Internal method that resets and starts the debug output values.\n    *\n    * @method Phaser.Utils.Debug#start\n    * @protected\n    * @param {number} [x=0] - The X value the debug info will start from.\n    * @param {number} [y=0] - The Y value the debug info will start from.\n    * @param {string} [color='rgb(255,255,255)'] - The color the debug text will drawn in.\n    * @param {number} [columnWidth=0] - The spacing between columns.\n    */\n    start: function (x, y, color, columnWidth) {\n\n        if (typeof x !== 'number') { x = 0; }\n        if (typeof y !== 'number') { y = 0; }\n        color = color || 'rgb(255,255,255)';\n        if (columnWidth === undefined) { columnWidth = 0; }\n\n        this.currentX = x;\n        this.currentY = y;\n        this.currentColor = color;\n        this.columnWidth = columnWidth;\n\n        this.dirty = true;\n\n        this.context.save();\n        this.context.setTransform(1, 0, 0, 1, 0, 0);\n        this.context.strokeStyle = color;\n        this.context.fillStyle = color;\n        this.context.font = this.font;\n        this.context.globalAlpha = this.currentAlpha;\n\n    },\n\n    /**\n    * Internal method that stops the debug output.\n    *\n    * @method Phaser.Utils.Debug#stop\n    * @protected\n    */\n    stop: function () {\n\n        this.context.restore();\n\n    },\n\n    /**\n    * Internal method that outputs a single line of text split over as many columns as needed, one per parameter.\n    *\n    * @method Phaser.Utils.Debug#line\n    * @protected\n    */\n    line: function () {\n\n        var x = this.currentX;\n\n        for (var i = 0; i < arguments.length; i++)\n        {\n            if (this.renderShadow)\n            {\n                this.context.fillStyle = 'rgb(0,0,0)';\n                this.context.fillText(arguments[i], x + 1, this.currentY + 1);\n                this.context.fillStyle = this.currentColor;\n            }\n\n            this.context.fillText(arguments[i], x, this.currentY);\n\n            x += this.columnWidth;\n        }\n\n        this.currentY += this.lineHeight;\n\n    },\n\n    /**\n    * Render Sound information, including decoded state, duration, volume and more.\n    *\n    * @method Phaser.Utils.Debug#soundInfo\n    * @param {Phaser.Sound} sound - The sound object to debug.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    soundInfo: function (sound, x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Sound: ' + sound.key + ' Locked: ' + sound.game.sound.touchLocked);\n        this.line('Is Ready?: ' + this.game.cache.isSoundReady(sound.key) + ' Pending Playback: ' + sound.pendingPlayback);\n        this.line('Decoded: ' + sound.isDecoded + ' Decoding: ' + sound.isDecoding);\n        this.line('Total Duration: ' + sound.totalDuration + ' Playing: ' + sound.isPlaying);\n        this.line('Time: ' + sound.currentTime);\n        this.line('Volume: ' + sound.volume + ' Muted: ' + sound.mute);\n        this.line('WebAudio: ' + sound.usingWebAudio + ' Audio: ' + sound.usingAudioTag);\n\n        if (sound.currentMarker !== '')\n        {\n            this.line('Marker: ' + sound.currentMarker + ' Duration: ' + sound.duration + ' (ms: ' + sound.durationMS + ')');\n            this.line('Start: ' + sound.markers[sound.currentMarker].start + ' Stop: ' + sound.markers[sound.currentMarker].stop);\n            this.line('Position: ' + sound.position);\n        }\n\n        this.stop();\n\n    },\n\n    /**\n    * Render camera information including dimensions and location.\n    *\n    * @method Phaser.Utils.Debug#cameraInfo\n    * @param {Phaser.Camera} camera - The Phaser.Camera to show the debug information for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    cameraInfo: function (camera, x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Camera (' + camera.width + ' x ' + camera.height + ')');\n        this.line('X: ' + camera.x + ' Y: ' + camera.y);\n\n        if (camera.bounds)\n        {\n            this.line('Bounds x: ' + camera.bounds.x + ' Y: ' + camera.bounds.y + ' w: ' + camera.bounds.width + ' h: ' + camera.bounds.height);\n        }\n\n        this.line('View x: ' + camera.view.x + ' Y: ' + camera.view.y + ' w: ' + camera.view.width + ' h: ' + camera.view.height);\n        // this.line('Screen View x: ' + camera.screenView.x + ' Y: ' + camera.screenView.y + ' w: ' + camera.screenView.width + ' h: ' + camera.screenView.height);\n        this.line('Total in view: ' + camera.totalInView);\n        this.stop();\n\n    },\n\n    /**\n    * Render Timer information.\n    *\n    * @method Phaser.Utils.Debug#timer\n    * @param {Phaser.Timer} timer - The Phaser.Timer to show the debug information for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    timer: function (timer, x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Timer (running: ' + timer.running + ' expired: ' + timer.expired + ')');\n        this.line('Next Tick: ' + timer.next + ' Duration: ' + timer.duration);\n        this.line('Paused: ' + timer.paused + ' Length: ' + timer.length);\n        this.stop();\n\n    },\n\n    /**\n    * Renders the Pointer.circle object onto the stage in green if down or red if up along with debug text.\n    *\n    * @method Phaser.Utils.Debug#pointer\n    * @param {Phaser.Pointer} pointer - The Pointer you wish to display.\n    * @param {boolean} [hideIfUp=false] - Doesn't render the circle if the pointer is up.\n    * @param {string} [downColor='rgba(0,255,0,0.5)'] - The color the circle is rendered in if down.\n    * @param {string} [upColor='rgba(255,0,0,0.5)'] - The color the circle is rendered in if up (and hideIfUp is false).\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    pointer: function (pointer, hideIfUp, downColor, upColor, color) {\n\n        if (pointer == null)\n        {\n            return;\n        }\n\n        if (hideIfUp === undefined) { hideIfUp = false; }\n        downColor = downColor || 'rgba(0,255,0,0.5)';\n        upColor = upColor || 'rgba(255,0,0,0.5)';\n\n        if (hideIfUp === true && pointer.isUp === true)\n        {\n            return;\n        }\n\n        this.start(pointer.x, pointer.y - 100, color);\n        this.context.beginPath();\n        this.context.arc(pointer.x, pointer.y, pointer.circle.radius, 0, Math.PI * 2);\n\n        if (pointer.active)\n        {\n            this.context.fillStyle = downColor;\n        }\n        else\n        {\n            this.context.fillStyle = upColor;\n        }\n\n        this.context.fill();\n        this.context.closePath();\n\n        //  Render the points\n        this.context.beginPath();\n        this.context.moveTo(pointer.positionDown.x, pointer.positionDown.y);\n        this.context.lineTo(pointer.position.x, pointer.position.y);\n        this.context.lineWidth = 2;\n        this.context.stroke();\n        this.context.closePath();\n\n        //  Render the text\n        this.line('ID: ' + pointer.id + \" Active: \" + pointer.active);\n        this.line('World X: ' + pointer.worldX + \" World Y: \" + pointer.worldY);\n        this.line('Screen X: ' + pointer.x + \" Screen Y: \" + pointer.y + \" In: \" + pointer.withinGame);\n        this.line('Duration: ' + pointer.duration + \" ms\");\n        this.line('is Down: ' + pointer.isDown + \" is Up: \" + pointer.isUp);\n        this.stop();\n\n    },\n\n    /**\n    * Render Sprite Input Debug information.\n    *\n    * @method Phaser.Utils.Debug#spriteInputInfo\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite to display the input data for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    spriteInputInfo: function (sprite, x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Sprite Input: (' + sprite.width + ' x ' + sprite.height + ')');\n        this.line('x: ' + sprite.input.pointerX().toFixed(1) + ' y: ' + sprite.input.pointerY().toFixed(1));\n        this.line('over: ' + sprite.input.pointerOver() + ' duration: ' + sprite.input.overDuration().toFixed(0));\n        this.line('down: ' + sprite.input.pointerDown() + ' duration: ' + sprite.input.downDuration().toFixed(0));\n        this.line('just over: ' + sprite.input.justOver() + ' just out: ' + sprite.input.justOut());\n        this.stop();\n\n    },\n\n    /**\n    * Renders Phaser.Key object information.\n    *\n    * @method Phaser.Utils.Debug#key\n    * @param {Phaser.Key} key - The Key to render the information for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    key: function (key, x, y, color) {\n\n        this.start(x, y, color, 150);\n\n        this.line('Key:', key.keyCode, 'isDown:', key.isDown);\n        this.line('justDown:', key.justDown, 'justUp:', key.justUp);\n        this.line('Time Down:', key.timeDown.toFixed(0), 'duration:', key.duration.toFixed(0));\n\n        this.stop();\n\n    },\n\n    /**\n    * Render debug information about the Input object.\n    *\n    * @method Phaser.Utils.Debug#inputInfo\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    inputInfo: function (x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Input');\n        this.line('X: ' + this.game.input.x + ' Y: ' + this.game.input.y);\n        this.line('World X: ' + this.game.input.worldX + ' World Y: ' + this.game.input.worldY);\n        this.line('Scale X: ' + this.game.input.scale.x.toFixed(1) + ' Scale Y: ' + this.game.input.scale.x.toFixed(1));\n        this.line('Screen X: ' + this.game.input.activePointer.screenX + ' Screen Y: ' + this.game.input.activePointer.screenY);\n        this.stop();\n\n    },\n\n    /**\n    * Renders the Sprites bounds. Note: This is really expensive as it has to calculate the bounds every time you call it!\n    *\n    * @method Phaser.Utils.Debug#spriteBounds\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite to display the bounds of.\n    * @param {string} [color] - Color of the debug info to be rendered (format is css color string).\n    * @param {boolean} [filled=true] - Render the rectangle as a fillRect (default, true) or a strokeRect (false)\n    */\n    spriteBounds: function (sprite, color, filled) {\n\n        var bounds = sprite.getBounds();\n\n        bounds.x += this.game.camera.x;\n        bounds.y += this.game.camera.y;\n\n        this.rectangle(bounds, color, filled);\n\n    },\n\n    /**\n    * Renders the Rope's segments. Note: This is really expensive as it has to calculate new segments every time you call it\n    *\n    * @method Phaser.Utils.Debug#ropeSegments\n    * @param {Phaser.Rope} rope - The rope to display the segments of.\n    * @param {string} [color] - Color of the debug info to be rendered (format is css color string).\n    * @param {boolean} [filled=true] - Render the rectangle as a fillRect (default, true) or a strokeRect (false)\n    */\n    ropeSegments: function (rope, color, filled) {\n\n        var segments = rope.segments;\n\n        var self = this;\n\n        segments.forEach(function(segment) {\n            self.rectangle(segment, color, filled);\n        }, this);\n\n    },\n\n    /**\n    * Render debug infos (including name, bounds info, position and some other properties) about the Sprite.\n    *\n    * @method Phaser.Utils.Debug#spriteInfo\n    * @param {Phaser.Sprite} sprite - The Sprite to display the information of.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    spriteInfo: function (sprite, x, y, color) {\n\n        this.start(x, y, color);\n\n        this.line('Sprite: ' + ' (' + sprite.width + ' x ' + sprite.height + ') anchor: ' + sprite.anchor.x + ' x ' + sprite.anchor.y);\n        this.line('x: ' + sprite.x.toFixed(1) + ' y: ' + sprite.y.toFixed(1));\n        this.line('angle: ' + sprite.angle.toFixed(1) + ' rotation: ' + sprite.rotation.toFixed(1));\n        this.line('visible: ' + sprite.visible + ' in camera: ' + sprite.inCamera);\n        this.line('bounds x: ' + sprite._bounds.x.toFixed(1) + ' y: ' + sprite._bounds.y.toFixed(1) + ' w: ' + sprite._bounds.width.toFixed(1) + ' h: ' + sprite._bounds.height.toFixed(1));\n\n        this.stop();\n\n    },\n\n    /**\n    * Renders the sprite coordinates in local, positional and world space.\n    *\n    * @method Phaser.Utils.Debug#spriteCoords\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite to display the coordinates for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    spriteCoords: function (sprite, x, y, color) {\n\n        this.start(x, y, color, 100);\n\n        if (sprite.name)\n        {\n            this.line(sprite.name);\n        }\n\n        this.line('x:', sprite.x.toFixed(2), 'y:', sprite.y.toFixed(2));\n        this.line('pos x:', sprite.position.x.toFixed(2), 'pos y:', sprite.position.y.toFixed(2));\n        this.line('world x:', sprite.world.x.toFixed(2), 'world y:', sprite.world.y.toFixed(2));\n\n        this.stop();\n\n    },\n\n    /**\n    * Renders Line information in the given color.\n    *\n    * @method Phaser.Utils.Debug#lineInfo\n    * @param {Phaser.Line} line - The Line to display the data for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    lineInfo: function (line, x, y, color) {\n\n        this.start(x, y, color, 80);\n        this.line('start.x:', line.start.x.toFixed(2), 'start.y:', line.start.y.toFixed(2));\n        this.line('end.x:', line.end.x.toFixed(2), 'end.y:', line.end.y.toFixed(2));\n        this.line('length:', line.length.toFixed(2), 'angle:', line.angle);\n        this.stop();\n\n    },\n\n    /**\n    * Renders a single pixel at the given size.\n    *\n    * @method Phaser.Utils.Debug#pixel\n    * @param {number} x - X position of the pixel to be rendered.\n    * @param {number} y - Y position of the pixel to be rendered.\n    * @param {string} [color] - Color of the pixel (format is css color string).\n    * @param {number} [size=2] - The 'size' to render the pixel at.\n    */\n    pixel: function (x, y, color, size) {\n\n        size = size || 2;\n\n        this.start();\n        this.context.fillStyle = color;\n        this.context.fillRect(x, y, size, size);\n        this.stop();\n\n    },\n\n    /**\n    * Renders a Phaser geometry object including Rectangle, Circle, Point or Line.\n    *\n    * @method Phaser.Utils.Debug#geom\n    * @param {Phaser.Rectangle|Phaser.Circle|Phaser.Point|Phaser.Line} object - The geometry object to render.\n    * @param {string} [color] - Color of the debug info to be rendered (format is css color string).\n    * @param {boolean} [filled=true] - Render the objected as a filled (default, true) or a stroked (false)\n    * @param {number} [forceType=0] - Force rendering of a specific type. If 0 no type will be forced, otherwise 1 = Rectangle, 2 = Circle, 3 = Point and 4 = Line.\n    */\n    geom: function (object, color, filled, forceType) {\n\n        if (filled === undefined) { filled = true; }\n        if (forceType === undefined) { forceType = 0; }\n\n        color = color || 'rgba(0,255,0,0.4)';\n\n        this.start();\n\n        this.context.fillStyle = color;\n        this.context.strokeStyle = color;\n\n        if (object instanceof Phaser.Rectangle || forceType === 1)\n        {\n            if (filled)\n            {\n                this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);\n            }\n            else\n            {\n                this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);\n            }\n        }\n        else if (object instanceof Phaser.Circle || forceType === 2)\n        {\n            this.context.beginPath();\n            this.context.arc(object.x - this.game.camera.x, object.y - this.game.camera.y, object.radius, 0, Math.PI * 2, false);\n            this.context.closePath();\n\n            if (filled)\n            {\n                this.context.fill();\n            }\n            else\n            {\n                this.context.stroke();\n            }\n        }\n        else if (object instanceof Phaser.Point || forceType === 3)\n        {\n            this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, 4, 4);\n        }\n        else if (object instanceof Phaser.Line || forceType === 4)\n        {\n            this.context.lineWidth = 1;\n            this.context.beginPath();\n            this.context.moveTo((object.start.x + 0.5) - this.game.camera.x, (object.start.y + 0.5) - this.game.camera.y);\n            this.context.lineTo((object.end.x + 0.5) - this.game.camera.x, (object.end.y + 0.5) - this.game.camera.y);\n            this.context.closePath();\n            this.context.stroke();\n        }\n\n        this.stop();\n\n    },\n\n    /**\n    * Renders a Rectangle.\n    *\n    * @method Phaser.Utils.Debug#geom\n    * @param {Phaser.Rectangle|object} object - The geometry object to render.\n    * @param {string} [color] - Color of the debug info to be rendered (format is css color string).\n    * @param {boolean} [filled=true] - Render the objected as a filled (default, true) or a stroked (false)\n    */\n    rectangle: function (object, color, filled) {\n\n        if (filled === undefined) { filled = true; }\n\n        color = color || 'rgba(0, 255, 0, 0.4)';\n\n        this.start();\n\n        if (filled)\n        {\n            this.context.fillStyle = color;\n            this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);\n        }\n        else\n        {\n            this.context.strokeStyle = color;\n            this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);\n        }\n\n        this.stop();\n\n    },\n\n    /**\n    * Render a string of text.\n    *\n    * @method Phaser.Utils.Debug#text\n    * @param {string} text - The line of text to draw.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color] - Color of the debug info to be rendered (format is css color string).\n    * @param {string} [font] - The font of text to draw.\n    */\n    text: function (text, x, y, color, font) {\n\n        color = color || 'rgb(255,255,255)';\n        font = font || '16px Courier';\n\n        this.start();\n        this.context.font = font;\n\n        if (this.renderShadow)\n        {\n            this.context.fillStyle = 'rgb(0,0,0)';\n            this.context.fillText(text, x + 1, y + 1);\n        }\n\n        this.context.fillStyle = color;\n        this.context.fillText(text, x, y);\n\n        this.stop();\n\n    },\n\n    /**\n    * Visually renders a QuadTree to the display.\n    *\n    * @method Phaser.Utils.Debug#quadTree\n    * @param {Phaser.QuadTree} quadtree - The quadtree to render.\n    * @param {string} color - The color of the lines in the quadtree.\n    */\n    quadTree: function (quadtree, color) {\n\n        color = color || 'rgba(255,0,0,0.3)';\n\n        this.start();\n\n        var bounds = quadtree.bounds;\n\n        if (quadtree.nodes.length === 0)\n        {\n            this.context.strokeStyle = color;\n            this.context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);\n            this.text('size: ' + quadtree.objects.length, bounds.x + 4, bounds.y + 16, 'rgb(0,200,0)', '12px Courier');\n\n            this.context.strokeStyle = 'rgb(0,255,0)';\n\n            for (var i = 0; i < quadtree.objects.length; i++)\n            {\n                this.context.strokeRect(quadtree.objects[i].x, quadtree.objects[i].y, quadtree.objects[i].width, quadtree.objects[i].height);\n            }\n        }\n        else\n        {\n            for (var i = 0; i < quadtree.nodes.length; i++)\n            {\n                this.quadTree(quadtree.nodes[i]);\n            }\n        }\n\n        this.stop();\n\n    },\n\n    /**\n    * Render a Sprites Physics body if it has one set. The body is rendered as a filled or stroked rectangle.\n    * This only works for Arcade Physics, Ninja Physics (AABB and Circle only) and Box2D Physics bodies.\n    * To display a P2 Physics body you should enable debug mode on the body when creating it.\n    *\n    * @method Phaser.Utils.Debug#body\n    * @param {Phaser.Sprite} sprite - The Sprite who's body will be rendered.\n    * @param {string} [color='rgba(0,255,0,0.4)'] - Color of the debug rectangle to be rendered. The format is a CSS color string such as '#ff0000' or 'rgba(255,0,0,0.5)'.\n    * @param {boolean} [filled=true] - Render the body as a filled rectangle (true) or a stroked rectangle (false)\n    */\n    body: function (sprite, color, filled) {\n\n        if (sprite.body)\n        {\n            this.start();\n\n            if (sprite.body.type === Phaser.Physics.ARCADE)\n            {\n                Phaser.Physics.Arcade.Body.render(this.context, sprite.body, color, filled);\n            }\n            else if (sprite.body.type === Phaser.Physics.NINJA)\n            {\n                Phaser.Physics.Ninja.Body.render(this.context, sprite.body, color, filled);\n            }\n            else if (sprite.body.type === Phaser.Physics.BOX2D)\n            {\n                Phaser.Physics.Box2D.renderBody(this.context, sprite.body, color);\n            }\n\n            this.stop();\n        }\n\n    },\n\n    /**\n    * Render a Sprites Physic Body information.\n    *\n    * @method Phaser.Utils.Debug#bodyInfo\n    * @param {Phaser.Sprite} sprite - The sprite to be rendered.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    bodyInfo: function (sprite, x, y, color) {\n\n        if (sprite.body)\n        {\n            this.start(x, y, color, 210);\n\n            if (sprite.body.type === Phaser.Physics.ARCADE)\n            {\n                Phaser.Physics.Arcade.Body.renderBodyInfo(this, sprite.body);\n            }\n            else if (sprite.body.type === Phaser.Physics.BOX2D)\n            {\n                this.game.physics.box2d.renderBodyInfo(this, sprite.body);\n            }\n\n            this.stop();\n        }\n\n    },\n\n    /**\n    * Renders 'debug draw' data for the Box2D world if it exists.\n    * This uses the standard debug drawing feature of Box2D, so colors will be decided by\n    * the Box2D engine.\n    *\n    * @method Phaser.Utils.Debug#box2dWorld\n    */\n    box2dWorld: function () {\n    \n        this.start();\n        \n        this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0);\n        this.context.rotate(this.game.world.rotation);\n        this.game.physics.box2d.renderDebugDraw(this.context);\n        \n        this.stop();\n\n    },\n\n    /**\n    * Renders 'debug draw' data for the given Box2D body.\n    * This uses the standard debug drawing feature of Box2D, so colors will be decided by the Box2D engine.\n    *\n    * @method Phaser.Utils.Debug#box2dBody\n    * @param {Phaser.Sprite} sprite - The sprite whos body will be rendered.\n    * @param {string} [color='rgb(0,255,0)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    box2dBody: function (body, color) {\n    \n        this.start();\n        this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0);\n        this.context.scale(this.game.world.scale.x, this.game.world.scale.y);\n        this.context.rotate(this.game.world.rotation);\n        Phaser.Physics.Box2D.renderBody(this.context, body, color);\n        this.stop();\n\n    },\n\n    /**\n    * Call this function from the Dev Tools console.\n    * \n    * It will scan the display list and output all of the Objects it finds, and their renderOrderIDs.\n    *\n    * **Note** Requires a browser that supports console.group and console.groupEnd (such as Chrome)\n    *\n    * @method displayList\n    * @param {Object} [displayObject] - The displayObject level display object to start from. Defaults to the World.\n    */\n    displayList: function (displayObject) {\n\n        if (displayObject === undefined) { displayObject = this.game.world; }\n\n        if (displayObject.hasOwnProperty('renderOrderID'))\n        {\n            console.log('[' + displayObject.renderOrderID + ']', displayObject);\n        }\n        else\n        {\n            console.log('[]', displayObject);\n        }\n\n        if (displayObject.children && displayObject.children.length > 0)\n        {\n            for (var i = 0; i < displayObject.children.length; i++)\n            {\n                this.game.debug.displayList(displayObject.children[i]);\n            }\n        }\n\n    },\n\n    /**\n    * Destroy this object.\n    *\n    * @method Phaser.Utils.Debug#destroy\n    */\n    destroy: function () {\n    \n        PIXI.CanvasPool.remove(this);\n\n    }\n\n};\n\nPhaser.Utils.Debug.prototype.constructor = Phaser.Utils.Debug;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* DOM utility class.\n*\n* Provides a useful Window and Element functions as well as cross-browser compatibility buffer.\n*\n* Some code originally derived from {@link https://github.com/ryanve/verge verge}.\n* Some parts were inspired by the research of Ryan Van Etten, released under MIT License 2013.\n* \n* @class Phaser.DOM\n* @static\n*/\nPhaser.DOM = {\n\n    /**\n    * Get the [absolute] position of the element relative to the Document.\n    *\n    * The value may vary slightly as the page is scrolled due to rounding errors.\n    *\n    * @method Phaser.DOM.getOffset\n    * @param {DOMElement} element - The targeted element that we want to retrieve the offset.\n    * @param {Phaser.Point} [point] - The point we want to take the x/y values of the offset.\n    * @return {Phaser.Point} - A point objet with the offsetX and Y as its properties.\n    */\n    getOffset: function (element, point) {\n\n        point = point || new Phaser.Point();\n\n        var box = element.getBoundingClientRect();\n\n        var scrollTop = Phaser.DOM.scrollY;\n        var scrollLeft = Phaser.DOM.scrollX;\n        var clientTop = document.documentElement.clientTop;\n        var clientLeft = document.documentElement.clientLeft;\n\n        point.x = box.left + scrollLeft - clientLeft;\n        point.y = box.top + scrollTop - clientTop;\n\n        return point;\n\n    },\n\n    /**\n    * A cross-browser element.getBoundingClientRect method with optional cushion.\n    * \n    * Returns a plain object containing the properties `top/bottom/left/right/width/height` with respect to the top-left corner of the current viewport.\n    * Its properties match the native rectangle.\n    * The cushion parameter is an amount of pixels (+/-) to cushion the element.\n    * It adjusts the measurements such that it is possible to detect when an element is near the viewport.\n    * \n    * @method Phaser.DOM.getBounds\n    * @param {DOMElement|Object} element - The element or stack (uses first item) to get the bounds for.\n    * @param {number} [cushion] - A +/- pixel adjustment amount.\n    * @return {Object|boolean} A plain object containing the properties `top/bottom/left/right/width/height` or `false` if a non-valid element is given.\n    */\n    getBounds: function (element, cushion) {\n\n        if (cushion === undefined) { cushion = 0; }\n\n        element = element && !element.nodeType ? element[0] : element;\n\n        if (!element || element.nodeType !== 1)\n        {\n            return false;\n        }\n        else\n        {\n            return this.calibrate(element.getBoundingClientRect(), cushion);\n        }\n\n    },\n\n    /**\n    * Calibrates element coordinates for `inLayoutViewport` checks.\n    *\n    * @method Phaser.DOM.calibrate\n    * @private\n    * @param {object} coords - An object containing the following properties: `{top: number, right: number, bottom: number, left: number}`\n    * @param {number} [cushion] - A value to adjust the coordinates by.\n    * @return {object} The calibrated element coordinates\n    */\n    calibrate: function (coords, cushion) {\n\n        cushion = +cushion || 0;\n\n        var output = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0 };\n\n        output.width = (output.right = coords.right + cushion) - (output.left = coords.left - cushion);\n        output.height = (output.bottom = coords.bottom + cushion) - (output.top = coords.top - cushion);\n\n        return output;\n\n    },\n\n    /**\n    * Get the Visual viewport aspect ratio (or the aspect ratio of an object or element)    \n    * \n    * @method Phaser.DOM.getAspectRatio\n    * @param {(DOMElement|Object)} [object=(visualViewport)] - The object to determine the aspect ratio for. Must have public `width` and `height` properties or methods.\n    * @return {number} The aspect ratio.\n    */\n    getAspectRatio: function (object) {\n\n        object = null == object ? this.visualBounds : 1 === object.nodeType ? this.getBounds(object) : object;\n\n        var w = object['width'];\n        var h = object['height'];\n\n        if (typeof w === 'function')\n        {\n            w = w.call(object);\n        }\n\n        if (typeof h === 'function')\n        {\n            h = h.call(object);\n        }\n\n        return w / h;\n\n    },\n\n    /**\n    * Tests if the given DOM element is within the Layout viewport.\n    * \n    * The optional cushion parameter allows you to specify a distance.\n    * \n    * inLayoutViewport(element, 100) is `true` if the element is in the viewport or 100px near it.\n    * inLayoutViewport(element, -100) is `true` if the element is in the viewport or at least 100px near it.\n    * \n    * @method Phaser.DOM.inLayoutViewport\n    * @param {DOMElement|Object} element - The DOM element to check. If no element is given it defaults to the Phaser game canvas.\n    * @param {number} [cushion] - The cushion allows you to specify a distance within which the element must be within the viewport.\n    * @return {boolean} True if the element is within the viewport, or within `cushion` distance from it.\n    */\n    inLayoutViewport: function (element, cushion) {\n\n        var r = this.getBounds(element, cushion);\n\n        return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= this.layoutBounds.width && r.left <= this.layoutBounds.height;\n\n    },\n\n    /**\n    * Returns the device screen orientation.\n    *\n    * Orientation values: 'portrait-primary', 'landscape-primary', 'portrait-secondary', 'landscape-secondary'.\n    *\n    * Order of resolving:\n    * - Screen Orientation API, or variation of - Future track. Most desktop and mobile browsers.\n    * - Screen size ratio check - If fallback is 'screen', suited for desktops.\n    * - Viewport size ratio check - If fallback is 'viewport', suited for mobile.\n    * - window.orientation - If fallback is 'window.orientation', works iOS and probably most Android; non-recommended track.\n    * - Media query\n    * - Viewport size ratio check (probably only IE9 and legacy mobile gets here..)\n    *\n    * See\n    * - https://w3c.github.io/screen-orientation/ (conflicts with mozOrientation/msOrientation)\n    * - https://developer.mozilla.org/en-US/docs/Web/API/Screen.orientation (mozOrientation)\n    * - http://msdn.microsoft.com/en-us/library/ie/dn342934(v=vs.85).aspx\n    * - https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Testing_media_queries\n    * - http://stackoverflow.com/questions/4917664/detect-viewport-orientation\n    * - http://www.matthewgifford.com/blog/2011/12/22/a-misconception-about-window-orientation\n    *\n    * @method Phaser.DOM.getScreenOrientation\n    * @protected\n    * @param {string} [primaryFallback=(none)] - Specify 'screen', 'viewport', or 'window.orientation'.\n    */\n    getScreenOrientation: function (primaryFallback) {\n\n        var screen = window.screen;\n        var orientation = screen.orientation || screen.mozOrientation || screen.msOrientation;\n\n        if (orientation && typeof orientation.type === 'string')\n        {\n            // Screen Orientation API specification\n            return orientation.type;\n        }\n        else if (typeof orientation === 'string')\n        {\n            // moz/ms-orientation are strings\n            return orientation;\n        }\n\n        var PORTRAIT = 'portrait-primary';\n        var LANDSCAPE = 'landscape-primary';\n        \n        if (primaryFallback === 'screen')\n        {\n            return (screen.height > screen.width) ? PORTRAIT : LANDSCAPE;\n        }\n        else if (primaryFallback === 'viewport')\n        {\n            return (this.visualBounds.height > this.visualBounds.width) ? PORTRAIT : LANDSCAPE;\n        }\n        else if (primaryFallback === 'window.orientation' && typeof window.orientation === 'number')\n        {\n            // This may change by device based on \"natural\" orientation.\n            return (window.orientation === 0 || window.orientation === 180) ? PORTRAIT : LANDSCAPE;\n        }\n        else if (window.matchMedia)\n        {\n            if (window.matchMedia(\"(orientation: portrait)\").matches)\n            {\n                return PORTRAIT;\n            }\n            else if (window.matchMedia(\"(orientation: landscape)\").matches)\n            {\n                return LANDSCAPE;\n            }\n        }\n\n        return (this.visualBounds.height > this.visualBounds.width) ? PORTRAIT : LANDSCAPE;\n\n    },\n\n    /**\n    * The bounds of the Visual viewport, as discussed in \n    * {@link http://www.quirksmode.org/mobile/viewports.html A tale of two viewports — part one}\n    * with one difference: the viewport size _excludes_ scrollbars, as found on some desktop browsers.   \n    *\n    * Supported mobile:\n    *   iOS/Safari, Android 4, IE10, Firefox OS (maybe not Firefox Android), Opera Mobile 16\n    *\n    * The properties change dynamically.\n    *\n    * @type {Phaser.Rectangle}\n    * @property {number} x - Scroll, left offset - eg. \"scrollX\"\n    * @property {number} y - Scroll, top offset - eg. \"scrollY\"\n    * @property {number} width - Viewport width in pixels.\n    * @property {number} height - Viewport height in pixels.\n    * @readonly\n    */\n    visualBounds: new Phaser.Rectangle(),\n\n    /**\n    * The bounds of the Layout viewport, as discussed in \n    * {@link http://www.quirksmode.org/mobile/viewports2.html A tale of two viewports — part two};\n    * but honoring the constraints as specified applicable viewport meta-tag.\n    *\n    * The bounds returned are not guaranteed to be fully aligned with CSS media queries (see\n    * {@link http://www.matanich.com/2013/01/07/viewport-size/ What size is my viewport?}).\n    *\n    * This is _not_ representative of the Visual bounds: in particular the non-primary axis will\n    * generally be significantly larger than the screen height on mobile devices when running with a\n    * constrained viewport.\n    *\n    * The properties change dynamically.\n    *\n    * @type {Phaser.Rectangle}\n    * @property {number} width - Viewport width in pixels.\n    * @property {number} height - Viewport height in pixels.\n    * @readonly\n    */\n    layoutBounds: new Phaser.Rectangle(),\n\n    /**\n    * The size of the document / Layout viewport.\n    *\n    * This incorrectly reports the dimensions in IE.\n    *\n    * The properties change dynamically.\n    *\n    * @type {Phaser.Rectangle}\n    * @property {number} width - Document width in pixels.\n    * @property {number} height - Document height in pixels.\n    * @readonly\n    */\n    documentBounds: new Phaser.Rectangle()\n\n};\n\nPhaser.Device.whenReady(function (device) {\n\n    // All target browsers should support page[XY]Offset.\n    var scrollX = window && ('pageXOffset' in window) ?\n        function () { return window.pageXOffset; } :\n        function () { return document.documentElement.scrollLeft; };\n\n    var scrollY = window && ('pageYOffset' in window) ?\n        function () { return window.pageYOffset; } :\n        function () { return document.documentElement.scrollTop; };\n\n    /**\n    * A cross-browser window.scrollX.\n    *\n    * @name Phaser.DOM.scrollX\n    * @property {number} scrollX\n    * @readonly\n    * @protected\n    */\n    Object.defineProperty(Phaser.DOM, \"scrollX\", {\n        get: scrollX\n    });\n\n    /**\n    * A cross-browser window.scrollY.\n    *\n    * @name Phaser.DOM.scrollY\n    * @property {number} scrollY\n    * @readonly\n    * @protected\n    */\n    Object.defineProperty(Phaser.DOM, \"scrollY\", {\n        get: scrollY\n    });\n\n    Object.defineProperty(Phaser.DOM.visualBounds, \"x\", {\n        get: scrollX\n    });\n\n    Object.defineProperty(Phaser.DOM.visualBounds, \"y\", {\n        get: scrollY\n    });\n\n    Object.defineProperty(Phaser.DOM.layoutBounds, \"x\", {\n        value: 0\n    });\n\n    Object.defineProperty(Phaser.DOM.layoutBounds, \"y\", {\n        value: 0\n    });\n\n    var treatAsDesktop = device.desktop &&\n        (document.documentElement.clientWidth <= window.innerWidth) &&\n        (document.documentElement.clientHeight <= window.innerHeight);\n\n    // Desktop browsers align the layout viewport with the visual viewport.\n    // This differs from mobile browsers with their zooming design.\n    // Ref. http://quirksmode.org/mobile/tableViewport.html  \n    if (treatAsDesktop)\n    {\n\n        // PST- When scrollbars are not included this causes upstream issues in ScaleManager.\n        // So reverted to the old \"include scrollbars.\"\n        var clientWidth = function () {\n            return Math.max(window.innerWidth, document.documentElement.clientWidth);\n        };\n        var clientHeight = function () {\n            return Math.max(window.innerHeight, document.documentElement.clientHeight);\n        };\n\n        // Interested in area sans-scrollbar\n        Object.defineProperty(Phaser.DOM.visualBounds, \"width\", {\n            get: clientWidth\n        });\n\n        Object.defineProperty(Phaser.DOM.visualBounds, \"height\", {\n            get: clientHeight\n        });\n\n        Object.defineProperty(Phaser.DOM.layoutBounds, \"width\", {\n            get: clientWidth\n        });\n\n        Object.defineProperty(Phaser.DOM.layoutBounds, \"height\", {\n            get: clientHeight\n        });\n\n    } else {\n\n        Object.defineProperty(Phaser.DOM.visualBounds, \"width\", {\n            get: function () {\n                return window.innerWidth;\n            }\n        });\n\n        Object.defineProperty(Phaser.DOM.visualBounds, \"height\", {\n            get: function () {\n                return window.innerHeight;\n            }\n        });\n\n        Object.defineProperty(Phaser.DOM.layoutBounds, \"width\", {\n\n            get: function () {\n                var a = document.documentElement.clientWidth;\n                var b = window.innerWidth;\n\n                return a < b ? b : a; // max\n            }\n\n        });\n\n        Object.defineProperty(Phaser.DOM.layoutBounds, \"height\", {\n\n            get: function () {\n                var a = document.documentElement.clientHeight;\n                var b = window.innerHeight;\n\n                return a < b ? b : a; // max\n            }\n\n        });\n\n    }\n\n    // For Phaser.DOM.documentBounds\n    // Ref. http://www.quirksmode.org/mobile/tableViewport_desktop.html\n\n    Object.defineProperty(Phaser.DOM.documentBounds, \"x\", {\n        value: 0\n    });\n\n    Object.defineProperty(Phaser.DOM.documentBounds, \"y\", {\n        value: 0\n    });\n\n    Object.defineProperty(Phaser.DOM.documentBounds, \"width\", {\n\n        get: function () {\n            var d = document.documentElement;\n            return Math.max(d.clientWidth, d.offsetWidth, d.scrollWidth);\n        }\n\n    });\n\n    Object.defineProperty(Phaser.DOM.documentBounds, \"height\", {\n\n        get: function () {\n            var d = document.documentElement;\n            return Math.max(d.clientHeight, d.offsetHeight, d.scrollHeight);\n        }\n\n    });\n\n}, null, true);\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* ArraySet is a Set data structure (items must be unique within the set) that also maintains order.\n* This allows specific items to be easily added or removed from the Set.\n*\n* Item equality (and uniqueness) is determined by the behavior of `Array.indexOf`.\n*\n* This used primarily by the Input subsystem.\n*\n* @class Phaser.ArraySet\n* @constructor\n* @param {any[]} [list=(new array)] - The backing array: if specified the items in the list _must_ be unique, per `Array.indexOf`, and the ownership of the array _should_ be relinquished to the ArraySet.\n*/\nPhaser.ArraySet = function (list) {\n\n    /**\n    * Current cursor position as established by `first` and `next`.\n    * @property {integer} position\n    * @default\n    */\n    this.position = 0;\n\n    /**\n    * The backing array.\n    * @property {any[]} list\n    */\n    this.list = list || [];\n\n};\n\nPhaser.ArraySet.prototype = {\n\n    /**\n    * Adds a new element to the end of the list.\n    * If the item already exists in the list it is not moved.\n    *\n    * @method Phaser.ArraySet#add\n    * @param {any} item - The element to add to this list.\n    * @return {any} The item that was added.\n    */\n    add: function (item) {\n\n        if (!this.exists(item))\n        {\n            this.list.push(item);\n        }\n\n        return item;\n\n    },\n\n    /**\n    * Gets the index of the item in the list, or -1 if it isn't in the list.\n    *\n    * @method Phaser.ArraySet#getIndex\n    * @param {any} item - The element to get the list index for.\n    * @return {integer} The index of the item or -1 if not found.\n    */\n    getIndex: function (item) {\n\n        return this.list.indexOf(item);\n\n    },\n\n    /**\n    * Gets an item from the set based on the property strictly equaling the value given.\n    * Returns null if not found.\n    *\n    * @method Phaser.ArraySet#getByKey\n    * @param {string} property - The property to check against the value.\n    * @param {any} value - The value to check if the property strictly equals.\n    * @return {any} The item that was found, or null if nothing matched.\n    */\n    getByKey: function (property, value) {\n\n        var i = this.list.length;\n\n        while (i--)\n        {\n            if (this.list[i][property] === value)\n            {\n                return this.list[i];\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Checks for the item within this list.\n    *\n    * @method Phaser.ArraySet#exists\n    * @param {any} item - The element to get the list index for.\n    * @return {boolean} True if the item is found in the list, otherwise false.\n    */\n    exists: function (item) {\n\n        return (this.list.indexOf(item) > -1);\n\n    },\n\n    /**\n    * Removes all the items.\n    *\n    * @method Phaser.ArraySet#reset\n    */\n    reset: function () {\n\n        this.list.length = 0;\n\n    },\n\n    /**\n    * Removes the given element from this list if it exists.\n    *\n    * @method Phaser.ArraySet#remove\n    * @param {any} item - The item to be removed from the list.\n    * @return {any} item - The item that was removed.\n    */\n    remove: function (item) {\n\n        var idx = this.list.indexOf(item);\n\n        if (idx > -1)\n        {\n            this.list.splice(idx, 1);\n            return item;\n        }\n\n    },\n\n    /**\n    * Sets the property `key` to the given value on all members of this list.\n    *\n    * @method Phaser.ArraySet#setAll\n    * @param {any} key - The property of the item to set.\n    * @param {any} value - The value to set the property to.\n    */\n    setAll: function (key, value) {\n\n        var i = this.list.length;\n\n        while (i--)\n        {\n            if (this.list[i])\n            {\n                this.list[i][key] = value;\n            }\n        }\n\n    },\n\n    /**\n    * Calls a function on all members of this list, using the member as the context for the callback.\n    *\n    * If the `key` property is present it must be a function.\n    * The function is invoked using the item as the context.\n    *\n    * @method Phaser.ArraySet#callAll\n    * @param {string} key - The name of the property with the function to call.\n    * @param {...*} parameter - Additional parameters that will be passed to the callback.\n    */\n    callAll: function (key) {\n\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        var i = this.list.length;\n\n        while (i--)\n        {\n            if (this.list[i] && this.list[i][key])\n            {\n                this.list[i][key].apply(this.list[i], args);\n            }\n        }\n\n    },\n\n    /**\n    * Removes every member from this ArraySet and optionally destroys it.\n    *\n    * @method Phaser.ArraySet#removeAll\n    * @param {boolean} [destroy=false] - Call `destroy` on each member as it's removed from this set.\n    */\n    removeAll: function (destroy) {\n\n        if (destroy === undefined) { destroy = false; }\n\n        var i = this.list.length;\n\n        while (i--)\n        {\n            if (this.list[i])\n            {\n                var item = this.remove(this.list[i]);\n\n                if (destroy)\n                {\n                    item.destroy();\n                }\n            }\n        }\n\n        this.position = 0;\n        this.list = [];\n\n    }\n\n};\n\n/**\n* Number of items in the ArraySet. Same as `list.length`.\n*\n* @name Phaser.ArraySet#total\n* @property {integer} total\n*/\nObject.defineProperty(Phaser.ArraySet.prototype, \"total\", {\n\n    get: function () {\n        return this.list.length;\n    }\n\n});\n\n/**\n* Returns the first item and resets the cursor to the start.\n*\n* @name Phaser.ArraySet#first\n* @property {any} first\n*/\nObject.defineProperty(Phaser.ArraySet.prototype, \"first\", {\n\n    get: function () {\n\n        this.position = 0;\n\n        if (this.list.length > 0)\n        {\n            return this.list[0];\n        }\n        else\n        {\n            return null;\n        }\n\n    }\n\n});\n\n/**\n* Returns the the next item (based on the cursor) and advances the cursor.\n*\n* @name Phaser.ArraySet#next\n* @property {any} next\n*/\nObject.defineProperty(Phaser.ArraySet.prototype, \"next\", {\n\n    get: function () {\n\n        if (this.position < this.list.length)\n        {\n            this.position++;\n\n            return this.list[this.position];\n        }\n        else\n        {\n            return null;\n        }\n\n    }\n\n});\n\nPhaser.ArraySet.prototype.constructor = Phaser.ArraySet;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Utility functions for dealing with Arrays.\n*\n* @class Phaser.ArrayUtils\n* @static\n*/\nPhaser.ArrayUtils = {\n\n    /**\n    * Fetch a random entry from the given array.\n    *\n    * Will return null if there are no array items that fall within the specified range\n    * or if there is no item for the randomly chosen index.\n    *\n    * @method\n    * @param {any[]} objects - An array of objects.\n    * @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.\n    * @param {integer} length - Optional restriction on the number of values you want to randomly select from.\n    * @return {object} The random object that was selected.\n    */\n    getRandomItem: function (objects, startIndex, length) {\n\n        if (objects === null) { return null; }\n        if (startIndex === undefined) { startIndex = 0; }\n        if (length === undefined) { length = objects.length; }\n\n        var randomIndex = startIndex + Math.floor(Math.random() * length);\n\n        return objects[randomIndex] === undefined ? null : objects[randomIndex];\n\n    },\n\n    /**\n    * Removes a random object from the given array and returns it.\n    *\n    * Will return null if there are no array items that fall within the specified range\n    * or if there is no item for the randomly chosen index.\n    *\n    * @method\n    * @param {any[]} objects - An array of objects.\n    * @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.\n    * @param {integer} length - Optional restriction on the number of values you want to randomly select from.\n    * @return {object} The random object that was removed.\n    */\n    removeRandomItem: function (objects, startIndex, length) {\n\n        if (objects == null) { // undefined or null\n            return null;\n        }\n\n        if (startIndex === undefined) { startIndex = 0; }\n        if (length === undefined) { length = objects.length; }\n\n        var randomIndex = startIndex + Math.floor(Math.random() * length);\n        if (randomIndex < objects.length)\n        {\n            var removed = objects.splice(randomIndex, 1);\n            return removed[0] === undefined ? null : removed[0];\n        }\n        else\n        {\n            return null;\n        }\n\n    },\n\n    /**\n    * A standard Fisher-Yates Array shuffle implementation which modifies the array in place.\n    *\n    * @method\n    * @param {any[]} array - The array to shuffle.\n    * @return {any[]} The original array, now shuffled.\n    */\n    shuffle: function (array) {\n\n        for (var i = array.length - 1; i > 0; i--)\n        {\n            var j = Math.floor(Math.random() * (i + 1));\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n\n        return array;\n\n    },\n\n    /**\n    * Transposes the elements of the given matrix (array of arrays).\n    *\n    * @method\n    * @param {Array<any[]>} array - The matrix to transpose.\n    * @return {Array<any[]>} A new transposed matrix\n    */\n    transposeMatrix: function (array) {\n\n        var sourceRowCount = array.length;\n        var sourceColCount = array[0].length;\n\n        var result = new Array(sourceColCount);\n\n        for (var i = 0; i < sourceColCount; i++)\n        {\n            result[i] = new Array(sourceRowCount);\n\n            for (var j = sourceRowCount - 1; j > -1; j--)\n            {\n                result[i][j] = array[j][i];\n            }\n        }\n\n        return result;\n\n    },\n\n    /**\n    * Rotates the given matrix (array of arrays).\n    *\n    * Based on the routine from {@link http://jsfiddle.net/MrPolywhirl/NH42z/}.\n    *\n    * @method\n    * @param {Array<any[]>} matrix - The array to rotate; this matrix _may_ be altered.\n    * @param {number|string} direction - The amount to rotate: the rotation in degrees (90, -90, 270, -270, 180) or a string command ('rotateLeft', 'rotateRight' or 'rotate180').\n    * @return {Array<any[]>} The rotated matrix. The source matrix should be discarded for the returned matrix.\n    */\n    rotateMatrix: function (matrix, direction) {\n\n        if (typeof direction !== 'string')\n        {\n            direction = ((direction % 360) + 360) % 360;\n        }\n\n        if (direction === 90 || direction === -270 || direction === 'rotateLeft')\n        {\n            matrix = Phaser.ArrayUtils.transposeMatrix(matrix);\n            matrix = matrix.reverse();\n        }\n        else if (direction === -90 || direction === 270 || direction === 'rotateRight')\n        {\n            matrix = matrix.reverse();\n            matrix = Phaser.ArrayUtils.transposeMatrix(matrix);\n        }\n        else if (Math.abs(direction) === 180 || direction === 'rotate180')\n        {\n            for (var i = 0; i < matrix.length; i++)\n            {\n                matrix[i].reverse();\n            }\n\n            matrix = matrix.reverse();\n        }\n\n        return matrix;\n\n    },\n\n    /**\n    * Snaps a value to the nearest value in an array.\n    * The result will always be in the range `[first_value, last_value]`.\n    *\n    * @method\n    * @param {number} value - The search value\n    * @param {number[]} arr - The input array which _must_ be sorted.\n    * @return {number} The nearest value found.\n    */\n    findClosest: function (value, arr) {\n\n        if (!arr.length)\n        {\n            return NaN;\n        }\n        else if (arr.length === 1 || value < arr[0])\n        {\n            return arr[0];\n        }\n\n        var i = 1;\n        while (arr[i] < value) {\n            i++;\n        }\n\n        var low = arr[i - 1];\n        var high = (i < arr.length) ? arr[i] : Number.POSITIVE_INFINITY;\n\n        return ((high - value) <= (value - low)) ? high : low;\n\n    },\n\n    /**\n    * Moves the element from the end of the array to the start, shifting all items in the process.\n    * The \"rotation\" happens to the right.\n    *\n    * Before: `[ A, B, C, D, E, F ]`\n    * After: `[ F, A, B, C, D, E ]`\n    * \n    * See also Phaser.ArrayUtils.rotateLeft.\n    *\n    * @method Phaser.ArrayUtils.rotateRight\n    * @param {any[]} array - The array to rotate. The array is modified.\n    * @return {any} The shifted value.\n    */\n    rotateRight: function (array) {\n\n        var s = array.pop();\n        array.unshift(s);\n\n        return s;\n\n    },\n\n    /**\n    * Moves the element from the start of the array to the end, shifting all items in the process.\n    * The \"rotation\" happens to the left.\n    *\n    * Before: `[ A, B, C, D, E, F ]`\n    * After: `[ B, C, D, E, F, A ]`\n    * \n    * See also Phaser.ArrayUtils.rotateRight\n    *\n    * @method Phaser.ArrayUtils.rotateLeft\n    * @param {any[]} array - The array to rotate. The array is modified.\n    * @return {any} The rotated value.\n    */\n    rotateLeft: function (array) {\n\n        var s = array.shift();\n        array.push(s);\n\n        return s;\n\n    },\n\n    /**\n    * Moves the element from the start of the array to the end, shifting all items in the process.\n    * The \"rotation\" happens to the left.\n    *\n    * Before: `[ A, B, C, D, E, F ]`\n    * After: `[ B, C, D, E, F, A ]`\n    * \n    * See also Phaser.ArrayUtils.rotateRight\n    *\n    * @method Phaser.ArrayUtils.rotate\n    * @deprecated Please use Phaser.ArrayUtils.rotate instead.\n    * @param {any[]} array - The array to rotate. The array is modified.\n    * @return {any} The rotated value.\n    */\n    rotate: function (array) {\n\n        var s = array.shift();\n        array.push(s);\n\n        return s;\n\n    },\n\n    /**\n    * Create an array representing the inclusive range of numbers (usually integers) in `[start, end]`.\n    * This is equivalent to `numberArrayStep(start, end, 1)`.\n    *\n    * @method Phaser.ArrayUtils#numberArray\n    * @param {number} start - The minimum value the array starts with.\n    * @param {number} end - The maximum value the array contains.\n    * @return {number[]} The array of number values.\n    */\n    numberArray: function (start, end) {\n\n        var result = [];\n\n        for (var i = start; i <= end; i++)\n        {\n            result.push(i);\n        }\n\n        return result;\n\n    },\n\n    /**\n    * Create an array of numbers (positive and/or negative) progressing from `start`\n    * up to but not including `end` by advancing by `step`.\n    *\n    * If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.\n    *\n    * Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;\n    * for forward compatibility make sure to pass in actual numbers.\n    *\n    * @method Phaser.ArrayUtils#numberArrayStep\n    * @param {number} start - The start of the range.\n    * @param {number} [end] - The end of the range.\n    * @param {number} [step=1] - The value to increment or decrement by.\n    * @returns {Array} Returns the new array of numbers.\n    * @example\n    * Phaser.ArrayUtils.numberArrayStep(4);\n    * // => [0, 1, 2, 3]\n    *\n    * Phaser.ArrayUtils.numberArrayStep(1, 5);\n    * // => [1, 2, 3, 4]\n    *\n    * Phaser.ArrayUtils.numberArrayStep(0, 20, 5);\n    * // => [0, 5, 10, 15]\n    *\n    * Phaser.ArrayUtils.numberArrayStep(0, -4, -1);\n    * // => [0, -1, -2, -3]\n    *\n    * Phaser.ArrayUtils.numberArrayStep(1, 4, 0);\n    * // => [1, 1, 1]\n    *\n    * Phaser.ArrayUtils.numberArrayStep(0);\n    * // => []\n    */\n    numberArrayStep: function (start, end, step) {\n\n        if (start === undefined || start === null) { start = 0; }\n\n        if (end === undefined || end === null)\n        {\n            end = start;\n            start = 0;\n        }\n\n        if (step === undefined) { step = 1; }\n\n        var result = [];\n        var total = Math.max(Phaser.Math.roundAwayFromZero((end - start) / (step || 1)), 0);\n\n        for (var i = 0; i < total; i++)\n        {\n            result.push(start);\n            start += step;\n        }\n\n        return result;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A basic Linked List data structure.\n*\n* This implementation _modifies_ the `prev` and `next` properties of each item added:\n* - The `prev` and `next` properties must be writable and should not be used for any other purpose.\n* - Items _cannot_ be added to multiple LinkedLists at the same time.\n* - Only objects can be added.\n*\n* @class Phaser.LinkedList\n* @constructor\n*/\nPhaser.LinkedList = function () {\n\n    /**\n    * Next element in the list.\n    * @property {object} next\n    * @default\n    */\n    this.next = null;\n\n    /**\n    * Previous element in the list.\n    * @property {object} prev\n    * @default\n    */\n    this.prev = null;\n\n    /**\n    * First element in the list.\n    * @property {object} first\n    * @default\n    */\n    this.first = null;\n\n    /**\n    * Last element in the list.\n    * @property {object} last\n    * @default\n    */\n    this.last = null;\n\n    /**\n    * Number of elements in the list.\n    * @property {integer} total\n    * @default\n    */\n    this.total = 0;\n\n};\n\nPhaser.LinkedList.prototype = {\n\n    /**\n    * Adds a new element to this linked list.\n    *\n    * @method Phaser.LinkedList#add\n    * @param {object} item - The element to add to this list. Can be a Phaser.Sprite or any other object you need to quickly iterate through.\n    * @return {object} The item that was added.\n    */\n    add: function (item) {\n\n        //  If the list is empty\n        if (this.total === 0 && this.first === null && this.last === null)\n        {\n            this.first = item;\n            this.last = item;\n            this.next = item;\n            item.prev = this;\n            this.total++;\n            return item;\n        }\n\n        //  Gets appended to the end of the list, regardless of anything, and it won't have any children of its own (non-nested list)\n        this.last.next = item;\n\n        item.prev = this.last;\n\n        this.last = item;\n\n        this.total++;\n\n        return item;\n\n    },\n\n    /**\n    * Resets the first, last, next and previous node pointers in this list.\n    *\n    * @method Phaser.LinkedList#reset\n    */\n    reset: function () {\n\n        this.first = null;\n        this.last = null;\n        this.next = null;\n        this.prev = null;\n        this.total = 0;\n\n    },\n\n    /**\n    * Removes the given element from this linked list if it exists.\n    *\n    * @method Phaser.LinkedList#remove\n    * @param {object} item - The item to be removed from the list.\n    */\n    remove: function (item) {\n\n        if (this.total === 1)\n        {\n            this.reset();\n            item.next = item.prev = null;\n            return;\n        }\n\n        if (item === this.first)\n        {\n            // It was 'first', make 'first' point to first.next\n            this.first = this.first.next;\n        }\n        else if (item === this.last)\n        {\n            // It was 'last', make 'last' point to last.prev\n            this.last = this.last.prev;\n        }\n\n        if (item.prev)\n        {\n            // make item.prev.next point to childs.next instead of item\n            item.prev.next = item.next;\n        }\n\n        if (item.next)\n        {\n            // make item.next.prev point to item.prev instead of item\n            item.next.prev = item.prev;\n        }\n\n        item.next = item.prev = null;\n\n        if (this.first === null )\n        {\n            this.last = null;\n        }\n\n        this.total--;\n\n    },\n\n    /**\n    * Calls a function on all members of this list, using the member as the context for the callback.\n    * The function must exist on the member.\n    *\n    * @method Phaser.LinkedList#callAll\n    * @param {function} callback - The function to call.\n    */\n    callAll: function (callback) {\n\n        if (!this.first || !this.last)\n        {\n            return;\n        }\n\n        var entity = this.first;\n\n        do\n        {\n            if (entity && entity[callback])\n            {\n                entity[callback].call(entity);\n            }\n\n            entity = entity.next;\n\n        }\n        while (entity !== this.last.next);\n\n    }\n\n};\n\nPhaser.LinkedList.prototype.constructor = Phaser.LinkedList;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Phaser.Create class is a collection of smaller helper methods that allow you to generate game content\n* quickly and easily, without the need for any external files. You can create textures for sprites and in\n* coming releases we'll add dynamic sound effect generation support as well (like sfxr).\n*\n* Access this via `Game.create` (`this.game.create` from within a State object)\n* \n* @class Phaser.Create\n* @constructor\n* @param {Phaser.Game} game - Game reference to the currently running game.\n */\nPhaser.Create = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.BitmapData} bmd - The internal BitmapData Create uses to generate textures from.\n    */\n    this.bmd = null;\n\n    /**\n    * @property {HTMLCanvasElement} canvas - The canvas the BitmapData uses.\n    */\n    this.canvas = null;\n\n    /**\n    * @property {CanvasRenderingContext2D} context - The 2d context of the canvas.\n    */\n    this.ctx = null;\n\n    /**\n    * @property {array} palettes - A range of 16 color palettes for use with sprite generation.\n    */\n    this.palettes = [\n        { 0: '#000', 1: '#9D9D9D', 2: '#FFF', 3: '#BE2633', 4: '#E06F8B', 5: '#493C2B', 6: '#A46422', 7: '#EB8931', 8: '#F7E26B', 9: '#2F484E', A: '#44891A', B: '#A3CE27', C: '#1B2632', D: '#005784', E: '#31A2F2', F: '#B2DCEF' },\n        { 0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#f5f4eb' },\n        { 0: '#000', 1: '#2234d1', 2: '#0c7e45', 3: '#44aacc', 4: '#8a3622', 5: '#5c2e78', 6: '#aa5c3d', 7: '#b5b5b5', 8: '#5e606e', 9: '#4c81fb', A: '#6cd947', B: '#7be2f9', C: '#eb8a60', D: '#e23d69', E: '#ffd93f', F: '#fff' },\n        { 0: '#000', 1: '#fff', 2: '#8b4131', 3: '#7bbdc5', 4: '#8b41ac', 5: '#6aac41', 6: '#3931a4', 7: '#d5de73', 8: '#945a20', 9: '#5a4100', A: '#bd736a', B: '#525252', C: '#838383', D: '#acee8b', E: '#7b73de', F: '#acacac' },\n        { 0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#fff' }\n    ];\n\n};\n\n/**\n* A 16 color palette by [Arne](http://androidarts.com/palette/16pal.htm)\n* @constant\n* @type {number}\n*/\nPhaser.Create.PALETTE_ARNE = 0;\n\n/**\n* A 16 color JMP inspired palette.\n* @constant\n* @type {number}\n*/\nPhaser.Create.PALETTE_JMP = 1;\n\n/**\n* A 16 color CGA inspired palette.\n* @constant\n* @type {number}\n*/\nPhaser.Create.PALETTE_CGA = 2;\n\n/**\n* A 16 color C64 inspired palette.\n* @constant\n* @type {number}\n*/\nPhaser.Create.PALETTE_C64 = 3;\n\n/**\n* A 16 color palette inspired by Japanese computers like the MSX.\n* @constant\n* @type {number}\n*/\nPhaser.Create.PALETTE_JAPANESE_MACHINE = 4;\n\nPhaser.Create.prototype = {\n\n    /**\n     * Generates a new PIXI.Texture from the given data, which can be applied to a Sprite.\n     *\n     * This allows you to create game graphics quickly and easily, with no external files but that use actual proper images\n     * rather than Phaser.Graphics objects, which are expensive to render and limited in scope.\n     *\n     * Each element of the array is a string holding the pixel color values, as mapped to one of the Phaser.Create PALETTE consts.\n     *\n     * For example:\n     *\n     * `var data = [\n     *   ' 333 ',\n     *   ' 777 ',\n     *   'E333E',\n     *   ' 333 ',\n     *   ' 3 3 '\n     * ];`\n     *\n     * `game.create.texture('bob', data);`\n     *\n     * The above will create a new texture called `bob`, which will look like a little man wearing a hat. You can then use it\n     * for sprites the same way you use any other texture: `game.add.sprite(0, 0, 'bob');`\n     *\n     * @method Phaser.Create#texture\n     * @param {string} key - The key used to store this texture in the Phaser Cache.\n     * @param {array} data - An array of pixel data.\n     * @param {integer} [pixelWidth=8] - The width of each pixel.\n     * @param {integer} [pixelHeight=8] - The height of each pixel.\n     * @param {integer} [palette=0] - The palette to use when rendering the texture. One of the Phaser.Create.PALETTE consts.\n     * @return {PIXI.Texture} The newly generated texture.\n     */\n    texture: function (key, data, pixelWidth, pixelHeight, palette) {\n\n        if (pixelWidth === undefined) { pixelWidth = 8; }\n        if (pixelHeight === undefined) { pixelHeight = pixelWidth; }\n        if (palette === undefined) { palette = 0; }\n\n        var w = data[0].length * pixelWidth;\n        var h = data.length * pixelHeight;\n\n        //  No bmd? Let's make one\n        if (this.bmd === null)\n        {\n            this.bmd = this.game.make.bitmapData();\n            this.canvas = this.bmd.canvas;\n            this.ctx = this.bmd.context;\n        }\n\n        this.bmd.resize(w, h);\n        this.bmd.clear();\n\n        //  Draw it\n        for (var y = 0; y < data.length; y++)\n        {\n            var row = data[y];\n\n            for (var x = 0; x < row.length; x++)\n            {\n                var d = row[x];\n\n                if (d !== '.' && d !== ' ')\n                {\n                    this.ctx.fillStyle = this.palettes[palette][d];\n                    this.ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);\n                }\n            }\n        }\n\n        return this.bmd.generateTexture(key);\n\n    },\n\n    /**\n     * Creates a grid texture based on the given dimensions.\n     *\n     * @method Phaser.Create#grid\n     * @param {string} key - The key used to store this texture in the Phaser Cache.\n     * @param {integer} width - The width of the grid in pixels.\n     * @param {integer} height - The height of the grid in pixels.\n     * @param {integer} cellWidth - The width of the grid cells in pixels.\n     * @param {integer} cellHeight - The height of the grid cells in pixels.\n     * @param {string} color - The color to draw the grid lines in. Should be a Canvas supported color string like `#ff5500` or `rgba(200,50,3,0.5)`.\n     * @return {PIXI.Texture} The newly generated texture.\n     */\n    grid: function (key, width, height, cellWidth, cellHeight, color) {\n\n        //  No bmd? Let's make one\n        if (this.bmd === null)\n        {\n            this.bmd = this.game.make.bitmapData();\n            this.canvas = this.bmd.canvas;\n            this.ctx = this.bmd.context;\n        }\n\n        this.bmd.resize(width, height);\n\n        this.ctx.fillStyle = color;\n\n        for (var y = 0; y < height; y += cellHeight)\n        {\n            this.ctx.fillRect(0, y, width, 1);\n        }\n\n        for (var x = 0; x < width; x += cellWidth)\n        {\n            this.ctx.fillRect(x, 0, 1, height);\n        }\n\n        return this.bmd.generateTexture(key);\n\n    }\n\n};\n\nPhaser.Create.prototype.constructor = Phaser.Create;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Phaser.Color class is a set of static methods that assist in color manipulation and conversion.\n*\n* @class Phaser.Color\n*/\nPhaser.Color = {\n\n    /**\n    * Packs the r, g, b, a components into a single integer, for use with Int32Array.\n    * If device is little endian then ABGR order is used. Otherwise RGBA order is used.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.packPixel\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {number} a - The alpha color component, in the range 0 - 255.\n    * @return {number} The packed color as uint32\n    */\n    packPixel: function (r, g, b, a) {\n\n        if (Phaser.Device.LITTLE_ENDIAN)\n        {\n            return ( (a << 24) | (b << 16) | (g <<  8) | r ) >>> 0;\n        }\n        else\n        {\n            return ( (r << 24) | (g << 16) | (b <<  8) | a ) >>> 0;\n        }\n\n    },\n\n    /**\n    * Unpacks the r, g, b, a components into the specified color object, or a new\n    * object, for use with Int32Array. If little endian, then ABGR order is used when\n    * unpacking, otherwise, RGBA order is used. The resulting color object has the\n    * `r, g, b, a` properties which are unrelated to endianness.\n    *\n    * Note that the integer is assumed to be packed in the correct endianness. On little-endian\n    * the format is 0xAABBGGRR and on big-endian the format is 0xRRGGBBAA. If you want a\n    * endian-independent method, use fromRGBA(rgba) and toRGBA(r, g, b, a).\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.unpackPixel\n    * @static\n    * @param {number} rgba - The integer, packed in endian order by packPixel.\n    * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.\n    * @param {boolean} [hsl=false] - Also convert the rgb values into hsl?\n    * @param {boolean} [hsv=false] - Also convert the rgb values into hsv?\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    unpackPixel: function (rgba, out, hsl, hsv) {\n\n        if (out === undefined || out === null) { out = Phaser.Color.createColor(); }\n        if (hsl === undefined || hsl === null) { hsl = false; }\n        if (hsv === undefined || hsv === null) { hsv = false; }\n\n        if (Phaser.Device.LITTLE_ENDIAN)\n        {\n            out.a = ((rgba & 0xff000000) >>> 24);\n            out.b = ((rgba & 0x00ff0000) >>> 16);\n            out.g = ((rgba & 0x0000ff00) >>> 8);\n            out.r = ((rgba & 0x000000ff));\n        }\n        else\n        {\n            out.r = ((rgba & 0xff000000) >>> 24);\n            out.g = ((rgba & 0x00ff0000) >>> 16);\n            out.b = ((rgba & 0x0000ff00) >>> 8);\n            out.a = ((rgba & 0x000000ff));\n        }\n\n        out.color = rgba;\n        out.rgba = 'rgba(' + out.r + ',' + out.g + ',' + out.b + ',' + (out.a / 255) + ')';\n\n        if (hsl)\n        {\n            Phaser.Color.RGBtoHSL(out.r, out.g, out.b, out);\n        }\n\n        if (hsv)\n        {\n            Phaser.Color.RGBtoHSV(out.r, out.g, out.b, out);\n        }\n\n        return out;\n\n    },\n\n    /**\n    * A utility to convert an integer in 0xRRGGBBAA format to a color object.\n    * This does not rely on endianness.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.fromRGBA\n    * @static\n    * @param {number} rgba - An RGBA hex\n    * @param {object} [out] - The object to use, optional.\n    * @return {object} A color object.\n    */\n    fromRGBA: function (rgba, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor();\n        }\n\n        out.r = ((rgba & 0xff000000) >>> 24);\n        out.g = ((rgba & 0x00ff0000) >>> 16);\n        out.b = ((rgba & 0x0000ff00) >>> 8);\n        out.a = ((rgba & 0x000000ff));\n\n        out.rgba = 'rgba(' + out.r + ',' + out.g + ',' + out.b + ',' + out.a + ')';\n\n        return out;\n\n    },\n\n    /**\n    * A utility to convert RGBA components to a 32 bit integer in RRGGBBAA format.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.toRGBA\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {number} a - The alpha color component, in the range 0 - 255.\n    * @return {number} A RGBA-packed 32 bit integer\n    */\n    toRGBA: function (r, g, b, a) {\n\n        return (r << 24) | (g << 16) | (b <<  8) | a;\n\n    },\n\n    /**\n    * Converts RGBA components to a 32 bit integer in AABBGGRR format.\n    *\n    * @method Phaser.Color.toABGR\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {number} a - The alpha color component, in the range 0 - 255.\n    * @return {number} A RGBA-packed 32 bit integer\n    */\n    toABGR: function (r, g, b, a) {\n\n        return ((a << 24) | (b << 16) | (g << 8) | r) >>> 0;\n\n    },\n\n    /**\n    * Converts an RGB color value to HSL (hue, saturation and lightness).\n    * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\n    * Assumes RGB values are contained in the set [0, 255] and returns h, s and l in the set [0, 1].\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.RGBtoHSL\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {object} [out] - An object into which 3 properties will be created, h, s and l. If not provided a new object will be created.\n    * @return {object} An object with the hue, saturation and lightness values set in the h, s and l properties.\n    */\n    RGBtoHSL: function (r, g, b, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor(r, g, b, 1);\n        }\n\n        r /= 255;\n        g /= 255;\n        b /= 255;\n\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n\n        // achromatic by default\n        out.h = 0;\n        out.s = 0;\n        out.l = (max + min) / 2;\n\n        if (max !== min)\n        {\n            var d = max - min;\n\n            out.s = out.l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            if (max === r)\n            {\n                out.h = (g - b) / d + (g < b ? 6 : 0);\n            }\n            else if (max === g)\n            {\n                out.h = (b - r) / d + 2;\n            }\n            else if (max === b)\n            {\n                out.h = (r - g) / d + 4;\n            }\n\n            out.h /= 6;\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Converts an HSL (hue, saturation and lightness) color value to RGB.\n    * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\n    * Assumes HSL values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.HSLtoRGB\n    * @static\n    * @param {number} h - The hue, in the range 0 - 1.\n    * @param {number} s - The saturation, in the range 0 - 1.\n    * @param {number} l - The lightness, in the range 0 - 1.\n    * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    HSLtoRGB: function (h, s, l, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor(l, l, l);\n        }\n        else\n        {\n            // achromatic by default\n            out.r = l;\n            out.g = l;\n            out.b = l;\n        }\n\n        if (s !== 0)\n        {\n            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            var p = 2 * l - q;\n            out.r = Phaser.Color.hueToColor(p, q, h + 1 / 3);\n            out.g = Phaser.Color.hueToColor(p, q, h);\n            out.b = Phaser.Color.hueToColor(p, q, h - 1 / 3);\n        }\n\n        // out.r = (out.r * 255 | 0);\n        // out.g = (out.g * 255 | 0);\n        // out.b = (out.b * 255 | 0);\n\n        out.r = Math.floor((out.r * 255 | 0));\n        out.g = Math.floor((out.g * 255 | 0));\n        out.b = Math.floor((out.b * 255 | 0));\n\n        Phaser.Color.updateColor(out);\n\n        return out;\n\n    },\n\n    /**\n    * Converts an RGB color value to HSV (hue, saturation and value).\n    * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\n    * Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.RGBtoHSV\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {object} [out] - An object into which 3 properties will be created, h, s and v. If not provided a new object will be created.\n    * @return {object} An object with the hue, saturation and value set in the h, s and v properties.\n    */\n    RGBtoHSV: function (r, g, b, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor(r, g, b, 255);\n        }\n\n        r /= 255;\n        g /= 255;\n        b /= 255;\n\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n        var d = max - min;\n\n        // achromatic by default\n        out.h = 0;\n        out.s = max === 0 ? 0 : d / max;\n        out.v = max;\n\n        if (max !== min)\n        {\n            if (max === r)\n            {\n                out.h = (g - b) / d + (g < b ? 6 : 0);\n            }\n            else if (max === g)\n            {\n                out.h = (b - r) / d + 2;\n            }\n            else if (max === b)\n            {\n                out.h = (r - g) / d + 4;\n            }\n\n            out.h /= 6;\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Converts an HSV (hue, saturation and value) color value to RGB.\n    * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\n    * Assumes HSV values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.HSVtoRGB\n    * @static\n    * @param {number} h - The hue, in the range 0 - 1.\n    * @param {number} s - The saturation, in the range 0 - 1.\n    * @param {number} v - The value, in the range 0 - 1.\n    * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    HSVtoRGB: function (h, s, v, out) {\n\n        if (out === undefined) { out = Phaser.Color.createColor(0, 0, 0, 1, h, s, 0, v); }\n\n        var r, g, b;\n        var i = Math.floor(h * 6);\n        var f = h * 6 - i;\n        var p = v * (1 - s);\n        var q = v * (1 - f * s);\n        var t = v * (1 - (1 - f) * s);\n\n        switch (i % 6)\n        {\n            case 0:\n                r = v;\n                g = t;\n                b = p;\n                break;\n            case 1:\n                r = q;\n                g = v;\n                b = p;\n                break;\n            case 2:\n                r = p;\n                g = v;\n                b = t;\n                break;\n            case 3:\n                r = p;\n                g = q;\n                b = v;\n                break;\n            case 4:\n                r = t;\n                g = p;\n                b = v;\n                break;\n            case 5:\n                r = v;\n                g = p;\n                b = q;\n                break;\n        }\n\n        out.r = Math.floor(r * 255);\n        out.g = Math.floor(g * 255);\n        out.b = Math.floor(b * 255);\n\n        Phaser.Color.updateColor(out);\n\n        return out;\n\n    },\n\n    /**\n    * Converts a hue to an RGB color.\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.hueToColor\n    * @static\n    * @param {number} p\n    * @param {number} q\n    * @param {number} t\n    * @return {number} The color component value.\n    */\n    hueToColor: function (p, q, t) {\n\n        if (t < 0)\n        {\n            t += 1;\n        }\n\n        if (t > 1)\n        {\n            t -= 1;\n        }\n\n        if (t < 1 / 6)\n        {\n            return p + (q - p) * 6 * t;\n        }\n\n        if (t < 1 / 2)\n        {\n            return q;\n        }\n\n        if (t < 2 / 3)\n        {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n\n        return p;\n\n    },\n\n    /**\n    * A utility function to create a lightweight 'color' object with the default components.\n    * Any components that are not specified will default to zero.\n    *\n    * This is useful when you want to use a shared color object for the getPixel and getPixelAt methods.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.createColor\n    * @static\n    * @param {number} [r=0] - The red color component, in the range 0 - 255.\n    * @param {number} [g=0] - The green color component, in the range 0 - 255.\n    * @param {number} [b=0] - The blue color component, in the range 0 - 255.\n    * @param {number} [a=1] - The alpha color component, in the range 0 - 1.\n    * @param {number} [h=0] - The hue, in the range 0 - 1.\n    * @param {number} [s=0] - The saturation, in the range 0 - 1.\n    * @param {number} [l=0] - The lightness, in the range 0 - 1.\n    * @param {number} [v=0] - The value, in the range 0 - 1.\n    * @return {object} The resulting object with r, g, b, a properties and h, s, l and v.\n    */\n    createColor: function (r, g, b, a, h, s, l, v) {\n\n        var out = { r: r || 0, g: g || 0, b: b || 0, a: a || 1, h: h || 0, s: s || 0, l: l || 0, v: v || 0, color: 0, color32: 0, rgba: '' };\n\n        return Phaser.Color.updateColor(out);\n\n    },\n\n    /**\n    * Takes a color object and updates the rgba, color and color32 properties.\n    *\n    * @method Phaser.Color.updateColor\n    * @static\n    * @param {object} out - The color object to update.\n    * @returns {number} A native color value integer (format: 0xAARRGGBB).\n    */\n    updateColor: function (out) {\n\n        out.rgba = 'rgba(' + out.r.toString() + ',' + out.g.toString() + ',' + out.b.toString() + ',' + out.a.toString() + ')';\n        out.color = Phaser.Color.getColor(out.r, out.g, out.b);\n        out.color32 = Phaser.Color.getColor32(out.a * 255, out.r, out.g, out.b);\n\n        return out;\n\n    },\n\n    /**\n    * Given an alpha and 3 color values this will return an integer representation of it.\n    *\n    * @method Phaser.Color.getColor32\n    * @static\n    * @param {number} a - The alpha color component, in the range 0 - 255.\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @returns {number} A native color value integer (format: 0xAARRGGBB).\n    */\n    getColor32: function (a, r, g, b) {\n\n        return a << 24 | r << 16 | g << 8 | b;\n\n    },\n\n    /**\n    * Given 3 color values this will return an integer representation of it.\n    *\n    * @method Phaser.Color.getColor\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @returns {number} A native color value integer (format: 0xRRGGBB).\n    */\n    getColor: function (r, g, b) {\n\n        return r << 16 | g << 8 | b;\n\n    },\n\n    /**\n    * Converts the given color values into a string.\n    * If prefix was '#' it will be in the format `#RRGGBB` otherwise `0xAARRGGBB`.\n    *\n    * @method Phaser.Color.RGBtoString\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {number} [a=255] - The alpha color component, in the range 0 - 255.\n    * @param {string} [prefix='#'] - The prefix used in the return string. If '#' it will return `#RRGGBB`, else `0xAARRGGBB`.\n    * @return {string} A string containing the color values. If prefix was '#' it will be in the format `#RRGGBB` otherwise `0xAARRGGBB`.\n    */\n    RGBtoString: function (r, g, b, a, prefix) {\n\n        if (a === undefined) { a = 255; }\n        if (prefix === undefined) { prefix = '#'; }\n\n        if (prefix === '#')\n        {\n            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n        }\n        else\n        {\n            return '0x' + Phaser.Color.componentToHex(a) + Phaser.Color.componentToHex(r) + Phaser.Color.componentToHex(g) + Phaser.Color.componentToHex(b);\n        }\n\n    },\n\n    /**\n    * Converts a hex string into an integer color value.\n    *\n    * @method Phaser.Color.hexToRGB\n    * @static\n    * @param {string} hex - The hex string to convert. Can be in the short-hand format `#03f` or `#0033ff`.\n    * @return {number} The rgb color value in the format 0xAARRGGBB.\n    */\n    hexToRGB: function (hex) {\n\n        var rgb = Phaser.Color.hexToColor(hex);\n\n        if (rgb)\n        {\n            return Phaser.Color.getColor32(rgb.a, rgb.r, rgb.g, rgb.b);\n        }\n\n    },\n\n    /**\n    * Converts a hex string into a Phaser Color object.\n    *\n    * The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional \"#\" or \"0x\", or be unprefixed.    \n    *\n    * An alpha channel is _not_ supported.\n    *\n    * @method Phaser.Color.hexToColor\n    * @static\n    * @param {string} hex - The color string in a hex format.\n    * @param {object} [out] - An object into which 3 properties will be created or set: r, g and b. If not provided a new object will be created.\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    hexToColor: function (hex, out) {\n\n        // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n        hex = hex.replace(/^(?:#|0x)?([a-f\\d])([a-f\\d])([a-f\\d])$/i, function(m, r, g, b) {\n            return r + r + g + g + b + b;\n        });\n\n        var result = /^(?:#|0x)?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n        if (result)\n        {\n            var r = parseInt(result[1], 16);\n            var g = parseInt(result[2], 16);\n            var b = parseInt(result[3], 16);\n\n            if (!out)\n            {\n                out = Phaser.Color.createColor(r, g, b);\n            }\n            else\n            {\n                out.r = r;\n                out.g = g;\n                out.b = b;\n            }\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Converts a CSS 'web' string into a Phaser Color object.\n    *\n    * The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].\n    *\n    * @method Phaser.Color.webToColor\n    * @static\n    * @param {string} web - The color string in CSS 'web' format.\n    * @param {object} [out] - An object into which 4 properties will be created: r, g, b and a. If not provided a new object will be created.\n    * @return {object} An object with the red, green, blue and alpha values set in the r, g, b and a properties.\n    */\n    webToColor: function (web, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor();\n        }\n\n        var result = /^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d+(?:\\.\\d+)?))?\\s*\\)$/.exec(web);\n\n        if (result)\n        {\n            out.r = parseInt(result[1], 10);\n            out.g = parseInt(result[2], 10);\n            out.b = parseInt(result[3], 10);\n            out.a = result[4] !== undefined ? parseFloat(result[4]) : 1;\n            Phaser.Color.updateColor(out);\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Converts a value - a \"hex\" string, a \"CSS 'web' string\", or a number - into red, green, blue, and alpha components.\n    *\n    * The value can be a string (see `hexToColor` and `webToColor` for the supported formats) or a packed integer (see `getRGB`).\n    *\n    * An alpha channel is _not_ supported when specifying a hex string.\n    *\n    * @method Phaser.Color.valueToColor\n    * @static\n    * @param {string|number} value - The color expressed as a recognized string format or a packed integer.\n    * @param {object} [out] - The object to use for the output. If not provided a new object will be created.\n    * @return {object} The (`out`) object with the red, green, blue, and alpha values set as the r/g/b/a properties.\n    */\n    valueToColor: function (value, out) {\n\n        //  The behavior is not consistent between hexToColor/webToColor on invalid input.\n        //  This unifies both by returning a new object, but returning null may be better.\n        if (!out)\n        {\n            out = Phaser.Color.createColor();\n        }\n\n        if (typeof value === 'string')\n        {\n            if (value.indexOf('rgb') === 0)\n            {\n                return Phaser.Color.webToColor(value, out);\n            }\n            else\n            {\n                //  `hexToColor` does not support alpha; match `createColor`.\n                out.a = 1;\n                return Phaser.Color.hexToColor(value, out);\n            }\n        }\n        else if (typeof value === 'number')\n        {\n            //  `getRGB` does not take optional object to modify;\n            //  alpha is also adjusted to match `createColor`.\n            var tempColor = Phaser.Color.getRGB(value);\n            out.r = tempColor.r;\n            out.g = tempColor.g;\n            out.b = tempColor.b;\n            out.a = tempColor.a / 255;\n            return out;\n        }\n        else\n        {\n            return out;\n        }\n\n    },\n\n    /**\n    * Return a string containing a hex representation of the given color component.\n    *\n    * @method Phaser.Color.componentToHex\n    * @static\n    * @param {number} color - The color channel to get the hex value for, must be a value between 0 and 255.\n    * @returns {string} A string of length 2 characters, i.e. 255 = ff, 100 = 64.\n    */\n    componentToHex: function (color) {\n\n        var hex = color.toString(16);\n\n        return (hex.length === 1) ? '0' + hex : hex;\n\n    },\n\n    /**\n    * Get HSV color wheel values in an array which will be 360 elements in size.\n    *\n    * @method Phaser.Color.HSVColorWheel\n    * @static\n    * @param {number} [s=1] - The saturation, in the range 0 - 1.\n    * @param {number} [v=1] - The value, in the range 0 - 1.\n    * @return {array} An array containing 360 elements corresponding to the HSV color wheel.\n    */\n    HSVColorWheel: function (s, v) {\n\n        if (s === undefined) { s = 1.0; }\n        if (v === undefined) { v = 1.0; }\n\n        var colors = [];\n\n        for (var c = 0; c <= 359; c++)\n        {\n            colors.push(Phaser.Color.HSVtoRGB(c / 359, s, v));\n        }\n\n        return colors;\n\n    },\n\n    /**\n    * Get HSL color wheel values in an array which will be 360 elements in size.\n    *\n    * @method Phaser.Color.HSLColorWheel\n    * @static\n    * @param {number} [s=0.5] - The saturation, in the range 0 - 1.\n    * @param {number} [l=0.5] - The lightness, in the range 0 - 1.\n    * @return {array} An array containing 360 elements corresponding to the HSL color wheel.\n    */\n    HSLColorWheel: function (s, l) {\n\n        if (s === undefined) { s = 0.5; }\n        if (l === undefined) { l = 0.5; }\n\n        var colors = [];\n\n        for (var c = 0; c <= 359; c++)\n        {\n            colors.push(Phaser.Color.HSLtoRGB(c / 359, s, l));\n        }\n\n        return colors;\n\n    },\n\n    /**\n    * Interpolates the two given colours based on the supplied step and currentStep properties.\n    *\n    * @method Phaser.Color.interpolateColor\n    * @static\n    * @param {number} color1 - The first color value.\n    * @param {number} color2 - The second color value.\n    * @param {number} steps - The number of steps to run the interpolation over.\n    * @param {number} currentStep - The currentStep value. If the interpolation will take 100 steps, a currentStep value of 50 would be half-way between the two.\n    * @param {number} alpha - The alpha of the returned color.\n    * @returns {number} The interpolated color value.\n    */\n    interpolateColor: function (color1, color2, steps, currentStep, alpha) {\n\n        if (alpha === undefined) { alpha = 255; }\n\n        var src1 = Phaser.Color.getRGB(color1);\n        var src2 = Phaser.Color.getRGB(color2);\n        var r = (((src2.red - src1.red) * currentStep) / steps) + src1.red;\n        var g = (((src2.green - src1.green) * currentStep) / steps) + src1.green;\n        var b = (((src2.blue - src1.blue) * currentStep) / steps) + src1.blue;\n\n        return Phaser.Color.getColor32(alpha, r, g, b);\n\n    },\n\n    /**\n    * Interpolates the two given colours based on the supplied step and currentStep properties.\n    *\n    * @method Phaser.Color.interpolateColorWithRGB\n    * @static\n    * @param {number} color - The first color value.\n    * @param {number} r - The red color value, between 0 and 0xFF (255).\n    * @param {number} g - The green color value, between 0 and 0xFF (255).\n    * @param {number} b - The blue color value, between 0 and 0xFF (255).\n    * @param {number} steps - The number of steps to run the interpolation over.\n    * @param {number} currentStep - The currentStep value. If the interpolation will take 100 steps, a currentStep value of 50 would be half-way between the two.\n    * @returns {number} The interpolated color value.\n    */\n    interpolateColorWithRGB: function (color, r, g, b, steps, currentStep) {\n\n        var src = Phaser.Color.getRGB(color);\n        var or = (((r - src.red) * currentStep) / steps) + src.red;\n        var og = (((g - src.green) * currentStep) / steps) + src.green;\n        var ob = (((b - src.blue) * currentStep) / steps) + src.blue;\n\n        return Phaser.Color.getColor(or, og, ob);\n\n    },\n\n    /**\n    * Interpolates the two given colours based on the supplied step and currentStep properties.\n    * @method Phaser.Color.interpolateRGB\n    * @static\n    * @param {number} r1 - The red color value, between 0 and 0xFF (255).\n    * @param {number} g1 - The green color value, between 0 and 0xFF (255).\n    * @param {number} b1 - The blue color value, between 0 and 0xFF (255).\n    * @param {number} r2 - The red color value, between 0 and 0xFF (255).\n    * @param {number} g2 - The green color value, between 0 and 0xFF (255).\n    * @param {number} b2 - The blue color value, between 0 and 0xFF (255).\n    * @param {number} steps - The number of steps to run the interpolation over.\n    * @param {number} currentStep - The currentStep value. If the interpolation will take 100 steps, a currentStep value of 50 would be half-way between the two.\n    * @returns {number} The interpolated color value.\n    */\n    interpolateRGB: function (r1, g1, b1, r2, g2, b2, steps, currentStep) {\n\n        var r = (((r2 - r1) * currentStep) / steps) + r1;\n        var g = (((g2 - g1) * currentStep) / steps) + g1;\n        var b = (((b2 - b1) * currentStep) / steps) + b1;\n\n        return Phaser.Color.getColor(r, g, b);\n\n    },\n\n    /**\n    * Returns a random color value between black and white\n    * Set the min value to start each channel from the given offset.\n    * Set the max value to restrict the maximum color used per channel.\n    *\n    * @method Phaser.Color.getRandomColor\n    * @static\n    * @param {number} [min=0] - The lowest value to use for the color.\n    * @param {number} [max=255] - The highest value to use for the color.\n    * @param {number} [alpha=255] - The alpha value of the returning color (default 255 = fully opaque).\n    * @returns {number} 32-bit color value with alpha.\n    */\n    getRandomColor: function (min, max, alpha) {\n\n        if (min === undefined) { min = 0; }\n        if (max === undefined) { max = 255; }\n        if (alpha === undefined) { alpha = 255; }\n\n        //  Sanity checks\n        if (max > 255 || min > max)\n        {\n            return Phaser.Color.getColor(255, 255, 255);\n        }\n\n        var red = min + Math.round(Math.random() * (max - min));\n        var green = min + Math.round(Math.random() * (max - min));\n        var blue = min + Math.round(Math.random() * (max - min));\n\n        return Phaser.Color.getColor32(alpha, red, green, blue);\n\n    },\n\n    /**\n    * Return the component parts of a color as an Object with the properties alpha, red, green, blue.\n    *\n    * Alpha will only be set if it exist in the given color (0xAARRGGBB)\n    *\n    * @method Phaser.Color.getRGB\n    * @static\n    * @param {number} color - Color in RGB (0xRRGGBB) or ARGB format (0xAARRGGBB).\n    * @returns {object} An Object with properties: alpha, red, green, blue (also r, g, b and a). Alpha will only be present if a color value > 16777215 was given.\n    */\n    getRGB: function (color) {\n\n        if (color > 16777215)\n        {\n            //  The color value has an alpha component\n            return {\n                alpha: color >>> 24,\n                red: color >> 16 & 0xFF,\n                green: color >> 8 & 0xFF,\n                blue: color & 0xFF,\n                a: color >>> 24,\n                r: color >> 16 & 0xFF,\n                g: color >> 8 & 0xFF,\n                b: color & 0xFF\n            };\n        }\n        else\n        {\n            return {\n                alpha: 255,\n                red: color >> 16 & 0xFF,\n                green: color >> 8 & 0xFF,\n                blue: color & 0xFF,\n                a: 255,\n                r: color >> 16 & 0xFF,\n                g: color >> 8 & 0xFF,\n                b: color & 0xFF\n            };\n        }\n\n    },\n\n    /**\n    * Returns a CSS friendly string value from the given color.\n    *\n    * @method Phaser.Color.getWebRGB\n    * @static\n    * @param {number|Object} color - Color in RGB (0xRRGGBB), ARGB format (0xAARRGGBB) or an Object with r, g, b, a properties.\n    * @returns {string} A string in the format: 'rgba(r,g,b,a)'\n    */\n    getWebRGB: function (color) {\n\n        if (typeof color === 'object')\n        {\n            return 'rgba(' + color.r.toString() + ',' + color.g.toString() + ',' + color.b.toString() + ',' + (color.a / 255).toString() + ')';\n        }\n        else\n        {\n            var rgb = Phaser.Color.getRGB(color);\n            return 'rgba(' + rgb.r.toString() + ',' + rgb.g.toString() + ',' + rgb.b.toString() + ',' + (rgb.a / 255).toString() + ')';\n        }\n\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component, as a value between 0 and 255.\n    *\n    * @method Phaser.Color.getAlpha\n    * @static\n    * @param {number} color - In the format 0xAARRGGBB.\n    * @returns {number} The Alpha component of the color, will be between 0 and 1 (0 being no Alpha (opaque), 1 full Alpha (transparent)).\n    */\n    getAlpha: function (color) {\n        return color >>> 24;\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component as a value between 0 and 1.\n    *\n    * @method Phaser.Color.getAlphaFloat\n    * @static\n    * @param {number} color - In the format 0xAARRGGBB.\n    * @returns {number} The Alpha component of the color, will be between 0 and 1 (0 being no Alpha (opaque), 1 full Alpha (transparent)).\n    */\n    getAlphaFloat: function (color) {\n        return (color >>> 24) / 255;\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Red component, as a value between 0 and 255.\n    *\n    * @method Phaser.Color.getRed\n    * @static\n    * @param {number} color In the format 0xAARRGGBB.\n    * @returns {number} The Red component of the color, will be between 0 and 255 (0 being no color, 255 full Red).\n    */\n    getRed: function (color) {\n        return color >> 16 & 0xFF;\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Green component, as a value between 0 and 255.\n    *\n    * @method Phaser.Color.getGreen\n    * @static\n    * @param {number} color - In the format 0xAARRGGBB.\n    * @returns {number} The Green component of the color, will be between 0 and 255 (0 being no color, 255 full Green).\n    */\n    getGreen: function (color) {\n        return color >> 8 & 0xFF;\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Blue component, as a value between 0 and 255.\n    *\n    * @method Phaser.Color.getBlue\n    * @static\n    * @param {number} color - In the format 0xAARRGGBB.\n    * @returns {number} The Blue component of the color, will be between 0 and 255 (0 being no color, 255 full Blue).\n    */\n    getBlue: function (color) {\n        return color & 0xFF;\n    },\n\n    /**\n    * Blends the source color, ignoring the backdrop.\n    *\n    * @method Phaser.Color.blendNormal\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendNormal: function (a) {\n        return a;\n    },\n\n    /**\n    * Selects the lighter of the backdrop and source colors.\n    *\n    * @method Phaser.Color.blendLighten\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendLighten: function (a, b) {\n        return (b > a) ? b : a;\n    },\n\n    /**\n    * Selects the darker of the backdrop and source colors.\n    *\n    * @method Phaser.Color.blendDarken\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendDarken: function (a, b) {\n        return (b > a) ? a : b;\n    },\n\n    /**\n    * Multiplies the backdrop and source color values.\n    * The result color is always at least as dark as either of the two constituent\n    * colors. Multiplying any color with black produces black;\n    * multiplying with white leaves the original color unchanged.\n    *\n    * @method Phaser.Color.blendMultiply\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendMultiply: function (a, b) {\n        return (a * b) / 255;\n    },\n\n    /**\n    * Takes the average of the source and backdrop colors.\n    *\n    * @method Phaser.Color.blendAverage\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendAverage: function (a, b) {\n        return (a + b) / 2;\n    },\n\n    /**\n    * Adds the source and backdrop colors together and returns the value, up to a maximum of 255.\n    *\n    * @method Phaser.Color.blendAdd\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendAdd: function (a, b) {\n        return Math.min(255, a + b);\n    },\n\n    /**\n    * Combines the source and backdrop colors and returns their value minus 255.\n    *\n    * @method Phaser.Color.blendSubtract\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendSubtract: function (a, b) {\n        return Math.max(0, a + b - 255);\n    },\n\n    /**\n    * Subtracts the darker of the two constituent colors from the lighter.\n    * \n    * Painting with white inverts the backdrop color; painting with black produces no change. \n    *\n    * @method Phaser.Color.blendDifference\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendDifference: function (a, b) {\n        return Math.abs(a - b);\n    },\n\n    /**\n    * Negation blend mode.\n    *\n    * @method Phaser.Color.blendNegation\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendNegation: function (a, b) {\n        return 255 - Math.abs(255 - a - b);\n    },\n\n    /**\n    * Multiplies the complements of the backdrop and source color values, then complements the result.\n    * The result color is always at least as light as either of the two constituent colors. \n    * Screening any color with white produces white; screening with black leaves the original color unchanged. \n    *\n    * @method Phaser.Color.blendScreen\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendScreen: function (a, b) {\n        return 255 - (((255 - a) * (255 - b)) >> 8);\n    },\n\n    /**\n    * Produces an effect similar to that of the Difference mode, but lower in contrast. \n    * Painting with white inverts the backdrop color; painting with black produces no change. \n    *\n    * @method Phaser.Color.blendExclusion\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendExclusion: function (a, b) {\n        return a + b - 2 * a * b / 255;\n    },\n\n    /**\n    * Multiplies or screens the colors, depending on the backdrop color.\n    * Source colors overlay the backdrop while preserving its highlights and shadows. \n    * The backdrop color is not replaced, but is mixed with the source color to reflect the lightness or darkness of the backdrop.\n    *\n    * @method Phaser.Color.blendOverlay\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendOverlay: function (a, b) {\n        return b < 128 ? (2 * a * b / 255) : (255 - 2 * (255 - a) * (255 - b) / 255);\n    },\n\n    /**\n    * Darkens or lightens the colors, depending on the source color value. \n    * \n    * If the source color is lighter than 0.5, the backdrop is lightened, as if it were dodged; \n    * this is useful for adding highlights to a scene. \n    * \n    * If the source color is darker than 0.5, the backdrop is darkened, as if it were burned in. \n    * The degree of lightening or darkening is proportional to the difference between the source color and 0.5; \n    * if it is equal to 0.5, the backdrop is unchanged.\n    * \n    * Painting with pure black or white produces a distinctly darker or lighter area, but does not result in pure black or white. \n    * The effect is similar to shining a diffused spotlight on the backdrop. \n    *\n    * @method Phaser.Color.blendSoftLight\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendSoftLight: function (a, b) {\n        return b < 128 ? (2 * ((a >> 1) + 64)) * (b / 255) : 255 - (2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255);\n    },\n\n    /**\n    * Multiplies or screens the colors, depending on the source color value. \n    * \n    * If the source color is lighter than 0.5, the backdrop is lightened, as if it were screened; \n    * this is useful for adding highlights to a scene. \n    * \n    * If the source color is darker than 0.5, the backdrop is darkened, as if it were multiplied; \n    * this is useful for adding shadows to a scene. \n    * \n    * The degree of lightening or darkening is proportional to the difference between the source color and 0.5; \n    * if it is equal to 0.5, the backdrop is unchanged.\n    * \n    * Painting with pure black or white produces pure black or white. The effect is similar to shining a harsh spotlight on the backdrop. \n    *\n    * @method Phaser.Color.blendHardLight\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendHardLight: function (a, b) {\n        return Phaser.Color.blendOverlay(b, a);\n    },\n\n    /**\n    * Brightens the backdrop color to reflect the source color. \n    * Painting with black produces no change.\n    *\n    * @method Phaser.Color.blendColorDodge\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendColorDodge: function (a, b) {\n        return b === 255 ? b : Math.min(255, ((a << 8) / (255 - b)));\n    },\n\n    /**\n    * Darkens the backdrop color to reflect the source color.\n    * Painting with white produces no change. \n    *\n    * @method Phaser.Color.blendColorBurn\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendColorBurn: function (a, b) {\n        return b === 0 ? b : Math.max(0, (255 - ((255 - a) << 8) / b));\n    },\n\n    /**\n    * An alias for blendAdd, it simply sums the values of the two colors.\n    *\n    * @method Phaser.Color.blendLinearDodge\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendLinearDodge: function (a, b) {\n        return Phaser.Color.blendAdd(a, b);\n    },\n\n    /**\n    * An alias for blendSubtract, it simply sums the values of the two colors and subtracts 255.\n    *\n    * @method Phaser.Color.blendLinearBurn\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendLinearBurn: function (a, b) {\n        return Phaser.Color.blendSubtract(a, b);\n    },\n\n    /**\n    * This blend mode combines Linear Dodge and Linear Burn (rescaled so that neutral colors become middle gray).\n    * Dodge applies to values of top layer lighter than middle gray, and burn to darker values.\n    * The calculation simplifies to the sum of bottom layer and twice the top layer, subtract 128. The contrast decreases.\n    *\n    * @method Phaser.Color.blendLinearLight\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendLinearLight: function (a, b) {\n        return b < 128 ? Phaser.Color.blendLinearBurn(a, 2 * b) : Phaser.Color.blendLinearDodge(a, (2 * (b - 128)));\n    },\n\n    /**\n    * This blend mode combines Color Dodge and Color Burn (rescaled so that neutral colors become middle gray).\n    * Dodge applies when values in the top layer are lighter than middle gray, and burn to darker values.\n    * The middle gray is the neutral color. When color is lighter than this, this effectively moves the white point of the bottom \n    * layer down by twice the difference; when it is darker, the black point is moved up by twice the difference. The perceived contrast increases.\n    *\n    * @method Phaser.Color.blendVividLight\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendVividLight: function (a, b) {\n        return b < 128 ? Phaser.Color.blendColorBurn(a, 2 * b) : Phaser.Color.blendColorDodge(a, (2 * (b - 128)));\n    },\n\n    /**\n    * If the backdrop color (light source) is lighter than 50%, the blendDarken mode is used, and colors lighter than the backdrop color do not change.\n    * If the backdrop color is darker than 50% gray, colors lighter than the blend color are replaced, and colors darker than the blend color do not change.\n    *\n    * @method Phaser.Color.blendPinLight\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendPinLight: function (a, b) {\n        return b < 128 ? Phaser.Color.blendDarken(a, 2 * b) : Phaser.Color.blendLighten(a, (2 * (b - 128)));\n    },\n\n    /**\n    * Runs blendVividLight on the source and backdrop colors.\n    * If the resulting color is 128 or more, it receives a value of 255; if less than 128, a value of 0.\n    * Therefore, all blended pixels have red, green, and blue channel values of either 0 or 255.\n    * This changes all pixels to primary additive colors (red, green, or blue), white, or black.\n    *\n    * @method Phaser.Color.blendHardMix\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendHardMix: function (a, b) {\n        return Phaser.Color.blendVividLight(a, b) < 128 ? 0 : 255;\n    },\n\n    /**\n    * Reflect blend mode. This mode is useful when adding shining objects or light zones to images. \n    *\n    * @method Phaser.Color.blendReflect\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendReflect: function (a, b) {\n        return b === 255 ? b : Math.min(255, (a * a / (255 - b)));\n    },\n\n    /**\n    * Glow blend mode. This mode is a variation of reflect mode with the source and backdrop colors swapped.\n    *\n    * @method Phaser.Color.blendGlow\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendGlow: function (a, b) {\n        return Phaser.Color.blendReflect(b, a);\n    },\n\n    /**\n    * Phoenix blend mode. This subtracts the lighter color from the darker color, and adds 255, giving a bright result.\n    *\n    * @method Phaser.Color.blendPhoenix\n    * @static\n    * @param {integer} a - The source color to blend, in the range 1 to 255.\n    * @param {integer} b - The backdrop color to blend, in the range 1 to 255.\n    * @returns {integer} The blended color value, in the range 1 to 255.\n    */\n    blendPhoenix: function (a, b) {\n        return Math.min(a, b) - Math.max(a, b) + 255;\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Physics Manager is responsible for looking after all of the running physics systems.\n* Phaser supports 4 physics systems: Arcade Physics, P2, Ninja Physics and Box2D via a commercial plugin.\n* \n* Game Objects (such as Sprites) can only belong to 1 physics system, but you can have multiple systems active in a single game.\n*\n* For example you could have P2 managing a polygon-built terrain landscape that an vehicle drives over, while it could be firing bullets that use the\n* faster (due to being much simpler) Arcade Physics system.\n*\n* @class Phaser.Physics\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {object} [physicsConfig=null] - A physics configuration object to pass to the Physics world on creation.\n*/\nPhaser.Physics = function (game, config) {\n\n    config = config || {};\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {object} config - The physics configuration object as passed to the game on creation.\n    */\n    this.config = config;\n\n    /**\n    * @property {Phaser.Physics.Arcade} arcade - The Arcade Physics system.\n    */\n    this.arcade = null;\n\n    /**\n    * @property {Phaser.Physics.P2} p2 - The P2.JS Physics system.\n    */\n    this.p2 = null;\n\n    /**\n    * @property {Phaser.Physics.Ninja} ninja - The N+ Ninja Physics system.\n    */\n    this.ninja = null;\n\n    /**\n    * @property {Phaser.Physics.Box2D} box2d - The Box2D Physics system.\n    */\n    this.box2d = null;\n\n    /**\n    * @property {Phaser.Physics.Chipmunk} chipmunk - The Chipmunk Physics system (to be done).\n    */\n    this.chipmunk = null;\n\n    /**\n    * @property {Phaser.Physics.Matter} matter - The MatterJS Physics system (coming soon).\n    */\n    this.matter = null;\n\n    this.parseConfig();\n\n};\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.ARCADE = 0;\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.P2JS = 1;\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.NINJA = 2;\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.BOX2D = 3;\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.CHIPMUNK = 4;\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.MATTERJS = 5;\n\nPhaser.Physics.prototype = {\n\n    /**\n    * Parses the Physics Configuration object passed to the Game constructor and starts any physics systems specified within.\n    *\n    * @method Phaser.Physics#parseConfig\n    */\n    parseConfig: function () {\n\n        if ((!this.config.hasOwnProperty('arcade') || this.config['arcade'] === true) && Phaser.Physics.hasOwnProperty('Arcade'))\n        {\n            //  If Arcade isn't specified, we create it automatically if we can\n            this.arcade = new Phaser.Physics.Arcade(this.game);\n        }\n\n        if (this.config.hasOwnProperty('ninja') && this.config['ninja'] === true && Phaser.Physics.hasOwnProperty('Ninja'))\n        {\n            this.ninja = new Phaser.Physics.Ninja(this.game);\n        }\n\n        if (this.config.hasOwnProperty('p2') && this.config['p2'] === true && Phaser.Physics.hasOwnProperty('P2'))\n        {\n            this.p2 = new Phaser.Physics.P2(this.game, this.config);\n        }\n\n        if (this.config.hasOwnProperty('box2d') && this.config['box2d'] === true && Phaser.Physics.hasOwnProperty('BOX2D'))\n        {\n            this.box2d = new Phaser.Physics.BOX2D(this.game, this.config);\n        }\n\n        if (this.config.hasOwnProperty('matter') && this.config['matter'] === true && Phaser.Physics.hasOwnProperty('Matter'))\n        {\n            this.matter = new Phaser.Physics.Matter(this.game, this.config);\n        }\n\n    },\n\n    /**\n    * This will create an instance of the requested physics simulation.\n    * Phaser.Physics.Arcade is running by default, but all others need activating directly.\n    * \n    * You can start the following physics systems:\n    * \n    * Phaser.Physics.P2JS - A full-body advanced physics system by Stefan Hedman.\n    * Phaser.Physics.NINJA - A port of Metanet Softwares N+ physics system.\n    * Phaser.Physics.BOX2D - A commercial Phaser Plugin (see http://phaser.io)\n    *\n    * Both Ninja Physics and Box2D require their respective plugins to be loaded before you can start them.\n    * They are not bundled into the core Phaser library.\n    *\n    * If the physics world has already been created (i.e. in another state in your game) then \n    * calling startSystem will reset the physics world, not re-create it. If you need to start them again from their constructors \n    * then set Phaser.Physics.p2 (or whichever system you want to recreate) to `null` before calling `startSystem`.\n    *\n    * @method Phaser.Physics#startSystem\n    * @param {number} system - The physics system to start: Phaser.Physics.ARCADE, Phaser.Physics.P2JS, Phaser.Physics.NINJA or Phaser.Physics.BOX2D.\n    */\n    startSystem: function (system) {\n\n        if (system === Phaser.Physics.ARCADE)\n        {\n            this.arcade = new Phaser.Physics.Arcade(this.game);\n        }\n        else if (system === Phaser.Physics.P2JS)\n        {\n            if (this.p2 === null)\n            {\n                this.p2 = new Phaser.Physics.P2(this.game, this.config);\n            }\n            else\n            {\n                this.p2.reset();\n            }\n        }\n        else if (system === Phaser.Physics.NINJA)\n        {\n            this.ninja = new Phaser.Physics.Ninja(this.game);\n        }\n        else if (system === Phaser.Physics.BOX2D)\n        {\n            if (this.box2d === null)\n            {\n                this.box2d = new Phaser.Physics.Box2D(this.game, this.config);\n            }\n            else\n            {\n                this.box2d.reset();\n            }\n        }\n        else if (system === Phaser.Physics.MATTERJS)\n        {\n            if (this.matter === null)\n            {\n                this.matter = new Phaser.Physics.Matter(this.game, this.config);\n            }\n            else\n            {\n                this.matter.reset();\n            }\n        }\n\n    },\n\n    /**\n    * This will create a default physics body on the given game object or array of objects.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\n    * It can be for any of the physics systems that have been started:\n    *\n    * Phaser.Physics.Arcade - A light weight AABB based collision system with basic separation.\n    * Phaser.Physics.P2JS - A full-body advanced physics system supporting multiple object shapes, polygon loading, contact materials, springs and constraints.\n    * Phaser.Physics.NINJA - A port of Metanet Softwares N+ physics system. Advanced AABB and Circle vs. Tile collision.\n    * Phaser.Physics.BOX2D - A port of https://code.google.com/p/box2d-html5\n    * Phaser.Physics.MATTER - A full-body and light-weight advanced physics system (still in development)\n    * Phaser.Physics.CHIPMUNK is still in development.\n    *\n    * If you require more control over what type of body is created, for example to create a Ninja Physics Circle instead of the default AABB, then see the\n    * individual physics systems `enable` methods instead of using this generic one.\n    *\n    * @method Phaser.Physics#enable\n    * @param {object|array} object - The game object to create the physics body on. Can also be an array of objects, a body will be created on every object in the array.\n    * @param {number} [system=Phaser.Physics.ARCADE] - The physics system that will be used to create the body. Defaults to Arcade Physics.\n    * @param {boolean} [debug=false] - Enable the debug drawing for this body. Defaults to false.\n    */\n    enable: function (object, system, debug) {\n\n        if (system === undefined) { system = Phaser.Physics.ARCADE; }\n        if (debug === undefined) { debug = false; }\n\n        if (system === Phaser.Physics.ARCADE)\n        {\n            this.arcade.enable(object);\n        }\n        else if (system === Phaser.Physics.P2JS && this.p2)\n        {\n            this.p2.enable(object, debug);\n        }\n        else if (system === Phaser.Physics.NINJA && this.ninja)\n        {\n            this.ninja.enableAABB(object);\n        }\n        else if (system === Phaser.Physics.BOX2D && this.box2d)\n        {\n            this.box2d.enable(object);\n        }\n        else if (system === Phaser.Physics.MATTERJS && this.matter)\n        {\n            this.matter.enable(object);\n        }\n        else\n        {\n            console.warn(object.key + ' is attempting to enable a physics body using an unknown physics system.');\n        }\n\n    },\n\n    /**\n    * preUpdate checks.\n    *\n    * @method Phaser.Physics#preUpdate\n    * @protected\n    */\n    preUpdate: function () {\n\n        //  ArcadePhysics / Ninja don't have a core to preUpdate\n\n        if (this.p2)\n        {\n            this.p2.preUpdate();\n        }\n\n        if (this.box2d)\n        {\n            this.box2d.preUpdate();\n        }\n\n        if (this.matter)\n        {\n            this.matter.preUpdate();\n        }\n\n    },\n\n    /**\n    * Updates all running physics systems.\n    *\n    * @method Phaser.Physics#update\n    * @protected\n    */\n    update: function () {\n\n        //  ArcadePhysics / Ninja don't have a core to update\n\n        if (this.p2)\n        {\n            this.p2.update();\n        }\n\n        if (this.box2d)\n        {\n            this.box2d.update();\n        }\n\n        if (this.matter)\n        {\n            this.matter.update();\n        }\n\n    },\n\n    /**\n    * Updates the physics bounds to match the world dimensions.\n    *\n    * @method Phaser.Physics#setBoundsToWorld\n    * @protected\n    */\n    setBoundsToWorld: function () {\n\n        if (this.arcade)\n        {\n            this.arcade.setBoundsToWorld();\n        }\n\n        if (this.ninja)\n        {\n            this.ninja.setBoundsToWorld();\n        }\n\n        if (this.p2)\n        {\n            this.p2.setBoundsToWorld();\n        }\n\n        if (this.box2d)\n        {\n            this.box2d.setBoundsToWorld();\n        }\n\n        if (this.matter)\n        {\n            this.matter.setBoundsToWorld();\n        }\n\n    },\n\n    /**\n    * Clears down all active physics systems. This doesn't destroy them, it just clears them of objects and is called when the State changes.\n    *\n    * @method Phaser.Physics#clear\n    * @protected\n    */\n    clear: function () {\n\n        if (this.p2)\n        {\n            this.p2.clear();\n        }\n\n        if (this.box2d)\n        {\n            this.box2d.clear();\n        }\n\n        if (this.matter)\n        {\n            this.matter.clear();\n        }\n\n    },\n\n    /**\n    * Resets the active physics system. Called automatically on a Phaser.State swap.\n    *\n    * @method Phaser.Physics#reset\n    * @protected\n    */\n    reset: function () {\n\n        if (this.p2)\n        {\n            this.p2.reset();\n        }\n\n        if (this.box2d)\n        {\n            this.box2d.reset();\n        }\n\n        if (this.matter)\n        {\n            this.matter.reset();\n        }\n\n    },\n\n    /**\n    * Destroys all active physics systems. Usually only called on a Game Shutdown, not on a State swap.\n    *\n    * @method Phaser.Physics#destroy\n    */\n    destroy: function () {\n\n        if (this.p2)\n        {\n            this.p2.destroy();\n        }\n\n        if (this.box2d)\n        {\n            this.box2d.destroy();\n        }\n\n        if (this.matter)\n        {\n            this.matter.destroy();\n        }\n\n        this.arcade = null;\n        this.ninja = null;\n        this.p2 = null;\n        this.box2d = null;\n        this.matter = null;\n\n    }\n\n};\n\nPhaser.Physics.prototype.constructor = Phaser.Physics;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Particles is the Particle Manager for the game. It is called during the game update loop and in turn updates any Emitters attached to it.\n*\n* @class Phaser.Particles\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Particles = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {object} emitters - Internal emitters store.\n    */\n    this.emitters = {};\n\n    /**\n    * @property {number} ID -\n    * @default\n    */\n    this.ID = 0;\n\n};\n\nPhaser.Particles.prototype = {\n\n    /**\n    * Adds a new Particle Emitter to the Particle Manager.\n    * @method Phaser.Particles#add\n    * @param {Phaser.Emitter} emitter - The emitter to be added to the particle manager.\n    * @return {Phaser.Emitter} The emitter that was added.\n    */\n    add: function (emitter) {\n\n        this.emitters[emitter.name] = emitter;\n\n        return emitter;\n\n    },\n\n    /**\n    * Removes an existing Particle Emitter from the Particle Manager.\n    * @method Phaser.Particles#remove\n    * @param {Phaser.Emitter} emitter - The emitter to remove.\n    */\n    remove: function (emitter) {\n\n        delete this.emitters[emitter.name];\n\n    },\n\n    /**\n    * Called by the core game loop. Updates all Emitters who have their exists value set to true.\n    * @method Phaser.Particles#update\n    * @protected\n    */\n    update: function () {\n\n        for (var key in this.emitters)\n        {\n            if (this.emitters[key].exists)\n            {\n                this.emitters[key].update();\n            }\n        }\n\n    }\n\n};\n\nPhaser.Particles.prototype.constructor = Phaser.Particles;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Video object that takes a previously loaded Video from the Phaser Cache and handles playback of it.\n*\n* Alternatively it takes a getUserMedia feed from an active webcam and streams the contents of that to\n* the Video instead (see `startMediaStream` method)\n*\n* The video can then be applied to a Sprite as a texture. If multiple Sprites share the same Video texture and playback\n* changes (i.e. you pause the video, or seek to a new time) then this change will be seen across all Sprites simultaneously.\n*\n* Due to a bug in IE11 you cannot play a video texture to a Sprite in WebGL. For IE11 force Canvas mode.\n*\n* If you need each Sprite to be able to play a video fully independently then you will need one Video object per Sprite.\n* Please understand the obvious performance implications of doing this, and the memory required to hold videos in RAM.\n*\n* On some mobile browsers such as iOS Safari, you cannot play a video until the user has explicitly touched the screen.\n* This works in the same way as audio unlocking. Phaser will handle the touch unlocking for you, however unlike with audio\n* it's worth noting that every single Video needs to be touch unlocked, not just the first one. You can use the `changeSource`\n* method to try and work around this limitation, but see the method help for details.\n*\n* Small screen devices, especially iPod and iPhone will launch the video in its own native video player,\n* outside of the Safari browser. There is no way to avoid this, it's a device imposed limitation.\n*\n* Note: On iOS if you need to detect when the user presses the 'Done' button (before the video ends)\n* then you need to add your own event listener\n*\n* @class Phaser.Video\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {string|null} [key=null] - The key of the video file in the Phaser.Cache that this Video object will play. Set to `null` or leave undefined if you wish to use a webcam as the source. See `startMediaStream` to start webcam capture.\n* @param {string|null} [url=null] - If the video hasn't been loaded then you can provide a full URL to the file here (make sure to set key to null)\n*/\nPhaser.Video = function (game, key, url) {\n\n    if (key === undefined) { key = null; }\n    if (url === undefined) { url = null; }\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {string} key - The key of the Video in the Cache, if stored there. Will be `null` if this Video is using the webcam instead.\n    * @default null\n    */\n    this.key = key;\n\n    /**\n    * @property {number} width - The width of the video in pixels.\n    * @default\n    */\n    this.width = 0;\n\n    /**\n    * @property {number} height - The height of the video in pixels.\n    * @default\n    */\n    this.height = 0;\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @default\n    */\n    this.type = Phaser.VIDEO;\n\n    /**\n    * @property {boolean} disableTextureUpload - If true this video will never send its image data to the GPU when its dirty flag is true. This only applies in WebGL.\n    */\n    this.disableTextureUpload = false;\n\n    /**\n    * @property {boolean} touchLocked - true if this video is currently locked awaiting a touch event. This happens on some mobile devices, such as iOS.\n    * @default\n    */\n    this.touchLocked = false;\n\n    /**\n    * @property {Phaser.Signal} onPlay - This signal is dispatched when the Video starts to play. It sends 3 parameters: a reference to the Video object, if the video is set to loop or not and the playback rate.\n    */\n    this.onPlay = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onChangeSource - This signal is dispatched if the Video source is changed. It sends 3 parameters: a reference to the Video object and the new width and height of the new video source.\n    */\n    this.onChangeSource = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onComplete - This signal is dispatched when the Video completes playback, i.e. enters an 'ended' state. On iOS specifically it also fires if the user hits the 'Done' button at any point during playback. Videos set to loop will never dispatch this signal.\n    */\n    this.onComplete = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onAccess - This signal is dispatched if the user allows access to their webcam.\n    */\n    this.onAccess = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onError - This signal is dispatched if an error occurs either getting permission to use the webcam (for a Video Stream) or when trying to play back a video file.\n    */\n    this.onError = new Phaser.Signal();\n\n    /**\n    * This signal is dispatched if when asking for permission to use the webcam no response is given within a the Video.timeout limit.\n    * This may be because the user has picked `Not now` in the permissions window, or there is a delay in establishing the LocalMediaStream.\n    * @property {Phaser.Signal} onTimeout\n    */\n    this.onTimeout = new Phaser.Signal();\n\n    /**\n    * @property {integer} timeout - The amount of ms allowed to elapsed before the Video.onTimeout signal is dispatched while waiting for webcam access.\n    * @default\n    */\n    this.timeout = 15000;\n\n    /**\n    * @property {integer} _timeOutID - setTimeout ID.\n    * @private\n    */\n    this._timeOutID = null;\n\n    /**\n    * @property {HTMLVideoElement} video - The HTML Video Element that is added to the document.\n    */\n    this.video = null;\n\n    /**\n    * @property {MediaStream} videoStream - The Video Stream data. Only set if this Video is streaming from the webcam via `startMediaStream`.\n    */\n    this.videoStream = null;\n\n    /**\n    * @property {boolean} isStreaming - Is there a streaming video source? I.e. from a webcam.\n    */\n    this.isStreaming = false;\n\n    /**\n    * When starting playback of a video Phaser will monitor its readyState using a setTimeout call.\n    * The setTimeout happens once every `Video.retryInterval` ms. It will carry on monitoring the video\n    * state in this manner until the `retryLimit` is reached and then abort.\n    * @property {integer} retryLimit\n    * @default\n    */\n    this.retryLimit = 20;\n\n    /**\n    * @property {integer} retry - The current retry attempt.\n    * @default\n    */\n    this.retry = 0;\n\n    /**\n    * @property {integer} retryInterval - The number of ms between each retry at monitoring the status of a downloading video.\n    * @default\n    */\n    this.retryInterval = 500;\n\n    /**\n    * @property {integer} _retryID - The callback ID of the retry setTimeout.\n    * @private\n    */\n    this._retryID = null;\n\n    /**\n    * @property {boolean} _codeMuted - Internal mute tracking var.\n    * @private\n    * @default\n    */\n    this._codeMuted = false;\n\n    /**\n    * @property {boolean} _muted - Internal mute tracking var.\n    * @private\n    * @default\n    */\n    this._muted = false;\n\n    /**\n    * @property {boolean} _codePaused - Internal paused tracking var.\n    * @private\n    * @default\n    */\n    this._codePaused = false;\n\n    /**\n    * @property {boolean} _paused - Internal paused tracking var.\n    * @private\n    * @default\n    */\n    this._paused = false;\n\n    /**\n    * @property {boolean} _pending - Internal var tracking play pending.\n    * @private\n    * @default\n    */\n    this._pending = false;\n\n    /**\n    * @property {boolean} _autoplay - Internal var tracking autoplay when changing source.\n    * @private\n    * @default\n    */\n    this._autoplay = false;\n\n    /**\n    * @property {function} _endCallback - The addEventListener ended function.\n    * @private\n    */\n    this._endCallback = null;\n\n    /**\n    * @property {function} _playCallback - The addEventListener playing function.\n    * @private\n    */\n    this._playCallback = null;\n\n    if (key && this.game.cache.checkVideoKey(key))\n    {\n        var _video = this.game.cache.getVideo(key);\n\n        if (_video.isBlob)\n        {\n            this.createVideoFromBlob(_video.data);\n        }\n        else\n        {\n            this.video = _video.data;\n        }\n\n        this.width = this.video.videoWidth;\n        this.height = this.video.videoHeight;\n    }\n    else if (url)\n    {\n        this.createVideoFromURL(url, false);\n    }\n\n    /**\n    * @property {PIXI.BaseTexture} baseTexture - The PIXI.BaseTexture.\n    * @default\n    */\n    if (this.video && !url)\n    {\n        this.baseTexture = new PIXI.BaseTexture(this.video);\n        this.baseTexture.forceLoaded(this.width, this.height);\n    }\n    else\n    {\n        this.baseTexture = new PIXI.BaseTexture(Phaser.Cache.DEFAULT.baseTexture.source);\n        this.baseTexture.forceLoaded(this.width, this.height);\n    }\n\n    /**\n    * @property {PIXI.Texture} texture - The PIXI.Texture.\n    * @default\n    */\n    this.texture = new PIXI.Texture(this.baseTexture);\n\n    /**\n    * @property {Phaser.Frame} textureFrame - The Frame this video uses for rendering.\n    * @default\n    */\n    this.textureFrame = new Phaser.Frame(0, 0, 0, this.width, this.height, 'video');\n\n    this.texture.setFrame(this.textureFrame);\n\n    this.texture.valid = false;\n\n    if (key !== null && this.video)\n    {\n        this.texture.valid = this.video.canplay;\n    }\n\n    /**\n    * A snapshot grabbed from the video. This is initially black. Populate it by calling Video.grab().\n    * When called the BitmapData is updated with a grab taken from the current video playing or active video stream.\n    * If Phaser has been compiled without BitmapData support this property will always be `null`.\n    *\n    * @property {Phaser.BitmapData} snapshot\n    * @readOnly\n    */\n    this.snapshot = null;\n\n    if (Phaser.BitmapData)\n    {\n        this.snapshot = new Phaser.BitmapData(this.game, '', this.width, this.height);\n    }\n\n    if (!this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || (window['PhaserGlobal'] && window['PhaserGlobal'].fakeiOSTouchLock))\n    {\n        this.setTouchLock();\n    }\n    else\n    {\n        if (_video)\n        {\n            _video.locked = false;\n        }\n    }\n\n};\n\nPhaser.Video.prototype = {\n\n    /**\n     * Connects to an external media stream for the webcam, rather than using a local one.\n     *\n     * @method Phaser.Video#connectToMediaStream\n     * @param {HTMLVideoElement} video - The HTML Video Element that the stream uses.\n     * @param {MediaStream} stream - The Video Stream data.\n     * @return {Phaser.Video} This Video object for method chaining.\n     */\n    connectToMediaStream: function (video, stream) {\n\n        if (video && stream)\n        {\n            this.video = video;\n            this.videoStream = stream;\n\n            this.isStreaming = true;\n            this.baseTexture.source = this.video;\n            this.updateTexture(null, this.video.videoWidth, this.video.videoHeight);\n\n            this.onAccess.dispatch(this);\n        }\n\n        return this;\n\n    },\n\n    /**\n     * Instead of playing a video file this method allows you to stream video data from an attached webcam.\n     *\n     * As soon as this method is called the user will be prompted by their browser to \"Allow\" access to the webcam.\n     * If they allow it the webcam feed is directed to this Video. Call `Video.play` to start the stream.\n     *\n     * If they block the webcam the onError signal will be dispatched containing the NavigatorUserMediaError\n     * or MediaStreamError event.\n     *\n     * You can optionally set a width and height for the stream. If set the input will be cropped to these dimensions.\n     * If not given then as soon as the stream has enough data the video dimensions will be changed to match the webcam device.\n     * You can listen for this with the onChangeSource signal.\n     *\n     * @method Phaser.Video#startMediaStream\n     * @param {boolean} [captureAudio=false] - Controls if audio should be captured along with video in the video stream.\n     * @param {integer} [width] - The width is used to create the video stream. If not provided the video width will be set to the width of the webcam input source.\n     * @param {integer} [height] - The height is used to create the video stream. If not provided the video height will be set to the height of the webcam input source.\n     * @return {Phaser.Video} This Video object for method chaining or false if the device doesn't support getUserMedia.\n     */\n    startMediaStream: function (captureAudio, width, height) {\n\n        if (captureAudio === undefined) { captureAudio = false; }\n        if (width === undefined) { width = null; }\n        if (height === undefined) { height = null; }\n\n        if (!this.game.device.getUserMedia)\n        {\n            this.onError.dispatch(this, 'No getUserMedia');\n            return false;\n        }\n\n        if (this.videoStream !== null)\n        {\n            if (this.videoStream['active'])\n            {\n                this.videoStream.active = false;\n            }\n            else\n            {\n                this.videoStream.stop();\n            }\n        }\n\n        this.removeVideoElement();\n\n        this.video = document.createElement(\"video\");\n        this.video.setAttribute('autoplay', 'autoplay');\n\n        if (width !== null)\n        {\n            this.video.width = width;\n        }\n\n        if (height !== null)\n        {\n            this.video.height = height;\n        }\n\n        //  Request access to the webcam\n\n        this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);\n\n        try {\n            navigator.getUserMedia(\n                { \"audio\": captureAudio, \"video\": true },\n                this.getUserMediaSuccess.bind(this),\n                this.getUserMediaError.bind(this)\n            );\n        }\n        catch (error)\n        {\n            this.getUserMediaError(error);\n        }\n\n        return this;\n\n    },\n\n    /**\n     * @method Phaser.Video#getUserMediaTimeout\n     * @private\n     */\n    getUserMediaTimeout: function () {\n\n        clearTimeout(this._timeOutID);\n\n        this.onTimeout.dispatch(this);\n\n    },\n\n    /**\n     * @method Phaser.Video#getUserMediaError\n     * @private\n     */\n    getUserMediaError: function (event) {\n\n        clearTimeout(this._timeOutID);\n\n        this.onError.dispatch(this, event);\n\n    },\n\n    /**\n     * @method Phaser.Video#getUserMediaSuccess\n     * @private\n     */\n    getUserMediaSuccess: function (stream) {\n\n        clearTimeout(this._timeOutID);\n\n        // Attach the stream to the video\n        this.videoStream = stream;\n\n        // Set the source of the video element with the stream from the camera\n        if (this.video.mozSrcObject !== undefined)\n        {\n            this.video.mozSrcObject = stream;\n        }\n        else\n        {\n            this.video.src = (window.URL && window.URL.createObjectURL(stream)) || stream;\n        }\n\n        var self = this;\n\n        this.video.onloadeddata = function () {\n\n            var retry = 10;\n\n            function checkStream () {\n\n                if (retry > 0)\n                {\n                    if (self.video.videoWidth > 0)\n                    {\n                        // Patch for Firefox bug where the height can't be read from the video\n                        var width = self.video.videoWidth;\n                        var height = self.video.videoHeight;\n\n                        if (isNaN(self.video.videoHeight))\n                        {\n                            height = width / (4/3);\n                        }\n\n                        self.video.play();\n\n                        self.isStreaming = true;\n                        self.baseTexture.source = self.video;\n                        self.updateTexture(null, width, height);\n                        self.onAccess.dispatch(self);\n                    }\n                    else\n                    {\n                        window.setTimeout(checkStream, 500);\n                    }\n                }\n                else\n                {\n                    console.warn('Unable to connect to video stream. Webcam error?');\n                }\n\n                retry--;\n            }\n\n            checkStream();\n\n        };\n\n    },\n\n    /**\n     * Creates a new Video element from the given Blob. The Blob must contain the video data in the correct encoded format.\n     * This method is typically called by the Phaser.Loader and Phaser.Cache for you, but is exposed publicly for convenience.\n     *\n     * @method Phaser.Video#createVideoFromBlob\n     * @param {Blob} blob - The Blob containing the video data: `Blob([new Uint8Array(data)])`\n     * @return {Phaser.Video} This Video object for method chaining.\n     */\n    createVideoFromBlob: function (blob) {\n\n        var _this = this;\n\n        this.video = document.createElement(\"video\");\n        this.video.controls = false;\n        this.video.setAttribute('autoplay', 'autoplay');\n        this.video.addEventListener('loadeddata', function (event) { _this.updateTexture(event); }, true);\n        this.video.src = window.URL.createObjectURL(blob);\n        this.video.canplay = true;\n\n        return this;\n\n    },\n\n    /**\n     * Creates a new Video element from the given URL.\n     *\n     * @method Phaser.Video#createVideoFromURL\n     * @param {string} url - The URL of the video.\n     * @param {boolean} [autoplay=false] - Automatically start the video?\n     * @return {Phaser.Video} This Video object for method chaining.\n     */\n    createVideoFromURL: function (url, autoplay) {\n\n        if (autoplay === undefined) { autoplay = false; }\n\n        //  Invalidate the texture while we wait for the new one to load (crashes IE11 otherwise)\n        if (this.texture)\n        {\n            this.texture.valid = false;\n        }\n\n        this.video = document.createElement(\"video\");\n        this.video.controls = false;\n\n        if (autoplay)\n        {\n            this.video.setAttribute('autoplay', 'autoplay');\n        }\n\n        this.video.src = url;\n\n        this.video.canplay = true;\n\n        this.video.load();\n\n        this.retry = this.retryLimit;\n\n        this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\n\n        this.key = url;\n\n        return this;\n\n    },\n\n    /**\n     * Called automatically if the video source changes and updates the internal texture dimensions.\n     * Then dispatches the onChangeSource signal.\n     *\n     * @method Phaser.Video#updateTexture\n     * @param {object} [event] - The event which triggered the texture update.\n     * @param {integer} [width] - The new width of the video. If undefined `video.videoWidth` is used.\n     * @param {integer} [height] - The new height of the video. If undefined `video.videoHeight` is used.\n     */\n    updateTexture: function (event, width, height) {\n\n        var change = false;\n\n        if (width === undefined || width === null) { width = this.video.videoWidth; change = true; }\n        if (height === undefined || height === null) { height = this.video.videoHeight; }\n\n        this.width = width;\n        this.height = height;\n\n        if (this.baseTexture.source !== this.video)\n        {\n            this.baseTexture.source = this.video;\n        }\n\n        this.baseTexture.forceLoaded(width, height);\n\n        this.texture.frame.resize(width, height);\n\n        this.texture.width = width;\n        this.texture.height = height;\n\n        this.texture.valid = true;\n\n        if (this.snapshot)\n        {\n            this.snapshot.resize(width, height);\n        }\n\n        if (change && this.key !== null)\n        {\n            this.onChangeSource.dispatch(this, width, height);\n\n            if (this._autoplay)\n            {\n                this.video.play();\n                this.onPlay.dispatch(this, this.loop, this.playbackRate);\n            }\n        }\n\n    },\n\n    /**\n     * Called when the video completes playback (reaches and ended state).\n     * Dispatches the Video.onComplete signal.\n     *\n     * @method Phaser.Video#complete\n     */\n    complete: function () {\n\n        this.onComplete.dispatch(this);\n\n    },\n\n    /**\n     * Starts this video playing if it's not already doing so.\n     *\n     * @method Phaser.Video#play\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that at present some browsers (i.e. Chrome) do not support *seamless* video looping.\n     * @param {number} [playbackRate=1] - The playback rate of the video. 1 is normal speed, 2 is x2 speed, and so on. You cannot set a negative playback rate.\n     * @return {Phaser.Video} This Video object for method chaining.\n     */\n    play: function (loop, playbackRate) {\n\n        if (loop === undefined) { loop = false; }\n        if (playbackRate === undefined) { playbackRate = 1; }\n\n        if (this.game.sound.onMute)\n        {\n            this.game.sound.onMute.add(this.setMute, this);\n            this.game.sound.onUnMute.add(this.unsetMute, this);\n\n            if (this.game.sound.mute)\n            {\n                this.setMute();\n            }\n        }\n\n        this.game.onPause.add(this.setPause, this);\n        this.game.onResume.add(this.setResume, this);\n\n        this._endCallback = this.complete.bind(this);\n\n        this.video.addEventListener('ended', this._endCallback, true);\n        this.video.addEventListener('webkitendfullscreen', this._endCallback, true);\n\n        if (loop)\n        {\n            this.video.loop = 'loop';\n        }\n        else\n        {\n            this.video.loop = '';\n        }\n\n        this.video.playbackRate = playbackRate;\n\n        if (this.touchLocked)\n        {\n            this._pending = true;\n        }\n        else\n        {\n            this._pending = false;\n\n            if (this.key !== null)\n            {\n                if (this.video.readyState !== 4)\n                {\n                    this.retry = this.retryLimit;\n                    this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\n                }\n                else\n                {\n                    this._playCallback = this.playHandler.bind(this);\n                    this.video.addEventListener('playing', this._playCallback, true);\n                }\n            }\n\n            this.video.play();\n\n            this.onPlay.dispatch(this, loop, playbackRate);\n        }\n\n        return this;\n\n    },\n\n    /**\n     * Called when the video starts to play. Updates the texture.\n     *\n     * @method Phaser.Video#playHandler\n     * @private\n     */\n    playHandler: function () {\n\n        this.video.removeEventListener('playing', this._playCallback, true);\n\n        this.updateTexture();\n\n    },\n\n    /**\n     * Stops the video playing.\n     *\n     * This removes all locally set signals.\n     *\n     * If you only wish to pause playback of the video, to resume at a later time, use `Video.paused = true` instead.\n     * If the video hasn't finished downloading calling `Video.stop` will not abort the download. To do that you need to\n     * call `Video.destroy` instead.\n     *\n     * If you are using a video stream from a webcam then calling Stop will disconnect the MediaStream session and disable the webcam.\n     *\n     * @method Phaser.Video#stop\n     * @return {Phaser.Video} This Video object for method chaining.\n     */\n    stop: function () {\n\n        if (this.game.sound.onMute)\n        {\n            this.game.sound.onMute.remove(this.setMute, this);\n            this.game.sound.onUnMute.remove(this.unsetMute, this);\n        }\n\n        this.game.onPause.remove(this.setPause, this);\n        this.game.onResume.remove(this.setResume, this);\n\n        //  Stream or file?\n\n        if (this.isStreaming)\n        {\n            if (this.video.mozSrcObject)\n            {\n                this.video.mozSrcObject.stop();\n                this.video.src = null;\n            }\n            else\n            {\n                this.video.src = \"\";\n\n                if (this.videoStream['active'])\n                {\n                    this.videoStream.active = false;\n                }\n                else\n                {\n                    if (this.videoStream.getTracks)\n                    {\n                        this.videoStream.getTracks().forEach(function (track) {\n                            track.stop();\n                        });\n                    }\n                    else\n                    {\n                        this.videoStream.stop();\n                    }\n\n                }\n            }\n\n            this.videoStream = null;\n            this.isStreaming = false;\n        }\n        else\n        {\n            this.video.removeEventListener('ended', this._endCallback, true);\n            this.video.removeEventListener('webkitendfullscreen', this._endCallback, true);\n            this.video.removeEventListener('playing', this._playCallback, true);\n\n            if (this.touchLocked)\n            {\n                this._pending = false;\n            }\n            else\n            {\n                this.video.pause();\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Updates the given Display Objects so they use this Video as their texture.\n    * This will replace any texture they will currently have set.\n    *\n    * @method Phaser.Video#add\n    * @param {Phaser.Sprite|Phaser.Sprite[]|Phaser.Image|Phaser.Image[]} object - Either a single Sprite/Image or an Array of Sprites/Images.\n    * @return {Phaser.Video} This Video object for method chaining.\n    */\n    add: function (object) {\n\n        if (Array.isArray(object))\n        {\n            for (var i = 0; i < object.length; i++)\n            {\n                if (object[i]['loadTexture'])\n                {\n                    object[i].loadTexture(this);\n                }\n            }\n        }\n        else\n        {\n            object.loadTexture(this);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Creates a new Phaser.Image object, assigns this Video to be its texture, adds it to the world then returns it.\n    *\n    * @method Phaser.Video#addToWorld\n    * @param {number} [x=0] - The x coordinate to place the Image at.\n    * @param {number} [y=0] - The y coordinate to place the Image at.\n    * @param {number} [anchorX=0] - Set the x anchor point of the Image. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.\n    * @param {number} [anchorY=0] - Set the y anchor point of the Image. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.\n    * @param {number} [scaleX=1] - The horizontal scale factor of the Image. A value of 1 means no scaling. 2 would be twice the size, and so on.\n    * @param {number} [scaleY=1] - The vertical scale factor of the Image. A value of 1 means no scaling. 2 would be twice the size, and so on.\n    * @return {Phaser.Image} The newly added Image object.\n    */\n    addToWorld: function (x, y, anchorX, anchorY, scaleX, scaleY) {\n\n        scaleX = scaleX || 1;\n        scaleY = scaleY || 1;\n\n        var image = this.game.add.image(x, y, this);\n\n        image.anchor.set(anchorX, anchorY);\n        image.scale.set(scaleX, scaleY);\n\n        return image;\n\n    },\n\n    /**\n    * If the game is running in WebGL this will push the texture up to the GPU if it's dirty.\n    * This is called automatically if the Video is being used by a Sprite, otherwise you need to remember to call it in your render function.\n    * If you wish to suppress this functionality set Video.disableTextureUpload to `true`.\n    *\n    * @method Phaser.Video#render\n    */\n    render: function () {\n\n        if (!this.disableTextureUpload && this.playing)\n        {\n            this.baseTexture.dirty();\n        }\n\n    },\n\n    /**\n    * Internal handler called automatically by the Video.mute setter.\n    *\n    * @method Phaser.Video#setMute\n    * @private\n    */\n    setMute: function () {\n\n        if (this._muted)\n        {\n            return;\n        }\n\n        this._muted = true;\n\n        this.video.muted = true;\n\n    },\n\n    /**\n    * Internal handler called automatically by the Video.mute setter.\n    *\n    * @method Phaser.Video#unsetMute\n    * @private\n    */\n    unsetMute: function () {\n\n        if (!this._muted || this._codeMuted)\n        {\n            return;\n        }\n\n        this._muted = false;\n\n        this.video.muted = false;\n\n    },\n\n    /**\n    * Internal handler called automatically by the Video.paused setter.\n    *\n    * @method Phaser.Video#setPause\n    * @private\n    */\n    setPause: function () {\n\n        if (this._paused || this.touchLocked)\n        {\n            return;\n        }\n\n        this._paused = true;\n\n        this.video.pause();\n\n    },\n\n    /**\n    * Internal handler called automatically by the Video.paused setter.\n    *\n    * @method Phaser.Video#setResume\n    * @private\n    */\n    setResume: function () {\n\n        if (!this._paused || this._codePaused || this.touchLocked)\n        {\n            return;\n        }\n\n        this._paused = false;\n\n        if (!this.video.ended)\n        {\n            this.video.play();\n        }\n\n    },\n\n    /**\n     * On some mobile browsers you cannot play a video until the user has explicitly touched the video to allow it.\n     * Phaser handles this via the `setTouchLock` method. However if you have 3 different videos, maybe an \"Intro\", \"Start\" and \"Game Over\"\n     * split into three different Video objects, then you will need the user to touch-unlock every single one of them.\n     *\n     * You can avoid this by using just one Video object and simply changing the video source. Once a Video element is unlocked it remains\n     * unlocked, even if the source changes. So you can use this to your benefit to avoid forcing the user to 'touch' the video yet again.\n     *\n     * As you'd expect there are limitations. So far we've found that the videos need to be in the same encoding format and bitrate.\n     * This method will automatically handle a change in video dimensions, but if you try swapping to a different bitrate we've found it\n     * cannot render the new video on iOS (desktop browsers cope better).\n     *\n     * When the video source is changed the video file is requested over the network. Listen for the `onChangeSource` signal to know\n     * when the new video has downloaded enough content to be able to be played. Previous settings such as the volume and loop state\n     * are adopted automatically by the new video.\n     *\n     * @method Phaser.Video#changeSource\n     * @param {string} src - The new URL to change the video.src to.\n     * @param {boolean} [autoplay=true] - Should the video play automatically after the source has been updated?\n     * @return {Phaser.Video} This Video object for method chaining.\n     */\n    changeSource: function (src, autoplay) {\n\n        if (autoplay === undefined) { autoplay = true; }\n\n        //  Invalidate the texture while we wait for the new one to load (crashes IE11 otherwise)\n        this.texture.valid = false;\n\n        this.video.pause();\n\n        this.retry = this.retryLimit;\n\n        this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\n\n        this.video.src = src;\n\n        this.video.load();\n\n        this._autoplay = autoplay;\n\n        if (!autoplay)\n        {\n            this.paused = true;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Internal callback that monitors the download progress of a video after changing its source.\n    *\n    * @method Phaser.Video#checkVideoProgress\n    * @private\n    */\n    checkVideoProgress: function () {\n\n        // if (this.video.readyState === 2 || this.video.readyState === 4)\n        if (this.video.readyState === 4)\n        {\n            //  We've got enough data to update the texture for playback\n            this.updateTexture();\n        }\n        else\n        {\n            this.retry--;\n\n            if (this.retry > 0)\n            {\n                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\n            }\n            else\n            {\n                console.warn('Phaser.Video: Unable to start downloading video in time', this.isStreaming);\n            }\n        }\n\n    },\n\n    /**\n    * Sets the Input Manager touch callback to be Video.unlock.\n    * Required for mobile video unlocking. Mostly just used internally.\n    *\n    * @method Phaser.Video#setTouchLock\n    */\n    setTouchLock: function () {\n\n        this.game.input.touch.addTouchLockCallback(this.unlock, this);\n        this.touchLocked = true;\n\n    },\n\n    /**\n    * Enables the video on mobile devices, usually after the first touch.\n    * If the SoundManager hasn't been unlocked then this will automatically unlock that as well.\n    * Only one video can be pending unlock at any one time.\n    *\n    * @method Phaser.Video#unlock\n    */\n    unlock: function () {\n\n        this.touchLocked = false;\n\n        this.video.play();\n\n        this.onPlay.dispatch(this, this.loop, this.playbackRate);\n\n        if (this.key)\n        {\n            var _video = this.game.cache.getVideo(this.key);\n\n            if (_video && !_video.isBlob)\n            {\n                _video.locked = false;\n            }\n        }\n\n        return true;\n\n    },\n\n    /**\n     * Grabs the current frame from the Video or Video Stream and renders it to the Video.snapshot BitmapData.\n     *\n     * You can optionally set if the BitmapData should be cleared or not, the alpha and the blend mode of the draw.\n     *\n     * If you need more advanced control over the grabbing them call `Video.snapshot.copy` directly with the same parameters as BitmapData.copy.\n     *\n     * @method Phaser.Video#grab\n     * @param {boolean} [clear=false] - Should the BitmapData be cleared before the Video is grabbed? Unless you are using alpha or a blend mode you can usually leave this set to false.\n     * @param {number} [alpha=1] - The alpha that will be set on the video before drawing. A value between 0 (fully transparent) and 1, opaque.\n     * @param {string} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all. This is a Canvas globalCompositeOperation value such as 'lighter' or 'xor'.\n     * @return {Phaser.BitmapData} A reference to the Video.snapshot BitmapData object for further method chaining.\n     */\n    grab: function (clear, alpha, blendMode) {\n\n        if (clear === undefined) { clear = false; }\n        if (alpha === undefined) { alpha = 1; }\n        if (blendMode === undefined) { blendMode = null; }\n\n        if (this.snapshot === null)\n        {\n            console.warn('Video.grab cannot run because Phaser.BitmapData is unavailable');\n            return;\n        }\n\n        if (clear)\n        {\n            this.snapshot.cls();\n        }\n\n        this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, alpha, blendMode);\n\n        return this.snapshot;\n\n    },\n\n    /**\n     * Removes the Video element from the DOM by calling parentNode.removeChild on itself.\n     * Also removes the autoplay and src attributes and nulls the reference.\n     *\n     * @method Phaser.Video#removeVideoElement\n     */\n    removeVideoElement: function () {\n\n        if (!this.video)\n        {\n            return;\n        }\n\n        if (this.video.parentNode)\n        {\n            this.video.parentNode.removeChild(this.video);\n        }\n\n        while (this.video.hasChildNodes())\n        {\n            this.video.removeChild(this.video.firstChild);\n        }\n\n        this.video.removeAttribute('autoplay');\n        this.video.removeAttribute('src');\n\n        this.video = null;\n\n    },\n\n    /**\n     * Destroys the Video object. This calls `Video.stop` and then `Video.removeVideoElement`.\n     * If any Sprites are using this Video as their texture it is up to you to manage those.\n     *\n     * @method Phaser.Video#destroy\n     */\n    destroy: function () {\n\n        this.stop();\n\n        this.removeVideoElement();\n\n        if (this.touchLocked)\n        {\n            this.game.input.touch.removeTouchLockCallback(this.unlock, this);\n        }\n\n        if (this._retryID)\n        {\n            window.clearTimeout(this._retryID);\n        }\n\n    }\n\n};\n\n/**\n* @name Phaser.Video#currentTime\n* @property {number} currentTime - The current time of the video in seconds. If set the video will attempt to seek to that point in time.\n*/\nObject.defineProperty(Phaser.Video.prototype, \"currentTime\", {\n\n    get: function () {\n\n        return (this.video) ? this.video.currentTime : 0;\n\n    },\n\n    set: function (value) {\n\n        this.video.currentTime = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Video#duration\n* @property {number} duration - The duration of the video in seconds.\n* @readOnly\n*/\nObject.defineProperty(Phaser.Video.prototype, \"duration\", {\n\n    get: function () {\n\n        return (this.video) ? this.video.duration : 0;\n\n    }\n\n});\n\n/**\n* @name Phaser.Video#progress\n* @property {number} progress - The progress of this video. This is a value between 0 and 1, where 0 is the start and 1 is the end of the video.\n* @readOnly\n*/\nObject.defineProperty(Phaser.Video.prototype, \"progress\", {\n\n    get: function () {\n\n        return (this.video) ? (this.video.currentTime / this.video.duration) : 0;\n\n    }\n\n});\n\n/**\n* @name Phaser.Video#mute\n* @property {boolean} mute - Gets or sets the muted state of the Video.\n*/\nObject.defineProperty(Phaser.Video.prototype, \"mute\", {\n\n    get: function () {\n\n        return this._muted;\n\n    },\n\n    set: function (value) {\n\n        value = value || null;\n\n        if (value)\n        {\n            if (this._muted)\n            {\n                return;\n            }\n\n            this._codeMuted = true;\n            this.setMute();\n        }\n        else\n        {\n            if (!this._muted)\n            {\n                return;\n            }\n\n            this._codeMuted = false;\n            this.unsetMute();\n        }\n    }\n\n});\n\n/**\n* Gets or sets the paused state of the Video.\n* If the video is still touch locked (such as on iOS devices) this call has no effect.\n*\n* @name Phaser.Video#paused\n* @property {boolean} paused\n*/\nObject.defineProperty(Phaser.Video.prototype, \"paused\", {\n\n    get: function () {\n\n        return this._paused;\n\n    },\n\n    set: function (value) {\n\n        value = value || null;\n\n        if (this.touchLocked)\n        {\n            return;\n        }\n\n        if (value)\n        {\n            if (this._paused)\n            {\n                return;\n            }\n\n            this._codePaused = true;\n            this.setPause();\n        }\n        else\n        {\n            if (!this._paused)\n            {\n                return;\n            }\n\n            this._codePaused = false;\n            this.setResume();\n        }\n    }\n\n});\n\n/**\n* @name Phaser.Video#volume\n* @property {number} volume - Gets or sets the volume of the Video, a value between 0 and 1. The value given is clamped to the range 0 to 1.\n*/\nObject.defineProperty(Phaser.Video.prototype, \"volume\", {\n\n    get: function () {\n\n        return (this.video) ? this.video.volume : 1;\n\n    },\n\n    set: function (value) {\n\n        if (value < 0)\n        {\n            value = 0;\n        }\n        else if (value > 1)\n        {\n            value = 1;\n        }\n\n        if (this.video)\n        {\n            this.video.volume = value;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Video#playbackRate\n* @property {number} playbackRate - Gets or sets the playback rate of the Video. This is the speed at which the video is playing.\n*/\nObject.defineProperty(Phaser.Video.prototype, \"playbackRate\", {\n\n    get: function () {\n\n        return (this.video) ? this.video.playbackRate : 1;\n\n    },\n\n    set: function (value) {\n\n        if (this.video)\n        {\n            this.video.playbackRate = value;\n        }\n\n    }\n\n});\n\n/**\n* Gets or sets if the Video is set to loop.\n* Please note that at present some browsers (i.e. Chrome) do not support *seamless* video looping.\n* If the video isn't yet set this will always return false.\n*\n* @name Phaser.Video#loop\n* @property {boolean} loop\n*/\nObject.defineProperty(Phaser.Video.prototype, \"loop\", {\n\n    get: function () {\n\n        return (this.video) ? this.video.loop : false;\n\n    },\n\n    set: function (value) {\n\n        if (value && this.video)\n        {\n            this.video.loop = 'loop';\n        }\n        else if (this.video)\n        {\n            this.video.loop = '';\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Video#playing\n* @property {boolean} playing - True if the video is currently playing (and not paused or ended), otherwise false.\n* @readOnly\n*/\nObject.defineProperty(Phaser.Video.prototype, \"playing\", {\n\n    get: function () {\n\n        return !(this.video.paused && this.video.ended);\n\n    }\n\n});\n\nPhaser.Video.prototype.constructor = Phaser.Video;\n\n/* global Phaser:true */\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n//  Pixi expects these globals to exist\n\nif (PIXI.blendModes === undefined)\n{\n    PIXI.blendModes = Phaser.blendModes;\n}\n\nif (PIXI.scaleModes === undefined)\n{\n    PIXI.scaleModes = Phaser.scaleModes;\n}\n\nif (PIXI.Texture.emptyTexture === undefined)\n{\n    PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture());\n}\n\nif (PIXI.DisplayObject._tempMatrix === undefined)\n{\n    PIXI.DisplayObject._tempMatrix = new PIXI.Matrix();\n}\n\nif (PIXI.RenderTexture.tempMatrix === undefined)\n{\n    PIXI.RenderTexture.tempMatrix = new PIXI.Matrix();\n}\n\nif (PIXI.Graphics && PIXI.Graphics.POLY === undefined)\n{\n    PIXI.Graphics.POLY = Phaser.POLYGON;\n    PIXI.Graphics.RECT = Phaser.RECTANGLE;\n    PIXI.Graphics.CIRC = Phaser.CIRCLE;\n    PIXI.Graphics.ELIP = Phaser.ELLIPSE;\n    PIXI.Graphics.RREC = Phaser.ROUNDEDRECTANGLE;\n}\n\nPIXI.TextureSilentFail = true;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = Phaser;\n        }\n        exports.Phaser = Phaser;\n    } else if (typeof define !== 'undefined' && define.amd) {\n        define('Phaser', (function() { return root.Phaser = Phaser; })() );\n    } else {\n        root.Phaser = Phaser;\n    }\n\n    return Phaser;\n}).call(this);\n\n/*\n* \"What matters in this life is not what we do but what we do for others, the legacy we leave and the imprint we make.\" - Eric Meyer\n*/\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/source-map-loader!./src/CustomizedDeps/phaser-custom.js\n// module id = 7\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 8\n// module chunks = 0","/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Bootstrap for the Google JS Library (Closure).\r\n *\r\n * In uncompiled mode base.js will write out Closure's deps file, unless the\r\n * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to\r\n * include their own deps file(s) from different locations.\r\n *\r\n *\r\n * @provideGoog\r\n */\r\n\r\n\r\n/**\r\n * @define {boolean} Overridden to true by the compiler when --closure_pass\r\n *     or --mark_as_compiled is specified.\r\n */\r\nvar COMPILED = false;\r\n\r\n\r\n/**\r\n * Base namespace for the Closure library.  Checks to see goog is already\r\n * defined in the current scope before assigning to prevent clobbering if\r\n * base.js is loaded more than once.\r\n *\r\n * @const\r\n */\r\nvar goog = goog || {};\r\n\r\n\r\n/**\r\n * Reference to the global context.  In most cases this will be 'window'.\r\n */\r\ngoog.global = this;\r\n\r\n\r\n/**\r\n * A hook for overriding the define values in uncompiled mode.\r\n *\r\n * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before\r\n * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},\r\n * {@code goog.define} will use the value instead of the default value.  This\r\n * allows flags to be overwritten without compilation (this is normally\r\n * accomplished with the compiler's \"define\" flag).\r\n *\r\n * Example:\r\n * <pre>\r\n *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};\r\n * </pre>\r\n *\r\n * @type {Object.<string, (string|number|boolean)>|undefined}\r\n */\r\ngoog.global.CLOSURE_UNCOMPILED_DEFINES;\r\n\r\n\r\n/**\r\n * A hook for overriding the define values in uncompiled or compiled mode,\r\n * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In\r\n * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.\r\n *\r\n * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or\r\n * string literals or the compiler will emit an error.\r\n *\r\n * While any @define value may be set, only those set with goog.define will be\r\n * effective for uncompiled code.\r\n *\r\n * Example:\r\n * <pre>\r\n *   var CLOSURE_DEFINES = {'goog.DEBUG': false};\r\n * </pre>\r\n *\r\n * @type {Object.<string, (string|number|boolean)>|undefined}\r\n */\r\ngoog.global.CLOSURE_DEFINES;\r\n\r\n\r\n/**\r\n * Returns true if the specified value is not undefined.\r\n * WARNING: Do not use this to test if an object has a property. Use the in\r\n * operator instead.\r\n *\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is defined.\r\n */\r\ngoog.isDef = function(val) {\r\n  // void 0 always evaluates to undefined and hence we do not need to depend on\r\n  // the definition of the global variable named 'undefined'.\r\n  return val !== void 0;\r\n};\r\n\r\n\r\n/**\r\n * Builds an object structure for the provided namespace path, ensuring that\r\n * names that already exist are not overwritten. For example:\r\n * \"a.b.c\" -> a = {};a.b={};a.b.c={};\r\n * Used by goog.provide and goog.exportSymbol.\r\n * @param {string} name name of the object that this file defines.\r\n * @param {*=} opt_object the object to expose at the end of the path.\r\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\r\n *     is |goog.global|.\r\n * @private\r\n */\r\ngoog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {\r\n  var parts = name.split('.');\r\n  var cur = opt_objectToExportTo || goog.global;\r\n\r\n  // Internet Explorer exhibits strange behavior when throwing errors from\r\n  // methods externed in this manner.  See the testExportSymbolExceptions in\r\n  // base_test.html for an example.\r\n  if (!(parts[0] in cur) && cur.execScript) {\r\n    cur.execScript('var ' + parts[0]);\r\n  }\r\n\r\n  // Certain browsers cannot parse code in the form for((a in b); c;);\r\n  // This pattern is produced by the JSCompiler when it collapses the\r\n  // statement above into the conditional loop below. To prevent this from\r\n  // happening, use a for-loop and reserve the init logic as below.\r\n\r\n  // Parentheses added to eliminate strict JS warning in Firefox.\r\n  for (var part; parts.length && (part = parts.shift());) {\r\n    if (!parts.length && goog.isDef(opt_object)) {\r\n      // last part and we have an object; use it\r\n      cur[part] = opt_object;\r\n    } else if (cur[part]) {\r\n      cur = cur[part];\r\n    } else {\r\n      cur = cur[part] = {};\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Defines a named value. In uncompiled mode, the value is retreived from\r\n * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and\r\n * has the property specified, and otherwise used the defined defaultValue.\r\n * When compiled, the default can be overridden using compiler command-line\r\n * options.\r\n *\r\n * @param {string} name The distinguished name to provide.\r\n * @param {string|number|boolean} defaultValue\r\n */\r\ngoog.define = function(name, defaultValue) {\r\n  var value = defaultValue;\r\n  if (!COMPILED) {\r\n    if (goog.global.CLOSURE_UNCOMPILED_DEFINES &&\r\n        Object.prototype.hasOwnProperty.call(\r\n            goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {\r\n      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];\r\n    } else if (goog.global.CLOSURE_DEFINES &&\r\n        Object.prototype.hasOwnProperty.call(\r\n            goog.global.CLOSURE_DEFINES, name)) {\r\n      value = goog.global.CLOSURE_DEFINES[name];\r\n    }\r\n  }\r\n  goog.exportPath_(name, value);\r\n};\r\n\r\n\r\n/**\r\n * @define {boolean} DEBUG is provided as a convenience so that debugging code\r\n * that should not be included in a production js_binary can be easily stripped\r\n * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most\r\n * toString() methods should be declared inside an \"if (goog.DEBUG)\" conditional\r\n * because they are generally used for debugging purposes and it is difficult\r\n * for the JSCompiler to statically determine whether they are used.\r\n */\r\ngoog.DEBUG = true;\r\n\r\n\r\n/**\r\n * @define {string} LOCALE defines the locale being used for compilation. It is\r\n * used to select locale specific data to be compiled in js binary. BUILD rule\r\n * can specify this value by \"--define goog.LOCALE=<locale_name>\" as JSCompiler\r\n * option.\r\n *\r\n * Take into account that the locale code format is important. You should use\r\n * the canonical Unicode format with hyphen as a delimiter. Language must be\r\n * lowercase, Language Script - Capitalized, Region - UPPERCASE.\r\n * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.\r\n *\r\n * See more info about locale codes here:\r\n * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers\r\n *\r\n * For language codes you should use values defined by ISO 693-1. See it here\r\n * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from\r\n * this rule: the Hebrew language. For legacy reasons the old code (iw) should\r\n * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.\r\n */\r\ngoog.define('goog.LOCALE', 'en');  // default to en\r\n\r\n\r\n/**\r\n * @define {boolean} Whether this code is running on trusted sites.\r\n *\r\n * On untrusted sites, several native functions can be defined or overridden by\r\n * external libraries like Prototype, Datejs, and JQuery and setting this flag\r\n * to false forces closure to use its own implementations when possible.\r\n *\r\n * If your JavaScript can be loaded by a third party site and you are wary about\r\n * relying on non-standard implementations, specify\r\n * \"--define goog.TRUSTED_SITE=false\" to the JSCompiler.\r\n */\r\ngoog.define('goog.TRUSTED_SITE', true);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether a project is expected to be running in strict mode.\r\n *\r\n * This define can be used to trigger alternate implementations compatible with\r\n * running in EcmaScript Strict mode or warn about unavailable functionality.\r\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode\r\n */\r\ngoog.define('goog.STRICT_MODE_COMPATIBLE', false);\r\n\r\n\r\n/**\r\n * Creates object stubs for a namespace.  The presence of one or more\r\n * goog.provide() calls indicate that the file defines the given\r\n * objects/namespaces.  Provided objects must not be null or undefined.\r\n * Build tools also scan for provide/require statements\r\n * to discern dependencies, build dependency files (see deps.js), etc.\r\n * @see goog.require\r\n * @param {string} name Namespace provided by this file in the form\r\n *     \"goog.package.part\".\r\n */\r\ngoog.provide = function(name) {\r\n  if (!COMPILED) {\r\n    // Ensure that the same namespace isn't provided twice. This is intended\r\n    // to teach new developers that 'goog.provide' is effectively a variable\r\n    // declaration. And when JSCompiler transforms goog.provide into a real\r\n    // variable declaration, the compiled JS should work the same as the raw\r\n    // JS--even when the raw JS uses goog.provide incorrectly.\r\n    if (goog.isProvided_(name)) {\r\n      throw Error('Namespace \"' + name + '\" already declared.');\r\n    }\r\n    delete goog.implicitNamespaces_[name];\r\n\r\n    var namespace = name;\r\n    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {\r\n      if (goog.getObjectByName(namespace)) {\r\n        break;\r\n      }\r\n      goog.implicitNamespaces_[namespace] = true;\r\n    }\r\n  }\r\n\r\n  goog.exportPath_(name);\r\n};\r\n\r\n\r\n/**\r\n * Marks that the current file should only be used for testing, and never for\r\n * live code in production.\r\n *\r\n * In the case of unit tests, the message may optionally be an exact namespace\r\n * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra\r\n * provide (if not explicitly defined in the code).\r\n *\r\n * @param {string=} opt_message Optional message to add to the error that's\r\n *     raised when used in production code.\r\n */\r\ngoog.setTestOnly = function(opt_message) {\r\n  if (COMPILED && !goog.DEBUG) {\r\n    opt_message = opt_message || '';\r\n    throw Error('Importing test-only code into non-debug environment' +\r\n                (opt_message ? ': ' + opt_message : '.'));\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Forward declares a symbol. This is an indication to the compiler that the\r\n * symbol may be used in the source yet is not required and may not be provided\r\n * in compilation.\r\n *\r\n * The most common usage of forward declaration is code that takes a type as a\r\n * function parameter but does not need to require it. By forward declaring\r\n * instead of requiring, no hard dependency is made, and (if not required\r\n * elsewhere) the namespace may never be required and thus, not be pulled\r\n * into the JavaScript binary. If it is required elsewhere, it will be type\r\n * checked as normal.\r\n *\r\n *\r\n * @param {string} name The namespace to forward declare in the form of\r\n *     \"goog.package.part\".\r\n */\r\ngoog.forwardDeclare = function(name) {};\r\n\r\n\r\nif (!COMPILED) {\r\n\r\n  /**\r\n   * Check if the given name has been goog.provided. This will return false for\r\n   * names that are available only as implicit namespaces.\r\n   * @param {string} name name of the object to look for.\r\n   * @return {boolean} Whether the name has been provided.\r\n   * @private\r\n   */\r\n  goog.isProvided_ = function(name) {\r\n    return !goog.implicitNamespaces_[name] &&\r\n        goog.isDefAndNotNull(goog.getObjectByName(name));\r\n  };\r\n\r\n  /**\r\n   * Namespaces implicitly defined by goog.provide. For example,\r\n   * goog.provide('goog.events.Event') implicitly declares that 'goog' and\r\n   * 'goog.events' must be namespaces.\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n  goog.implicitNamespaces_ = {};\r\n}\r\n\r\n\r\n/**\r\n * Returns an object based on its fully qualified external name.  The object\r\n * is not found if null or undefined.  If you are using a compilation pass that\r\n * renames property names beware that using this function will not find renamed\r\n * properties.\r\n *\r\n * @param {string} name The fully qualified name.\r\n * @param {Object=} opt_obj The object within which to look; default is\r\n *     |goog.global|.\r\n * @return {?} The value (object or primitive) or, if not found, null.\r\n */\r\ngoog.getObjectByName = function(name, opt_obj) {\r\n  var parts = name.split('.');\r\n  var cur = opt_obj || goog.global;\r\n  for (var part; part = parts.shift(); ) {\r\n    if (goog.isDefAndNotNull(cur[part])) {\r\n      cur = cur[part];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  return cur;\r\n};\r\n\r\n\r\n/**\r\n * Globalizes a whole namespace, such as goog or goog.lang.\r\n *\r\n * @param {Object} obj The namespace to globalize.\r\n * @param {Object=} opt_global The object to add the properties to.\r\n * @deprecated Properties may be explicitly exported to the global scope, but\r\n *     this should no longer be done in bulk.\r\n */\r\ngoog.globalize = function(obj, opt_global) {\r\n  var global = opt_global || goog.global;\r\n  for (var x in obj) {\r\n    global[x] = obj[x];\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Adds a dependency from a file to the files it requires.\r\n * @param {string} relPath The path to the js file.\r\n * @param {Array} provides An array of strings with the names of the objects\r\n *                         this file provides.\r\n * @param {Array} requires An array of strings with the names of the objects\r\n *                         this file requires.\r\n */\r\ngoog.addDependency = function(relPath, provides, requires) {\r\n  if (goog.DEPENDENCIES_ENABLED) {\r\n    var provide, require;\r\n    var path = relPath.replace(/\\\\/g, '/');\r\n    var deps = goog.dependencies_;\r\n    for (var i = 0; provide = provides[i]; i++) {\r\n      deps.nameToPath[provide] = path;\r\n      if (!(path in deps.pathToNames)) {\r\n        deps.pathToNames[path] = {};\r\n      }\r\n      deps.pathToNames[path][provide] = true;\r\n    }\r\n    for (var j = 0; require = requires[j]; j++) {\r\n      if (!(path in deps.requires)) {\r\n        deps.requires[path] = {};\r\n      }\r\n      deps.requires[path][require] = true;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n\r\n\r\n// NOTE(nnaze): The debug DOM loader was included in base.js as an original way\r\n// to do \"debug-mode\" development.  The dependency system can sometimes be\r\n// confusing, as can the debug DOM loader's asynchronous nature.\r\n//\r\n// With the DOM loader, a call to goog.require() is not blocking -- the script\r\n// will not load until some point after the current script.  If a namespace is\r\n// needed at runtime, it needs to be defined in a previous script, or loaded via\r\n// require() with its registered dependencies.\r\n// User-defined namespaces may need their own deps file.  See http://go/js_deps,\r\n// http://go/genjsdeps, or, externally, DepsWriter.\r\n// https://developers.google.com/closure/library/docs/depswriter\r\n//\r\n// Because of legacy clients, the DOM loader can't be easily removed from\r\n// base.js.  Work is being done to make it disableable or replaceable for\r\n// different environments (DOM-less JavaScript interpreters like Rhino or V8,\r\n// for example). See bootstrap/ for more information.\r\n\r\n\r\n/**\r\n * @define {boolean} Whether to enable the debug loader.\r\n *\r\n * If enabled, a call to goog.require() will attempt to load the namespace by\r\n * appending a script tag to the DOM (if the namespace has been registered).\r\n *\r\n * If disabled, goog.require() will simply assert that the namespace has been\r\n * provided (and depend on the fact that some outside tool correctly ordered\r\n * the script).\r\n */\r\ngoog.define('goog.ENABLE_DEBUG_LOADER', true);\r\n\r\n\r\n/**\r\n * Implements a system for the dynamic resolution of dependencies that works in\r\n * parallel with the BUILD system. Note that all calls to goog.require will be\r\n * stripped by the JSCompiler when the --closure_pass option is used.\r\n * @see goog.provide\r\n * @param {string} name Namespace to include (as was given in goog.provide()) in\r\n *     the form \"goog.package.part\".\r\n */\r\ngoog.require = function(name) {\r\n\r\n  // If the object already exists we do not need do do anything.\r\n  // TODO(arv): If we start to support require based on file name this has to\r\n  //            change.\r\n  // TODO(arv): If we allow goog.foo.* this has to change.\r\n  // TODO(arv): If we implement dynamic load after page load we should probably\r\n  //            not remove this code for the compiled output.\r\n  if (!COMPILED) {\r\n    if (goog.isProvided_(name)) {\r\n      return;\r\n    }\r\n\r\n    if (goog.ENABLE_DEBUG_LOADER) {\r\n      var path = goog.getPathFromDeps_(name);\r\n      if (path) {\r\n        goog.included_[path] = true;\r\n        goog.writeScripts_();\r\n        return;\r\n      }\r\n    }\r\n\r\n    var errorMessage = 'goog.require could not find: ' + name;\r\n    if (goog.global.console) {\r\n      goog.global.console['error'](errorMessage);\r\n    }\r\n\r\n\r\n      throw Error(errorMessage);\r\n\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Path for included scripts.\r\n * @type {string}\r\n */\r\ngoog.basePath = '';\r\n\r\n\r\n/**\r\n * A hook for overriding the base path.\r\n * @type {string|undefined}\r\n */\r\ngoog.global.CLOSURE_BASE_PATH;\r\n\r\n\r\n/**\r\n * Whether to write out Closure's deps file. By default, the deps are written.\r\n * @type {boolean|undefined}\r\n */\r\ngoog.global.CLOSURE_NO_DEPS;\r\n\r\n\r\n/**\r\n * A function to import a single script. This is meant to be overridden when\r\n * Closure is being run in non-HTML contexts, such as web workers. It's defined\r\n * in the global scope so that it can be set before base.js is loaded, which\r\n * allows deps.js to be imported properly.\r\n *\r\n * The function is passed the script source, which is a relative URI. It should\r\n * return true if the script was imported, false otherwise.\r\n * @type {(function(string): boolean)|undefined}\r\n */\r\ngoog.global.CLOSURE_IMPORT_SCRIPT;\r\n\r\n\r\n/**\r\n * Null function used for default values of callbacks, etc.\r\n * @return {void} Nothing.\r\n */\r\ngoog.nullFunction = function() {};\r\n\r\n\r\n/**\r\n * The identity function. Returns its first argument.\r\n *\r\n * @param {*=} opt_returnValue The single value that will be returned.\r\n * @param {...*} var_args Optional trailing arguments. These are ignored.\r\n * @return {?} The first argument. We can't know the type -- just pass it along\r\n *      without type.\r\n * @deprecated Use goog.functions.identity instead.\r\n */\r\ngoog.identityFunction = function(opt_returnValue, var_args) {\r\n  return opt_returnValue;\r\n};\r\n\r\n\r\n/**\r\n * When defining a class Foo with an abstract method bar(), you can do:\r\n * Foo.prototype.bar = goog.abstractMethod\r\n *\r\n * Now if a subclass of Foo fails to override bar(), an error will be thrown\r\n * when bar() is invoked.\r\n *\r\n * Note: This does not take the name of the function to override as an argument\r\n * because that would make it more difficult to obfuscate our JavaScript code.\r\n *\r\n * @type {!Function}\r\n * @throws {Error} when invoked to indicate the method should be overridden.\r\n */\r\ngoog.abstractMethod = function() {\r\n  throw Error('unimplemented abstract method');\r\n};\r\n\r\n\r\n/**\r\n * Adds a {@code getInstance} static method that always returns the same\r\n * instance object.\r\n * @param {!Function} ctor The constructor for the class to add the static\r\n *     method to.\r\n */\r\ngoog.addSingletonGetter = function(ctor) {\r\n  ctor.getInstance = function() {\r\n    if (ctor.instance_) {\r\n      return ctor.instance_;\r\n    }\r\n    if (goog.DEBUG) {\r\n      // NOTE: JSCompiler can't optimize away Array#push.\r\n      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;\r\n    }\r\n    return ctor.instance_ = new ctor;\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * All singleton classes that have been instantiated, for testing. Don't read\r\n * it directly, use the {@code goog.testing.singleton} module. The compiler\r\n * removes this variable if unused.\r\n * @type {!Array.<!Function>}\r\n * @private\r\n */\r\ngoog.instantiatedSingletons_ = [];\r\n\r\n\r\n/**\r\n * True if goog.dependencies_ is available.\r\n * @const {boolean}\r\n */\r\ngoog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;\r\n\r\n\r\nif (goog.DEPENDENCIES_ENABLED) {\r\n  /**\r\n   * Object used to keep track of urls that have already been added. This record\r\n   * allows the prevention of circular dependencies.\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n  goog.included_ = {};\r\n\r\n\r\n  /**\r\n   * This object is used to keep track of dependencies and other data that is\r\n   * used for loading scripts.\r\n   * @private\r\n   * @type {Object}\r\n   */\r\n  goog.dependencies_ = {\r\n    pathToNames: {}, // 1 to many\r\n    nameToPath: {}, // 1 to 1\r\n    requires: {}, // 1 to many\r\n    // Used when resolving dependencies to prevent us from visiting file twice.\r\n    visited: {},\r\n    written: {} // Used to keep track of script files we have written.\r\n  };\r\n\r\n\r\n  /**\r\n   * Tries to detect whether is in the context of an HTML document.\r\n   * @return {boolean} True if it looks like HTML document.\r\n   * @private\r\n   */\r\n  goog.inHtmlDocument_ = function() {\r\n    var doc = goog.global.document;\r\n    return typeof doc != 'undefined' &&\r\n           'write' in doc;  // XULDocument misses write.\r\n  };\r\n\r\n\r\n  /**\r\n   * Tries to detect the base path of base.js script that bootstraps Closure.\r\n   * @private\r\n   */\r\n  goog.findBasePath_ = function() {\r\n    if (goog.global.CLOSURE_BASE_PATH) {\r\n      goog.basePath = goog.global.CLOSURE_BASE_PATH;\r\n      return;\r\n    } else if (!goog.inHtmlDocument_()) {\r\n      return;\r\n    }\r\n    var doc = goog.global.document;\r\n    var scripts = doc.getElementsByTagName('script');\r\n    // Search backwards since the current script is in almost all cases the one\r\n    // that has base.js.\r\n    for (var i = scripts.length - 1; i >= 0; --i) {\r\n      var src = scripts[i].src;\r\n      var qmark = src.lastIndexOf('?');\r\n      var l = qmark == -1 ? src.length : qmark;\r\n      if (src.substr(l - 7, 7) == 'base.js') {\r\n        goog.basePath = src.substr(0, l - 7);\r\n        return;\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Imports a script if, and only if, that script hasn't already been imported.\r\n   * (Must be called at execution time)\r\n   * @param {string} src Script source.\r\n   * @private\r\n   */\r\n  goog.importScript_ = function(src) {\r\n    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||\r\n        goog.writeScriptTag_;\r\n    if (!goog.dependencies_.written[src] && importScript(src)) {\r\n      goog.dependencies_.written[src] = true;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * The default implementation of the import function. Writes a script tag to\r\n   * import the script.\r\n   *\r\n   * @param {string} src The script source.\r\n   * @return {boolean} True if the script was imported, false otherwise.\r\n   * @private\r\n   */\r\n  goog.writeScriptTag_ = function(src) {\r\n    if (goog.inHtmlDocument_()) {\r\n      var doc = goog.global.document;\r\n\r\n      // If the user tries to require a new symbol after document load,\r\n      // something has gone terribly wrong. Doing a document.write would\r\n      // wipe out the page.\r\n      if (doc.readyState == 'complete') {\r\n        // Certain test frameworks load base.js multiple times, which tries\r\n        // to write deps.js each time. If that happens, just fail silently.\r\n        // These frameworks wipe the page between each load of base.js, so this\r\n        // is OK.\r\n        var isDeps = /\\bdeps.js$/.test(src);\r\n        if (isDeps) {\r\n          return false;\r\n        } else {\r\n          throw Error('Cannot write \"' + src + '\" after document load');\r\n        }\r\n      }\r\n\r\n      doc.write(\r\n          '<script type=\"text/javascript\" src=\"' + src + '\"></' + 'script>');\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Resolves dependencies based on the dependencies added using addDependency\r\n   * and calls importScript_ in the correct order.\r\n   * @private\r\n   */\r\n  goog.writeScripts_ = function() {\r\n    // The scripts we need to write this time.\r\n    var scripts = [];\r\n    var seenScript = {};\r\n    var deps = goog.dependencies_;\r\n\r\n    function visitNode(path) {\r\n      if (path in deps.written) {\r\n        return;\r\n      }\r\n\r\n      // We have already visited this one. We can get here if we have cyclic\r\n      // dependencies.\r\n      if (path in deps.visited) {\r\n        if (!(path in seenScript)) {\r\n          seenScript[path] = true;\r\n          scripts.push(path);\r\n        }\r\n        return;\r\n      }\r\n\r\n      deps.visited[path] = true;\r\n\r\n      if (path in deps.requires) {\r\n        for (var requireName in deps.requires[path]) {\r\n          // If the required name is defined, we assume that it was already\r\n          // bootstrapped by other means.\r\n          if (!goog.isProvided_(requireName)) {\r\n            if (requireName in deps.nameToPath) {\r\n              visitNode(deps.nameToPath[requireName]);\r\n            } else {\r\n              throw Error('Undefined nameToPath for ' + requireName);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!(path in seenScript)) {\r\n        seenScript[path] = true;\r\n        scripts.push(path);\r\n      }\r\n    }\r\n\r\n    for (var path in goog.included_) {\r\n      if (!deps.written[path]) {\r\n        visitNode(path);\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < scripts.length; i++) {\r\n      if (scripts[i]) {\r\n        goog.importScript_(goog.basePath + scripts[i]);\r\n      } else {\r\n        throw Error('Undefined script input');\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Looks at the dependency rules and tries to determine the script file that\r\n   * fulfills a particular rule.\r\n   * @param {string} rule In the form goog.namespace.Class or project.script.\r\n   * @return {?string} Url corresponding to the rule, or null.\r\n   * @private\r\n   */\r\n  goog.getPathFromDeps_ = function(rule) {\r\n    if (rule in goog.dependencies_.nameToPath) {\r\n      return goog.dependencies_.nameToPath[rule];\r\n    } else {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  goog.findBasePath_();\r\n\r\n  // Allow projects to manage the deps files themselves.\r\n  // if (!goog.global.CLOSURE_NO_DEPS) {\r\n  //   goog.importScript_(goog.basePath + 'deps.js');\r\n  // }\r\n}\r\n\r\n\r\n\r\n//==============================================================================\r\n// Language Enhancements\r\n//==============================================================================\r\n\r\n\r\n/**\r\n * This is a \"fixed\" version of the typeof operator.  It differs from the typeof\r\n * operator in such a way that null returns 'null' and arrays return 'array'.\r\n * @param {*} value The value to get the type of.\r\n * @return {string} The name of the type.\r\n */\r\ngoog.typeOf = function(value) {\r\n  var s = typeof value;\r\n  if (s == 'object') {\r\n    if (value) {\r\n      // Check these first, so we can avoid calling Object.prototype.toString if\r\n      // possible.\r\n      //\r\n      // IE improperly marshals tyepof across execution contexts, but a\r\n      // cross-context object will still return false for \"instanceof Object\".\r\n      if (value instanceof Array) {\r\n        return 'array';\r\n      } else if (value instanceof Object) {\r\n        return s;\r\n      }\r\n\r\n      // HACK: In order to use an Object prototype method on the arbitrary\r\n      //   value, the compiler requires the value be cast to type Object,\r\n      //   even though the ECMA spec explicitly allows it.\r\n      var className = Object.prototype.toString.call(\r\n          /** @type {Object} */ (value));\r\n      // In Firefox 3.6, attempting to access iframe window objects' length\r\n      // property throws an NS_ERROR_FAILURE, so we need to special-case it\r\n      // here.\r\n      if (className == '[object Window]') {\r\n        return 'object';\r\n      }\r\n\r\n      // We cannot always use constructor == Array or instanceof Array because\r\n      // different frames have different Array objects. In IE6, if the iframe\r\n      // where the array was created is destroyed, the array loses its\r\n      // prototype. Then dereferencing val.splice here throws an exception, so\r\n      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'\r\n      // so that will work. In this case, this function will return false and\r\n      // most array functions will still work because the array is still\r\n      // array-like (supports length and []) even though it has lost its\r\n      // prototype.\r\n      // Mark Miller noticed that Object.prototype.toString\r\n      // allows access to the unforgeable [[Class]] property.\r\n      //  15.2.4.2 Object.prototype.toString ( )\r\n      //  When the toString method is called, the following steps are taken:\r\n      //      1. Get the [[Class]] property of this object.\r\n      //      2. Compute a string value by concatenating the three strings\r\n      //         \"[object \", Result(1), and \"]\".\r\n      //      3. Return Result(2).\r\n      // and this behavior survives the destruction of the execution context.\r\n      if ((className == '[object Array]' ||\r\n           // In IE all non value types are wrapped as objects across window\r\n           // boundaries (not iframe though) so we have to do object detection\r\n           // for this edge case.\r\n           typeof value.length == 'number' &&\r\n           typeof value.splice != 'undefined' &&\r\n           typeof value.propertyIsEnumerable != 'undefined' &&\r\n           !value.propertyIsEnumerable('splice')\r\n\r\n          )) {\r\n        return 'array';\r\n      }\r\n      // HACK: There is still an array case that fails.\r\n      //     function ArrayImpostor() {}\r\n      //     ArrayImpostor.prototype = [];\r\n      //     var impostor = new ArrayImpostor;\r\n      // this can be fixed by getting rid of the fast path\r\n      // (value instanceof Array) and solely relying on\r\n      // (value && Object.prototype.toString.vall(value) === '[object Array]')\r\n      // but that would require many more function calls and is not warranted\r\n      // unless closure code is receiving objects from untrusted sources.\r\n\r\n      // IE in cross-window calls does not correctly marshal the function type\r\n      // (it appears just as an object) so we cannot use just typeof val ==\r\n      // 'function'. However, if the object has a call property, it is a\r\n      // function.\r\n      if ((className == '[object Function]' ||\r\n          typeof value.call != 'undefined' &&\r\n          typeof value.propertyIsEnumerable != 'undefined' &&\r\n          !value.propertyIsEnumerable('call'))) {\r\n        return 'function';\r\n      }\r\n\r\n    } else {\r\n      return 'null';\r\n    }\r\n\r\n  } else if (s == 'function' && typeof value.call == 'undefined') {\r\n    // In Safari typeof nodeList returns 'function', and on Firefox typeof\r\n    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We\r\n    // would like to return object for those and we can detect an invalid\r\n    // function by making sure that the function object has a call method.\r\n    return 'object';\r\n  }\r\n  return s;\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is null.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is null.\r\n */\r\ngoog.isNull = function(val) {\r\n  return val === null;\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is defined and not null.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is defined and not null.\r\n */\r\ngoog.isDefAndNotNull = function(val) {\r\n  // Note that undefined == null.\r\n  return val != null;\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is an array.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is an array.\r\n */\r\ngoog.isArray = function(val) {\r\n  return goog.typeOf(val) == 'array';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the object looks like an array. To qualify as array like\r\n * the value needs to be either a NodeList or an object with a Number length\r\n * property.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is an array.\r\n */\r\ngoog.isArrayLike = function(val) {\r\n  var type = goog.typeOf(val);\r\n  return type == 'array' || type == 'object' && typeof val.length == 'number';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the object looks like a Date. To qualify as Date-like the\r\n * value needs to be an object and have a getFullYear() function.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is a like a Date.\r\n */\r\ngoog.isDateLike = function(val) {\r\n  return goog.isObject(val) && typeof val.getFullYear == 'function';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is a string.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is a string.\r\n */\r\ngoog.isString = function(val) {\r\n  return typeof val == 'string';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is a boolean.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is boolean.\r\n */\r\ngoog.isBoolean = function(val) {\r\n  return typeof val == 'boolean';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is a number.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is a number.\r\n */\r\ngoog.isNumber = function(val) {\r\n  return typeof val == 'number';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is a function.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is a function.\r\n */\r\ngoog.isFunction = function(val) {\r\n  return goog.typeOf(val) == 'function';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is an object.  This includes arrays and\r\n * functions.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is an object.\r\n */\r\ngoog.isObject = function(val) {\r\n  var type = typeof val;\r\n  return type == 'object' && val != null || type == 'function';\r\n  // return Object(val) === val also works, but is slower, especially if val is\r\n  // not an object.\r\n};\r\n\r\n\r\n/**\r\n * Gets a unique ID for an object. This mutates the object so that further calls\r\n * with the same object as a parameter returns the same value. The unique ID is\r\n * guaranteed to be unique across the current session amongst objects that are\r\n * passed into {@code getUid}. There is no guarantee that the ID is unique or\r\n * consistent across sessions. It is unsafe to generate unique ID for function\r\n * prototypes.\r\n *\r\n * @param {Object} obj The object to get the unique ID for.\r\n * @return {number} The unique ID for the object.\r\n */\r\ngoog.getUid = function(obj) {\r\n  // TODO(arv): Make the type stricter, do not accept null.\r\n\r\n  // In Opera window.hasOwnProperty exists but always returns false so we avoid\r\n  // using it. As a consequence the unique ID generated for BaseClass.prototype\r\n  // and SubClass.prototype will be the same.\r\n  return obj[goog.UID_PROPERTY_] ||\r\n      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);\r\n};\r\n\r\n\r\n/**\r\n * Whether the given object is alreay assigned a unique ID.\r\n *\r\n * This does not modify the object.\r\n *\r\n * @param {Object} obj The object to check.\r\n * @return {boolean} Whether there an assigned unique id for the object.\r\n */\r\ngoog.hasUid = function(obj) {\r\n  return !!obj[goog.UID_PROPERTY_];\r\n};\r\n\r\n\r\n/**\r\n * Removes the unique ID from an object. This is useful if the object was\r\n * previously mutated using {@code goog.getUid} in which case the mutation is\r\n * undone.\r\n * @param {Object} obj The object to remove the unique ID field from.\r\n */\r\ngoog.removeUid = function(obj) {\r\n  // TODO(arv): Make the type stricter, do not accept null.\r\n\r\n  // In IE, DOM nodes are not instances of Object and throw an exception if we\r\n  // try to delete.  Instead we try to use removeAttribute.\r\n  if ('removeAttribute' in obj) {\r\n    obj.removeAttribute(goog.UID_PROPERTY_);\r\n  }\r\n  /** @preserveTry */\r\n  try {\r\n    delete obj[goog.UID_PROPERTY_];\r\n  } catch (ex) {\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Name for unique ID property. Initialized in a way to help avoid collisions\r\n * with other closure JavaScript on the same page.\r\n * @type {string}\r\n * @private\r\n */\r\ngoog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);\r\n\r\n\r\n/**\r\n * Counter for UID.\r\n * @type {number}\r\n * @private\r\n */\r\ngoog.uidCounter_ = 0;\r\n\r\n\r\n/**\r\n * Adds a hash code field to an object. The hash code is unique for the\r\n * given object.\r\n * @param {Object} obj The object to get the hash code for.\r\n * @return {number} The hash code for the object.\r\n * @deprecated Use goog.getUid instead.\r\n */\r\ngoog.getHashCode = goog.getUid;\r\n\r\n\r\n/**\r\n * Removes the hash code field from an object.\r\n * @param {Object} obj The object to remove the field from.\r\n * @deprecated Use goog.removeUid instead.\r\n */\r\ngoog.removeHashCode = goog.removeUid;\r\n\r\n\r\n/**\r\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\r\n * arrays will be cloned recursively.\r\n *\r\n * WARNINGS:\r\n * <code>goog.cloneObject</code> does not detect reference loops. Objects that\r\n * refer to themselves will cause infinite recursion.\r\n *\r\n * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies\r\n * UIDs created by <code>getUid</code> into cloned results.\r\n *\r\n * @param {*} obj The value to clone.\r\n * @return {*} A clone of the input value.\r\n * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.\r\n */\r\ngoog.cloneObject = function(obj) {\r\n  var type = goog.typeOf(obj);\r\n  if (type == 'object' || type == 'array') {\r\n    if (obj.clone) {\r\n      return obj.clone();\r\n    }\r\n    var clone = type == 'array' ? [] : {};\r\n    for (var key in obj) {\r\n      clone[key] = goog.cloneObject(obj[key]);\r\n    }\r\n    return clone;\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\n\r\n/**\r\n * A native implementation of goog.bind.\r\n * @param {Function} fn A function to partially apply.\r\n * @param {Object|undefined} selfObj Specifies the object which this should\r\n *     point to when the function is run.\r\n * @param {...*} var_args Additional arguments that are partially applied to the\r\n *     function.\r\n * @return {!Function} A partially-applied form of the function bind() was\r\n *     invoked as a method of.\r\n * @private\r\n * @suppress {deprecated} The compiler thinks that Function.prototype.bind is\r\n *     deprecated because some people have declared a pure-JS version.\r\n *     Only the pure-JS version is truly deprecated.\r\n */\r\ngoog.bindNative_ = function(fn, selfObj, var_args) {\r\n  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));\r\n};\r\n\r\n\r\n/**\r\n * A pure-JS implementation of goog.bind.\r\n * @param {Function} fn A function to partially apply.\r\n * @param {Object|undefined} selfObj Specifies the object which this should\r\n *     point to when the function is run.\r\n * @param {...*} var_args Additional arguments that are partially applied to the\r\n *     function.\r\n * @return {!Function} A partially-applied form of the function bind() was\r\n *     invoked as a method of.\r\n * @private\r\n */\r\ngoog.bindJs_ = function(fn, selfObj, var_args) {\r\n  if (!fn) {\r\n    throw new Error();\r\n  }\r\n\r\n  if (arguments.length > 2) {\r\n    var boundArgs = Array.prototype.slice.call(arguments, 2);\r\n    return function() {\r\n      // Prepend the bound arguments to the current arguments.\r\n      var newArgs = Array.prototype.slice.call(arguments);\r\n      Array.prototype.unshift.apply(newArgs, boundArgs);\r\n      return fn.apply(selfObj, newArgs);\r\n    };\r\n\r\n  } else {\r\n    return function() {\r\n      return fn.apply(selfObj, arguments);\r\n    };\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Partially applies this function to a particular 'this object' and zero or\r\n * more arguments. The result is a new function with some arguments of the first\r\n * function pre-filled and the value of this 'pre-specified'.\r\n *\r\n * Remaining arguments specified at call-time are appended to the pre-specified\r\n * ones.\r\n *\r\n * Also see: {@link #partial}.\r\n *\r\n * Usage:\r\n * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');\r\n * barMethBound('arg3', 'arg4');</pre>\r\n *\r\n * @param {?function(this:T, ...)} fn A function to partially apply.\r\n * @param {T} selfObj Specifies the object which this should point to when the\r\n *     function is run.\r\n * @param {...*} var_args Additional arguments that are partially applied to the\r\n *     function.\r\n * @return {!Function} A partially-applied form of the function bind() was\r\n *     invoked as a method of.\r\n * @template T\r\n * @suppress {deprecated} See above.\r\n */\r\ngoog.bind = function(fn, selfObj, var_args) {\r\n  // TODO(nicksantos): narrow the type signature.\r\n  if (Function.prototype.bind &&\r\n      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome\r\n      // extension environment. This means that for Chrome extensions, they get\r\n      // the implementation of Function.prototype.bind that calls goog.bind\r\n      // instead of the native one. Even worse, we don't want to introduce a\r\n      // circular dependency between goog.bind and Function.prototype.bind, so\r\n      // we have to hack this to make sure it works correctly.\r\n      Function.prototype.bind.toString().indexOf('native code') != -1) {\r\n    goog.bind = goog.bindNative_;\r\n  } else {\r\n    goog.bind = goog.bindJs_;\r\n  }\r\n  return goog.bind.apply(null, arguments);\r\n};\r\n\r\n\r\n/**\r\n * Like bind(), except that a 'this object' is not required. Useful when the\r\n * target function is already bound.\r\n *\r\n * Usage:\r\n * var g = partial(f, arg1, arg2);\r\n * g(arg3, arg4);\r\n *\r\n * @param {Function} fn A function to partially apply.\r\n * @param {...*} var_args Additional arguments that are partially applied to fn.\r\n * @return {!Function} A partially-applied form of the function bind() was\r\n *     invoked as a method of.\r\n */\r\ngoog.partial = function(fn, var_args) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function() {\r\n    // Clone the array (with slice()) and append additional arguments\r\n    // to the existing arguments.\r\n    var newArgs = args.slice();\r\n    newArgs.push.apply(newArgs, arguments);\r\n    return fn.apply(this, newArgs);\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Copies all the members of a source object to a target object. This method\r\n * does not work on all browsers for all objects that contain keys such as\r\n * toString or hasOwnProperty. Use goog.object.extend for this purpose.\r\n * @param {Object} target Target.\r\n * @param {Object} source Source.\r\n */\r\ngoog.mixin = function(target, source) {\r\n  for (var x in source) {\r\n    target[x] = source[x];\r\n  }\r\n\r\n  // For IE7 or lower, the for-in-loop does not contain any properties that are\r\n  // not enumerable on the prototype object (for example, isPrototypeOf from\r\n  // Object.prototype) but also it will not include 'replace' on objects that\r\n  // extend String and change 'replace' (not that it is common for anyone to\r\n  // extend anything except Object).\r\n};\r\n\r\n\r\n/**\r\n * @return {number} An integer value representing the number of milliseconds\r\n *     between midnight, January 1, 1970 and the current time.\r\n */\r\ngoog.now = (goog.TRUSTED_SITE && Date.now) || (function() {\r\n  // Unary plus operator converts its operand to a number which in the case of\r\n  // a date is done by calling getTime().\r\n  return +new Date();\r\n});\r\n\r\n\r\n/**\r\n * Evals JavaScript in the global scope.  In IE this uses execScript, other\r\n * browsers use goog.global.eval. If goog.global.eval does not evaluate in the\r\n * global scope (for example, in Safari), appends a script tag instead.\r\n * Throws an exception if neither execScript or eval is defined.\r\n * @param {string} script JavaScript string.\r\n */\r\ngoog.globalEval = function(script) {\r\n  if (goog.global.execScript) {\r\n    goog.global.execScript(script, 'JavaScript');\r\n  } else if (goog.global.eval) {\r\n    // Test to see if eval works\r\n    if (goog.evalWorksForGlobals_ == null) {\r\n      goog.global.eval('var _et_ = 1;');\r\n      if (typeof goog.global['_et_'] != 'undefined') {\r\n        delete goog.global['_et_'];\r\n        goog.evalWorksForGlobals_ = true;\r\n      } else {\r\n        goog.evalWorksForGlobals_ = false;\r\n      }\r\n    }\r\n\r\n    if (goog.evalWorksForGlobals_) {\r\n      goog.global.eval(script);\r\n    } else {\r\n      var doc = goog.global.document;\r\n      var scriptElt = doc.createElement('script');\r\n      scriptElt.type = 'text/javascript';\r\n      scriptElt.defer = false;\r\n      // Note(user): can't use .innerHTML since \"t('<test>')\" will fail and\r\n      // .text doesn't work in Safari 2.  Therefore we append a text node.\r\n      scriptElt.appendChild(doc.createTextNode(script));\r\n      doc.body.appendChild(scriptElt);\r\n      doc.body.removeChild(scriptElt);\r\n    }\r\n  } else {\r\n    throw Error('goog.globalEval not available');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Indicates whether or not we can call 'eval' directly to eval code in the\r\n * global scope. Set to a Boolean by the first call to goog.globalEval (which\r\n * empirically tests whether eval works for globals). @see goog.globalEval\r\n * @type {?boolean}\r\n * @private\r\n */\r\ngoog.evalWorksForGlobals_ = null;\r\n\r\n\r\n/**\r\n * Optional map of CSS class names to obfuscated names used with\r\n * goog.getCssName().\r\n * @type {Object|undefined}\r\n * @private\r\n * @see goog.setCssNameMapping\r\n */\r\ngoog.cssNameMapping_;\r\n\r\n\r\n/**\r\n * Optional obfuscation style for CSS class names. Should be set to either\r\n * 'BY_WHOLE' or 'BY_PART' if defined.\r\n * @type {string|undefined}\r\n * @private\r\n * @see goog.setCssNameMapping\r\n */\r\ngoog.cssNameMappingStyle_;\r\n\r\n\r\n/**\r\n * Handles strings that are intended to be used as CSS class names.\r\n *\r\n * This function works in tandem with @see goog.setCssNameMapping.\r\n *\r\n * Without any mapping set, the arguments are simple joined with a hyphen and\r\n * passed through unaltered.\r\n *\r\n * When there is a mapping, there are two possible styles in which these\r\n * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)\r\n * of the passed in css name is rewritten according to the map. In the BY_WHOLE\r\n * style, the full css name is looked up in the map directly. If a rewrite is\r\n * not specified by the map, the compiler will output a warning.\r\n *\r\n * When the mapping is passed to the compiler, it will replace calls to\r\n * goog.getCssName with the strings from the mapping, e.g.\r\n *     var x = goog.getCssName('foo');\r\n *     var y = goog.getCssName(this.baseClass, 'active');\r\n *  becomes:\r\n *     var x= 'foo';\r\n *     var y = this.baseClass + '-active';\r\n *\r\n * If one argument is passed it will be processed, if two are passed only the\r\n * modifier will be processed, as it is assumed the first argument was generated\r\n * as a result of calling goog.getCssName.\r\n *\r\n * @param {string} className The class name.\r\n * @param {string=} opt_modifier A modifier to be appended to the class name.\r\n * @return {string} The class name or the concatenation of the class name and\r\n *     the modifier.\r\n */\r\ngoog.getCssName = function(className, opt_modifier) {\r\n  var getMapping = function(cssName) {\r\n    return goog.cssNameMapping_[cssName] || cssName;\r\n  };\r\n\r\n  var renameByParts = function(cssName) {\r\n    // Remap all the parts individually.\r\n    var parts = cssName.split('-');\r\n    var mapped = [];\r\n    for (var i = 0; i < parts.length; i++) {\r\n      mapped.push(getMapping(parts[i]));\r\n    }\r\n    return mapped.join('-');\r\n  };\r\n\r\n  var rename;\r\n  if (goog.cssNameMapping_) {\r\n    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?\r\n        getMapping : renameByParts;\r\n  } else {\r\n    rename = function(a) {\r\n      return a;\r\n    };\r\n  }\r\n\r\n  if (opt_modifier) {\r\n    return className + '-' + rename(opt_modifier);\r\n  } else {\r\n    return rename(className);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Sets the map to check when returning a value from goog.getCssName(). Example:\r\n * <pre>\r\n * goog.setCssNameMapping({\r\n *   \"goog\": \"a\",\r\n *   \"disabled\": \"b\",\r\n * });\r\n *\r\n * var x = goog.getCssName('goog');\r\n * // The following evaluates to: \"a a-b\".\r\n * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')\r\n * </pre>\r\n * When declared as a map of string literals to string literals, the JSCompiler\r\n * will replace all calls to goog.getCssName() using the supplied map if the\r\n * --closure_pass flag is set.\r\n *\r\n * @param {!Object} mapping A map of strings to strings where keys are possible\r\n *     arguments to goog.getCssName() and values are the corresponding values\r\n *     that should be returned.\r\n * @param {string=} opt_style The style of css name mapping. There are two valid\r\n *     options: 'BY_PART', and 'BY_WHOLE'.\r\n * @see goog.getCssName for a description.\r\n */\r\ngoog.setCssNameMapping = function(mapping, opt_style) {\r\n  goog.cssNameMapping_ = mapping;\r\n  goog.cssNameMappingStyle_ = opt_style;\r\n};\r\n\r\n\r\n/**\r\n * To use CSS renaming in compiled mode, one of the input files should have a\r\n * call to goog.setCssNameMapping() with an object literal that the JSCompiler\r\n * can extract and use to replace all calls to goog.getCssName(). In uncompiled\r\n * mode, JavaScript code should be loaded before this base.js file that declares\r\n * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is\r\n * to ensure that the mapping is loaded before any calls to goog.getCssName()\r\n * are made in uncompiled mode.\r\n *\r\n * A hook for overriding the CSS name mapping.\r\n * @type {Object|undefined}\r\n */\r\ngoog.global.CLOSURE_CSS_NAME_MAPPING;\r\n\r\n\r\nif (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {\r\n  // This does not call goog.setCssNameMapping() because the JSCompiler\r\n  // requires that goog.setCssNameMapping() be called with an object literal.\r\n  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;\r\n}\r\n\r\n\r\n/**\r\n * Gets a localized message.\r\n *\r\n * This function is a compiler primitive. If you give the compiler a localized\r\n * message bundle, it will replace the string at compile-time with a localized\r\n * version, and expand goog.getMsg call to a concatenated string.\r\n *\r\n * Messages must be initialized in the form:\r\n * <code>\r\n * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});\r\n * </code>\r\n *\r\n * @param {string} str Translatable string, places holders in the form {$foo}.\r\n * @param {Object=} opt_values Map of place holder name to value.\r\n * @return {string} message with placeholders filled.\r\n */\r\ngoog.getMsg = function(str, opt_values) {\r\n  if (opt_values) {\r\n    str = str.replace(/\\{\\$([^}]+)}/g, function(match, key) {\r\n      return key in opt_values ? opt_values[key] : match;\r\n    });\r\n  }\r\n  return str;\r\n};\r\n\r\n\r\n/**\r\n * Gets a localized message. If the message does not have a translation, gives a\r\n * fallback message.\r\n *\r\n * This is useful when introducing a new message that has not yet been\r\n * translated into all languages.\r\n *\r\n * This function is a compiler primitive. Must be used in the form:\r\n * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>\r\n * where MSG_A and MSG_B were initialized with goog.getMsg.\r\n *\r\n * @param {string} a The preferred message.\r\n * @param {string} b The fallback message.\r\n * @return {string} The best translated message.\r\n */\r\ngoog.getMsgWithFallback = function(a, b) {\r\n  return a;\r\n};\r\n\r\n\r\n/**\r\n * Exposes an unobfuscated global namespace path for the given object.\r\n * Note that fields of the exported object *will* be obfuscated, unless they are\r\n * exported in turn via this function or goog.exportProperty.\r\n *\r\n * Also handy for making public items that are defined in anonymous closures.\r\n *\r\n * ex. goog.exportSymbol('public.path.Foo', Foo);\r\n *\r\n * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);\r\n *     public.path.Foo.staticFunction();\r\n *\r\n * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\r\n *                       Foo.prototype.myMethod);\r\n *     new public.path.Foo().myMethod();\r\n *\r\n * @param {string} publicPath Unobfuscated name to export.\r\n * @param {*} object Object the name should point to.\r\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\r\n *     is goog.global.\r\n */\r\ngoog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {\r\n  goog.exportPath_(publicPath, object, opt_objectToExportTo);\r\n};\r\n\r\n\r\n/**\r\n * Exports a property unobfuscated into the object's namespace.\r\n * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\r\n * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\r\n * @param {Object} object Object whose static property is being exported.\r\n * @param {string} publicName Unobfuscated name to export.\r\n * @param {*} symbol Object the name should point to.\r\n */\r\ngoog.exportProperty = function(object, publicName, symbol) {\r\n  object[publicName] = symbol;\r\n};\r\n\r\n\r\n/**\r\n * Inherit the prototype methods from one constructor into another.\r\n *\r\n * Usage:\r\n * <pre>\r\n * function ParentClass(a, b) { }\r\n * ParentClass.prototype.foo = function(a) { };\r\n *\r\n * function ChildClass(a, b, c) {\r\n *   ChildClass.base(this, 'constructor', a, b);\r\n * }\r\n * goog.inherits(ChildClass, ParentClass);\r\n *\r\n * var child = new ChildClass('a', 'b', 'see');\r\n * child.foo(); // This works.\r\n * </pre>\r\n *\r\n * @param {Function} childCtor Child class.\r\n * @param {Function} parentCtor Parent class.\r\n */\r\ngoog.inherits = function(childCtor, parentCtor) {\r\n  /** @constructor */\r\n  function tempCtor() {};\r\n  tempCtor.prototype = parentCtor.prototype;\r\n  childCtor.superClass_ = parentCtor.prototype;\r\n  childCtor.prototype = new tempCtor();\r\n  /** @override */\r\n  childCtor.prototype.constructor = childCtor;\r\n\r\n  /**\r\n   * Calls superclass constructor/method.\r\n   *\r\n   * This function is only available if you use goog.inherits to\r\n   * express inheritance relationships between classes.\r\n   *\r\n   * NOTE: This is a replacement for goog.base and for superClass_\r\n   * property defined in childCtor.\r\n   *\r\n   * @param {!Object} me Should always be \"this\".\r\n   * @param {string} methodName The method name to call. Calling\r\n   *     superclass constructor can be done with the special string\r\n   *     'constructor'.\r\n   * @param {...*} var_args The arguments to pass to superclass\r\n   *     method/constructor.\r\n   * @return {*} The return value of the superclass method/constructor.\r\n   */\r\n  childCtor.base = function(me, methodName, var_args) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    return parentCtor.prototype[methodName].apply(me, args);\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Call up to the superclass.\r\n *\r\n * If this is called from a constructor, then this calls the superclass\r\n * constructor with arguments 1-N.\r\n *\r\n * If this is called from a prototype method, then you must pass the name of the\r\n * method as the second argument to this function. If you do not, you will get a\r\n * runtime error. This calls the superclass' method with arguments 2-N.\r\n *\r\n * This function only works if you use goog.inherits to express inheritance\r\n * relationships between your classes.\r\n *\r\n * This function is a compiler primitive. At compile-time, the compiler will do\r\n * macro expansion to remove a lot of the extra overhead that this function\r\n * introduces. The compiler will also enforce a lot of the assumptions that this\r\n * function makes, and treat it as a compiler error if you break them.\r\n *\r\n * @param {!Object} me Should always be \"this\".\r\n * @param {*=} opt_methodName The method name if calling a super method.\r\n * @param {...*} var_args The rest of the arguments.\r\n * @return {*} The return value of the superclass method.\r\n * @suppress {es5Strict} This method can not be used in strict mode, but\r\n *     all Closure Library consumers must depend on this file.\r\n */\r\ngoog.base = function(me, opt_methodName, var_args) {\r\n  var caller = arguments.callee.caller;\r\n\r\n  if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {\r\n    throw Error('arguments.caller not defined.  goog.base() cannot be used ' +\r\n                'with strict mode code. See ' +\r\n                'http://www.ecma-international.org/ecma-262/5.1/#sec-C');\r\n  }\r\n\r\n  if (caller.superClass_) {\r\n    // This is a constructor. Call the superclass constructor.\r\n    return caller.superClass_.constructor.apply(\r\n        me, Array.prototype.slice.call(arguments, 1));\r\n  }\r\n\r\n  var args = Array.prototype.slice.call(arguments, 2);\r\n  var foundCaller = false;\r\n  for (var ctor = me.constructor;\r\n       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {\r\n    if (ctor.prototype[opt_methodName] === caller) {\r\n      foundCaller = true;\r\n    } else if (foundCaller) {\r\n      return ctor.prototype[opt_methodName].apply(me, args);\r\n    }\r\n  }\r\n\r\n  // If we did not find the caller in the prototype chain, then one of two\r\n  // things happened:\r\n  // 1) The caller is an instance method.\r\n  // 2) This method was not called by the right caller.\r\n  if (me[opt_methodName] === caller) {\r\n    return me.constructor.prototype[opt_methodName].apply(me, args);\r\n  } else {\r\n    throw Error(\r\n        'goog.base called from a method of one name ' +\r\n        'to a method of a different name');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Allow for aliasing within scope functions.  This function exists for\r\n * uncompiled code - in compiled code the calls will be inlined and the aliases\r\n * applied.  In uncompiled code the function is simply run since the aliases as\r\n * written are valid JavaScript.\r\n *\r\n *\r\n * @param {function()} fn Function to call.  This function can contain aliases\r\n *     to namespaces (e.g. \"var dom = goog.dom\") or classes\r\n *     (e.g. \"var Timer = goog.Timer\").\r\n */\r\ngoog.scope = function(fn) {\r\n  fn.call(goog.global);\r\n};\r\n\r\n\r\n/*\r\n * To support uncompiled, strict mode bundles that use eval to divide source\r\n * like so:\r\n *    eval('someSource;//# sourceUrl sourcefile.js');\r\n * We need to export the globally defined symbols \"goog\" and \"COMPILED\".\r\n * Exporting \"goog\" breaks the compiler optimizations, so we required that\r\n * be defined externally.\r\n * NOTE: We don't use goog.exportSymbol here because we don't want to trigger\r\n * extern generation when that compiler option is enabled.\r\n */\r\nif (!COMPILED) {\r\n  goog.global['COMPILED'] = COMPILED;\r\n}\r\n\r\n\r\n\r\n//==============================================================================\r\n// goog.defineClass implementation\r\n//==============================================================================\r\n\r\n/**\r\n * Creates a restricted form of a Closure \"class\":\r\n *   - from the compiler's perspective, the instance returned from the\r\n *     constructor is sealed (no new properties may be added).  This enables\r\n *     better checks.\r\n *   - the compiler will rewrite this definition to a form that is optimal\r\n *     for type checking and optimization (initially this will be a more\r\n *     traditional form).\r\n *\r\n * @param {Function} superClass The superclass, Object or null.\r\n * @param {goog.defineClass.ClassDescriptor} def\r\n *     An object literal describing the\r\n *     the class.  It may have the following properties:\r\n *     \"constructor\": the constructor function\r\n *     \"statics\": an object literal containing methods to add to the constructor\r\n *        as \"static\" methods or a function that will receive the constructor\r\n *        function as its only parameter to which static properties can\r\n *        be added.\r\n *     all other properties are added to the prototype.\r\n * @return {!Function} The class constructor.\r\n */\r\ngoog.defineClass = function(superClass, def) {\r\n  // TODO(johnlenz): consider making the superClass an optional parameter.\r\n  var constructor = def.constructor;\r\n  var statics = def.statics;\r\n  // Wrap the constructor prior to setting up the prototype and static methods.\r\n  if (!constructor || constructor == Object.prototype.constructor) {\r\n    constructor = function() {\r\n      throw Error('cannot instantiate an interface (no constructor defined).');\r\n    };\r\n  }\r\n\r\n  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);\r\n  if (superClass) {\r\n    goog.inherits(cls, superClass);\r\n  }\r\n\r\n  // Remove all the properties that should not be copied to the prototype.\r\n  delete def.constructor;\r\n  delete def.statics;\r\n\r\n  goog.defineClass.applyProperties_(cls.prototype, def);\r\n  if (statics != null) {\r\n    if (statics instanceof Function) {\r\n      statics(cls);\r\n    } else {\r\n      goog.defineClass.applyProperties_(cls, statics);\r\n    }\r\n  }\r\n\r\n  return cls;\r\n};\r\n\r\n\r\n/**\r\n * @typedef {\r\n *     !Object|\r\n *     {constructor:!Function}|\r\n *     {constructor:!Function, statics:(Object|function(Function):void)}}\r\n */\r\ngoog.defineClass.ClassDescriptor;\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the instances returned by\r\n * goog.defineClass should be sealed when possible.\r\n */\r\ngoog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);\r\n\r\n\r\n/**\r\n * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is\r\n * defined, this function will wrap the constructor in a function that seals the\r\n * results of the provided constructor function.\r\n *\r\n * @param {!Function} ctr The constructor whose results maybe be sealed.\r\n * @param {Function} superClass The superclass constructor.\r\n * @return {!Function} The replacement constructor.\r\n * @private\r\n */\r\ngoog.defineClass.createSealingConstructor_ = function(ctr, superClass) {\r\n  if (goog.defineClass.SEAL_CLASS_INSTANCES &&\r\n      Object.seal instanceof Function) {\r\n    // Don't seal subclasses of unsealable-tagged legacy classes.\r\n    if (superClass && superClass.prototype &&\r\n        superClass.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {\r\n      return ctr;\r\n    }\r\n    /** @this {*} */\r\n    var wrappedCtr = function() {\r\n      // Don't seal an instance of a subclass when it calls the constructor of\r\n      // its super class as there is most likely still setup to do.\r\n      var instance = ctr.apply(this, arguments) || this;\r\n      if (this.constructor === wrappedCtr) {\r\n        Object.seal(instance);\r\n      }\r\n      return instance;\r\n    };\r\n    return wrappedCtr;\r\n  }\r\n  return ctr;\r\n};\r\n\r\n\r\n// TODO(johnlenz): share these values with the goog.object\r\n/**\r\n * The names of the fields that are defined on Object.prototype.\r\n * @type {!Array.<string>}\r\n * @private\r\n * @const\r\n */\r\ngoog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [\r\n  'constructor',\r\n  'hasOwnProperty',\r\n  'isPrototypeOf',\r\n  'propertyIsEnumerable',\r\n  'toLocaleString',\r\n  'toString',\r\n  'valueOf'\r\n];\r\n\r\n\r\n// TODO(johnlenz): share this function with the goog.object\r\n/**\r\n * @param {!Object} target The object to add properties to.\r\n * @param {!Object} source The object to copy properites from.\r\n * @private\r\n */\r\ngoog.defineClass.applyProperties_ = function(target, source) {\r\n  // TODO(johnlenz): update this to support ES5 getters/setters\r\n\r\n  var key;\r\n  for (key in source) {\r\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n      target[key] = source[key];\r\n    }\r\n  }\r\n\r\n  // For IE the for-in-loop does not contain any properties that are not\r\n  // enumerable on the prototype object (for example isPrototypeOf from\r\n  // Object.prototype) and it will also not include 'replace' on objects that\r\n  // extend String and change 'replace' (not that it is common for anyone to\r\n  // extend anything except Object).\r\n  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {\r\n    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];\r\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n      target[key] = source[key];\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Sealing classes breaks the older idiom of assigning properties on the\r\n * prototype rather than in the constructor.  As such, goog.defineClass\r\n * must not seal subclasses of these old-style classes until they are fixed.\r\n * Until then, this marks a class as \"broken\", instructing defineClass\r\n * not to seal subclasses.\r\n * @param {!Function} ctr The legacy constructor to tag as unsealable.\r\n */\r\ngoog.tagUnsealableClass = function(ctr) {\r\n  if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {\r\n    ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Name for unsealable tag property.\r\n * @const @private {string}\r\n */\r\ngoog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = 'goog_defineClass_legacy_unsealable';\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Settings');\r\n\r\n//goog.require('goog.asserts');\r\n//goog.require('goog.string.format');\r\n\r\nif (!Object.defineProperty)\r\n{\r\n\tObject.defineProperty = function (obj, name, options)\r\n\t{\r\n\t\tif (Object.__defineGetter__)\r\n\t\t{\r\n\t\t\tif ('get' in options)\r\n\t\t\t{\r\n\t\t\t\tobj.__defineGetter__(name, options.get);\r\n\t\t\t}\r\n\t\t\telse if ('value' in options)\r\n\t\t\t{\r\n\t\t\t\tobj.__defineGetter__(name, options.value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (Object.__defineSetter__)\r\n\t\t{\r\n\t\t\tif ('set' in options)\r\n\t\t\t{\r\n\t\t\t\tobj.__defineSetter__(name, options.set);\r\n\t\t\t}\r\n\t\t\telse if ('value' in options)\r\n\t\t\t{\r\n\t\t\t\tobj.__defineSetter__(name, options.value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @define {boolean}\r\n */\r\nbox2d.DEBUG = false;\r\n\r\n/** \r\n * @export \r\n * @define {boolean}\r\n */\r\nbox2d.ENABLE_ASSERTS = box2d.DEBUG;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {boolean} condition \r\n * @param {string=} opt_message \r\n * @param {...} var_args \r\n */\r\nbox2d.b2Assert = function (condition, opt_message, var_args)\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tif (!condition)\r\n\t\t{\r\n\t\t\tdebugger;\r\n\t\t}\r\n\t\r\n\t\t//goog.asserts.assert(condition, opt_message, var_args);\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxFloat = 1E+37; // FLT_MAX instead of Number.MAX_VALUE;\r\n/**\r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_epsilon = 1E-5; // FLT_EPSILON instead of Number.MIN_VALUE;\r\n/**\r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_epsilon_sq = (box2d.b2_epsilon * box2d.b2_epsilon);\r\n/**\r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_pi = Math.PI;\r\n\r\n/**\r\n * Global tuning constants based on meters-kilograms-seconds \r\n * (MKS) units. \r\n */\r\n\r\n// Collision\r\n\r\n/** \r\n * The maximum number of contact points between two convex \r\n * shapes. Do not change this value. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxManifoldPoints = 2;\r\n\r\n/** \r\n * The maximum number of vertices on a convex polygon. You \r\n * cannot increase this too much because b2BlockAllocator has a \r\n * maximum object size. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxPolygonVertices = 8;\r\n\r\n/** \r\n * This is used to fatten AABBs in the dynamic tree. This allows \r\n * proxies to move by a small amount without triggering a tree \r\n * adjustment. \r\n * This is in meters. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_aabbExtension = 0.1;\r\n\r\n/** \r\n * This is used to fatten AABBs in the dynamic tree. This is \r\n * used to predict the future position based on the current \r\n * displacement. \r\n * This is a dimensionless multiplier. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_aabbMultiplier = 2;\r\n\r\n/** \r\n * A small length used as a collision and constraint tolerance. \r\n * Usually it is chosen to be numerically significant, but \r\n * visually insignificant. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_linearSlop = 0.008; //0.005;\r\n\r\n/** \r\n * A small angle used as a collision and constraint tolerance. \r\n * Usually it is chosen to be numerically significant, but \r\n * visually insignificant. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_angularSlop = 2 / 180 * box2d.b2_pi;\r\n\r\n/** \r\n * The radius of the polygon/edge shape skin. This should not be \r\n * modified. Making this smaller means polygons will have an \r\n * insufficient buffer for continuous collision. \r\n * Making it larger may create artifacts for vertex collision.\r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_polygonRadius = 2 * box2d.b2_linearSlop;\r\n\r\n/** \r\n * Maximum number of sub-steps per contact in continuous physics \r\n * simulation. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxSubSteps = 8;\r\n\r\n\r\n// Dynamics\r\n\r\n/** \r\n * Maximum number of contacts to be handled to solve a TOI \r\n * impact. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxTOIContacts = 32;\r\n\r\n/** \r\n * A velocity threshold for elastic collisions. Any collision \r\n * with a relative linear velocity below this threshold will be \r\n * treated as inelastic. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_velocityThreshold = 1;\r\n\r\n/** \r\n * The maximum linear position correction used when solving \r\n * constraints. This helps to prevent overshoot. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxLinearCorrection = 0.2;\r\n\r\n/** \r\n * The maximum angular position correction used when solving \r\n * constraints. This helps to prevent overshoot. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxAngularCorrection = 8 / 180 * box2d.b2_pi;\r\n\r\n/** \r\n * The maximum linear velocity of a body. This limit is very \r\n * large and is used to prevent numerical problems. You \r\n * shouldn't need to adjust this. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxTranslation = 3;\r\n/** \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxTranslationSquared = box2d.b2_maxTranslation * box2d.b2_maxTranslation;\r\n\r\n/** \r\n * The maximum angular velocity of a body. This limit is very \r\n * large and is used to prevent numerical problems. You \r\n * shouldn't need to adjust this. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxRotation = 0.5 * box2d.b2_pi;\r\n/** \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_maxRotationSquared = box2d.b2_maxRotation * box2d.b2_maxRotation;\r\n\r\n/** \r\n * This scale factor controls how fast overlap is resolved. \r\n * Ideally this would be 1 so that overlap is removed in one \r\n * time step. However using values close to 1 often lead to \r\n * overshoot. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_baumgarte = 0.2;\r\n/** \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_toiBaumgarte = 0.75;\r\n\r\n\r\n\r\n// Sleep\r\n\r\n/** \r\n * The time that a body must be still before it will go to \r\n * sleep. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_timeToSleep = 0.5;\r\n\r\n/** \r\n * A body cannot sleep if its linear velocity is above this \r\n * tolerance. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_linearSleepTolerance = 0.01;\r\n\r\n/** \r\n * A body cannot sleep if its angular velocity is above this \r\n * tolerance. \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_angularSleepTolerance = 2 / 180 * box2d.b2_pi;\r\n\r\n// Memory Allocation\r\n\r\n/** \r\n * Implement this function to use your own memory allocator. \r\n * @export \r\n * @return {*} \r\n * @param {number} size \r\n */\r\nbox2d.b2Alloc = function (size)\r\n{\r\n\treturn null;\r\n}\r\n\r\n/** \r\n * If you implement b2Alloc, you should also implement this \r\n * function. \r\n * @export  \r\n * @return {void} \r\n * @param {*} mem \r\n */\r\nbox2d.b2Free = function (mem)\r\n{\r\n}\r\n\r\n/** \r\n * Logging function. \r\n * You can modify this to use your logging facility.\r\n * @export \r\n * @return {void} \r\n * @param {...string|number|boolean} var_args \r\n */\r\nbox2d.b2Log = function (var_args)\r\n{\r\n\tgoog.global.console.log.apply(null, arguments);\r\n}\r\n\r\n/** \r\n * Version numberinf scheme See \r\n * http://en.wikipedia.org/wiki/Software_versioning \r\n * @export \r\n * @constructor\r\n * @param {number=} major \r\n * @param {number=} minor \r\n * @param {number=} revision \r\n */\r\nbox2d.b2Version = function (major, minor, revision)\r\n{\r\n\tthis.major = major || 0;\r\n\tthis.minor = minor || 0;\r\n\tthis.revision = revision || 0;\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Version.prototype.major = 0; ///< significant changes\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Version.prototype.minor = 0; ///< incremental changes\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Version.prototype.revision = 0; ///< bug fixes\r\n\r\n/**\r\n * @export \r\n * @return {string}\r\n */\r\nbox2d.b2Version.prototype.toString = function ()\r\n{\r\n\treturn this.major + \".\" + this.minor + \".\" + this.revision;\r\n}\r\n\r\n/** \r\n * Current version. \r\n * @export \r\n * @const \r\n * @type {box2d.b2Version} \r\n */\r\nbox2d.b2_version = new box2d.b2Version(2, 3, 0);\r\n/** \r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_changelist = 278;\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {string} v \r\n */\r\nbox2d.b2ParseInt = function (v)\r\n{\r\n\treturn parseInt(v, 10);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number} \r\n * @param {string} v \r\n */\r\nbox2d.b2ParseUInt = function (v)\r\n{\r\n\treturn box2d.b2Abs(parseInt(v, 10));\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {Array.<*>} \r\n * @param {number=} length \r\n * @param {function(number): *=} init \r\n */\r\nbox2d.b2MakeArray = function (length, init)\r\n{\r\n\tif (length === undefined) length = 0;\r\n\tvar a = new Array(length);\r\n\tif (init !== undefined)\r\n\t{\r\n\t\tfor (var i = 0; i < length; ++i)\r\n\t\t{\r\n\t\t\ta[i] = init(i);\r\n\t\t}\r\n\t}\r\n\treturn a;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {Array.<number>} \r\n * @param {number=} length\r\n */\r\nbox2d.b2MakeNumberArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return 0; });\r\n}\r\n\r\n/*\r\n* Copyright (c) 2007-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Math');\r\n\r\ngoog.require('box2d.b2Settings');\r\n\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2_pi_over_180 = box2d.b2_pi / 180.0;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2_180_over_pi = 180.0 / box2d.b2_pi;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2_two_pi = 2.0 * box2d.b2_pi;\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n * @param {number} n\r\n */\r\nbox2d.b2Abs = function (n)\r\n{\r\n\treturn (n < 0)?(-n):(n);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} a\r\n * @param {number} b\r\n */\r\nbox2d.b2Min = function (a, b)\r\n{\r\n\treturn (a < b)?(a):(b);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} a\r\n * @param {number} b\r\n */\r\nbox2d.b2Max = function (a, b)\r\n{\r\n\treturn (a > b)?(a):(b);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} a\r\n * @param {number} lo\r\n * @param {number} hi\r\n */\r\nbox2d.b2Clamp = function (a, lo, hi)\r\n{\r\n\treturn (a < lo)?(lo):((a > hi)?(hi):(a));\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {Array.<number>} a\r\n * @param {Array.<number>} b\r\n */\r\nbox2d.b2Swap = function (a, b)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\tvar tmp = a[0];\r\n\ta[0] = b[0];\r\n\tb[0] = tmp;\r\n}\r\n\r\n/** \r\n * This function is used to ensure that a floating point number \r\n * is not a NaN or infinity. \r\n * @export \r\n * @return {boolean}\r\n * @param {number} n\r\n */\r\nbox2d.b2IsValid = function (n)\r\n{\r\n\treturn isFinite(n);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number} \r\n * @param {number} n\r\n */\r\nbox2d.b2Sq = function (n)\r\n{\r\n\treturn n * n;\r\n}\r\n\r\n/** \r\n * This is a approximate yet fast inverse square-root. \r\n * @export \r\n * @return {number}\r\n * @param {number} n\r\n */\r\nbox2d.b2InvSqrt = function (n)\r\n{\r\n\treturn 1 / Math.sqrt(n);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} n\r\n */\r\nbox2d.b2Sqrt = function (n)\r\n{\r\n\treturn Math.sqrt(n);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nbox2d.b2Pow = function (x, y)\r\n{\r\n\treturn Math.pow(x, y);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} degrees\r\n */\r\nbox2d.b2DegToRad = function (degrees)\r\n{\r\n\treturn degrees * box2d.b2_pi_over_180;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} radians\r\n */\r\nbox2d.b2RadToDeg = function (radians)\r\n{\r\n\treturn radians * box2d.b2_180_over_pi;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} radians\r\n */\r\nbox2d.b2Cos = function (radians)\r\n{\r\n\treturn Math.cos(radians);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} radians\r\n */\r\nbox2d.b2Sin = function (radians)\r\n{\r\n\treturn Math.sin(radians);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} n\r\n */\r\nbox2d.b2Acos = function (n)\r\n{\r\n\treturn Math.acos(n);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} n\r\n */\r\nbox2d.b2Asin = function (n)\r\n{\r\n\treturn Math.asin(n);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} y\r\n * @param {number} x\r\n */\r\nbox2d.b2Atan2 = function (y, x)\r\n{\r\n\treturn Math.atan2(y, x);\r\n}\r\n\r\n/** \r\n * Next Largest Power of 2 \r\n * Given a binary integer value x, the next largest power of 2 \r\n * can be computed by a SWAR algorithm that recursively \"folds\" \r\n * the upper bits into the lower bits. This process yields a bit \r\n * vector with the same most significant 1 as x, but all 1's \r\n * below it. Adding 1 to that value yields the next largest \r\n * power of 2. For a 32-bit value: \r\n * @export \r\n * @return {number}\r\n * @param {number} x\r\n */\r\nbox2d.b2NextPowerOfTwo = function (x)\r\n{\r\n\tx |= (x >> 1) & 0x7FFFFFFF;\r\n\tx |= (x >> 2) & 0x3FFFFFFF;\r\n\tx |= (x >> 4) & 0x0FFFFFFF;\r\n\tx |= (x >> 8) & 0x00FFFFFF;\r\n\tx |= (x >> 16) & 0x0000FFFF;\r\n\treturn x + 1;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {boolean}\r\n * @param {number} x\r\n */\r\nbox2d.b2IsPowerOfTwo = function (x)\r\n{\r\n\treturn x > 0 && (x & (x - 1)) === 0;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Random = function ()\r\n{\r\n\treturn Math.random() * 2.0 - 1.0;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {number} lo\r\n * @param {number} hi\r\n */\r\nbox2d.b2RandomRange = function (lo, hi)\r\n{\r\n\treturn (hi - lo) * Math.random() + lo;\r\n}\r\n\r\n/** \r\n * A 2D column vector. \r\n * @export \r\n * @constructor \r\n * @param {number=} x\r\n * @param {number=} y\r\n */\r\nbox2d.b2Vec2 = function (x, y)\r\n{\r\n\tthis.x = x || 0.0;\r\n\tthis.y = y || 0.0;\r\n\t//this.a = new Float32Array(2);\r\n\t//this.a[0] = x || 0;\r\n\t//this.a[1] = y || 0;\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Vec2.prototype.x = 0.0;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Vec2.prototype.y = 0.0;\r\n\r\n//\t/**\r\n//\t * @type {Float32Array} \r\n//\t */\r\n//\tbox2d.b2Vec2.prototype.a;\r\n//\t\r\n//\tbox2d.b2Vec2.prototype.__defineGetter__('x', function () { return this.a[0]; });\r\n//\tbox2d.b2Vec2.prototype.__defineGetter__('y', function () { return this.a[1]; });\r\n//\tbox2d.b2Vec2.prototype.__defineSetter__('x', function (n) { this.a[0] = n; });\r\n//\tbox2d.b2Vec2.prototype.__defineSetter__('y', function (n) { this.a[1] = n; });\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Vec2_zero = new box2d.b2Vec2();\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Vec2.ZERO = new box2d.b2Vec2();\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Vec2.UNITX = new box2d.b2Vec2(1.0, 0.0);\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Vec2.UNITY = new box2d.b2Vec2(0.0, 1.0);\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Vec2.s_t0 = new box2d.b2Vec2();\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Vec2.s_t1 = new box2d.b2Vec2();\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Vec2.s_t2 = new box2d.b2Vec2();\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Vec2.s_t3 = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {Array.<box2d.b2Vec2>}\r\n * @param {number=} length\r\n */\r\nbox2d.b2Vec2.MakeArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return new box2d.b2Vec2(); });\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n */\r\nbox2d.b2Vec2.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2Vec2(this.x, this.y);\r\n}\r\n\r\n/** \r\n * Set this vector to all zeros. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n */\r\nbox2d.b2Vec2.prototype.SetZero = function ()\r\n{\r\n\tthis.x = 0.0;\r\n\tthis.y = 0.0;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Set this vector to some specified coordinates. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nbox2d.b2Vec2.prototype.SetXY = function (x, y)\r\n{\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} other\r\n */\r\nbox2d.b2Vec2.prototype.Copy = function (other)\r\n{\r\n\t//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }\r\n\tthis.x = other.x;\r\n\tthis.y = other.y;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Add a vector to this vector. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n */\r\nbox2d.b2Vec2.prototype.SelfAdd = function (v)\r\n{\r\n\tthis.x += v.x;\r\n\tthis.y += v.y;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} x \r\n * @param {number} y \r\n */\r\nbox2d.b2Vec2.prototype.SelfAddXY = function (x, y)\r\n{\r\n\tthis.x += x;\r\n\tthis.y += y;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Subtract a vector from this vector. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n */\r\nbox2d.b2Vec2.prototype.SelfSub = function (v)\r\n{\r\n\tthis.x -= v.x;\r\n\tthis.y -= v.y;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} x \r\n * @param {number} y \r\n */\r\nbox2d.b2Vec2.prototype.SelfSubXY = function (x, y)\r\n{\r\n\tthis.x -= x;\r\n\tthis.y -= y;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Multiply this vector by a scalar. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} s\r\n */\r\nbox2d.b2Vec2.prototype.SelfMul = function (s)\r\n{\r\n\tthis.x *= s;\r\n\tthis.y *= s;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * this += s * v \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} s\r\n * @param {box2d.b2Vec2} v\r\n */\r\nbox2d.b2Vec2.prototype.SelfMulAdd = function (s, v)\r\n{\r\n\tthis.x += s * v.x;\r\n\tthis.y += s * v.y;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * this -= s * v \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} s\r\n * @param {box2d.b2Vec2} v\r\n */\r\nbox2d.b2Vec2.prototype.SelfMulSub = function (s, v)\r\n{\r\n\tthis.x -= s * v.x;\r\n\tthis.y -= s * v.y;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} v\r\n */\r\nbox2d.b2Vec2.prototype.Dot = function (v)\r\n{\r\n\treturn this.x * v.x + this.y * v.y;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} v\r\n */\r\nbox2d.b2Vec2.prototype.Cross = function (v)\r\n{\r\n\treturn this.x * v.y - this.y * v.x;\r\n}\r\n\r\n/** \r\n * Get the length of this vector (the norm). \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Vec2.prototype.Length = function ()\r\n{\r\n\tvar x = this.x, y = this.y;\r\n\treturn Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2Vec2.prototype.GetLength = box2d.b2Vec2.prototype.Length;\r\n\r\n/** \r\n * Get the length squared. For performance, use this instead of \r\n * b2Vec2::Length (if possible). \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Vec2.prototype.LengthSquared = function ()\r\n{\r\n\tvar x = this.x, y = this.y;\r\n\treturn (x * x + y * y);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2Vec2.prototype.GetLengthSquared = box2d.b2Vec2.prototype.LengthSquared;\r\n\r\n/** \r\n * Convert this vector into a unit vector. Returns the length. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Vec2.prototype.Normalize = function ()\r\n{\r\n\tvar length = this.GetLength();\r\n\tif (length >= box2d.b2_epsilon)\r\n\t{\r\n\t\tvar inv_length = 1.0 / length;\r\n\t\tthis.x *= inv_length;\r\n\t\tthis.y *= inv_length;\r\n\t}\r\n\treturn length;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n */\r\nbox2d.b2Vec2.prototype.SelfNormalize = function ()\r\n{\r\n\tvar length = this.GetLength();\r\n\tif (length >= box2d.b2_epsilon)\r\n\t{\r\n\t\tvar inv_length = 1.0 / length;\r\n\t\tthis.x *= inv_length;\r\n\t\tthis.y *= inv_length;\r\n\t}\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} c\r\n * @param {number} s\r\n */\r\nbox2d.b2Vec2.prototype.SelfRotate = function (c, s)\r\n{\r\n\tvar x = this.x, y = this.y;\r\n\tthis.x = c * x - s * y;\r\n\tthis.y = s * x + c * y;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} radians\r\n */\r\nbox2d.b2Vec2.prototype.SelfRotateRadians = function (radians)\r\n{\r\n\treturn this.SelfRotate(Math.cos(radians), Math.sin(radians));\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} degrees\r\n */\r\nbox2d.b2Vec2.prototype.SelfRotateDegrees = function (degrees)\r\n{\r\n\treturn this.SelfRotateRadians(box2d.b2DegToRad(degrees));\r\n}\r\n\r\n/** \r\n * Does this vector contain finite coordinates? \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2Vec2.prototype.IsValid = function ()\r\n{\r\n\treturn isFinite(this.x) && isFinite(this.y);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} s\r\n */\r\nbox2d.b2Vec2.prototype.SelfCrossVS = function (s)\r\n{\r\n\tvar x = this.x;\r\n\tthis.x =  s * this.y;\r\n\tthis.y = -s * x;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} s\r\n */\r\nbox2d.b2Vec2.prototype.SelfCrossSV = function (s)\r\n{\r\n\tvar x = this.x;\r\n\tthis.x = -s * this.y;\r\n\tthis.y =  s * x;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n */\r\nbox2d.b2Vec2.prototype.SelfMinV = function (v)\r\n{\r\n\tthis.x = box2d.b2Min(this.x, v.x);\r\n\tthis.y = box2d.b2Min(this.y, v.y);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n */\r\nbox2d.b2Vec2.prototype.SelfMaxV = function (v)\r\n{\r\n\tthis.x = box2d.b2Max(this.x, v.x);\r\n\tthis.y = box2d.b2Max(this.y, v.y);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n */\r\nbox2d.b2Vec2.prototype.SelfAbs = function ()\r\n{\r\n\tthis.x = box2d.b2Abs(this.x);\r\n\tthis.y = box2d.b2Abs(this.y);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n */\r\nbox2d.b2Vec2.prototype.SelfNeg = function ()\r\n{\r\n\tthis.x = (-this.x);\r\n\tthis.y = (-this.y);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Get the skew vector such that dot(skew_vec, other) === \r\n * cross(vec, other) \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n */\r\nbox2d.b2Vec2.prototype.SelfSkew = function ()\r\n{\r\n\tvar x = this.x;\r\n\tthis.x = -this.y;\r\n\tthis.y = x;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2AbsV = function (v, out)\r\n{\r\n\tout.x = box2d.b2Abs(v.x);\r\n\tout.y = box2d.b2Abs(v.y);\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MinV = function (a, b, out)\r\n{\r\n\tout.x = box2d.b2Min(a.x, b.x);\r\n\tout.y = box2d.b2Min(a.y, b.y);\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MaxV = function (a, b, out)\r\n{\r\n\tout.x = box2d.b2Max(a.x, b.x);\r\n\tout.y = box2d.b2Max(a.y, b.y);\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} lo\r\n * @param {box2d.b2Vec2} hi\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2ClampV = function (v, lo, hi, out)\r\n{\r\n\tout.x = box2d.b2Clamp(v.x, lo.x, hi.x);\r\n\tout.y = box2d.b2Clamp(v.y, lo.y, hi.y);\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n * @param {number} c\r\n * @param {number} s\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2RotateV = function (v, c, s, out)\r\n{\r\n\tvar v_x = v.x, v_y = v.y;\r\n\tout.x = c * v_x - s * v_y;\r\n\tout.y = s * v_x + c * v_y;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n * @param {number} radians\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2RotateRadiansV = function (v, radians, out)\r\n{\r\n\treturn box2d.b2RotateV(v, Math.cos(radians), Math.sin(radians), out);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n * @param {number} degrees\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2RotateDegreesV = function (v, degrees, out)\r\n{\r\n\treturn box2d.b2RotateRadiansV(v, box2d.b2DegToRad(degrees), out);\r\n}\r\n\r\n/** \r\n * Perform the dot product on two vectors. \r\n * a.x * b.x + a.y * b.y \r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n */\r\nbox2d.b2DotVV = function (a, b)\r\n{\r\n\treturn a.x * b.x + a.y * b.y;\r\n}\r\n\r\n/** \r\n * Perform the cross product on two vectors. In 2D this produces a scalar. \r\n * a.x * b.y - a.y * b.x \r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n */\r\nbox2d.b2CrossVV = function (a, b)\r\n{\r\n\treturn a.x * b.y - a.y * b.x;\r\n}\r\n\r\n/** \r\n * Perform the cross product on a vector and a scalar. In 2D \r\n * this produces a vector. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n * @param {number} s\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2CrossVS = function (v, s, out)\r\n{\r\n\tvar v_x = v.x;\r\n\tout.x =  s * v.y;\r\n\tout.y = -s * v_x;\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * box2d.b2CrossVS(v, 1.0, out) \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2CrossVOne = function (v, out)\r\n{\r\n\tvar v_x = v.x;\r\n\tout.x =  v.y;\r\n\tout.y = -v_x;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Perform the cross product on a scalar and a vector. In 2D \r\n * this produces a vector. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} s\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2CrossSV = function (s, v, out)\r\n{\r\n\tvar v_x = v.x;\r\n\tout.x = -s * v.y;\r\n\tout.y =  s * v_x;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * box2d.b2CrossSV(1.0, v, out) \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2CrossOneV = function (v, out)\r\n{\r\n\tvar v_x = v.x;\r\n\tout.x = -v.y;\r\n\tout.y =  v_x;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Add two vectors component-wise. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2AddVV = function (a, b, out) { out.x = a.x + b.x; out.y = a.y + b.y; return out; }\r\n\r\n/** \r\n * Subtract two vectors component-wise. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2SubVV = function (a, b, out) { out.x = a.x - b.x; out.y = a.y - b.y; return out; }\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} s\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MulSV = function (s, v, out) { out.x = v.x * s; out.y = v.y * s; return out; }\r\n\r\n/** \r\n * out = a + (s * b)\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} a\r\n * @param {number} s\r\n * @param {box2d.b2Vec2} b\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2AddVMulSV = function (a, s, b, out) { out.x = a.x + (s * b.x); out.y = a.y + (s * b.y); return out; }\r\n/** \r\n * out = a - (s * b)\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} a\r\n * @param {number} s\r\n * @param {box2d.b2Vec2} b\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2SubVMulSV = function (a, s, b, out) { out.x = a.x - (s * b.x); out.y = a.y - (s * b.y); return out; }\r\n\r\n/** \r\n * out = a + b2CrossSV(s, v) \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} a\r\n * @param {number} s\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2AddVCrossSV = function (a, s, v, out)\r\n{\r\n\tvar v_x = v.x;\r\n\tout.x = a.x - (s * v.y);\r\n\tout.y = a.y + (s * v_x);\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Get the center of two vectors. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MidVV = function (a, b, out) { out.x = (a.x + b.x) * 0.5; out.y = (a.y + b.y) * 0.5; return out; }\r\n\r\n/** \r\n * Get the extent of two vectors (half-widths). \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2ExtVV = function (a, b, out) { out.x = (b.x - a.x) * 0.5; out.y = (b.y - a.y) * 0.5; return out; }\r\n\r\n/**\r\n * @export \r\n * @return {boolean}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n */\r\nbox2d.b2IsEqualToV = function (a, b)\r\n{\r\n\treturn a.x === b.x && a.y === b.y;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n */\r\nbox2d.b2DistanceVV = function (a, b)\r\n{\r\n\tvar c_x = a.x - b.x;\r\n\tvar c_y = a.y - b.y;\r\n\treturn Math.sqrt(c_x * c_x + c_y * c_y);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} a\r\n * @param {box2d.b2Vec2} b\r\n */\r\nbox2d.b2DistanceSquaredVV = function (a, b)\r\n{\r\n\tvar c_x = a.x - b.x;\r\n\tvar c_y = a.y - b.y;\r\n\treturn (c_x * c_x + c_y * c_y);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2NegV = function (v, out) { out.x = -v.x; out.y = -v.y; return out; }\r\n\r\n/** \r\n * @export \r\n * @constructor \r\n * @param {number=} x\r\n * @param {number=} y\r\n * @param {number=} z\r\n */\r\nbox2d.b2Vec3 = function (x, y, z)\r\n{\r\n\tthis.x = x || 0.0;\r\n\tthis.y = y || 0.0;\r\n\tthis.z = z || 0.0;\r\n\t//this.a = new Float32Array(3);\r\n\t//this.a[0] = x || 0;\r\n\t//this.a[1] = y || 0;\r\n\t//this.a[2] = z || 0;\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Vec3.prototype.x = 0.0;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Vec3.prototype.y = 0.0;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Vec3.prototype.z = 0.0;\r\n\r\n//\t/**\r\n//\t * @type {Float32Array} \r\n//\t */\r\n//\tbox2d.b2Vec3.prototype.a;\r\n//\t\r\n//\tbox2d.b2Vec3.prototype.__defineGetter__('x', function () { return this.a[0]; });\r\n//\tbox2d.b2Vec3.prototype.__defineGetter__('y', function () { return this.a[1]; });\r\n//\tbox2d.b2Vec3.prototype.__defineGetter__('z', function () { return this.a[2]; });\r\n//\tbox2d.b2Vec3.prototype.__defineSetter__('x', function (n) { this.a[0] = n; });\r\n//\tbox2d.b2Vec3.prototype.__defineSetter__('y', function (n) { this.a[1] = n; });\r\n//\tbox2d.b2Vec3.prototype.__defineSetter__('z', function (n) { this.a[2] = n; });\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec3}\r\n */\r\nbox2d.b2Vec3.ZERO = new box2d.b2Vec3();\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec3}\r\n */\r\nbox2d.b2Vec3.s_t0 = new box2d.b2Vec3();\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n */\r\nbox2d.b2Vec3.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2Vec3(this.x, this.y, this.z);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n */\r\nbox2d.b2Vec3.prototype.SetZero = function ()\r\n{\r\n\tthis.x = 0.0;\r\n\tthis.y = 0.0;\r\n\tthis.z = 0.0;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} z\r\n */\r\nbox2d.b2Vec3.prototype.SetXYZ = function (x, y, z)\r\n{\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\tthis.z = z;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {box2d.b2Vec3} other\r\n */\r\nbox2d.b2Vec3.prototype.Copy = function (other)\r\n{\r\n\t//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }\r\n\tthis.x = other.x;\r\n\tthis.y = other.y;\r\n\tthis.z = other.z;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n */\r\nbox2d.b2Vec3.prototype.SelfNeg = function ()\r\n{\r\n\tthis.x = (-this.x);\r\n\tthis.y = (-this.y);\r\n\tthis.z = (-this.z);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {box2d.b2Vec3} v\r\n */\r\nbox2d.b2Vec3.prototype.SelfAdd = function (v)\r\n{\r\n\tthis.x += v.x;\r\n\tthis.y += v.y;\r\n\tthis.z += v.z;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} z \r\n */\r\nbox2d.b2Vec3.prototype.SelfAddXYZ = function (x, y, z)\r\n{\r\n\tthis.x += x;\r\n\tthis.y += y;\r\n\tthis.z += z;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {box2d.b2Vec3} v\r\n */\r\nbox2d.b2Vec3.prototype.SelfSub = function (v)\r\n{\r\n\tthis.x -= v.x;\r\n\tthis.y -= v.y;\r\n\tthis.z -= v.z;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} z \r\n */\r\nbox2d.b2Vec3.prototype.SelfSubXYZ = function (x, y, z)\r\n{\r\n\tthis.x -= x;\r\n\tthis.y -= y;\r\n\tthis.z -= z;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {number} s\r\n */\r\nbox2d.b2Vec3.prototype.SelfMul = function (s)\r\n{\r\n\tthis.x *= s;\r\n\tthis.y *= s;\r\n\tthis.z *= s;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Perform the dot product on two vectors. \r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec3} a\r\n * @param {box2d.b2Vec3} b\r\n */\r\nbox2d.b2DotV3V3 = function (a, b)\r\n{\r\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\r\n}\r\n\r\n/** \r\n * Perform the cross product on two vectors. \r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {box2d.b2Vec3} a\r\n * @param {box2d.b2Vec3} b\r\n * @param {box2d.b2Vec3} out\r\n */\r\nbox2d.b2CrossV3V3 = function (a, b, out)\r\n{\r\n\tvar a_x = a.x, a_y = a.y, a_z = a.z;\r\n\tvar b_x = b.x, b_y = b.y, b_z = b.z;\r\n\tout.x = a_y * b_z - a_z * b_y;\r\n\tout.y = a_z * b_x - a_x * b_z;\r\n\tout.z = a_x * b_y - a_y * b_x;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * A 2-by-2 matrix. Stored in column-major order. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Mat22 = function ()\r\n{\r\n\tthis.ex = new box2d.b2Vec2(1.0, 0.0);\r\n\tthis.ey = new box2d.b2Vec2(0.0, 1.0);\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Mat22.prototype.ex = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Mat22.prototype.ey = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22} \r\n */\r\nbox2d.b2Mat22.IDENTITY = new box2d.b2Mat22();\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n */\r\nbox2d.b2Mat22.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2Mat22().Copy(this);\r\n}\r\n\r\n/** \r\n * Construct this matrix using columns. \r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Vec2} c1\r\n * @param {box2d.b2Vec2} c2\r\n */\r\nbox2d.b2Mat22.FromVV = function (c1, c2)\r\n{\r\n\treturn new box2d.b2Mat22().SetVV(c1, c2);\r\n}\r\n\r\n/** \r\n * Construct this matrix using scalars. \r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {number} r1c1 or ex.x\r\n * @param {number} r1c2 or ey.x\r\n * @param {number} r2c1 or ex.y\r\n * @param {number} r2c2 or ey.y\r\n */\r\nbox2d.b2Mat22.FromSSSS = function (r1c1, r1c2, r2c1, r2c2)\r\n{\r\n\treturn new box2d.b2Mat22().SetSSSS(r1c1, r1c2, r2c1, r2c2);\r\n}\r\n\r\n/** \r\n * Construct this matrix using an angle. This matrix becomes an \r\n * orthonormal rotation matrix. \r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {number} radians\r\n */\r\nbox2d.b2Mat22.FromAngleRadians = function (radians)\r\n{\r\n\treturn new box2d.b2Mat22().SetAngleRadians(radians);\r\n}\r\n\r\n/** \r\n * Initialize this matrix using scalars. \r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {number} r1c1 or ex.x\r\n * @param {number} r1c2 or ey.x\r\n * @param {number} r2c1 or ex.y\r\n * @param {number} r2c2 or ey.y\r\n */\r\nbox2d.b2Mat22.prototype.SetSSSS = function (r1c1, r1c2, r2c1, r2c2)\r\n{\r\n\tthis.ex.SetXY(r1c1, r2c1);\r\n\tthis.ey.SetXY(r1c2, r2c2);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Initialize this matrix using columns. \r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Vec2} c1\r\n * @param {box2d.b2Vec2} c2\r\n */\r\nbox2d.b2Mat22.prototype.SetVV = function (c1, c2)\r\n{\r\n\tthis.ex.Copy(c1);\r\n\tthis.ey.Copy(c2);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Initialize this matrix using an angle. This matrix becomes an \r\n * orthonormal rotation matrix. \r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {number} radians\r\n */\r\nbox2d.b2Mat22.prototype.SetAngle = function (radians)\r\n{\r\n\tvar c = Math.cos(radians);\r\n\tvar s = Math.sin(radians);\r\n\tthis.ex.SetXY( c, s);\r\n\tthis.ey.SetXY(-s, c);\r\n\treturn this;\r\n}\r\n\r\nbox2d.b2Mat22.prototype.SetAngleRadians = box2d.b2Mat22.prototype.SetAngle;\r\n\r\nbox2d.b2Mat22.prototype.SetAngleDegrees = function (angle) { return this.SetAngle(box2d.b2DegToRad(angle)); }\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Mat22} other\r\n */\r\nbox2d.b2Mat22.prototype.Copy = function (other)\r\n{\r\n\t//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }\r\n\tthis.ex.Copy(other.ex);\r\n\tthis.ey.Copy(other.ey);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Set this to the identity matrix. \r\n * @export \r\n * @return {box2d.b2Mat22}\r\n */\r\nbox2d.b2Mat22.prototype.SetIdentity = function ()\r\n{\r\n\tthis.ex.SetXY(1.0, 0.0);\r\n\tthis.ey.SetXY(0.0, 1.0);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Set this matrix to all zeros. \r\n * @export \r\n * @return {box2d.b2Mat22}\r\n */\r\nbox2d.b2Mat22.prototype.SetZero = function ()\r\n{\r\n\tthis.ex.SetZero();\r\n\tthis.ey.SetZero();\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Extract the angle from this matrix (assumed to be a rotation \r\n * matrix). \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Mat22.prototype.GetAngle = function ()\r\n{\r\n\treturn Math.atan2(this.ex.y, this.ex.x);\r\n}\r\n\r\nbox2d.b2Mat22.prototype.GetAngleRadians = box2d.b2Mat22.prototype.GetAngle;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Mat22} out\r\n */\r\nbox2d.b2Mat22.prototype.GetInverse = function (out)\r\n{\r\n\tvar a = this.ex.x;\r\n\tvar b = this.ey.x;\r\n\tvar c = this.ex.y;\r\n\tvar d = this.ey.y;\r\n\tvar det = a * d - b * c;\r\n\tif (det !== 0.0)\r\n\t{\r\n\t\tdet = 1.0 / det;\r\n\t}\r\n\tout.ex.x =   det * d;\r\n\tout.ey.x = (-det * b);\r\n\tout.ex.y = (-det * c);\r\n\tout.ey.y =   det * a;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Solve A * x = b, where b is a column vector. This is more \r\n * efficient than computing the inverse in one-shot cases. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} b_x\r\n * @param {number} b_y\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2Mat22.prototype.Solve = function (b_x, b_y, out)\r\n{\r\n\tvar a11 = this.ex.x, a12 = this.ey.x;\r\n\tvar a21 = this.ex.y, a22 = this.ey.y;\r\n\tvar det = a11 * a22 - a12 * a21;\r\n\tif (det !== 0.0)\r\n\t{\r\n\t\tdet = 1.0 / det;\r\n\t}\r\n\tout.x = det * (a22 * b_x - a12 * b_y);\r\n\tout.y = det * (a11 * b_y - a21 * b_x);\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n */\r\nbox2d.b2Mat22.prototype.SelfAbs = function ()\r\n{\r\n\tthis.ex.SelfAbs();\r\n\tthis.ey.SelfAbs();\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n */\r\nbox2d.b2Mat22.prototype.SelfInv = function ()\r\n{\r\n\treturn this.GetInverse(this);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Mat22} M\r\n */\r\nbox2d.b2Mat22.prototype.SelfAddM = function (M)\r\n{\r\n\tthis.ex.SelfAdd(M.ex);\r\n\tthis.ey.SelfAdd(M.ey);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Mat22} M\r\n */\r\nbox2d.b2Mat22.prototype.SelfSubM = function (M)\r\n{\r\n\tthis.ex.SelfSub(M.ex);\r\n\tthis.ey.SelfSub(M.ey);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Mat22} M\r\n * @param {box2d.b2Mat22} out\r\n */\r\nbox2d.b2AbsM = function (M, out)\r\n{\r\n\tvar M_ex = M.ex, M_ey = M.ey;\r\n\tout.ex.x = box2d.b2Abs(M_ex.x);\r\n\tout.ex.y = box2d.b2Abs(M_ex.y);\r\n\tout.ey.x = box2d.b2Abs(M_ey.x);\r\n\tout.ey.y = box2d.b2Abs(M_ey.y);\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Multiply a matrix times a vector. If a rotation matrix is \r\n * provided, then this transforms the vector from one frame to \r\n * another. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Mat22} M\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MulMV = function (M, v, out)\r\n{\r\n\tvar M_ex = M.ex, M_ey = M.ey;\r\n\tvar v_x = v.x, v_y = v.y;\r\n\tout.x = M_ex.x * v_x + M_ey.x * v_y;\r\n\tout.y = M_ex.y * v_x + M_ey.y * v_y;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Multiply a matrix transpose times a vector. If a rotation \r\n * matrix is provided, then this transforms the vector from one \r\n * frame to another (inverse transform). \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Mat22} M\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MulTMV = function (M, v, out)\r\n{\r\n\tvar M_ex = M.ex, M_ey = M.ey;\r\n\tvar v_x = v.x, v_y = v.y;\r\n\tout.x = M_ex.x * v_x + M_ex.y * v_y;\r\n\tout.y = M_ey.x * v_x + M_ey.y * v_y;\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Mat22} A\r\n * @param {box2d.b2Mat22} B\r\n * @param {box2d.b2Mat22} out\r\n */\r\nbox2d.b2AddMM = function (A, B, out)\r\n{\r\n\tvar A_ex = A.ex, A_ey = A.ey;\r\n\tvar B_ex = B.ex, B_ey = B.ey;\r\n\tout.ex.x = A_ex.x + B_ex.x;\r\n\tout.ex.y = A_ex.y + B_ex.y;\r\n\tout.ey.x = A_ey.x + B_ey.x;\r\n\tout.ey.y = A_ey.y + B_ey.y;\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Mat22} A\r\n * @param {box2d.b2Mat22} B\r\n * @param {box2d.b2Mat22} out\r\n */\r\nbox2d.b2MulMM = function (A, B, out)\r\n{\r\n\tvar A_ex_x = A.ex.x, A_ex_y = A.ex.y;\r\n\tvar A_ey_x = A.ey.x, A_ey_y = A.ey.y;\r\n\tvar B_ex_x = B.ex.x, B_ex_y = B.ex.y;\r\n\tvar B_ey_x = B.ey.x, B_ey_y = B.ey.y;\r\n\tout.ex.x = A_ex_x * B_ex_x + A_ey_x * B_ex_y;\r\n\tout.ex.y = A_ex_y * B_ex_x + A_ey_y * B_ex_y;\r\n\tout.ey.x = A_ex_x * B_ey_x + A_ey_x * B_ey_y;\r\n\tout.ey.y = A_ex_y * B_ey_x + A_ey_y * B_ey_y;\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat22}\r\n * @param {box2d.b2Mat22} A\r\n * @param {box2d.b2Mat22} B\r\n * @param {box2d.b2Mat22} out\r\n */\r\nbox2d.b2MulTMM = function (A, B, out)\r\n{\r\n\tvar A_ex_x = A.ex.x, A_ex_y = A.ex.y;\r\n\tvar A_ey_x = A.ey.x, A_ey_y = A.ey.y;\r\n\tvar B_ex_x = B.ex.x, B_ex_y = B.ex.y;\r\n\tvar B_ey_x = B.ey.x, B_ey_y = B.ey.y;\r\n\tout.ex.x = A_ex_x * B_ex_x + A_ex_y * B_ex_y;\r\n\tout.ex.y = A_ey_x * B_ex_x + A_ey_y * B_ex_y;\r\n\tout.ey.x = A_ex_x * B_ey_x + A_ex_y * B_ey_y;\r\n\tout.ey.y = A_ey_x * B_ey_x + A_ey_y * B_ey_y;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * A 3-by-3 matrix. Stored in column-major order. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Mat33 = function ()\r\n{\r\n\tthis.ex = new box2d.b2Vec3(1.0, 0.0, 0.0);\r\n\tthis.ey = new box2d.b2Vec3(0.0, 1.0, 0.0);\r\n\tthis.ez = new box2d.b2Vec3(0.0, 0.0, 1.0);\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec3} \r\n */\r\nbox2d.b2Mat33.prototype.ex = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec3} \r\n */\r\nbox2d.b2Mat33.prototype.ey = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec3} \r\n */\r\nbox2d.b2Mat33.prototype.ez = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat33} \r\n */\r\nbox2d.b2Mat33.IDENTITY = new box2d.b2Mat33();\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat33}\r\n */\r\nbox2d.b2Mat33.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2Mat33().Copy(this);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat33}\r\n * @param {box2d.b2Vec3} c1\r\n * @param {box2d.b2Vec3} c2\r\n * @param {box2d.b2Vec3} c3\r\n */\r\nbox2d.b2Mat33.prototype.SetVVV = function (c1, c2, c3)\r\n{\r\n\tthis.ex.Copy(c1);\r\n\tthis.ey.Copy(c2);\r\n\tthis.ez.Copy(c3);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat33}\r\n * @param {box2d.b2Mat33} other\r\n */\r\nbox2d.b2Mat33.prototype.Copy = function (other)\r\n{\r\n\t//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }\r\n\tthis.ex.Copy(other.ex);\r\n\tthis.ey.Copy(other.ey);\r\n\tthis.ez.Copy(other.ez);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat33}\r\n */\r\nbox2d.b2Mat33.prototype.SetIdentity = function ()\r\n{\r\n\tthis.ex.SetXYZ(1.0, 0.0, 0.0);\r\n\tthis.ey.SetXYZ(0.0, 1.0, 0.0);\r\n\tthis.ez.SetXYZ(0.0, 0.0, 1.0);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Set this matrix to all zeros. \r\n * @export \r\n * @return {box2d.b2Mat33}\r\n */\r\nbox2d.b2Mat33.prototype.SetZero = function ()\r\n{\r\n\tthis.ex.SetZero();\r\n\tthis.ey.SetZero();\r\n\tthis.ez.SetZero();\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Mat33}\r\n * @param {box2d.b2Mat33} M\r\n */\r\nbox2d.b2Mat33.prototype.SelfAddM = function (M)\r\n{\r\n\tthis.ex.SelfAdd(M.ex);\r\n\tthis.ey.SelfAdd(M.ey);\r\n\tthis.ez.SelfAdd(M.ez);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Solve A * x = b, where b is a column vector. This is more \r\n * efficient than computing the inverse in one-shot cases. \r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {number} b_x\r\n * @param {number} b_y\r\n * @param {number} b_z\r\n * @param {box2d.b2Vec3} out\r\n */\r\nbox2d.b2Mat33.prototype.Solve33 = function (b_x, b_y, b_z, out)\r\n{\r\n\tvar a11 = this.ex.x, a21 = this.ex.y, a31 = this.ex.z;\r\n\tvar a12 = this.ey.x, a22 = this.ey.y, a32 = this.ey.z;\r\n\tvar a13 = this.ez.x, a23 = this.ez.y, a33 = this.ez.z;\r\n\tvar det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);\r\n\tif (det !== 0.0)\r\n\t{\r\n\t\tdet = 1.0 / det;\r\n\t}\r\n\tout.x = det * (b_x * (a22 * a33 - a32 * a23) + b_y * (a32 * a13 - a12 * a33) + b_z * (a12 * a23 - a22 * a13));\r\n\tout.y = det * (a11 * (b_y * a33 - b_z * a23) + a21 * (b_z * a13 - b_x * a33) + a31 * (b_x * a23 - b_y * a13));\r\n\tout.z = det * (a11 * (a22 * b_z - a32 * b_y) + a21 * (a32 * b_x - a12 * b_z) + a31 * (a12 * b_y - a22 * b_x));\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Solve A * x = b, where b is a column vector. This is more \r\n * efficient than computing the inverse in one-shot cases. Solve \r\n * only the upper 2-by-2 matrix equation. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} b_x\r\n * @param {number} b_y\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2Mat33.prototype.Solve22 = function (b_x, b_y, out)\r\n{\r\n\tvar a11 = this.ex.x, a12 = this.ey.x;\r\n\tvar a21 = this.ex.y, a22 = this.ey.y;\r\n\tvar det = a11 * a22 - a12 * a21;\r\n\tif (det !== 0.0)\r\n\t{\r\n\t\tdet = 1.0 / det;\r\n\t}\r\n\tout.x = det * (a22 * b_x - a12 * b_y);\r\n\tout.y = det * (a11 * b_y - a21 * b_x);\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Get the inverse of this matrix as a 2-by-2. \r\n * Returns the zero matrix if singular.\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Mat33} M \r\n */\r\nbox2d.b2Mat33.prototype.GetInverse22 = function (M)\r\n{\r\n\tvar a = this.ex.x, b = this.ey.x, c = this.ex.y, d = this.ey.y;\r\n\tvar det = a * d - b * c;\r\n\tif (det !== 0.0)\r\n\t{\r\n\t\tdet = 1.0 / det;\r\n\t}\r\n\r\n\tM.ex.x =  det * d; M.ey.x = -det * b; M.ex.z = 0.0;\r\n\tM.ex.y = -det * c; M.ey.y =  det * a; M.ey.z = 0.0;\r\n\tM.ez.x =      0.0; M.ez.y =      0.0; M.ez.z = 0.0;\r\n}\r\n\r\n/** \r\n * Get the symmetric inverse of this matrix as a 3-by-3. \r\n * Returns the zero matrix if singular.\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Mat33} M \r\n */\r\nbox2d.b2Mat33.prototype.GetSymInverse33 = function (M)\r\n{\r\n\tvar det = box2d.b2DotV3V3(this.ex, box2d.b2CrossV3V3(this.ey, this.ez, box2d.b2Vec3.s_t0));\r\n\tif (det !== 0.0)\r\n\t{\r\n\t\tdet = 1.0 / det;\r\n\t}\r\n\r\n\tvar a11 = this.ex.x, a12 = this.ey.x, a13 = this.ez.x;\r\n\tvar a22 = this.ey.y, a23 = this.ez.y;\r\n\tvar a33 = this.ez.z;\r\n\r\n\tM.ex.x = det * (a22 * a33 - a23 * a23);\r\n\tM.ex.y = det * (a13 * a23 - a12 * a33);\r\n\tM.ex.z = det * (a12 * a23 - a13 * a22);\r\n\r\n\tM.ey.x = M.ex.y;\r\n\tM.ey.y = det * (a11 * a33 - a13 * a13);\r\n\tM.ey.z = det * (a13 * a12 - a11 * a23);\r\n\r\n\tM.ez.x = M.ex.z;\r\n\tM.ez.y = M.ey.z;\r\n\tM.ez.z = det * (a11 * a22 - a12 * a12);\r\n}\r\n\r\n/** \r\n * Multiply a matrix times a vector. \r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {box2d.b2Mat33} A\r\n * @param {box2d.b2Vec3} v\r\n * @param {box2d.b2Vec3} out\r\n */\r\nbox2d.b2MulM33V3 = function (A, v, out)\r\n{\r\n\tvar v_x = v.x, v_y = v.y, v_z = v.z;\r\n\tout.x = A.ex.x * v_x + A.ey.x * v_y + A.ez.x * v_z;\r\n\tout.y = A.ex.y * v_x + A.ey.y * v_y + A.ez.y * v_z;\r\n\tout.z = A.ex.z * v_x + A.ey.z * v_y + A.ez.z * v_z;\r\n\treturn out;\r\n}\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec3}\r\n * @param {box2d.b2Mat33} A\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} z\r\n * @param {box2d.b2Vec3} out\r\n */\r\nbox2d.b2MulM33XYZ = function (A, x, y, z, out)\r\n{\r\n\tout.x = A.ex.x * x + A.ey.x * y + A.ez.x * z;\r\n\tout.y = A.ex.y * x + A.ey.y * y + A.ez.y * z;\r\n\tout.z = A.ex.z * x + A.ey.z * y + A.ez.z * z;\r\n\treturn out;\r\n}\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Mat33} A\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MulM33V2 = function (A, v, out)\r\n{\r\n\tvar v_x = v.x, v_y = v.y;\r\n\tout.x = A.ex.x * v_x + A.ey.x * v_y;\r\n\tout.y = A.ex.y * v_x + A.ey.y * v_y;\r\n\treturn out;\r\n}\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Mat33} A\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MulM33XY = function (A, x, y, out)\r\n{\r\n\tout.x = A.ex.x * x + A.ey.x * y;\r\n\tout.y = A.ex.y * x + A.ey.y * y;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Rotation \r\n * Initialize from an angle in radians \r\n * @export \r\n * @constructor \r\n * @param {number=} angle \r\n */\r\nbox2d.b2Rot = function (angle)\r\n{\r\n\t/// Sine and cosine\r\n\tif (angle)\r\n\t{\r\n\t\t/// TODO_ERIN optimize\r\n\t\tthis.angle = angle;\r\n\t\tthis.s = Math.sin(angle);\r\n\t\tthis.c = Math.cos(angle);\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Rot.prototype.angle = 0.0;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Rot.prototype.s = 0.0;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Rot.prototype.c = 1.0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot} \r\n */\r\nbox2d.b2Rot.IDENTITY = new box2d.b2Rot();\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Rot}\r\n */\r\nbox2d.b2Rot.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2Rot().Copy(this);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Rot}\r\n * @param {box2d.b2Rot} other \r\n */\r\nbox2d.b2Rot.prototype.Copy = function (other)\r\n{\r\n\tthis.angle = other.angle;\r\n\tthis.s = other.s;\r\n\tthis.c = other.c;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Set using an angle in radians. \r\n * @export \r\n * @return {box2d.b2Rot} \r\n * @param {number} angle \r\n */\r\nbox2d.b2Rot.prototype.SetAngle = function (angle)\r\n{\r\n\t/// TODO_ERIN optimize\r\n\tif (this.angle !== angle)\r\n\t{\r\n\t\tthis.angle = angle;\r\n\t\tthis.s = Math.sin(angle);\r\n\t\tthis.c = Math.cos(angle);\r\n\t}\r\n\treturn this;\r\n}\r\n\r\nbox2d.b2Rot.prototype.SetAngleRadians = box2d.b2Rot.prototype.SetAngle;\r\n\r\nbox2d.b2Rot.prototype.SetAngleDegrees = function (angle) { return this.SetAngle(box2d.b2DegToRad(angle)); }\r\n\r\n/** \r\n * Set to the identity rotation \r\n * @export \r\n * @return {box2d.b2Rot} \r\n */\r\nbox2d.b2Rot.prototype.SetIdentity = function ()\r\n{\r\n\tthis.angle = 0.0;\r\n\tthis.s = 0.0;\r\n\tthis.c = 1.0;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Get the angle in radians \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Rot.prototype.GetAngle = function ()\r\n{\r\n\treturn this.angle;\r\n//\treturn Math.atan2(this.s, this.c);\r\n}\r\n\r\nbox2d.b2Rot.prototype.GetAngleRadians = box2d.b2Rot.prototype.GetAngle;\r\n\r\nbox2d.b2Rot.prototype.GetAngleDegrees = function () { return box2d.b2RadToDeg(this.GetAngle()); }\r\n\r\n/** \r\n * Get the x-axis \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Rot.prototype.GetXAxis = function (out)\r\n{\r\n\tout.x = this.c;\r\n\tout.y = this.s;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Get the y-axis \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Rot.prototype.GetYAxis = function (out)\r\n{\r\n\tout.x = -this.s;\r\n\tout.y = this.c;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Multiply two rotations: q * r \r\n * @export \r\n * @return {box2d.b2Rot} \r\n * @param {box2d.b2Rot} q\r\n * @param {box2d.b2Rot} r\r\n * @param {box2d.b2Rot} out \r\n */\r\nbox2d.b2MulRR = function (q, r, out)\r\n{\r\n\t// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\r\n\t// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]\r\n\t// s = qs * rc + qc * rs\r\n\t// c = qc * rc - qs * rs\r\n\tvar q_c = q.c, q_s = q.s;\r\n\tvar r_c = r.c, r_s = r.s;\r\n\tout.s = q_s * r_c + q_c * r_s;\r\n\tout.c = q_c * r_c - q_s * r_s;\r\n\tout.angle = q.angle + r.angle;\r\n\twhile (out.angle < -box2d.b2_pi) { out.angle += box2d.b2_two_pi; }\r\n\twhile (out.angle >= box2d.b2_pi) { out.angle -= box2d.b2_two_pi; }\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Transpose multiply two rotations: qT * r \r\n * @export \r\n * @return {box2d.b2Rot} \r\n * @param {box2d.b2Rot} q\r\n * @param {box2d.b2Rot} r\r\n * @param {box2d.b2Rot} out \r\n */\r\nbox2d.b2MulTRR = function (q, r, out)\r\n{\r\n\t// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\r\n\t// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]\r\n\t// s = qc * rs - qs * rc\r\n\t// c = qc * rc + qs * rs\r\n\tvar q_c = q.c, q_s = q.s;\r\n\tvar r_c = r.c, r_s = r.s;\r\n\tout.s = q_c * r_s - q_s * r_c;\r\n\tout.c = q_c * r_c + q_s * r_s;\r\n\tout.angle = q.angle - r.angle;\r\n\twhile (out.angle < -box2d.b2_pi) { out.angle += box2d.b2_two_pi; }\r\n\twhile (out.angle >= box2d.b2_pi) { out.angle -= box2d.b2_two_pi; }\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Rotate a vector \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Rot} q \r\n * @param {box2d.b2Vec2} v \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2MulRV = function (q, v, out)\r\n{\r\n\tvar q_c = q.c, q_s = q.s;\r\n\tvar v_x = v.x, v_y = v.y;\r\n\tout.x = q_c * v_x - q_s * v_y;\r\n\tout.y = q_s * v_x + q_c * v_y;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Inverse rotate a vector \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Rot} q \r\n * @param {box2d.b2Vec2} v \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2MulTRV = function (q, v, out)\r\n{\r\n\tvar q_c = q.c, q_s = q.s;\r\n\tvar v_x = v.x, v_y = v.y;\r\n\tout.x =  q_c * v_x + q_s * v_y;\r\n\tout.y = -q_s * v_x + q_c * v_y;\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * A transform contains translation and rotation. It is used to \r\n * represent the position and orientation of rigid frames. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Transform = function ()\r\n{\r\n\tthis.p = new box2d.b2Vec2();\r\n\tthis.q = new box2d.b2Rot();\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Transform.prototype.p = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot} \r\n */\r\nbox2d.b2Transform.prototype.q = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Transform} \r\n */\r\nbox2d.b2Transform.IDENTITY = new box2d.b2Transform();\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Transform}\r\n */\r\nbox2d.b2Transform.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2Transform().Copy(this);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {box2d.b2Transform} other\r\n */\r\nbox2d.b2Transform.prototype.Copy = function (other)\r\n{\r\n\t//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }\r\n\tthis.p.Copy(other.p);\r\n\tthis.q.Copy(other.q);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Set this to the identity transform. \r\n * @export \r\n * @return {box2d.b2Transform}\r\n */\r\nbox2d.b2Transform.prototype.SetIdentity = function ()\r\n{\r\n\tthis.p.SetZero();\r\n\tthis.q.SetIdentity();\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Set this based on the position and angle. \r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {box2d.b2Vec2} position\r\n * @param {box2d.b2Rot} q\r\n */\r\nbox2d.b2Transform.prototype.SetPositionRotation = function (position, q)\r\n{\r\n\tthis.p.Copy(position);\r\n\tthis.q.Copy(q);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {box2d.b2Vec2} pos\r\n * @param {number} a\r\n */\r\nbox2d.b2Transform.prototype.SetPositionAngleRadians = function (pos, a)\r\n{\r\n\tthis.p.Copy(pos);\r\n\tthis.q.SetAngleRadians(a);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {box2d.b2Vec2} position\r\n */\r\nbox2d.b2Transform.prototype.SetPosition = function (position)\r\n{\r\n\tthis.p.Copy(position);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nbox2d.b2Transform.prototype.SetPositionXY = function (x, y)\r\n{\r\n\tthis.p.SetXY(x, y);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {box2d.b2Rot} rotation\r\n */\r\nbox2d.b2Transform.prototype.SetRotation = function (rotation)\r\n{\r\n\tthis.q.Copy(rotation);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {number} radians\r\n */\r\nbox2d.b2Transform.prototype.SetRotationAngleRadians = function (radians)\r\n{\r\n\tthis.q.SetAngleRadians(radians);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n */\r\nbox2d.b2Transform.prototype.GetPosition = function ()\r\n{\r\n\treturn this.p;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Rot}\r\n */\r\nbox2d.b2Transform.prototype.GetRotation = function ()\r\n{\r\n\treturn this.q;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Transform.prototype.GetRotationAngle = function ()\r\n{\r\n\treturn this.q.GetAngle();\r\n}\r\n\r\nbox2d.b2Transform.prototype.GetRotationAngleRadians = box2d.b2Transform.prototype.GetRotationAngle;\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Transform.prototype.GetAngle = function ()\r\n{\r\n\treturn this.q.GetAngle();\r\n}\r\n\r\nbox2d.b2Transform.prototype.GetAngleRadians = box2d.b2Transform.prototype.GetAngle;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Transform} T\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MulXV = function (T, v, out)\r\n{\r\n//\tfloat32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;\r\n//\tfloat32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;\r\n//\r\n//\treturn b2Vec2(x, y);\r\n\tvar T_q_c = T.q.c, T_q_s = T.q.s;\r\n\tvar v_x = v.x, v_y = v.y;\r\n\tout.x = (T_q_c * v_x - T_q_s * v_y) + T.p.x;\r\n\tout.y = (T_q_s * v_x + T_q_c * v_y) + T.p.y;\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Transform} T\r\n * @param {box2d.b2Vec2} v\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MulTXV = function (T, v, out)\r\n{\r\n//\tfloat32 px = v.x - T.p.x;\r\n//\tfloat32 py = v.y - T.p.y;\r\n//\tfloat32 x = (T.q.c * px + T.q.s * py);\r\n//\tfloat32 y = (-T.q.s * px + T.q.c * py);\r\n//\r\n//\treturn b2Vec2(x, y);\r\n\tvar T_q_c = T.q.c, T_q_s = T.q.s;\r\n\tvar p_x = v.x - T.p.x;\r\n\tvar p_y = v.y - T.p.y;\r\n\tout.x = ( T_q_c * p_x + T_q_s * p_y);\r\n\tout.y = (-T_q_s * p_x + T_q_c * p_y);\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\r\n *    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {box2d.b2Transform} A\r\n * @param {box2d.b2Transform} B\r\n * @param {box2d.b2Transform} out \r\n */\r\nbox2d.b2MulXX = function (A, B, out)\r\n{\r\n\tbox2d.b2MulRR(A.q, B.q, out.q);\r\n\tbox2d.b2AddVV(box2d.b2MulRV(A.q, B.p, out.p), A.p, out.p);\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * v2 = A.q' * (B.q * v1 + B.p - A.p)\r\n *    = A.q' * B.q * v1 + A.q' * (B.p - A.p)\r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {box2d.b2Transform} A\r\n * @param {box2d.b2Transform} B\r\n * @param {box2d.b2Transform} out \r\n */\r\nbox2d.b2MulTXX = function (A, B, out)\r\n{\r\n\tbox2d.b2MulTRR(A.q, B.q, out.q);\r\n\tbox2d.b2MulTRV(A.q, box2d.b2SubVV(B.p, A.p, out.p), out.p);\r\n\treturn out;\r\n}\r\n\r\n/**\r\n * This describes the motion of a body/shape for TOI computation.\r\n * Shapes are defined with respect to the body origin, which may\r\n * no coincide with the center of mass. However, to support dynamics\r\n * we must interpolate the center of mass position.\r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Sweep = function ()\r\n{\r\n\tthis.localCenter = new box2d.b2Vec2();\r\n\tthis.c0 = new box2d.b2Vec2();\r\n\tthis.c = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Sweep.prototype.localCenter = null; ///< local center of mass position\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Sweep.prototype.c0 = null; ///< center world positions\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2Sweep.prototype.c = null;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Sweep.prototype.a0 = 0.0; ///< world angles\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Sweep.prototype.a = 0.0;\r\n\r\n/**\r\n * Fraction of the current time step in the range [0,1]\r\n * c0 and a0 are the positions at alpha0.\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Sweep.prototype.alpha0 = 0.0;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Sweep}\r\n */\r\nbox2d.b2Sweep.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2Sweep().Copy(this);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Sweep}\r\n * @param {box2d.b2Sweep} other\r\n */\r\nbox2d.b2Sweep.prototype.Copy = function (other)\r\n{\r\n\t//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }\r\n\tthis.localCenter.Copy(other.localCenter);\r\n\tthis.c0.Copy(other.c0);\r\n\tthis.c.Copy(other.c);\r\n\tthis.a0 = other.a0;\r\n\tthis.a = other.a;\r\n\tthis.alpha0 = other.alpha0;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Get the interpolated transform at a specific time. \r\n * @export \r\n * @return {box2d.b2Transform}\r\n * @param {box2d.b2Transform} xf\r\n * @param {number} beta is a factor in [0,1], where 0 indicates alpha0.\r\n */\r\nbox2d.b2Sweep.prototype.GetTransform = function (xf, beta)\r\n{\r\n\tvar one_minus_beta = (1.0 - beta);\r\n\txf.p.x = one_minus_beta * this.c0.x + beta * this.c.x;\r\n\txf.p.y = one_minus_beta * this.c0.y + beta * this.c.y;\r\n\tvar angle = one_minus_beta * this.a0 + beta * this.a;\r\n\txf.q.SetAngleRadians(angle);\r\n\r\n\t// Shift to origin\r\n\txf.p.SelfSub(box2d.b2MulRV(xf.q, this.localCenter, box2d.b2Vec2.s_t0));\r\n\treturn xf;\r\n}\r\n\r\n/** \r\n * Advance the sweep forward, yielding a new initial state. \r\n * @export \r\n * @return {void} \r\n * @param {number} alpha the new initial time.\r\n */\r\nbox2d.b2Sweep.prototype.Advance = function (alpha)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.alpha0 < 1.0); }\r\n\tvar beta = (alpha - this.alpha0) / (1.0 - this.alpha0);\r\n\tthis.c0.x += beta * (this.c.x - this.c0.x);\r\n\tthis.c0.y += beta * (this.c.y - this.c0.y);\r\n\tthis.a0 += beta * (this.a - this.a0);\r\n\tthis.alpha0 = alpha;\r\n}\r\n\r\n/** \r\n * Normalize an angle in radians to be between -pi and pi \r\n * (actually 0 and 2*pi) \r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Sweep.prototype.Normalize = function ()\r\n{\r\n\tvar d = box2d.b2_two_pi * Math.floor(this.a0 / box2d.b2_two_pi);\r\n\tthis.a0 -= d;\r\n\tthis.a -= d;\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Controller');\r\n\r\ngoog.require('box2d.b2Settings');\r\n\r\n/** \r\n * A controller edge is used to connect bodies and controllers \r\n * together in a bipartite graph. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2ControllerEdge = function ()\r\n{\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Controller} \r\n */\r\nbox2d.b2ControllerEdge.prototype.controller = null; ///< provides quick access to other end of this edge.\r\n/**\r\n * @export \r\n * @type {box2d.b2Body} \r\n */\r\nbox2d.b2ControllerEdge.prototype.body = null; ///< the body\r\n/**\r\n * @export \r\n * @type {box2d.b2ControllerEdge} \r\n */\r\nbox2d.b2ControllerEdge.prototype.prevBody = null; ///< the previous controller edge in the controllers's joint list\r\n/**\r\n * @export \r\n * @type {box2d.b2ControllerEdge} \r\n */\r\nbox2d.b2ControllerEdge.prototype.nextBody = null; ///< the next controller edge in the controllers's joint list\r\n/**\r\n * @export \r\n * @type {box2d.b2ControllerEdge} \r\n */\r\nbox2d.b2ControllerEdge.prototype.prevController = null; ///< the previous controller edge in the body's joint list\r\n/**\r\n * @export \r\n * @type {box2d.b2ControllerEdge} \r\n */\r\nbox2d.b2ControllerEdge.prototype.nextController = null; ///< the next controller edge in the body's joint list\r\n\r\n/** \r\n * Base class for controllers. Controllers are a convience for \r\n * encapsulating common per-step functionality. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Controller = function ()\r\n{\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2World} \r\n */\r\nbox2d.b2Controller.prototype.m_world = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2ControllerEdge} \r\n */\r\nbox2d.b2Controller.prototype.m_bodyList = null;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Controller.prototype.m_bodyCount = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Controller} \r\n */\r\nbox2d.b2Controller.prototype.m_prev = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Controller} \r\n */\r\nbox2d.b2Controller.prototype.m_next = null;\r\n\r\n/** \r\n * Controllers override this to implement per-step \r\n * functionality. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TimeStep} step \r\n */\r\nbox2d.b2Controller.prototype.Step = function (step)\r\n{\r\n}\r\n\r\n/** \r\n * Controllers override this to provide debug drawing. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Draw} debugDraw\r\n */\r\nbox2d.b2Controller.prototype.Draw = function (debugDraw)\r\n{\r\n}\r\n\r\n/** \r\n * Get the next controller in the world's body list. \r\n * @export \r\n * @return {box2d.b2Controller} \r\n */\r\nbox2d.b2Controller.prototype.GetNext = function ()\r\n{\r\n\treturn this.m_next;\r\n}\r\n\r\n/** \r\n * Get the previous controller in the world's body list. \r\n * @export \r\n * @return {box2d.b2Controller} \r\n */\r\nbox2d.b2Controller.prototype.GetPrev = function ()\r\n{\r\n\treturn this.m_prev;\r\n}\r\n\r\n/** \r\n * Get the parent world of this body. \r\n * @export \r\n * @return {box2d.b2World} \r\n */\r\nbox2d.b2Controller.prototype.GetWorld = function ()\r\n{\r\n\treturn this.m_world;\r\n}\r\n\r\n/** \r\n * Get the attached body list \r\n * @export \r\n * @return {box2d.b2ControllerEdge}\r\n */\r\nbox2d.b2Controller.prototype.GetBodyList = function ()\r\n{\r\n\treturn this.m_bodyList;\r\n}\r\n\r\n/** \r\n * Adds a body to the controller list. \r\n * @export \r\n * @return {void}\r\n * @param {box2d.b2Body} body\r\n */\r\nbox2d.b2Controller.prototype.AddBody = function (body)\r\n{\r\n\tvar edge = new box2d.b2ControllerEdge();\r\n\r\n\tedge.body = body;\r\n\tedge.controller = this;\r\n\r\n\t//Add edge to controller list\r\n\tedge.nextBody = this.m_bodyList;\r\n\tedge.prevBody = null;\r\n\tif (this.m_bodyList)\r\n\t\tthis.m_bodyList.prevBody = edge;\r\n\tthis.m_bodyList = edge;\r\n\t++this.m_bodyCount;\r\n\r\n\t//Add edge to body list\r\n\tedge.nextController = body.m_controllerList;\r\n\tedge.prevController = null;\r\n\tif (body.m_controllerList)\r\n\t\tbody.m_controllerList.prevController = edge;\r\n\tbody.m_controllerList = edge;\r\n\t++body.m_controllerCount;\r\n}\r\n\r\n/** \r\n * Removes a body from the controller list. \r\n * @export \r\n * @return {void}\r\n * @param {box2d.b2Body} body\r\n */\r\nbox2d.b2Controller.prototype.RemoveBody = function (body)\r\n{\r\n\t//Assert that the controller is not empty\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_bodyCount > 0); }\r\n\r\n\t//Find the corresponding edge\r\n\t/*b2ControllerEdge*/ var edge = this.m_bodyList;\r\n\twhile(edge && edge.body !== body)\r\n\t\tedge = edge.nextBody;\r\n\r\n\t//Assert that we are removing a body that is currently attached to the controller\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(edge !== null); }\r\n\r\n\t//Remove edge from controller list\r\n\tif (edge.prevBody)\r\n\t\tedge.prevBody.nextBody = edge.nextBody;\r\n\tif (edge.nextBody)\r\n\t\tedge.nextBody.prevBody = edge.prevBody;\r\n\tif (this.m_bodyList === edge)\r\n\t\tthis.m_bodyList = edge.nextBody;\r\n\t--this.m_bodyCount;\r\n\r\n\t//Remove edge from body list\r\n\tif (edge.nextController)\r\n\t\tedge.nextController.prevController = edge.prevController;\r\n\tif (edge.prevController)\r\n\t\tedge.prevController.nextController = edge.nextController;\r\n\tif (body.m_controllerList === edge)\r\n\t\tbody.m_controllerList = edge.nextController;\r\n\t--body.m_controllerCount;\r\n}\r\n\r\n/** \r\n * Removes all bodies from the controller list. \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2Controller.prototype.Clear = function ()\r\n{\r\n\twhile (this.m_bodyList)\r\n\t{\r\n\t\tthis.RemoveBody(this.m_bodyList.body);\r\n\t}\r\n\r\n\tthis.m_bodyCount = 0;\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2ConstantAccelController');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Controller');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Applies a force every frame \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Controller} \r\n */\r\nbox2d.b2ConstantAccelController = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n\r\n\tthis.A = new box2d.b2Vec2(0, 0);\r\n};\r\n\r\ngoog.inherits(box2d.b2ConstantAccelController, box2d.b2Controller);\r\n\r\n/** \r\n * The acceleration to apply \r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2ConstantAccelController.prototype.A = null;\r\n\r\n/** \r\n * @see box2d.b2Controller::Step \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TimeStep} step \r\n */\r\nbox2d.b2ConstantAccelController.prototype.Step = function (step)\r\n{\r\n\tvar dtA = box2d.b2MulSV(step.dt, this.A, box2d.b2ConstantAccelController.prototype.Step.s_dtA);\r\n\tfor (var i = this.m_bodyList; i; i = i.nextBody)\r\n\t{\r\n\t\tvar body = i.body;\r\n\t\tif (!body.IsAwake())\r\n\t\t\tcontinue;\r\n\t\tbody.SetLinearVelocity(box2d.b2AddVV(body.GetLinearVelocity(), dtA, box2d.b2Vec2.s_t0));\r\n\t}\r\n}\r\nbox2d.b2ConstantAccelController.prototype.Step.s_dtA = new box2d.b2Vec2();\r\n\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Joint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2JointType = \r\n{\r\n\te_unknownJoint\t\t: 0,\r\n\te_revoluteJoint\t\t: 1,\r\n\te_prismaticJoint\t: 2,\r\n\te_distanceJoint\t\t: 3,\r\n\te_pulleyJoint\t\t: 4,\r\n\te_mouseJoint\t\t: 5,\r\n\te_gearJoint\t\t\t: 6,\r\n\te_wheelJoint\t\t: 7,\r\n\te_weldJoint\t\t\t: 8,\r\n\te_frictionJoint\t\t: 9,\r\n\te_ropeJoint\t\t\t: 10,\r\n\te_motorJoint\t\t: 11,\r\n\te_areaJoint\t\t\t: 12\r\n};\r\ngoog.exportProperty(box2d.b2JointType, 'e_unknownJoint'  , box2d.b2JointType.e_unknownJoint  );\r\ngoog.exportProperty(box2d.b2JointType, 'e_revoluteJoint' , box2d.b2JointType.e_revoluteJoint );\r\ngoog.exportProperty(box2d.b2JointType, 'e_prismaticJoint', box2d.b2JointType.e_prismaticJoint);\r\ngoog.exportProperty(box2d.b2JointType, 'e_distanceJoint' , box2d.b2JointType.e_distanceJoint );\r\ngoog.exportProperty(box2d.b2JointType, 'e_pulleyJoint'   , box2d.b2JointType.e_pulleyJoint   );\r\ngoog.exportProperty(box2d.b2JointType, 'e_mouseJoint'    , box2d.b2JointType.e_mouseJoint    );\r\ngoog.exportProperty(box2d.b2JointType, 'e_gearJoint'     , box2d.b2JointType.e_gearJoint     );\r\ngoog.exportProperty(box2d.b2JointType, 'e_wheelJoint'    , box2d.b2JointType.e_wheelJoint    );\r\ngoog.exportProperty(box2d.b2JointType, 'e_weldJoint'     , box2d.b2JointType.e_weldJoint     );\r\ngoog.exportProperty(box2d.b2JointType, 'e_frictionJoint' , box2d.b2JointType.e_frictionJoint );\r\ngoog.exportProperty(box2d.b2JointType, 'e_ropeJoint'     , box2d.b2JointType.e_ropeJoint     );\r\ngoog.exportProperty(box2d.b2JointType, 'e_motorJoint'    , box2d.b2JointType.e_motorJoint    );\r\ngoog.exportProperty(box2d.b2JointType, 'e_areaJoint'     , box2d.b2JointType.e_areaJoint     );\r\n\r\n/** \r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2LimitState = \r\n{\r\n\te_inactiveLimit\t: 0,\r\n\te_atLowerLimit\t: 1,\r\n\te_atUpperLimit\t: 2,\r\n\te_equalLimits\t: 3\r\n};\r\ngoog.exportProperty(box2d.b2LimitState, 'e_inactiveLimit', box2d.b2LimitState.e_inactiveLimit);\r\ngoog.exportProperty(box2d.b2LimitState, 'e_atLowerLimit' , box2d.b2LimitState.e_atLowerLimit );\r\ngoog.exportProperty(box2d.b2LimitState, 'e_atUpperLimit' , box2d.b2LimitState.e_atUpperLimit );\r\ngoog.exportProperty(box2d.b2LimitState, 'e_equalLimits'  , box2d.b2LimitState.e_equalLimits  );\r\n\r\n/** \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Jacobian = function ()\r\n{\r\n\tthis.linear = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2Jacobian.prototype.linear = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Jacobian.prototype.angularA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Jacobian.prototype.angularB = 0;\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Jacobian}\r\n */\r\nbox2d.b2Jacobian.prototype.SetZero = function ()\r\n{\r\n\tthis.linear.SetZero();\r\n\tthis.angularA = 0;\r\n\tthis.angularB = 0;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Jacobian}\r\n * @param {box2d.b2Vec2} x\r\n * @param {number} a1\r\n * @param {number} a2\r\n */\r\nbox2d.b2Jacobian.prototype.Set = function (x, a1, a2)\r\n{\r\n\tthis.linear.Copy(x);\r\n\tthis.angularA = a1;\r\n\tthis.angularB = a2;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * A joint edge is used to connect bodies and joints together in \r\n * a joint graph where each body is a node and each joint is an \r\n * edge. A joint edge belongs to a doubly linked list maintained \r\n * in each attached body. Each joint has two joint nodes, one \r\n * for each attached body. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2JointEdge = function ()\r\n{\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2JointEdge.prototype.other = null; ///< provides quick access to the other body attached.\r\n/**\r\n * @export \r\n * @type {box2d.b2Joint}\r\n */\r\nbox2d.b2JointEdge.prototype.joint = null; ///< the joint\r\n/**\r\n * @export \r\n * @type {box2d.b2JointEdge}\r\n */\r\nbox2d.b2JointEdge.prototype.prev = null; ///< the previous joint edge in the body's joint list\r\n/**\r\n * @export \r\n * @type {box2d.b2JointEdge}\r\n */\r\nbox2d.b2JointEdge.prototype.next = null; ///< the next joint edge in the body's joint list\r\n\r\n/** \r\n * Joint definitions are used to construct joints. \r\n * @export \r\n * @constructor \r\n * @param {box2d.b2JointType} type \r\n */\r\nbox2d.b2JointDef = function (type)\r\n{\r\n\tthis.type = type;\r\n}\r\n\r\n/** \r\n * The joint type is set automatically for concrete joint types.\r\n * @export \r\n * @type {box2d.b2JointType}\r\n */\r\nbox2d.b2JointDef.prototype.type = box2d.b2JointType.e_unknownJoint;\r\n\r\n/** \r\n * Use this to attach application specific data to your joints. \r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2JointDef.prototype.userData = null;\r\n\r\n/** \r\n * The first attached body. \r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2JointDef.prototype.bodyA = null;\r\n\r\n/** \r\n * The second attached body. \r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2JointDef.prototype.bodyB = null;\r\n\r\n/** \r\n * Set this flag to true if the attached bodies should collide. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2JointDef.prototype.collideConnected = false;\r\n\r\n/** \r\n * The base joint class. Joints are used to constraint two \r\n * bodies together in various fashions. Some joints also feature \r\n * limits and motors. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Joint = function (def)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.bodyA !== def.bodyB); }\r\n\r\n\tthis.m_type = def.type;\r\n\tthis.m_edgeA = new box2d.b2JointEdge();\r\n\tthis.m_edgeB = new box2d.b2JointEdge();\r\n\tthis.m_bodyA = def.bodyA;\r\n\tthis.m_bodyB = def.bodyB;\r\n\r\n\tthis.m_collideConnected = def.collideConnected;\r\n\r\n\tthis.m_userData = def.userData;\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2JointType}\r\n */\r\nbox2d.b2Joint.prototype.m_type = box2d.b2JointType.e_unknownJoint;\r\n/**\r\n * @export \r\n * @type {box2d.b2Joint}\r\n */\r\nbox2d.b2Joint.prototype.m_prev = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Joint}\r\n */\r\nbox2d.b2Joint.prototype.m_next = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2JointEdge}\r\n */\r\nbox2d.b2Joint.prototype.m_edgeA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2JointEdge}\r\n */\r\nbox2d.b2Joint.prototype.m_edgeB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2Joint.prototype.m_bodyA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2Joint.prototype.m_bodyB = null;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Joint.prototype.m_index = 0;\r\n\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2Joint.prototype.m_islandFlag = false;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2Joint.prototype.m_collideConnected = false;\r\n\r\n/**\r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2Joint.prototype.m_userData = null;\r\n\r\n/** \r\n * Get the anchor point on bodyA in world coordinates. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2Joint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn out.SetZero();\r\n}\r\n\r\n/** \r\n * Get the anchor point on bodyB in world coordinates. \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2Joint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn out.SetZero();\r\n}\r\n\r\n/** \r\n * Get the reaction force on bodyB at the joint anchor in \r\n * Newtons. \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2Joint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n\treturn out.SetZero();\r\n}\r\n\r\n/** \r\n * Get the reaction torque on bodyB in N*m. \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2Joint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2Joint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2Joint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n}\r\n\r\n/** \r\n * This returns true if the position errors are within \r\n * tolerance. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2Joint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\treturn false;\r\n}\r\n\r\n/** \r\n * Get the type of the concrete joint. \r\n * @export \r\n * @return {box2d.b2JointType} \r\n */\r\nbox2d.b2Joint.prototype.GetType = function ()\r\n{\r\n\treturn this.m_type;\r\n}\r\n\r\n/** \r\n * Get the first body attached to this joint. \r\n * @export \r\n * @return {box2d.b2Body}\r\n */\r\nbox2d.b2Joint.prototype.GetBodyA = function ()\r\n{\r\n\treturn this.m_bodyA;\r\n}\r\n\r\n/** \r\n * Get the second body attached to this joint. \r\n * @export \r\n * @return {box2d.b2Body}\r\n */\r\nbox2d.b2Joint.prototype.GetBodyB = function ()\r\n{\r\n\treturn this.m_bodyB;\r\n}\r\n\r\n/** \r\n * Get the next joint the world joint list. \r\n * @export \r\n * @return {box2d.b2Joint} \r\n */\r\nbox2d.b2Joint.prototype.GetNext = function ()\r\n{\r\n\treturn this.m_next;\r\n}\r\n\r\n/** \r\n * Get the user data pointer. \r\n * @export \r\n * @return {*} \r\n */\r\nbox2d.b2Joint.prototype.GetUserData = function ()\r\n{\r\n\treturn this.m_userData;\r\n}\r\n\r\n/** \r\n * Set the user data pointer. \r\n * @export \r\n * @return {void} \r\n * @param {*} data \r\n */\r\nbox2d.b2Joint.prototype.SetUserData = function (data)\r\n{\r\n\tthis.m_userData = data;\r\n}\r\n\r\n/** \r\n * Get collide connected. \r\n * Note: modifying the collide connect flag won't work correctly \r\n * because the flag is only checked when fixture AABBs begin to \r\n * overlap. \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2Joint.prototype.GetCollideConnected = function ()\r\n{\r\n\treturn this.m_collideConnected;\r\n}\r\n\r\n/** \r\n * Dump this joint to the log file. \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2Joint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tbox2d.b2Log(\"// Dump is not supported for this joint type.\\n\");\r\n\t}\r\n}\r\n\r\n/** \r\n * Short-cut function to determine if either body is inactive. \r\n * @export \r\n * @return {boolean} \r\n */\r\nbox2d.b2Joint.prototype.IsActive = function ()\r\n{\r\n\treturn this.m_bodyA.IsActive() && this.m_bodyB.IsActive();\r\n}\r\n\r\n/** \r\n * Shift the origin for any points stored in world coordinates. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} newOrigin\r\n */\r\nbox2d.b2Joint.prototype.ShiftOrigin = function (newOrigin)\r\n{\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2RevoluteJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Revolute joint definition. This requires defining an anchor \r\n * point where the bodies are joined. The definition uses local \r\n * anchor points so that the initial configuration can violate \r\n * the constraint slightly. You also need to specify the initial \r\n * relative angle for joint limits. This helps when saving and \r\n * loading a game. \r\n * The local anchor points are measured from the body's origin \r\n * rather than the center of mass because: \r\n * 1. you might not know where the center of mass will be. \r\n * 2. if you add/remove shapes from a body and recompute the \r\n * mass, the joints will be broken. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2RevoluteJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_revoluteJoint); // base class constructor\r\n\r\n\tthis.localAnchorA = new box2d.b2Vec2(0, 0);\r\n\tthis.localAnchorB = new box2d.b2Vec2(0, 0);\r\n}\r\n\r\ngoog.inherits(box2d.b2RevoluteJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJointDef.prototype.localAnchorA = null;\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJointDef.prototype.localAnchorB = null;\r\n\r\n/** \r\n * The bodyB angle minus bodyA angle in the reference state \r\n * (radians). \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJointDef.prototype.referenceAngle = 0;\r\n\r\n/** \r\n * A flag to enable joint limits. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2RevoluteJointDef.prototype.enableLimit = false;\r\n\r\n/** \r\n * The lower angle for the joint limit (radians). \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJointDef.prototype.lowerAngle = 0;\r\n\r\n/** \r\n * The upper angle for the joint limit (radians). \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJointDef.prototype.upperAngle = 0;\r\n\r\n/** \r\n * A flag to enable the joint motor. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2RevoluteJointDef.prototype.enableMotor = false;\r\n\r\n/** \r\n * The desired motor speed. Usually in radians per second. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJointDef.prototype.motorSpeed = 0;\r\n\r\n/** \r\n * The maximum motor torque used to achieve the desired motor \r\n * speed. \r\n * Usually in N-m. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJointDef.prototype.maxMotorTorque = 0;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} bA \r\n * @param {box2d.b2Body} bB \r\n * @param {box2d.b2Vec2} anchor \r\n */\r\nbox2d.b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor)\r\n{\r\n\tthis.bodyA = bA;\r\n\tthis.bodyB = bB;\r\n\tthis.bodyA.GetLocalPoint(anchor, this.localAnchorA);\r\n\tthis.bodyB.GetLocalPoint(anchor, this.localAnchorB);\r\n\tthis.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians();\r\n}\r\n\r\n/** \r\n * A revolute joint constrains two bodies to share a common \r\n * point while they are free to rotate about the point. The \r\n * relative rotation about the shared point is the joint angle. \r\n * You can limit the relative rotation with a joint limit that \r\n * specifies a lower and upper angle. You can use a motor to \r\n * drive the relative rotation about the shared point. A maximum \r\n * motor torque is provided so that infinite forces are not \r\n * generated. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2RevoluteJointDef} def \r\n */\r\nbox2d.b2RevoluteJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_localAnchorA = new box2d.b2Vec2();\r\n\tthis.m_localAnchorB = new box2d.b2Vec2();\r\n\tthis.m_impulse = new box2d.b2Vec3();\r\n\r\n\tthis.m_rA = new box2d.b2Vec2();\r\n\tthis.m_rB = new box2d.b2Vec2();\r\n\tthis.m_localCenterA = new box2d.b2Vec2();\r\n\tthis.m_localCenterB = new box2d.b2Vec2();\r\n\tthis.m_mass = new box2d.b2Mat33();\r\n\r\n\tthis.m_qA = new box2d.b2Rot();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_lalcA = new box2d.b2Vec2();\r\n\tthis.m_lalcB = new box2d.b2Vec2();\r\n\tthis.m_K = new box2d.b2Mat22();\r\n\r\n\tthis.m_localAnchorA.Copy(def.localAnchorA);\r\n\tthis.m_localAnchorB.Copy(def.localAnchorB);\r\n\tthis.m_referenceAngle = def.referenceAngle;\r\n\r\n\tthis.m_impulse.SetZero();\r\n\tthis.m_motorImpulse = 0;\r\n\r\n\tthis.m_lowerAngle = def.lowerAngle;\r\n\tthis.m_upperAngle = def.upperAngle;\r\n\tthis.m_maxMotorTorque = def.maxMotorTorque;\r\n\tthis.m_motorSpeed = def.motorSpeed;\r\n\tthis.m_enableLimit = def.enableLimit;\r\n\tthis.m_enableMotor = def.enableMotor;\r\n\tthis.m_limitState = box2d.b2LimitState.e_inactiveLimit;\r\n}\r\n\r\ngoog.inherits(box2d.b2RevoluteJoint, box2d.b2Joint);\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_localAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_localAnchorB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec3}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_impulse = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_motorImpulse = 0;\r\n\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_enableMotor = false;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_maxMotorTorque = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_motorSpeed = 0;\r\n\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_enableLimit = false;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_referenceAngle = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_lowerAngle = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_upperAngle = 0;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_rB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_invIB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat33}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_mass = null; // effective mass for point-to-point constraint.\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_motorMass = 0; // effective mass for motor/limit angular constraint.\r\n/**\r\n * @export \r\n * @type {box2d.b2LimitState}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_lalcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_lalcB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.m_K = null;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2RevoluteJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassA = this.m_bodyA.m_invMass;\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIA = this.m_bodyA.m_invI;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n//\tb2Rot qA(aA), qB(aB);\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n//\tm_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tbox2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tm_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tbox2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n\t// J = [-I -r1_skew I r2_skew]\r\n\t//     [ 0       -1 0       1]\r\n\t// r_skew = [-ry; rx]\r\n\r\n\t// Matlab\r\n\t// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]\r\n\t//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]\r\n\t//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t/*bool*/ var fixedRotation = (iA + iB === 0);\r\n\r\n\tthis.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\r\n\tthis.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\r\n\tthis.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\r\n\tthis.m_mass.ex.y = this.m_mass.ey.x;\r\n\tthis.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\r\n\tthis.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\r\n\tthis.m_mass.ex.z = this.m_mass.ez.x;\r\n\tthis.m_mass.ey.z = this.m_mass.ez.y;\r\n\tthis.m_mass.ez.z = iA + iB;\r\n\r\n\tthis.m_motorMass = iA + iB;\r\n\tif (this.m_motorMass > 0)\r\n\t{\r\n\t\tthis.m_motorMass = 1 / this.m_motorMass;\r\n\t}\r\n\r\n\tif (this.m_enableMotor === false || fixedRotation)\r\n\t{\r\n\t\tthis.m_motorImpulse = 0;\r\n\t}\r\n\r\n\tif (this.m_enableLimit && fixedRotation === false)\r\n\t{\r\n\t\t/*float32*/ var jointAngle = aB - aA - this.m_referenceAngle;\r\n\t\tif (box2d.b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * box2d.b2_angularSlop)\r\n\t\t{\r\n\t\t\tthis.m_limitState = box2d.b2LimitState.e_equalLimits;\r\n\t\t}\r\n\t\telse if (jointAngle <= this.m_lowerAngle)\r\n\t\t{\r\n\t\t\tif (this.m_limitState !== box2d.b2LimitState.e_atLowerLimit)\r\n\t\t\t{\r\n\t\t\t\tthis.m_impulse.z = 0;\r\n\t\t\t}\r\n\t\t\tthis.m_limitState = box2d.b2LimitState.e_atLowerLimit;\r\n\t\t}\r\n\t\telse if (jointAngle >= this.m_upperAngle)\r\n\t\t{\r\n\t\t\tif (this.m_limitState !== box2d.b2LimitState.e_atUpperLimit)\r\n\t\t\t{\r\n\t\t\t\tthis.m_impulse.z = 0;\r\n\t\t\t}\r\n\t\t\tthis.m_limitState = box2d.b2LimitState.e_atUpperLimit;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_limitState = box2d.b2LimitState.e_inactiveLimit;\r\n\t\t\tthis.m_impulse.z = 0;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_limitState = box2d.b2LimitState.e_inactiveLimit;\r\n\t}\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\t// Scale impulses to support a variable time step.\r\n\t\tthis.m_impulse.SelfMul(data.step.dtRatio);\r\n\t\tthis.m_motorImpulse *= data.step.dtRatio;\r\n\r\n//\t\tb2Vec2 P(m_impulse.x, m_impulse.y);\r\n\t\tvar P = box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * (box2d.b2CrossVV(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * (box2d.b2CrossVV(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse.SetZero();\r\n\t\tthis.m_motorImpulse = 0;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2RevoluteJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t/*bool*/ var fixedRotation = (iA + iB === 0);\r\n\r\n\t// Solve motor constraint.\r\n\tif (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits && fixedRotation === false)\r\n\t{\r\n\t\t/*float32*/ var Cdot = wB - wA - this.m_motorSpeed;\r\n\t\t/*float32*/ var impulse = -this.m_motorMass * Cdot;\r\n\t\t/*float32*/ var oldImpulse = this.m_motorImpulse;\r\n\t\t/*float32*/ var maxImpulse = data.step.dt * this.m_maxMotorTorque;\r\n\t\tthis.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\r\n\t\timpulse = this.m_motorImpulse - oldImpulse;\r\n\r\n\t\twA -= iA * impulse;\r\n\t\twB += iB * impulse;\r\n\t}\r\n\r\n\t// Solve limit constraint.\r\n\tif (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && fixedRotation === false)\r\n\t{\r\n//\t\tb2Vec2 Cdot1 = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);\r\n\t\tvar Cdot1 = box2d.b2SubVV(\r\n\t\t\tbox2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1),\r\n\t\t\tbox2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1)\r\n\t\t/*float32*/ var Cdot2 = wB - wA;\r\n//\t\tb2Vec3 Cdot(Cdot1.x, Cdot1.y, Cdot2);\r\n\r\n//\t\tb2Vec3 impulse = -this.m_mass.Solve33(Cdot);\r\n\t\tvar impulse = this.m_mass.Solve33(Cdot1.x, Cdot1.y, Cdot2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3).SelfNeg();\r\n\r\n\t\tif (this.m_limitState === box2d.b2LimitState.e_equalLimits)\r\n\t\t{\r\n\t\t\tthis.m_impulse.SelfAdd(impulse);\r\n\t\t}\r\n\t\telse if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit)\r\n\t\t{\r\n\t\t\t/*float32*/ var newImpulse = this.m_impulse.z + impulse.z;\r\n\t\t\tif (newImpulse < 0)\r\n\t\t\t{\r\n//\t\t\t\tb2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);\r\n\t\t\t\tvar rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;\r\n\t\t\t\tvar rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;\r\n\t\t\t\t/*box2d.b2Vec2*/ var reduced = this.m_mass.Solve22(rhs_x, rhs_y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);\r\n\t\t\t\timpulse.x = reduced.x;\r\n\t\t\t\timpulse.y = reduced.y;\r\n\t\t\t\timpulse.z = -this.m_impulse.z;\r\n\t\t\t\tthis.m_impulse.x += reduced.x;\r\n\t\t\t\tthis.m_impulse.y += reduced.y;\r\n\t\t\t\tthis.m_impulse.z = 0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_impulse.SelfAdd(impulse);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit)\r\n\t\t{\r\n\t\t\t/*float32*/ var newImpulse = this.m_impulse.z + impulse.z;\r\n\t\t\tif (newImpulse > 0)\r\n\t\t\t{\r\n//\t\t\t\tb2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);\r\n\t\t\t\tvar rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;\r\n\t\t\t\tvar rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;\r\n\t\t\t\t/*box2d.b2Vec2*/ var reduced = this.m_mass.Solve22(rhs_x, rhs_y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);\r\n\t\t\t\timpulse.x = reduced.x;\r\n\t\t\t\timpulse.y = reduced.y;\r\n\t\t\t\timpulse.z = -this.m_impulse.z;\r\n\t\t\t\tthis.m_impulse.x += reduced.x;\r\n\t\t\t\tthis.m_impulse.y += reduced.y;\r\n\t\t\t\tthis.m_impulse.z = 0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_impulse.SelfAdd(impulse);\r\n\t\t\t}\r\n\t\t}\r\n\r\n//\t\tb2Vec2 P(impulse.x, impulse.y);\r\n\t\tvar P = box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P.SetXY(impulse.x, impulse.y);\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * (box2d.b2CrossVV(this.m_rA, P) + impulse.z);\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * (box2d.b2CrossVV(this.m_rB, P) + impulse.z);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Solve point-to-point constraint\r\n//\t\tb2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);\r\n\t\tvar Cdot = box2d.b2SubVV(\r\n\t\t\tbox2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1),\r\n\t\t\tbox2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot)\r\n//\t\tb2Vec2 impulse = m_mass.Solve22(-Cdot);\r\n\t\t/*box2d.b2Vec2*/ var impulse = this.m_mass.Solve22(-Cdot.x, -Cdot.y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2);\r\n\r\n\t\tthis.m_impulse.x += impulse.x;\r\n\t\tthis.m_impulse.y += impulse.y;\r\n\r\n//\t\tvA -= mA * impulse;\r\n\t\tvA.SelfMulSub(mA, impulse);\r\n\t\twA -= iA * box2d.b2CrossVV(this.m_rA, impulse);\r\n\r\n//\t\tvB += mB * impulse;\r\n\t\tvB.SelfMulAdd(mB, impulse);\r\n\t\twB += iB * box2d.b2CrossVV(this.m_rB, impulse);\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();\r\nbox2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2();\r\nbox2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2();\r\nbox2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3 = new box2d.b2Vec3();\r\nbox2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced = new box2d.b2Vec2();\r\nbox2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2 = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2RevoluteJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\r\n//\tb2Rot qA(aA), qB(aB);\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n\t/*float32*/ var angularError = 0;\r\n\t/*float32*/ var positionError = 0;\r\n\r\n\t/*bool*/ var fixedRotation = (this.m_invIA + this.m_invIB === 0);\r\n\r\n\t// Solve angular limit constraint.\r\n\tif (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && fixedRotation === false)\r\n\t{\r\n\t\t/*float32*/ var angle = aB - aA - this.m_referenceAngle;\r\n\t\t/*float32*/ var limitImpulse = 0;\r\n\r\n\t\tif (this.m_limitState === box2d.b2LimitState.e_equalLimits)\r\n\t\t{\r\n\t\t\t// Prevent large angular corrections\r\n\t\t\t/*float32*/ var C = box2d.b2Clamp(angle - this.m_lowerAngle, -box2d.b2_maxAngularCorrection, box2d.b2_maxAngularCorrection);\r\n\t\t\tlimitImpulse = -this.m_motorMass * C;\r\n\t\t\tangularError = box2d.b2Abs(C);\r\n\t\t}\r\n\t\telse if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit)\r\n\t\t{\r\n\t\t\t/*float32*/ var C = angle - this.m_lowerAngle;\r\n\t\t\tangularError = -C;\r\n\r\n\t\t\t// Prevent large angular corrections and allow some slop.\r\n\t\t\tC = box2d.b2Clamp(C + box2d.b2_angularSlop, -box2d.b2_maxAngularCorrection, 0);\r\n\t\t\tlimitImpulse = -this.m_motorMass * C;\r\n\t\t}\r\n\t\telse if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit)\r\n\t\t{\r\n\t\t\t/*float32*/ var C = angle - this.m_upperAngle;\r\n\t\t\tangularError = C;\r\n\r\n\t\t\t// Prevent large angular corrections and allow some slop.\r\n\t\t\tC = box2d.b2Clamp(C - box2d.b2_angularSlop, 0, box2d.b2_maxAngularCorrection);\r\n\t\t\tlimitImpulse = -this.m_motorMass * C;\r\n\t\t}\r\n\r\n\t\taA -= this.m_invIA * limitImpulse;\r\n\t\taB += this.m_invIB * limitImpulse;\r\n\t}\r\n\r\n\t// Solve point-to-point constraint.\r\n\t{\r\n\t\tqA.SetAngleRadians(aA);\r\n\t\tqB.SetAngleRadians(aB);\r\n//\t\tb2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\t\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\t\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\t\tb2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\t\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\t\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n//\t\tb2Vec2 C = cB + rB - cA - rA;\r\n\t\tvar C = \r\n\t\t\tbox2d.b2SubVV(\r\n\t\t\t\tbox2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), \r\n\t\t\t\tbox2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C);\r\n//\t\tpositionError = C.Length();\r\n\t\tpositionError = C.GetLength();\r\n\r\n\t\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t\tvar K = this.m_K;\r\n\t\tK.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\r\n\t\tK.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\r\n\t\tK.ey.x = K.ex.y;\r\n\t\tK.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\r\n\r\n//\t\tb2Vec2 impulse = -K.Solve(C);\r\n\t\t/*box2d.b2Vec2*/ var impulse = K.Solve(C.x, C.y, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();\r\n\r\n//\t\tcA -= mA * impulse;\r\n\t\tcA.SelfMulSub(mA, impulse);\r\n\t\taA -= iA * box2d.b2CrossVV(rA, impulse);\r\n\r\n//\t\tcB += mB * impulse;\r\n\t\tcB.SelfMulAdd(mB, impulse);\r\n\t\taB += iB * box2d.b2CrossVV(rB, impulse);\r\n\t}\r\n\r\n//\tdata.positions[this.m_indexA].c = cA;\r\n\tdata.positions[this.m_indexA].a = aA;\r\n//\tdata.positions[this.m_indexB].c = cB;\r\n\tdata.positions[this.m_indexB].a = aB;\r\n\t\r\n\treturn positionError <= box2d.b2_linearSlop && angularError <= box2d.b2_angularSlop;\r\n}\r\nbox2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C = new box2d.b2Vec2();\r\nbox2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * Get the reaction force given the inverse time step. \r\n * Unit is N.\r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n//\tb2Vec2 P(this.m_impulse.x, this.m_impulse.y);\r\n//\treturn inv_dt * P;\r\n\treturn out.SetXY(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);\r\n}\r\n\r\n/** \r\n * Get the reaction torque due to the joint limit given the \r\n * inverse time step. \r\n * Unit is N*m. \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn inv_dt * this.m_impulse.z;\r\n}\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2=} out \r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }\r\n\r\n/** \r\n * Get the reference angle. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetReferenceAngle = function () { return this.m_referenceAngle; }\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetJointAngleRadians = function ()\r\n{\r\n//\tb2Body* bA = this.m_bodyA;\r\n//\tb2Body* bB = this.m_bodyB;\r\n//\treturn bB->this.m_sweep.a - bA->this.m_sweep.a - this.m_referenceAngle;\r\n\treturn this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetJointSpeed = function ()\r\n{\r\n//\tb2Body* bA = this.m_bodyA;\r\n//\tb2Body* bB = this.m_bodyB;\r\n//\treturn bB->this.m_angularVelocity - bA->this.m_angularVelocity;\r\n\treturn this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.IsMotorEnabled = function ()\r\n{\r\n\treturn this.m_enableMotor;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag\r\n */\r\nbox2d.b2RevoluteJoint.prototype.EnableMotor = function (flag)\r\n{\r\n\tif (this.m_enableMotor !== flag)\r\n\t{\r\n\t\tthis.m_bodyA.SetAwake(true);\r\n\t\tthis.m_bodyB.SetAwake(true);\r\n\t\tthis.m_enableMotor = flag;\r\n\t}\r\n}\r\n\r\n/** \r\n * Get the current motor torque given the inverse time step. \r\n * Unit is N*m. \r\n * @export \r\n * @return {number}\r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetMotorTorque = function (inv_dt)\r\n{\r\n\treturn inv_dt * this.m_motorImpulse;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetMotorSpeed = function ()\r\n{\r\n\treturn this.m_motorSpeed;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {number} torque\r\n */\r\nbox2d.b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque)\r\n{\r\n\tthis.m_maxMotorTorque = torque;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetMaxMotorTorque = function () { return this.m_maxMotorTorque; }\r\n\r\n/** \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.IsLimitEnabled = function ()\r\n{\r\n\treturn this.m_enableLimit;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag\r\n */\r\nbox2d.b2RevoluteJoint.prototype.EnableLimit = function (flag)\r\n{\r\n\tif (flag !== this.m_enableLimit)\r\n\t{\r\n\t\tthis.m_bodyA.SetAwake(true);\r\n\t\tthis.m_bodyB.SetAwake(true);\r\n\t\tthis.m_enableLimit = flag;\r\n\t\tthis.m_impulse.z = 0;\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetLowerLimit = function ()\r\n{\r\n\treturn this.m_lowerAngle;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.GetUpperLimit = function ()\r\n{\r\n\treturn this.m_upperAngle;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {number} lower \r\n * @param {number} upper \r\n */\r\nbox2d.b2RevoluteJoint.prototype.SetLimits = function (lower, upper)\r\n{\r\n\t\r\n\tif (lower !== this.m_lowerAngle || upper !== this.m_upperAngle)\r\n\t{\r\n\t\tthis.m_bodyA.SetAwake(true);\r\n\t\tthis.m_bodyB.SetAwake(true);\r\n\t\tthis.m_impulse.z = 0;\r\n\t\tthis.m_lowerAngle = lower;\r\n\t\tthis.m_upperAngle = upper;\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {number} speed\r\n */\r\nbox2d.b2RevoluteJoint.prototype.SetMotorSpeed = function (speed)\r\n{\r\n\tif (this.m_motorSpeed !== speed)\r\n\t{\r\n\t\tthis.m_bodyA.SetAwake(true);\r\n\t\tthis.m_bodyB.SetAwake(true);\r\n\t\tthis.m_motorSpeed = speed;\r\n\t}\r\n}\r\n\r\n/** \r\n * Dump to b2Log. \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2RevoluteJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\t\r\n\t\tbox2d.b2Log(\"  /*box2d.b2RevoluteJointDef*/ var jd = new box2d.b2RevoluteJointDef();\\n\");\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.localAnchorA.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n\t\tbox2d.b2Log(\"  jd.localAnchorB.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n\t\tbox2d.b2Log(\"  jd.referenceAngle = %.15f;\\n\", this.m_referenceAngle);\r\n\t\tbox2d.b2Log(\"  jd.enableLimit = %s;\\n\", (this.m_enableLimit)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.lowerAngle = %.15f;\\n\", this.m_lowerAngle);\r\n\t\tbox2d.b2Log(\"  jd.upperAngle = %.15f;\\n\", this.m_upperAngle);\r\n\t\tbox2d.b2Log(\"  jd.enableMotor = %s;\\n\", (this.m_enableMotor)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.motorSpeed = %.15f;\\n\", this.m_motorSpeed);\r\n\t\tbox2d.b2Log(\"  jd.maxMotorTorque = %.15f;\\n\", this.m_maxMotorTorque);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2PrismaticJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Prismatic joint definition. This requires defining a line of \r\n * motion using an axis and an anchor point. The definition uses \r\n * local anchor points and a local axis so that the initial \r\n * configuration can violate the constraint slightly. The joint \r\n * translation is zero when the local anchor points coincide in \r\n * world space. Using local anchors and a local axis helps when \r\n * saving and loading a game. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2PrismaticJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_prismaticJoint); // base class constructor\r\n\r\n\tthis.localAnchorA = new box2d.b2Vec2();\r\n\tthis.localAnchorB = new box2d.b2Vec2();\r\n\tthis.localAxisA = new box2d.b2Vec2(1, 0);\r\n}\r\n\r\ngoog.inherits(box2d.b2PrismaticJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.localAnchorA = null;\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.localAnchorB = null;\r\n\r\n/** \r\n * The local translation unit axis in bodyA. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.localAxisA = null;\r\n\r\n/** \r\n * The constrained angle between the bodies: bodyB_angle - \r\n * bodyA_angle. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.referenceAngle = 0;\r\n\r\n/** \r\n * Enable/disable the joint limit. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.enableLimit = false;\r\n\r\n/** \r\n * The lower translation limit, usually in meters. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.lowerTranslation = 0;\r\n\r\n/** \r\n * The upper translation limit, usually in meters. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.upperTranslation = 0;\r\n\r\n/** \r\n * Enable/disable the joint motor. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.enableMotor = false;\r\n\r\n/** \r\n * The maximum motor torque, usually in N-m. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.maxMotorForce = 0;\r\n\r\n/** \r\n * The desired motor speed in radians per second. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJointDef.prototype.motorSpeed = 0;\r\n\r\n/** \r\n * Initialize the bodies, anchors, axis, and reference angle \r\n * using the world anchor and unit world axis. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} bA \r\n * @param {box2d.b2Body} bB \r\n * @param {box2d.b2Vec2} anchor \r\n * @param {box2d.b2Vec2} axis \r\n */\r\nbox2d.b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis)\r\n{\r\n\tthis.bodyA = bA;\r\n\tthis.bodyB = bB;\r\n\tthis.bodyA.GetLocalPoint(anchor, this.localAnchorA);\r\n\tthis.bodyB.GetLocalPoint(anchor, this.localAnchorB);\r\n\tthis.bodyA.GetLocalVector(axis, this.localAxisA);\r\n\tthis.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians();\r\n}\r\n\r\n/** \r\n * A prismatic joint. This joint provides one degree of freedom: \r\n * translation along an axis fixed in bodyA. Relative rotation \r\n * is prevented. You can use a joint limit to restrict the range \r\n * of motion and a joint motor to drive the motion or to model \r\n * joint friction. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2PrismaticJointDef} def \r\n */\r\nbox2d.b2PrismaticJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_localAnchorA = def.localAnchorA.Clone();\r\n\tthis.m_localAnchorB = def.localAnchorB.Clone();\r\n\tthis.m_localXAxisA = def.localAxisA.Clone().SelfNormalize();\r\n\tthis.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2());\r\n\tthis.m_referenceAngle = def.referenceAngle;\r\n\tthis.m_impulse = new box2d.b2Vec3(0, 0, 0);\r\n\tthis.m_lowerTranslation = def.lowerTranslation;\r\n\tthis.m_upperTranslation = def.upperTranslation;\r\n\tthis.m_maxMotorForce = def.maxMotorForce;\r\n\tthis.m_motorSpeed = def.motorSpeed;\r\n\tthis.m_enableLimit = def.enableLimit;\r\n\tthis.m_enableMotor = def.enableMotor;\r\n\r\n\tthis.m_localCenterA = new box2d.b2Vec2();\r\n\tthis.m_localCenterB = new box2d.b2Vec2();\r\n\tthis.m_axis = new box2d.b2Vec2(0, 0);\r\n\tthis.m_perp = new box2d.b2Vec2(0, 0);\r\n\tthis.m_K = new box2d.b2Mat33();\r\n\tthis.m_K3 = new box2d.b2Mat33();\r\n\tthis.m_K2 = new box2d.b2Mat22();\r\n\r\n\tthis.m_qA = new box2d.b2Rot();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_lalcA = new box2d.b2Vec2();\r\n\tthis.m_lalcB = new box2d.b2Vec2();\r\n\tthis.m_rA = new box2d.b2Vec2();\r\n\tthis.m_rB = new box2d.b2Vec2();\r\n}\r\n\r\ngoog.inherits(box2d.b2PrismaticJoint, box2d.b2Joint);\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_localAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_localAnchorB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_localXAxisA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_localYAxisA = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_referenceAngle = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec3}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_impulse = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_motorImpulse = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_lowerTranslation = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_upperTranslation = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_maxMotorForce = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_motorSpeed = 0;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_enableLimit = false;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_enableMotor = false;\r\n/**\r\n * @export \r\n * @type {box2d.b2LimitState}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_invIB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_axis = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_perp = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_s1 = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_s2 = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_a1 = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_a2 = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat33}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_K = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat33}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_K3 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_K2 = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_motorMass = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_lalcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_lalcB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.m_rB = null;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2PrismaticJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassA = this.m_bodyA.m_invMass;\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIA = this.m_bodyA.m_invI;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n\t// Compute the effective masses.\r\n//\tb2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tb2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n//\tb2Vec2 d = (cB - cA) + rB - rA;\r\n\tvar d = box2d.b2AddVV(\r\n\t\tbox2d.b2SubVV(cB, cA, box2d.b2Vec2.s_t0),\r\n\t\tbox2d.b2SubVV(rB, rA, box2d.b2Vec2.s_t1),\r\n\t\tbox2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d);\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t// Compute motor Jacobian and effective mass.\r\n\t{\r\n//\t\tm_axis = b2Mul(qA, m_localXAxisA);\r\n\t\tbox2d.b2MulRV(qA, this.m_localXAxisA, this.m_axis);\r\n//\t\tm_a1 = b2Cross(d + rA, m_axis);\r\n\t\tthis.m_a1 = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), this.m_axis);\r\n//\t\tm_a2 = b2Cross(rB, m_axis);\r\n\t\tthis.m_a2 = box2d.b2CrossVV(rB, this.m_axis);\r\n\r\n\t\tthis.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\r\n\t\tif (this.m_motorMass > 0)\r\n\t\t{\r\n\t\t\tthis.m_motorMass = 1 / this.m_motorMass;\r\n\t\t}\r\n\t}\r\n\r\n\t// Prismatic constraint.\r\n\t{\r\n//\t\tm_perp = b2Mul(qA, m_localYAxisA);\r\n\t\tbox2d.b2MulRV(qA, this.m_localYAxisA, this.m_perp);\r\n\r\n//\t\tm_s1 = b2Cross(d + rA, m_perp);\r\n\t\tthis.m_s1 = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), this.m_perp);\r\n//\t\tm_s2 = b2Cross(rB, m_perp);\r\n\t\tthis.m_s2 = box2d.b2CrossVV(rB, this.m_perp);\r\n\r\n//\t\tfloat32 k11 = mA + mB + iA * m_s1 * m_s1 + iB * m_s2 * m_s2;\r\n\t\tthis.m_K.ex.x = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\r\n//\t\tfloat32 k12 = iA * m_s1 + iB * m_s2;\r\n\t\tthis.m_K.ex.y = iA * this.m_s1 + iB * this.m_s2;\r\n//\t\tfloat32 k13 = iA * m_s1 * m_a1 + iB * m_s2 * m_a2;\r\n\t\tthis.m_K.ex.z = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\r\n\t\tthis.m_K.ey.x = this.m_K.ex.y;\r\n//\t\tfloat32 k22 = iA + iB;\r\n\t\tthis.m_K.ey.y = iA + iB;\r\n\t\tif (this.m_K.ey.y === 0)\r\n\t\t{\r\n\t\t\t// For bodies with fixed rotation.\r\n\t\t\tthis.m_K.ey.y = 1;\r\n\t\t}\r\n//\t\tfloat32 k23 = iA * m_a1 + iB * m_a2;\r\n\t\tthis.m_K.ey.z = iA * this.m_a1 + iB * this.m_a2;\r\n\t\tthis.m_K.ez.x = this.m_K.ex.z;\r\n\t\tthis.m_K.ez.y = this.m_K.ey.z;\r\n//\t\tfloat32 k33 = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2;\r\n\t\tthis.m_K.ez.z = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\r\n\r\n//\t\tm_K.ex.Set(k11, k12, k13);\r\n//\t\tm_K.ey.Set(k12, k22, k23);\r\n//\t\tm_K.ez.Set(k13, k23, k33);\r\n\t}\r\n\r\n\t// Compute motor and limit terms.\r\n\tif (this.m_enableLimit)\r\n\t{\r\n//\t\tfloat32 jointTranslation = b2Dot(m_axis, d);\r\n\t\tvar jointTranslation = box2d.b2DotVV(this.m_axis, d);\r\n\t\tif (box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop)\r\n\t\t{\r\n\t\t\tthis.m_limitState = box2d.b2LimitState.e_equalLimits;\r\n\t\t}\r\n\t\telse if (jointTranslation <= this.m_lowerTranslation)\r\n\t\t{\r\n\t\t\tif (this.m_limitState !== box2d.b2LimitState.e_atLowerLimit)\r\n\t\t\t{\r\n\t\t\t\tthis.m_limitState = box2d.b2LimitState.e_atLowerLimit;\r\n\t\t\t\tthis.m_impulse.z = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (jointTranslation >= this.m_upperTranslation)\r\n\t\t{\r\n\t\t\tif (this.m_limitState !== box2d.b2LimitState.e_atUpperLimit)\r\n\t\t\t{\r\n\t\t\t\tthis.m_limitState = box2d.b2LimitState.e_atUpperLimit;\r\n\t\t\t\tthis.m_impulse.z = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_limitState = box2d.b2LimitState.e_inactiveLimit;\r\n\t\t\tthis.m_impulse.z = 0;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_limitState = box2d.b2LimitState.e_inactiveLimit;\r\n\t\tthis.m_impulse.z = 0;\r\n\t}\r\n\r\n\tif (this.m_enableMotor === false)\r\n\t{\r\n\t\tthis.m_motorImpulse = 0;\r\n\t}\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\t// Account for variable time step.\r\n//\t\tm_impulse *= data.step.dtRatio;\r\n\t\tthis.m_impulse.SelfMul(data.step.dtRatio);\r\n\t\tthis.m_motorImpulse *= data.step.dtRatio;\r\n\r\n//\t\tb2Vec2 P = m_impulse.x * m_perp + (m_motorImpulse + m_impulse.z) * m_axis;\r\n\t\tvar P = box2d.b2AddVV(\r\n\t\t\tbox2d.b2MulSV(this.m_impulse.x, this.m_perp, box2d.b2Vec2.s_t0), \r\n\t\t\tbox2d.b2MulSV((this.m_motorImpulse + this.m_impulse.z), this.m_axis, box2d.b2Vec2.s_t1), \r\n\t\t\tbox2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P);\r\n//\t\tfloat32 LA = m_impulse.x * m_s1 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a1;\r\n\t\tvar LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\r\n//\t\tfloat32 LB = m_impulse.x * m_s2 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a2;\r\n\t\tvar LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * LA;\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * LB;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse.SetZero();\r\n\t\tthis.m_motorImpulse = 0;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2();\r\nbox2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2PrismaticJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t// Solve linear motor constraint.\r\n\tif (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits)\r\n\t{\r\n//\t\tfloat32 Cdot = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;\r\n\t\tvar Cdot = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;\r\n\t\tvar impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\r\n\t\tvar oldImpulse = this.m_motorImpulse;\r\n\t\tvar maxImpulse = data.step.dt * this.m_maxMotorForce;\r\n\t\tthis.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);\r\n\t\timpulse = this.m_motorImpulse - oldImpulse;\r\n\r\n//\t\tb2Vec2 P = impulse * m_axis;\r\n\t\tvar P = box2d.b2MulSV(impulse, this.m_axis, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P);\r\n\t\tvar LA = impulse * this.m_a1;\r\n\t\tvar LB = impulse * this.m_a2;\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * LA;\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * LB;\r\n\t}\r\n\r\n//\tb2Vec2 Cdot1;\r\n//\tCdot1.x = b2Dot(m_perp, vB - vA) + m_s2 * wB - m_s1 * wA;\r\n\tvar Cdot1_x = box2d.b2DotVV(this.m_perp, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_s2 * wB - this.m_s1 * wA;\r\n//\tCdot1.y = wB - wA;\r\n\tvar Cdot1_y = wB - wA;\r\n\r\n\tif (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit)\r\n\t{\r\n\t\t// Solve prismatic and limit constraint in block form.\r\n//\t\tfloat32 Cdot2;\r\n//\t\tCdot2 = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;\r\n\t\tvar Cdot2 = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;\r\n//\t\tbox2d.b2Vec3 Cdot(Cdot1.x, Cdot1.y, Cdot2);\r\n\r\n//\t\tbox2d.b2Vec3 f1 = m_impulse;\r\n\t\tvar f1 = box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1.Copy(this.m_impulse);\r\n//\t\tbox2d.b2Vec3 df =  m_K.Solve33(-Cdot);\r\n\t\tvar df = this.m_K.Solve33((-Cdot1_x), (-Cdot1_y), (-Cdot2), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3);\r\n//\t\tm_impulse += df;\r\n\t\tthis.m_impulse.SelfAdd(df);\r\n\r\n\t\tif (this.m_limitState === box2d.b2LimitState.e_atLowerLimit)\r\n\t\t{\r\n\t\t\tthis.m_impulse.z = box2d.b2Max(this.m_impulse.z, 0);\r\n\t\t}\r\n\t\telse if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit)\r\n\t\t{\r\n\t\t\tthis.m_impulse.z = box2d.b2Min(this.m_impulse.z, 0);\r\n\t\t}\r\n\r\n\t\t// f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) + f1(1:2)\r\n//\t\tb2Vec2 b = -Cdot1 - (m_impulse.z - f1.z) * box2d.b2Vec2(m_K.ez.x, m_K.ez.y);\r\n\t\tvar b_x = (-Cdot1_x) - (this.m_impulse.z - f1.z) * this.m_K.ez.x;\r\n\t\tvar b_y = (-Cdot1_y) - (this.m_impulse.z - f1.z) * this.m_K.ez.y;\r\n//\t\tb2Vec2 f2r = m_K.Solve22(b) + box2d.b2Vec2(f1.x, f1.y);\r\n\t\tvar f2r = this.m_K.Solve22(b_x, b_y, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r);\r\n\t\tf2r.x += f1.x;\r\n\t\tf2r.y += f1.y;\r\n//\t\tm_impulse.x = f2r.x;\r\n\t\tthis.m_impulse.x = f2r.x;\r\n//\t\tm_impulse.y = f2r.y;\r\n\t\tthis.m_impulse.y = f2r.y;\r\n\r\n//\t\tdf = m_impulse - f1;\r\n\t\tdf.x = this.m_impulse.x - f1.x;\r\n\t\tdf.y = this.m_impulse.y - f1.y;\r\n\t\tdf.z = this.m_impulse.z - f1.z;\r\n\r\n//\t\tb2Vec2 P = df.x * m_perp + df.z * m_axis;\r\n\t\tvar P = box2d.b2AddVV(\r\n\t\t\tbox2d.b2MulSV(df.x, this.m_perp, box2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2MulSV(df.z, this.m_axis, box2d.b2Vec2.s_t1),\r\n\t\t\tbox2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P);\r\n//\t\tfloat32 LA = df.x * m_s1 + df.y + df.z * m_a1;\r\n\t\tvar LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;\r\n//\t\tfloat32 LB = df.x * m_s2 + df.y + df.z * m_a2;\r\n\t\tvar LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * LA;\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * LB;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Limit is inactive, just solve the prismatic constraint in block form.\r\n//\t\tb2Vec2 df = m_K.Solve22(-Cdot1);\r\n\t\tvar df = this.m_K.Solve22((-Cdot1_x), (-Cdot1_y), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2);\r\n\t\tthis.m_impulse.x += df.x;\r\n\t\tthis.m_impulse.y += df.y;\r\n\r\n//\t\tb2Vec2 P = df.x * m_perp;\r\n\t\tvar P = box2d.b2MulSV(df.x, this.m_perp, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P);\r\n//\t\tfloat32 LA = df.x * m_s1 + df.y;\r\n\t\tvar LA = df.x * this.m_s1 + df.y;\r\n//\t\tfloat32 LB = df.x * m_s2 + df.y;\r\n\t\tvar LB = df.x * this.m_s2 + df.y;\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * LA;\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * LB;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();\r\nbox2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r = new box2d.b2Vec2();\r\nbox2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1 = new box2d.b2Vec3();\r\nbox2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3 = new box2d.b2Vec3();\r\nbox2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2 = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2PrismaticJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\t\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n//\tb2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tb2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n//\tb2Vec2 d = cB + rB - cA - rA;\r\n\tvar d = box2d.b2SubVV(\r\n\t\tbox2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0),\r\n\t\tbox2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1),\r\n\t\tbox2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d);\r\n\r\n//\tb2Vec2 axis = b2Mul(qA, m_localXAxisA);\r\n\tvar axis = box2d.b2MulRV(qA, this.m_localXAxisA, this.m_axis);\r\n//\tfloat32 a1 = b2Cross(d + rA, axis);\r\n\tvar a1 = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), axis);\r\n//\tfloat32 a2 = b2Cross(rB, axis);\r\n\tvar a2 = box2d.b2CrossVV(rB, axis);\r\n//\tb2Vec2 perp = b2Mul(qA, m_localYAxisA);\r\n\tvar perp = box2d.b2MulRV(qA, this.m_localYAxisA, this.m_perp);\r\n\r\n//\tfloat32 s1 = b2Cross(d + rA, perp);\r\n\tvar s1 = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), perp);\r\n//\tfloat32 s2 = b2Cross(rB, perp);\r\n\tvar s2 = box2d.b2CrossVV(rB, perp);\r\n\r\n//\tbox2d.b2Vec3 impulse;\r\n\tvar impulse = box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse;\r\n//\tb2Vec2 C1;\r\n//\tC1.x = b2Dot(perp, d);\r\n\tvar C1_x = box2d.b2DotVV(perp, d);\r\n//\tC1.y = aB - aA - m_referenceAngle;\r\n\tvar C1_y = aB - aA - this.m_referenceAngle;\r\n\r\n\tvar linearError = box2d.b2Abs(C1_x);\r\n\tvar angularError = box2d.b2Abs(C1_y);\r\n\r\n\tvar active = false;\r\n\tvar C2 = 0;\r\n\tif (this.m_enableLimit)\r\n\t{\r\n//\t\tfloat32 translation = b2Dot(axis, d);\r\n\t\tvar translation = box2d.b2DotVV(axis, d);\r\n\t\tif (box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop)\r\n\t\t{\r\n\t\t\t// Prevent large angular corrections\r\n\t\t\tC2 = box2d.b2Clamp(translation, (-box2d.b2_maxLinearCorrection), box2d.b2_maxLinearCorrection);\r\n\t\t\tlinearError = box2d.b2Max(linearError, box2d.b2Abs(translation));\r\n\t\t\tactive = true;\r\n\t\t}\r\n\t\telse if (translation <= this.m_lowerTranslation)\r\n\t\t{\r\n\t\t\t// Prevent large linear corrections and allow some slop.\r\n\t\t\tC2 = box2d.b2Clamp(translation - this.m_lowerTranslation + box2d.b2_linearSlop, (-box2d.b2_maxLinearCorrection), 0);\r\n\t\t\tlinearError = box2d.b2Max(linearError, this.m_lowerTranslation - translation);\r\n\t\t\tactive = true;\r\n\t\t}\r\n\t\telse if (translation >= this.m_upperTranslation)\r\n\t\t{\r\n\t\t\t// Prevent large linear corrections and allow some slop.\r\n\t\t\tC2 = box2d.b2Clamp(translation - this.m_upperTranslation - box2d.b2_linearSlop, 0, box2d.b2_maxLinearCorrection);\r\n\t\t\tlinearError = box2d.b2Max(linearError, translation - this.m_upperTranslation);\r\n\t\t\tactive = true;\r\n\t\t}\r\n\t}\r\n\r\n\tif (active)\r\n\t{\r\n//\t\tfloat32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n\t\tvar k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n//\t\tfloat32 k12 = iA * s1 + iB * s2;\r\n\t\tvar k12 = iA * s1 + iB * s2;\r\n//\t\tfloat32 k13 = iA * s1 * a1 + iB * s2 * a2;\r\n\t\tvar k13 = iA * s1 * a1 + iB * s2 * a2;\r\n//\t\tfloat32 k22 = iA + iB;\r\n\t\tvar k22 = iA + iB;\r\n\t\tif (k22 === 0)\r\n\t\t{\r\n\t\t\t// For fixed rotation\r\n\t\t\tk22 = 1;\r\n\t\t}\r\n//\t\tfloat32 k23 = iA * a1 + iB * a2;\r\n\t\tvar k23 = iA * a1 + iB * a2;\r\n//\t\tfloat32 k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;\r\n\t\tvar k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;\r\n\r\n//\t\tbox2d.b2Mat33 K;\r\n\t\tvar K = this.m_K3;\r\n//\t\tK.ex.Set(k11, k12, k13);\r\n\t\tK.ex.SetXYZ(k11, k12, k13);\r\n//\t\tK.ey.Set(k12, k22, k23);\r\n\t\tK.ey.SetXYZ(k12, k22, k23);\r\n//\t\tK.ez.Set(k13, k23, k33);\r\n\t\tK.ez.SetXYZ(k13, k23, k33);\r\n\r\n//\t\tbox2d.b2Vec3 C;\r\n//\t\tC.x = C1.x;\r\n//\t\tC.y = C1.y;\r\n//\t\tC.z = C2;\r\n\r\n//\t\timpulse = K.Solve33(-C);\r\n\t\timpulse = K.Solve33((-C1_x), (-C1_y), (-C2), impulse);\r\n\t}\r\n\telse\r\n\t{\r\n//\t\tfloat32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n\t\tvar k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n//\t\tfloat32 k12 = iA * s1 + iB * s2;\r\n\t\tvar k12 = iA * s1 + iB * s2;\r\n//\t\tfloat32 k22 = iA + iB;\r\n\t\tvar k22 = iA + iB;\r\n\t\tif (k22 === 0)\r\n\t\t{\r\n\t\t\tk22 = 1;\r\n\t\t}\r\n\r\n//\t\tbox2d.b2Mat22 K;\r\n\t\tvar K2 = this.m_K2;\r\n//\t\tK.ex.Set(k11, k12);\r\n\t\tK2.ex.SetXY(k11, k12);\r\n//\t\tK.ey.Set(k12, k22);\r\n\t\tK2.ey.SetXY(k12, k22);\r\n\r\n//\t\tb2Vec2 impulse1 = K.Solve(-C1);\r\n\t\tvar impulse1 = K2.Solve((-C1_x), (-C1_y), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1);\r\n\t\timpulse.x = impulse1.x;\r\n\t\timpulse.y = impulse1.y;\r\n\t\timpulse.z = 0;\r\n\t}\r\n\r\n//\tb2Vec2 P = impulse.x * perp + impulse.z * axis;\r\n\tvar P = box2d.b2AddVV(\r\n\t\tbox2d.b2MulSV(impulse.x, perp, box2d.b2Vec2.s_t0), \r\n\t\tbox2d.b2MulSV(impulse.z, axis, box2d.b2Vec2.s_t1), \r\n\t\tbox2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P);\r\n//\tfloat32 LA = impulse.x * s1 + impulse.y + impulse.z * a1;\r\n\tvar LA = impulse.x * s1 + impulse.y + impulse.z * a1;\r\n//\tfloat32 LB = impulse.x * s2 + impulse.y + impulse.z * a2;\r\n\tvar LB = impulse.x * s2 + impulse.y + impulse.z * a2;\r\n\r\n//\tcA -= mA * P;\r\n\tcA.SelfMulSub(mA, P);\r\n\taA -= iA * LA;\r\n//\tcB += mB * P;\r\n\tcB.SelfMulAdd(mB, P);\r\n\taB += iB * LB;\r\n\r\n//\tdata.positions[this.m_indexA].c = cA;\r\n\tdata.positions[this.m_indexA].a = aA;\r\n//\tdata.positions[this.m_indexB].c = cB;\r\n\tdata.positions[this.m_indexB].a = aB;\r\n\r\n\treturn linearError <= box2d.b2_linearSlop && angularError <= box2d.b2_angularSlop;\r\n}\r\nbox2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2();\r\nbox2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3();;\r\nbox2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1 = new box2d.b2Vec2();;\r\nbox2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();;\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n//\treturn inv_dt * (m_impulse.x * m_perp + (m_motorImpulse + m_impulse.z) * m_axis);\r\n\treturn out.SetXY(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn inv_dt * this.m_impulse.y;\r\n}\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }\r\n\r\n/** \r\n * The local joint axis relative to bodyA. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetLocalAxisA = function (out) { return out.Copy(this.m_localXAxisA); }\r\n\r\n/** \r\n * Get the reference angle. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetReferenceAngle = function () { return this.m_referenceAngle; }\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetJointTranslation = function ()\r\n{\r\n//\tb2Vec2 pA = m_bodyA.GetWorldPoint(m_localAnchorA);\r\n\tvar pA = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA);\r\n//\tb2Vec2 pB = m_bodyB.GetWorldPoint(m_localAnchorB);\r\n\tvar pB = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB);\r\n//\tb2Vec2 d = pB - pA;\r\n\tvar d = box2d.b2SubVV(pB, pA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d);\r\n//\tb2Vec2 axis = m_bodyA.GetWorldVector(m_localXAxisA);\r\n\tvar axis = this.m_bodyA.GetWorldVector(this.m_localXAxisA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis);\r\n\r\n//\tfloat32 translation = b2Dot(d, axis);\r\n\tvar translation = box2d.b2DotVV(d, axis);\r\n\treturn translation;\r\n}\r\nbox2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA = new box2d.b2Vec2();\r\nbox2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB = new box2d.b2Vec2();\r\nbox2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d = new box2d.b2Vec2();\r\nbox2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetJointSpeed = function ()\r\n{\r\n\t/*box2d.b2Body*/ var bA = this.m_bodyA;\r\n\t/*box2d.b2Body*/ var bB = this.m_bodyB;\r\n\r\n//\tb2Vec2 rA = b2Mul(bA->m_xf.q, m_localAnchorA - bA->m_sweep.localCenter);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, bA.m_sweep.localCenter, this.m_lalcA);\r\n\tvar rA = box2d.b2MulRV(bA.m_xf.q, this.m_lalcA, this.m_rA);\r\n//\tb2Vec2 rB = b2Mul(bB->m_xf.q, m_localAnchorB - bB->m_sweep.localCenter);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, bB.m_sweep.localCenter, this.m_lalcB);\r\n\tvar rB = box2d.b2MulRV(bB.m_xf.q, this.m_lalcB, this.m_rB);\r\n//\tb2Vec2 pA = bA->m_sweep.c + rA;\r\n\tvar pA = box2d.b2AddVV(bA.m_sweep.c, rA, box2d.b2Vec2.s_t0); // pA uses s_t0\r\n//\tb2Vec2 pB = bB->m_sweep.c + rB;\r\n\tvar pB = box2d.b2AddVV(bB.m_sweep.c, rB, box2d.b2Vec2.s_t1); // pB uses s_t1\r\n//\tb2Vec2 d = pB - pA;\r\n\tvar d = box2d.b2SubVV(pB, pA, box2d.b2Vec2.s_t2); // d uses s_t2\r\n//\tb2Vec2 axis = b2Mul(bA.m_xf.q, m_localXAxisA);\r\n\tvar axis = bA.GetWorldVector(this.m_localXAxisA, this.m_axis);\r\n\r\n\tvar vA = bA.m_linearVelocity;\r\n\tvar vB = bB.m_linearVelocity;\r\n\tvar wA = bA.m_angularVelocity;\r\n\tvar wB = bB.m_angularVelocity;\r\n\r\n//\tfloat32 speed = b2Dot(d, b2Cross(wA, axis)) + b2Dot(axis, vB + b2Cross(wB, rB) - vA - b2Cross(wA, rA));\r\n\tvar speed = \r\n\t\tbox2d.b2DotVV(d, box2d.b2CrossSV(wA, axis, box2d.b2Vec2.s_t0)) + \r\n\t\tbox2d.b2DotVV(\r\n\t\t\taxis, \r\n\t\t\tbox2d.b2SubVV(\r\n\t\t\t\tbox2d.b2AddVCrossSV(vB, wB, rB, box2d.b2Vec2.s_t0),\r\n\t\t\t\tbox2d.b2AddVCrossSV(vA, wA, rA, box2d.b2Vec2.s_t1), \r\n\t\t\t\tbox2d.b2Vec2.s_t0));\r\n\treturn speed;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.IsLimitEnabled = function ()\r\n{\r\n\treturn this.m_enableLimit;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag\r\n */\r\nbox2d.b2PrismaticJoint.prototype.EnableLimit = function (flag)\r\n{\r\n\tif (flag !== this.m_enableLimit)\r\n\t{\r\n\t\tthis.m_bodyA.SetAwake(true);\r\n\t\tthis.m_bodyB.SetAwake(true);\r\n\t\tthis.m_enableLimit = flag;\r\n\t\tthis.m_impulse.z = 0;\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetLowerLimit = function ()\r\n{\r\n\treturn this.m_lowerTranslation;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetUpperLimit = function ()\r\n{\r\n\treturn this.m_upperTranslation;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {number} upper \r\n * @param {number} lower \r\n */\r\nbox2d.b2PrismaticJoint.prototype.SetLimits = function (lower, upper)\r\n{\r\n\tif (lower !== this.m_lowerTranslation || upper !== this.m_upperTranslation)\r\n\t{\r\n\t\tthis.m_bodyA.SetAwake(true);\r\n\t\tthis.m_bodyB.SetAwake(true);\r\n\t\tthis.m_lowerTranslation = lower;\r\n\t\tthis.m_upperTranslation = upper;\r\n\t\tthis.m_impulse.z = 0;\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.IsMotorEnabled = function ()\r\n{\r\n\treturn this.m_enableMotor;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag\r\n */\r\nbox2d.b2PrismaticJoint.prototype.EnableMotor = function (flag)\r\n{\r\n\tthis.m_bodyA.SetAwake(true);\r\n\tthis.m_bodyB.SetAwake(true);\r\n\tthis.m_enableMotor = flag;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {number} speed \r\n */\r\nbox2d.b2PrismaticJoint.prototype.SetMotorSpeed = function (speed)\r\n{\r\n\tthis.m_bodyA.SetAwake(true);\r\n\tthis.m_bodyB.SetAwake(true);\r\n\tthis.m_motorSpeed = speed;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetMotorSpeed = function ()\r\n{\r\n\treturn this.m_motorSpeed;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {number} force\r\n */\r\nbox2d.b2PrismaticJoint.prototype.SetMaxMotorForce = function (force)\r\n{\r\n\tthis.m_bodyA.SetAwake(true);\r\n\tthis.m_bodyB.SetAwake(true);\r\n\tthis.m_maxMotorForce = force;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetMaxMotorForce = function () { return this.m_maxMotorForce; }\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2PrismaticJoint.prototype.GetMotorForce = function (inv_dt)\r\n{\r\n\treturn inv_dt * this.m_motorImpulse;\r\n}\r\n\r\n/** \r\n * Dump to b2Log \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2PrismaticJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\t\r\n\t\tbox2d.b2Log(\"  /*box2d.b2PrismaticJointDef*/ var jd = new box2d.b2PrismaticJointDef();\\n\");\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.localAnchorA.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n\t\tbox2d.b2Log(\"  jd.localAnchorB.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n\t\tbox2d.b2Log(\"  jd.localAxisA.SetXY(%.15f, %.15f);\\n\", this.m_localXAxisA.x, this.m_localXAxisA.y);\r\n\t\tbox2d.b2Log(\"  jd.referenceAngle = %.15f;\\n\", this.m_referenceAngle);\r\n\t\tbox2d.b2Log(\"  jd.enableLimit = %s;\\n\", (this.m_enableLimit)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.lowerTranslation = %.15f;\\n\", this.m_lowerTranslation);\r\n\t\tbox2d.b2Log(\"  jd.upperTranslation = %.15f;\\n\", this.m_upperTranslation);\r\n\t\tbox2d.b2Log(\"  jd.enableMotor = %s;\\n\", (this.m_enableMotor)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.motorSpeed = %.15f;\\n\", this.m_motorSpeed);\r\n\t\tbox2d.b2Log(\"  jd.maxMotorForce = %.15f;\\n\", this.m_maxMotorForce);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2GearJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2RevoluteJoint');\r\ngoog.require('box2d.b2PrismaticJoint');\r\n\r\n/** \r\n * Gear joint definition. This definition requires two existing \r\n * revolute or prismatic joints (any combination will work). \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2GearJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_gearJoint); // base class constructor\r\n}\r\n\r\ngoog.inherits(box2d.b2GearJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The first revolute/prismatic joint attached to the gear \r\n * joint. \r\n * @export \r\n * @type {box2d.b2Joint}\r\n */\r\nbox2d.b2GearJointDef.prototype.joint1 = null;\r\n\r\n/** \r\n * The second revolute/prismatic joint attached to the gear \r\n * joint. \r\n * @export \r\n * @type {box2d.b2Joint}\r\n */\r\nbox2d.b2GearJointDef.prototype.joint2 = null;\r\n\r\n/** \r\n * The gear ratio. \r\n * @see box2d.b2GearJoint for explanation. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJointDef.prototype.ratio = 1;\r\n\r\n/** \r\n * A gear joint is used to connect two joints together. Either \r\n * joint can be a revolute or prismatic joint. You specify a \r\n * gear ratio to bind the motions together: \r\n * coordinateA + ratio * coordinateB = constant \r\n * The ratio can be negative or positive. If one joint is a \r\n * revolute joint and the other joint is a prismatic joint, then \r\n * the ratio will have units of length or units of 1/length. \r\n * warning You have to manually destroy the gear joint if jointA \r\n * or jointB is destroyed. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2GearJointDef} def \r\n */\r\nbox2d.b2GearJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_joint1 = def.joint1;\r\n\tthis.m_joint2 = def.joint2;\r\n\r\n\tthis.m_localAnchorA = new box2d.b2Vec2();\r\n\tthis.m_localAnchorB = new box2d.b2Vec2();\r\n\tthis.m_localAnchorC = new box2d.b2Vec2();\r\n\tthis.m_localAnchorD = new box2d.b2Vec2();\r\n\r\n\tthis.m_localAxisC = new box2d.b2Vec2();\r\n\tthis.m_localAxisD = new box2d.b2Vec2();\r\n\r\n\tthis.m_lcA = new box2d.b2Vec2(), this.m_lcB = new box2d.b2Vec2(), this.m_lcC = new box2d.b2Vec2(), this.m_lcD = new box2d.b2Vec2();\r\n\tthis.m_JvAC = new box2d.b2Vec2(), this.m_JvBD = new box2d.b2Vec2();\r\n\r\n\tthis.m_qA = new box2d.b2Rot(), this.m_qB = new box2d.b2Rot(), this.m_qC = new box2d.b2Rot(), this.m_qD = new box2d.b2Rot();\r\n\tthis.m_lalcA = new box2d.b2Vec2(), this.m_lalcB = new box2d.b2Vec2(), this.m_lalcC = new box2d.b2Vec2(), this.m_lalcD = new box2d.b2Vec2();\r\n\r\n\tthis.m_typeA = this.m_joint1.GetType();\r\n\tthis.m_typeB = this.m_joint2.GetType();\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_typeA === box2d.b2JointType.e_revoluteJoint || this.m_typeA === box2d.b2JointType.e_prismaticJoint); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_typeB === box2d.b2JointType.e_revoluteJoint || this.m_typeB === box2d.b2JointType.e_prismaticJoint); }\r\n\r\n\t/*float32*/ var coordinateA, coordinateB;\r\n\r\n\t// TODO_ERIN there might be some problem with the joint edges in b2Joint.\r\n\r\n\tthis.m_bodyC = this.m_joint1.GetBodyA();\r\n\tthis.m_bodyA = this.m_joint1.GetBodyB();\r\n\r\n\t// Get geometry of joint1\r\n\t/*box2d.b2Transform*/ var xfA = this.m_bodyA.m_xf;\r\n\t/*float32*/ var aA = this.m_bodyA.m_sweep.a;\r\n\t/*box2d.b2Transform*/ var xfC = this.m_bodyC.m_xf;\r\n\t/*float32*/ var aC = this.m_bodyC.m_sweep.a;\r\n\r\n\tif (this.m_typeA === box2d.b2JointType.e_revoluteJoint)\r\n\t{\r\n\t\t/*box2d.b2RevoluteJoint*/ var revolute = def.joint1;\r\n\t\tthis.m_localAnchorC.Copy(revolute.m_localAnchorA);\r\n\t\tthis.m_localAnchorA.Copy(revolute.m_localAnchorB);\r\n\t\tthis.m_referenceAngleA = revolute.m_referenceAngle;\r\n\t\tthis.m_localAxisC.SetZero();\r\n\r\n\t\tcoordinateA = aA - aC - this.m_referenceAngleA;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t/*box2d.b2PrismaticJoint*/ var prismatic = def.joint1;\r\n\t\tthis.m_localAnchorC.Copy(prismatic.m_localAnchorA);\r\n\t\tthis.m_localAnchorA.Copy(prismatic.m_localAnchorB);\r\n\t\tthis.m_referenceAngleA = prismatic.m_referenceAngle;\r\n\t\tthis.m_localAxisC.Copy(prismatic.m_localXAxisA);\r\n\r\n//\t\tb2Vec2 pC = m_localAnchorC;\r\n\t\tvar pC = this.m_localAnchorC;\r\n//\t\tb2Vec2 pA = b2MulT(xfC.q, b2Mul(xfA.q, m_localAnchorA) + (xfA.p - xfC.p));\r\n\t\tvar pA = box2d.b2MulTRV(\r\n\t\t\txfC.q,\r\n\t\t\tbox2d.b2AddVV(\r\n\t\t\t\tbox2d.b2MulRV(xfA.q, this.m_localAnchorA, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2SubVV(xfA.p, xfC.p, box2d.b2Vec2.s_t1),\r\n\t\t\t\tbox2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2Vec2.s_t0); // pA uses s_t0\r\n//\t\tcoordinateA = b2Dot(pA - pC, m_localAxisC);\r\n\t\tcoordinateA = box2d.b2DotVV(box2d.b2SubVV(pA, pC, box2d.b2Vec2.s_t0), this.m_localAxisC);\r\n\t}\r\n\r\n\tthis.m_bodyD = this.m_joint2.GetBodyA();\r\n\tthis.m_bodyB = this.m_joint2.GetBodyB();\r\n\r\n\t// Get geometry of joint2\r\n\t/*box2d.b2Transform*/ var xfB = this.m_bodyB.m_xf;\r\n\t/*float32*/ var aB = this.m_bodyB.m_sweep.a;\r\n\t/*box2d.b2Transform*/ var xfD = this.m_bodyD.m_xf;\r\n\t/*float32*/ var aD = this.m_bodyD.m_sweep.a;\r\n\r\n\tif (this.m_typeB === box2d.b2JointType.e_revoluteJoint)\r\n\t{\r\n\t\t/*box2d.b2RevoluteJoint*/ var revolute = def.joint2;\r\n\t\tthis.m_localAnchorD.Copy(revolute.m_localAnchorA);\r\n\t\tthis.m_localAnchorB.Copy(revolute.m_localAnchorB);\r\n\t\tthis.m_referenceAngleB = revolute.m_referenceAngle;\r\n\t\tthis.m_localAxisD.SetZero();\r\n\r\n\t\tcoordinateB = aB - aD - this.m_referenceAngleB;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t/*box2d.b2PrismaticJoint*/ var prismatic = def.joint2;\r\n\t\tthis.m_localAnchorD.Copy(prismatic.m_localAnchorA);\r\n\t\tthis.m_localAnchorB.Copy(prismatic.m_localAnchorB);\r\n\t\tthis.m_referenceAngleB = prismatic.m_referenceAngle;\r\n\t\tthis.m_localAxisD.Copy(prismatic.m_localXAxisA);\r\n\r\n//\t\tb2Vec2 pD = m_localAnchorD;\r\n\t\tvar pD = this.m_localAnchorD;\r\n//\t\tb2Vec2 pB = b2MulT(xfD.q, b2Mul(xfB.q, m_localAnchorB) + (xfB.p - xfD.p));\r\n\t\tvar pB = box2d.b2MulTRV(\r\n\t\t\txfD.q,\r\n\t\t\tbox2d.b2AddVV(\r\n\t\t\t\tbox2d.b2MulRV(xfB.q, this.m_localAnchorB, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2SubVV(xfB.p, xfD.p, box2d.b2Vec2.s_t1),\r\n\t\t\t\tbox2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2Vec2.s_t0); // pB uses s_t0\r\n//\t\tcoordinateB = b2Dot(pB - pD, m_localAxisD);\r\n\t\tcoordinateB = box2d.b2DotVV(box2d.b2SubVV(pB, pD, box2d.b2Vec2.s_t0), this.m_localAxisD);\r\n\t}\r\n\r\n\tthis.m_ratio = def.ratio;\r\n\r\n\tthis.m_constant = coordinateA + this.m_ratio * coordinateB;\r\n\r\n\tthis.m_impulse = 0;\r\n}\r\n\r\ngoog.inherits(box2d.b2GearJoint, box2d.b2Joint);\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Joint}\r\n */\r\nbox2d.b2GearJoint.prototype.m_joint1 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Joint}\r\n */\r\nbox2d.b2GearJoint.prototype.m_joint2 = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2JointType}\r\n */\r\nbox2d.b2GearJoint.prototype.m_typeA = box2d.b2JointType.e_unknownJoint;\r\n/**\r\n * @export \r\n * @type {box2d.b2JointType}\r\n */\r\nbox2d.b2GearJoint.prototype.m_typeB = box2d.b2JointType.e_unknownJoint;\r\n\r\n// Body A is connected to body C\r\n// Body B is connected to body D\r\n/**\r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2GearJoint.prototype.m_bodyC = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2GearJoint.prototype.m_bodyD = null;\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_localAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_localAnchorB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_localAnchorC = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_localAnchorD = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_localAxisC = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_localAxisD = null;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_referenceAngleA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_referenceAngleB = 0;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_constant = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_ratio = 0;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_impulse = 0;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_indexC = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_indexD = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_lcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_lcB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_lcC = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_lcD = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_mA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_mB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_mC = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_mD = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_iA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_iB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_iC = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_iD = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_JvAC = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_JvBD = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_JwA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_JwB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_JwC = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_JwD = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GearJoint.prototype.m_mass = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2GearJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2GearJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2GearJoint.prototype.m_qC = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2GearJoint.prototype.m_qD = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_lalcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_lalcB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_lalcC = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2GearJoint.prototype.m_lalcD = null;\r\n\r\n/**\r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2GearJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_indexC = this.m_bodyC.m_islandIndex;\r\n\tthis.m_indexD = this.m_bodyD.m_islandIndex;\r\n\tthis.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter);\r\n\tthis.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter);\r\n\tthis.m_mA = this.m_bodyA.m_invMass;\r\n\tthis.m_mB = this.m_bodyB.m_invMass;\r\n\tthis.m_mC = this.m_bodyC.m_invMass;\r\n\tthis.m_mD = this.m_bodyD.m_invMass;\r\n\tthis.m_iA = this.m_bodyA.m_invI;\r\n\tthis.m_iB = this.m_bodyB.m_invI;\r\n\tthis.m_iC = this.m_bodyC.m_invI;\r\n\tthis.m_iD = this.m_bodyD.m_invI;\r\n\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*float32*/ var aC = data.positions[this.m_indexC].a;\r\n\t/*box2d.b2Vec2&*/ var vC = data.velocities[this.m_indexC].v;\r\n\t/*float32*/ var wC = data.velocities[this.m_indexC].w;\r\n\r\n\t/*float32*/ var aD = data.positions[this.m_indexD].a;\r\n\t/*box2d.b2Vec2&*/ var vD = data.velocities[this.m_indexD].v;\r\n\t/*float32*/ var wD = data.velocities[this.m_indexD].w;\r\n\r\n//\tbox2d.b2Rot qA(aA), qB(aB), qC(aC), qD(aD);\r\n\tvar qA = this.m_qA.SetAngleRadians(aA), \r\n\t\tqB = this.m_qB.SetAngleRadians(aB), \r\n\t\tqC = this.m_qC.SetAngleRadians(aC), \r\n\t\tqD = this.m_qD.SetAngleRadians(aD);\r\n\r\n\tthis.m_mass = 0;\r\n\r\n\tif (this.m_typeA === box2d.b2JointType.e_revoluteJoint)\r\n\t{\r\n\t\tthis.m_JvAC.SetZero();\r\n\t\tthis.m_JwA = 1;\r\n\t\tthis.m_JwC = 1;\r\n\t\tthis.m_mass += this.m_iA + this.m_iC;\r\n\t}\r\n\telse\r\n\t{\r\n//\t\tb2Vec2 u = b2Mul(qC, m_localAxisC);\r\n\t\tvar u = box2d.b2MulRV(qC, this.m_localAxisC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);\r\n//\t\tb2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);\r\n\t\tbox2d.b2SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC);\r\n\t\tvar rC = box2d.b2MulRV(qC, this.m_lalcC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC);\r\n//\t\tb2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);\r\n\t\tbox2d.b2SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA);\r\n\t\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA);\r\n//\t\tm_JvAC = u;\r\n\t\tthis.m_JvAC.Copy(u);\r\n//\t\tm_JwC = b2Cross(rC, u);\r\n\t\tthis.m_JwC = box2d.b2CrossVV(rC, u);\r\n//\t\tm_JwA = b2Cross(rA, u);\r\n\t\tthis.m_JwA = box2d.b2CrossVV(rA, u);\r\n\t\tthis.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\r\n\t}\r\n\r\n\tif (this.m_typeB === box2d.b2JointType.e_revoluteJoint)\r\n\t{\r\n\t\tthis.m_JvBD.SetZero();\r\n\t\tthis.m_JwB = this.m_ratio;\r\n\t\tthis.m_JwD = this.m_ratio;\r\n\t\tthis.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\r\n\t}\r\n\telse\r\n\t{\r\n//\t\tb2Vec2 u = b2Mul(qD, m_localAxisD);\r\n\t\tvar u = box2d.b2MulRV(qD, this.m_localAxisD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);\r\n//\t\tb2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);\r\n\t\tbox2d.b2SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD);\r\n\t\tvar rD = box2d.b2MulRV(qD, this.m_lalcD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD);\r\n//\t\tb2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);\r\n\t\tbox2d.b2SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB);\r\n\t\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB);\r\n//\t\tm_JvBD = m_ratio * u;\r\n\t\tbox2d.b2MulSV(this.m_ratio, u, this.m_JvBD);\r\n//\t\tm_JwD = m_ratio * b2Cross(rD, u);\r\n\t\tthis.m_JwD = this.m_ratio * box2d.b2CrossVV(rD, u);\r\n//\t\tm_JwB = m_ratio * b2Cross(rB, u);\r\n\t\tthis.m_JwB = this.m_ratio * box2d.b2CrossVV(rB, u);\r\n\t\tthis.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\r\n\t}\r\n\r\n\t// Compute effective mass.\r\n\tthis.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n//\t\tvA += (m_mA * m_impulse) * m_JvAC;\r\n\t\tvA.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC);\r\n\t\twA += this.m_iA * this.m_impulse * this.m_JwA;\r\n//\t\tvB += (m_mB * m_impulse) * m_JvBD;\r\n\t\tvB.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD);\r\n\t\twB += this.m_iB * this.m_impulse * this.m_JwB;\r\n//\t\tvC -= (m_mC * m_impulse) * m_JvAC;\r\n\t\tvC.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC);\r\n\t\twC -= this.m_iC * this.m_impulse * this.m_JwC;\r\n//\t\tvD -= (m_mD * m_impulse) * m_JvBD;\r\n\t\tvD.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD);\r\n\t\twD -= this.m_iD * this.m_impulse * this.m_JwD;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse = 0;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n//\tdata.velocities[this.m_indexC].v = vC;\r\n\tdata.velocities[this.m_indexC].w = wC;\r\n//\tdata.velocities[this.m_indexD].v = vD;\r\n\tdata.velocities[this.m_indexD].w = wD;\r\n}\r\nbox2d.b2GearJoint.prototype.InitVelocityConstraints.s_u = new box2d.b2Vec2();\r\nbox2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA = new box2d.b2Vec2();\r\nbox2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB = new box2d.b2Vec2();\r\nbox2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC = new box2d.b2Vec2();\r\nbox2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD = new box2d.b2Vec2();\r\n\r\n/**\r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2GearJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\t/*box2d.b2Vec2&*/ var vC = data.velocities[this.m_indexC].v;\r\n\t/*float32*/ var wC = data.velocities[this.m_indexC].w;\r\n\t/*box2d.b2Vec2&*/ var vD = data.velocities[this.m_indexD].v;\r\n\t/*float32*/ var wD = data.velocities[this.m_indexD].w;\r\n\r\n//\tfloat32 Cdot = b2Dot(m_JvAC, vA - vC) + b2Dot(m_JvBD, vB - vD);\r\n\tvar Cdot = \r\n\t\tbox2d.b2DotVV(this.m_JvAC, box2d.b2SubVV(vA, vC, box2d.b2Vec2.s_t0)) + \r\n\t\tbox2d.b2DotVV(this.m_JvBD, box2d.b2SubVV(vB, vD, box2d.b2Vec2.s_t0));\r\n\tCdot += (this.m_JwA * wA - this.m_JwC * wC) + (this.m_JwB * wB - this.m_JwD * wD);\r\n\r\n\t/*float32*/ var impulse = -this.m_mass * Cdot;\r\n\tthis.m_impulse += impulse;\r\n\r\n//\tvA += (m_mA * impulse) * m_JvAC;\r\n\tvA.SelfMulAdd((this.m_mA * impulse), this.m_JvAC);\r\n\twA += this.m_iA * impulse * this.m_JwA;\r\n//\tvB += (m_mB * impulse) * m_JvBD;\r\n\tvB.SelfMulAdd((this.m_mB * impulse), this.m_JvBD);\r\n\twB += this.m_iB * impulse * this.m_JwB;\r\n//\tvC -= (m_mC * impulse) * m_JvAC;\r\n\tvC.SelfMulSub((this.m_mC * impulse), this.m_JvAC);\r\n\twC -= this.m_iC * impulse * this.m_JwC;\r\n//\tvD -= (m_mD * impulse) * m_JvBD;\r\n\tvD.SelfMulSub((this.m_mD * impulse), this.m_JvBD);\r\n\twD -= this.m_iD * impulse * this.m_JwD;\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n//\tdata.velocities[this.m_indexC].v = vC;\r\n\tdata.velocities[this.m_indexC].w = wC;\r\n//\tdata.velocities[this.m_indexD].v = vD;\r\n\tdata.velocities[this.m_indexD].w = wD;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2GearJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var cC = data.positions[this.m_indexC].c;\r\n\t/*float32*/ var aC = data.positions[this.m_indexC].a;\r\n\t/*box2d.b2Vec2&*/ var cD = data.positions[this.m_indexD].c;\r\n\t/*float32*/ var aD = data.positions[this.m_indexD].a;\r\n\r\n//\tbox2d.b2Rot qA(aA), qB(aB), qC(aC), qD(aD);\r\n\tvar qA = this.m_qA.SetAngleRadians(aA), \r\n\t\tqB = this.m_qB.SetAngleRadians(aB), \r\n\t\tqC = this.m_qC.SetAngleRadians(aC), \r\n\t\tqD = this.m_qD.SetAngleRadians(aD);\r\n\r\n\t/*float32*/ var linearError = 0;\r\n\r\n\t/*float32*/ var coordinateA, coordinateB;\r\n\r\n\t/*box2d.b2Vec2*/ var JvAC = this.m_JvAC, JvBD = this.m_JvBD;\r\n\t/*float32*/ var JwA, JwB, JwC, JwD;\r\n\t/*float32*/ var mass = 0;\r\n\r\n\tif (this.m_typeA === box2d.b2JointType.e_revoluteJoint)\r\n\t{\r\n\t\tJvAC.SetZero();\r\n\t\tJwA = 1;\r\n\t\tJwC = 1;\r\n\t\tmass += this.m_iA + this.m_iC;\r\n\r\n\t\tcoordinateA = aA - aC - this.m_referenceAngleA;\r\n\t}\r\n\telse\r\n\t{\r\n//\t\tb2Vec2 u = b2Mul(qC, m_localAxisC);\r\n\t\tvar u = box2d.b2MulRV(qC, this.m_localAxisC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);\r\n//\t\tb2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);\r\n\t\tvar rC = box2d.b2MulRV(qC, this.m_lalcC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC);\r\n//\t\tb2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);\r\n\t\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA);\r\n//\t\tJvAC = u;\r\n\t\tJvAC.Copy(u);\r\n//\t\tJwC = b2Cross(rC, u);\r\n\t\tJwC = box2d.b2CrossVV(rC, u);\r\n//\t\tJwA = b2Cross(rA, u);\r\n\t\tJwA = box2d.b2CrossVV(rA, u);\r\n\t\tmass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\r\n\r\n//\t\tb2Vec2 pC = m_localAnchorC - m_lcC;\r\n\t\tvar pC = this.m_lalcC;\r\n//\t\tb2Vec2 pA = b2MulT(qC, rA + (cA - cC));\r\n\t\tvar pA = box2d.b2MulTRV(\r\n\t\t\tqC,\r\n\t\t\tbox2d.b2AddVV(\r\n\t\t\t\trA, \r\n\t\t\t\tbox2d.b2SubVV(cA, cC, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2Vec2.s_t0); // pA uses s_t0\r\n//\t\tcoordinateA = b2Dot(pA - pC, m_localAxisC);\r\n\t\tcoordinateA = box2d.b2DotVV(box2d.b2SubVV(pA, pC, box2d.b2Vec2.s_t0), this.m_localAxisC);\r\n\t}\r\n\r\n\tif (this.m_typeB === box2d.b2JointType.e_revoluteJoint)\r\n\t{\r\n\t\tJvBD.SetZero();\r\n\t\tJwB = this.m_ratio;\r\n\t\tJwD = this.m_ratio;\r\n\t\tmass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\r\n\r\n\t\tcoordinateB = aB - aD - this.m_referenceAngleB;\r\n\t}\r\n\telse\r\n\t{\r\n//\t\tb2Vec2 u = b2Mul(qD, m_localAxisD);\r\n\t\tvar u = box2d.b2MulRV(qD, this.m_localAxisD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);\r\n//\t\tb2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);\r\n\t\tvar rD = box2d.b2MulRV(qD, this.m_lalcD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD);\r\n//\t\tb2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);\r\n\t\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB);\r\n//\t\tJvBD = m_ratio * u;\r\n\t\tbox2d.b2MulSV(this.m_ratio, u, JvBD);\r\n//\t\tJwD = m_ratio * b2Cross(rD, u);\r\n\t\tJwD = this.m_ratio * box2d.b2CrossVV(rD, u);\r\n//\t\tJwB = m_ratio * b2Cross(rB, u);\r\n\t\tJwB = this.m_ratio * box2d.b2CrossVV(rB, u);\r\n\t\tmass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;\r\n\r\n//\t\tb2Vec2 pD = m_localAnchorD - m_lcD;\r\n\t\tvar pD = this.m_lalcD;\r\n//\t\tb2Vec2 pB = b2MulT(qD, rB + (cB - cD));\r\n\t\tvar pB = box2d.b2MulTRV(\r\n\t\t\tqD,\r\n\t\t\tbox2d.b2AddVV(\r\n\t\t\t\trB, \r\n\t\t\t\tbox2d.b2SubVV(cB, cD, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2Vec2.s_t0); // pB uses s_t0\r\n//\t\tcoordinateB = b2Dot(pB - pD, m_localAxisD);\r\n\t\tcoordinateB = box2d.b2DotVV(box2d.b2SubVV(pB, pD, box2d.b2Vec2.s_t0), this.m_localAxisD);\r\n\t}\r\n\r\n\t/*float32*/ var C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant;\r\n\r\n\t/*float32*/ var impulse = 0;\r\n\tif (mass > 0)\r\n\t{\r\n\t\timpulse = -C / mass;\r\n\t}\r\n\r\n//\tcA += m_mA * impulse * JvAC;\r\n\tcA.SelfMulAdd(this.m_mA * impulse, JvAC);\r\n\taA += this.m_iA * impulse * JwA;\r\n//\tcB += m_mB * impulse * JvBD;\r\n\tcB.SelfMulAdd(this.m_mB * impulse, JvBD);\r\n\taB += this.m_iB * impulse * JwB;\r\n//\tcC -= m_mC * impulse * JvAC;\r\n\tcC.SelfMulSub(this.m_mC * impulse, JvAC);\r\n\taC -= this.m_iC * impulse * JwC;\r\n//\tcD -= m_mD * impulse * JvBD;\r\n\tcD.SelfMulSub(this.m_mD * impulse, JvBD);\r\n\taD -= this.m_iD * impulse * JwD;\r\n\r\n//\tdata.positions[this.m_indexA].c = cA;\r\n\tdata.positions[this.m_indexA].a = aA;\r\n//\tdata.positions[this.m_indexB].c = cB;\r\n\tdata.positions[this.m_indexB].a = aB;\r\n//\tdata.positions[this.m_indexC].c = cC;\r\n\tdata.positions[this.m_indexC].a = aC;\r\n//\tdata.positions[this.m_indexD].c = cD;\r\n\tdata.positions[this.m_indexD].a = aD;\r\n\r\n\t// TODO_ERIN not implemented\r\n\treturn linearError < box2d.b2_linearSlop;\r\n}\r\nbox2d.b2GearJoint.prototype.SolvePositionConstraints.s_u = new box2d.b2Vec2();\r\nbox2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2();\r\nbox2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2();\r\nbox2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC = new box2d.b2Vec2();\r\nbox2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2GearJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2GearJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2GearJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n//\tb2Vec2 P = m_impulse * m_JvAC;\r\n//\treturn inv_dt * P;\r\n\treturn box2d.b2MulSV(inv_dt * this.m_impulse, this.m_JvAC, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2GearJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n//\tfloat32 L = m_impulse * m_JwA;\r\n//\treturn inv_dt * L;\r\n\treturn inv_dt * this.m_impulse * this.m_JwA;\r\n}\r\n\r\n/** \r\n * Get the first joint. \r\n * @export \r\n * @return {box2d.b2Joint}\r\n */\r\nbox2d.b2GearJoint.prototype.GetJoint1 = function () { return this.m_joint1; }\r\n\r\n/** \r\n * Get the second joint. \r\n * @export \r\n * @return {box2d.b2Joint}\r\n */\r\nbox2d.b2GearJoint.prototype.GetJoint2 = function () { return this.m_joint2; }\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2GearJoint.prototype.GetRatio = function ()\r\n{\r\n\treturn this.m_ratio;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {number} ratio\r\n */\r\nbox2d.b2GearJoint.prototype.SetRatio = function (ratio)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(ratio)); }\r\n\tthis.m_ratio = ratio;\r\n}\r\n\r\n/** \r\n * Dump joint to dmLog \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2GearJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\t\r\n\t\tvar index1 = this.m_joint1.m_index;\r\n\t\tvar index2 = this.m_joint2.m_index;\r\n\t\r\n\t\tbox2d.b2Log(\"  /*box2d.b2GearJointDef*/ var jd = new box2d.b2GearJointDef();\\n\");\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.joint1 = joints[%d];\\n\", index1);\r\n\t\tbox2d.b2Log(\"  jd.joint2 = joints[%d];\\n\", index2);\r\n\t\tbox2d.b2Log(\"  jd.ratio = %.15f;\\n\", this.m_ratio);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Distance');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * A distance proxy is used by the GJK algorithm. \r\n * It encapsulates any shape.\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2DistanceProxy = function ()\r\n{\r\n\tthis.m_buffer = box2d.b2Vec2.MakeArray(2);\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2DistanceProxy.prototype.m_buffer = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2DistanceProxy.prototype.m_vertices = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceProxy.prototype.m_count = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceProxy.prototype.m_radius = 0;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2DistanceProxy} \r\n */\r\nbox2d.b2DistanceProxy.prototype.Reset = function ()\r\n{\r\n\tthis.m_vertices = null;\r\n\tthis.m_count = 0;\r\n\tthis.m_radius = 0;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Initialize the proxy using the given shape. The shape must \r\n * remain in scope while the proxy is in use. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Shape} shape \r\n * @param {number} index\r\n */\r\nbox2d.b2DistanceProxy.prototype.SetShape = function (shape, index)\r\n{\r\n\tshape.SetupDistanceProxy(this, index);\r\n}\r\n\r\n/** \r\n * Get the supporting vertex index in the given direction. \r\n * @export \r\n * @return {number} \r\n * @param {box2d.b2Vec2} d \r\n */\r\nbox2d.b2DistanceProxy.prototype.GetSupport = function (d)\r\n{\r\n\t/** @type {number} */ var bestIndex = 0;\r\n\t/** @type {number} */ var bestValue = box2d.b2DotVV(this.m_vertices[0], d);\r\n\tfor (var i = 1; i < this.m_count; ++i)\r\n\t{\r\n\t\t/** @type {number} */ var value = box2d.b2DotVV(this.m_vertices[i], d);\r\n\t\tif (value > bestValue)\r\n\t\t{\r\n\t\t\tbestIndex = i;\r\n\t\t\tbestValue = value;\r\n\t\t}\r\n\t}\r\n\r\n\treturn bestIndex;\r\n}\r\n\r\n/** \r\n * Get the supporting vertex in the given direction. \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} d \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2DistanceProxy.prototype.GetSupportVertex = function (d, out)\r\n{\r\n\t/** @type {number} */ var bestIndex = 0;\r\n\t/** @type {number} */ var bestValue = box2d.b2DotVV(this.m_vertices[0], d);\r\n\tfor (var i = 1; i < this.m_count; ++i)\r\n\t{\r\n\t\t/** @type {number} */ var value = box2d.b2DotVV(this.m_vertices[i], d);\r\n\t\tif (value > bestValue)\r\n\t\t{\r\n\t\t\tbestIndex = i;\r\n\t\t\tbestValue = value;\r\n\t\t}\r\n\t}\r\n\r\n\treturn out.Copy(this.m_vertices[bestIndex]);\r\n}\r\n\r\n/** \r\n * Get the vertex count. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2DistanceProxy.prototype.GetVertexCount = function ()\r\n{\r\n\treturn this.m_count;\r\n}\r\n\r\n/** \r\n * Get a vertex by index. Used by box2d.b2Distance. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {number} index \r\n */\r\nbox2d.b2DistanceProxy.prototype.GetVertex = function (index)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= index && index < this.m_count); }\r\n\treturn this.m_vertices[index];\r\n}\r\n\r\n/** \r\n * Used to warm start box2d.b2Distance. \r\n * Set count to zero on first call.\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2SimplexCache = function ()\r\n{\r\n\tthis.indexA = box2d.b2MakeNumberArray(3);\r\n\tthis.indexB = box2d.b2MakeNumberArray(3);\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2SimplexCache.prototype.metric = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2SimplexCache.prototype.count = 0;\r\n/**\r\n * @export \r\n * @type {Array.<number>}\r\n */\r\nbox2d.b2SimplexCache.prototype.indexA = null;\r\n/**\r\n * @export \r\n * @type {Array.<number>}\r\n */\r\nbox2d.b2SimplexCache.prototype.indexB = null;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2SimplexCache} \r\n */\r\nbox2d.b2SimplexCache.prototype.Reset = function ()\r\n{\r\n\tthis.metric = 0;\r\n\tthis.count = 0;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Input for box2d.b2Distance. \r\n * You have to option to use the shape radii in the computation. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2DistanceInput = function ()\r\n{\r\n\tthis.proxyA = new box2d.b2DistanceProxy();\r\n\tthis.proxyB = new box2d.b2DistanceProxy();\r\n\tthis.transformA = new box2d.b2Transform();\r\n\tthis.transformB = new box2d.b2Transform();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2DistanceProxy}\r\n */\r\nbox2d.b2DistanceInput.prototype.proxyA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2DistanceProxy}\r\n */\r\nbox2d.b2DistanceInput.prototype.proxyB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Transform}\r\n */\r\nbox2d.b2DistanceInput.prototype.transformA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Transform}\r\n */\r\nbox2d.b2DistanceInput.prototype.transformB = null;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2DistanceInput.prototype.useRadii = false;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2DistanceInput} \r\n */\r\nbox2d.b2DistanceInput.prototype.Reset = function ()\r\n{\r\n\tthis.proxyA.Reset();\r\n\tthis.proxyB.Reset();\r\n\tthis.transformA.SetIdentity();\r\n\tthis.transformB.SetIdentity();\r\n\tthis.useRadii = false;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Output for box2d.b2Distance. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2DistanceOutput = function ()\r\n{\r\n\tthis.pointA = new box2d.b2Vec2();\r\n\tthis.pointB = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceOutput.prototype.pointA = null;\t///< closest point on shapeA\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceOutput.prototype.pointB = null;\t///< closest point on shapeB\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceOutput.prototype.distance = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceOutput.prototype.iterations = 0; ///< number of GJK iterations used\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2DistanceOutput} \r\n */\r\nbox2d.b2DistanceOutput.prototype.Reset = function ()\r\n{\r\n\tthis.pointA.SetZero();\r\n\tthis.pointB.SetZero();\r\n\tthis.distance = 0;\r\n\tthis.iterations = 0;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * GJK using Voronoi regions (Christer Ericson) and Barycentric \r\n * coordinates. \r\n */\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2_gjkCalls = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2_gjkIters = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2_gjkMaxIters = 0;\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2SimplexVertex = function ()\r\n{\r\n\tthis.wA = new box2d.b2Vec2();\r\n\tthis.wB = new box2d.b2Vec2();\r\n\tthis.w = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2SimplexVertex.prototype.wA = null; // support point in proxyA\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2SimplexVertex.prototype.wB = null; // support point in proxyB\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2SimplexVertex.prototype.w = null; // wB - wA\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2SimplexVertex.prototype.a = 0; // barycentric coordinate for closest point\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2SimplexVertex.prototype.indexA = 0; // wA index\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2SimplexVertex.prototype.indexB = 0; // wB index\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2SimplexVertex} \r\n * @param {box2d.b2SimplexVertex} other \r\n */\r\nbox2d.b2SimplexVertex.prototype.Copy = function (other)\r\n{\r\n\tthis.wA.Copy(other.wA);\t\t// support point in proxyA\r\n\tthis.wB.Copy(other.wB);     // support point in proxyB\r\n\tthis.w.Copy(other.w);       // wB - wA\r\n\tthis.a = other.a;           // barycentric coordinate for closest point\r\n\tthis.indexA = other.indexA; // wA index\r\n\tthis.indexB = other.indexB; // wB index\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Simplex = function ()\r\n{\r\n\tthis.m_v1 = new box2d.b2SimplexVertex();\r\n\tthis.m_v2 = new box2d.b2SimplexVertex();\r\n\tthis.m_v3 = new box2d.b2SimplexVertex();\r\n\tthis.m_vertices = new Array(3);\r\n\tthis.m_vertices[0] = this.m_v1;\r\n\tthis.m_vertices[1] = this.m_v2;\r\n\tthis.m_vertices[2] = this.m_v3;\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2SimplexVertex}\r\n */\r\nbox2d.b2Simplex.prototype.m_v1 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2SimplexVertex}\r\n */\r\nbox2d.b2Simplex.prototype.m_v2 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2SimplexVertex}\r\n */\r\nbox2d.b2Simplex.prototype.m_v3 = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2SimplexVertex>}\r\n */\r\nbox2d.b2Simplex.prototype.m_vertices = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Simplex.prototype.m_count = 0;\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SimplexCache} cache \r\n * @param {box2d.b2DistanceProxy} proxyA \r\n * @param {box2d.b2Transform} transformA \r\n * @param {box2d.b2DistanceProxy} proxyB \r\n * @param {box2d.b2Transform} transformB \r\n */\r\nbox2d.b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= cache.count && cache.count <= 3); }\r\n\r\n\t// Copy data from cache.\r\n\tthis.m_count = cache.count;\r\n\t/** @type Array.<box2d.b2SimplexVertex> */ var vertices = this.m_vertices;\r\n\tfor (var i = 0; i < this.m_count; ++i)\r\n\t{\r\n\t\t/** @type {box2d.b2SimplexVertex} */ var v = vertices[i];\r\n\t\tv.indexA = cache.indexA[i];\r\n\t\tv.indexB = cache.indexB[i];\r\n\t\t/** @type {box2d.b2Vec2} */ var wALocal = proxyA.GetVertex(v.indexA);\r\n\t\t/** @type {box2d.b2Vec2} */ var wBLocal = proxyB.GetVertex(v.indexB);\r\n\t\tbox2d.b2MulXV(transformA, wALocal, v.wA);\r\n\t\tbox2d.b2MulXV(transformB, wBLocal, v.wB);\r\n\t\tbox2d.b2SubVV(v.wB, v.wA, v.w);\r\n\t\tv.a = 0;\r\n\t}\r\n\r\n\t// Compute the new simplex metric, if it is substantially different than\r\n\t// old metric then flush the simplex.\r\n\tif (this.m_count > 1)\r\n\t{\r\n\t\t/** @type {number} */ var metric1 = cache.metric;\r\n\t\t/** @type {number} */ var metric2 = this.GetMetric();\r\n\t\tif (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < box2d.b2_epsilon)\r\n\t\t{\r\n\t\t\t// Reset the simplex.\r\n\t\t\tthis.m_count = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t// If the cache is empty or invalid ...\r\n\tif (this.m_count === 0)\r\n\t{\r\n\t\t/** type {box2d.b2SimplexVertex} */ var v = vertices[0];\r\n\t\tv.indexA = 0;\r\n\t\tv.indexB = 0;\r\n\t\t/** type {box2d.b2Vec2} */ var wALocal = proxyA.GetVertex(0);\r\n\t\t/** type {box2d.b2Vec2} */ var wBLocal = proxyB.GetVertex(0);\r\n\t\tbox2d.b2MulXV(transformA, wALocal, v.wA);\r\n\t\tbox2d.b2MulXV(transformB, wBLocal, v.wB);\r\n\t\tbox2d.b2SubVV(v.wB, v.wA, v.w);\r\n\t\tv.a = 1;\r\n\t\tthis.m_count = 1;\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SimplexCache} cache \r\n */\r\nbox2d.b2Simplex.prototype.WriteCache = function (cache)\r\n{\r\n\tcache.metric = this.GetMetric();\r\n\tcache.count = this.m_count;\r\n\t/** @type {Array.<box2d.b2SimplexVertex>} */ var vertices = this.m_vertices;\r\n\tfor (var i = 0; i < this.m_count; ++i)\r\n\t{\r\n\t\tcache.indexA[i] = vertices[i].indexA;\r\n\t\tcache.indexB[i] = vertices[i].indexB;\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Simplex.prototype.GetSearchDirection = function (out)\r\n{\r\n\tswitch (this.m_count)\r\n\t{\r\n\tcase 1:\r\n\t\treturn box2d.b2NegV(this.m_v1.w, out);\r\n\r\n\tcase 2:\r\n\t\t{\r\n\t\t\tvar e12 = box2d.b2SubVV(this.m_v2.w, this.m_v1.w, out);\r\n\t\t\tvar sgn = box2d.b2CrossVV(e12, box2d.b2NegV(this.m_v1.w, box2d.b2Vec2.s_t0));\r\n\t\t\tif (sgn > 0)\r\n\t\t\t{\r\n\t\t\t\t// Origin is left of e12.\r\n\t\t\t\treturn box2d.b2CrossOneV(e12, out);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Origin is right of e12.\r\n\t\t\t\treturn box2d.b2CrossVOne(e12, out);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\tdefault:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\treturn out.SetZero();\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Simplex.prototype.GetClosestPoint = function (out)\r\n{\r\n\tswitch (this.m_count)\r\n\t{\r\n\tcase 0:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\treturn out.SetZero();\r\n\r\n\tcase 1:\r\n\t\treturn out.Copy(this.m_v1.w);\r\n\r\n\tcase 2:\r\n\t\treturn out.SetXY(\r\n\t\t\tthis.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, \r\n\t\t\tthis.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);\r\n\r\n\tcase 3:\r\n\t\treturn out.SetZero();\r\n\r\n\tdefault:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\treturn out.SetZero();\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} pA\r\n * @param {box2d.b2Vec2} pB \r\n */\r\nbox2d.b2Simplex.prototype.GetWitnessPoints = function (pA, pB)\r\n{\r\n\tswitch (this.m_count)\r\n\t{\r\n\tcase 0:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\tbreak;\r\n\r\n\tcase 1:\r\n\t\tpA.Copy(this.m_v1.wA);\r\n\t\tpB.Copy(this.m_v1.wB);\r\n\t\tbreak;\r\n\r\n\tcase 2:\r\n\t\tpA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;\r\n\t\tpA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;\r\n\t\tpB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;\r\n\t\tpB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;\r\n\t\tbreak;\r\n\r\n\tcase 3:\r\n\t\tpB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;\r\n\t\tpB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Simplex.prototype.GetMetric = function ()\r\n{\r\n\tswitch (this.m_count)\r\n\t{\r\n\tcase 0:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\treturn 0;\r\n\r\n\tcase 1:\r\n\t\treturn 0;\r\n\r\n\tcase 2:\r\n\t\treturn box2d.b2DistanceVV(this.m_v1.w, this.m_v2.w);\r\n\r\n\tcase 3:\r\n\t\treturn box2d.b2CrossVV(box2d.b2SubVV(this.m_v2.w, this.m_v1.w, box2d.b2Vec2.s_t0), box2d.b2SubVV(this.m_v3.w, this.m_v1.w, box2d.b2Vec2.s_t1));\r\n\r\n\tdefault:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n/** \r\n * Solve a line segment using barycentric coordinates.\r\n *\r\n * p = a1 * w1 + a2 * w2\r\n * a1 + a2 = 1\r\n *\r\n * The vector from the origin to the closest point on the line is\r\n * perpendicular to the line.\r\n * e12 = w2 - w1\r\n * dot(p, e) = 0\r\n * a1 * dot(w1, e) + a2 * dot(w2, e) = 0\r\n *\r\n * 2-by-2 linear system\r\n * [1      1     ][a1] = [1]\r\n * [w1.e12 w2.e12][a2] = [0]\r\n *\r\n * Define\r\n * d12_1 =  dot(w2, e12)\r\n * d12_2 = -dot(w1, e12)\r\n * d12 = d12_1 + d12_2\r\n *\r\n * Solution\r\n * a1 = d12_1 / d12\r\n * a2 = d12_2 / d12\r\n *  \r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Simplex.prototype.Solve2 = function ()\r\n{\r\n\t/** @type {box2d.b2Vec2} */ var w1 = this.m_v1.w;\r\n\t/** @type {box2d.b2Vec2} */ var w2 = this.m_v2.w;\r\n\t/** @type {box2d.b2Vec2} */ var e12 = box2d.b2SubVV(w2, w1, box2d.b2Simplex.s_e12);\r\n\r\n\t// w1 region\r\n\t/** @type {number} */ var d12_2 = (-box2d.b2DotVV(w1, e12));\r\n\tif (d12_2 <= 0)\r\n\t{\r\n\t\t// a2 <= 0, so we clamp it to 0\r\n\t\tthis.m_v1.a = 1;\r\n\t\tthis.m_count = 1;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// w2 region\r\n\t/** @type {number} */ var d12_1 = box2d.b2DotVV(w2, e12);\r\n\tif (d12_1 <= 0)\r\n\t{\r\n\t\t// a1 <= 0, so we clamp it to 0\r\n\t\tthis.m_v2.a = 1;\r\n\t\tthis.m_count = 1;\r\n\t\tthis.m_v1.Copy(this.m_v2);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Must be in e12 region.\r\n\t/** @type {number} */ var inv_d12 = 1 / (d12_1 + d12_2);\r\n\tthis.m_v1.a = d12_1 * inv_d12;\r\n\tthis.m_v2.a = d12_2 * inv_d12;\r\n\tthis.m_count = 2;\r\n}\r\n\r\n/**\r\n * Possible regions:\r\n * - points[2]\r\n * - edge points[0]-points[2]\r\n * - edge points[1]-points[2]\r\n * - inside the triangle\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Simplex.prototype.Solve3 = function ()\r\n{\r\n\t/** @type {box2d.b2Vec2} */ var w1 = this.m_v1.w;\r\n\t/** @type {box2d.b2Vec2} */ var w2 = this.m_v2.w;\r\n\t/** @type {box2d.b2Vec2} */ var w3 = this.m_v3.w;\r\n\r\n\t// Edge12\r\n\t// [1      1     ][a1] = [1]\r\n\t// [w1.e12 w2.e12][a2] = [0]\r\n\t// a3 = 0\r\n\t/** @type {box2d.b2Vec2} */ var e12 = box2d.b2SubVV(w2, w1, box2d.b2Simplex.s_e12);\r\n\t/** @type {number} */ var w1e12 = box2d.b2DotVV(w1, e12);\r\n\t/** @type {number} */ var w2e12 = box2d.b2DotVV(w2, e12);\r\n\t/** @type {number} */ var d12_1 = w2e12;\r\n\t/** @type {number} */ var d12_2 = (-w1e12);\r\n\r\n\t// Edge13\r\n\t// [1      1     ][a1] = [1]\r\n\t// [w1.e13 w3.e13][a3] = [0]\r\n\t// a2 = 0\r\n\t/** @type {box2d.b2Vec2} */ var e13 = box2d.b2SubVV(w3, w1, box2d.b2Simplex.s_e13);\r\n\t/** @type {number} */ var w1e13 = box2d.b2DotVV(w1, e13);\r\n\t/** @type {number} */ var w3e13 = box2d.b2DotVV(w3, e13);\r\n\t/** @type {number} */ var d13_1 = w3e13;\r\n\t/** @type {number} */ var d13_2 = (-w1e13);\r\n\r\n\t// Edge23\r\n\t// [1      1     ][a2] = [1]\r\n\t// [w2.e23 w3.e23][a3] = [0]\r\n\t// a1 = 0\r\n\t/** @type {box2d.b2Vec2} */ var e23 = box2d.b2SubVV(w3, w2, box2d.b2Simplex.s_e23);\r\n\t/** @type {number} */ var w2e23 = box2d.b2DotVV(w2, e23);\r\n\t/** @type {number} */ var w3e23 = box2d.b2DotVV(w3, e23);\r\n\t/** @type {number} */ var d23_1 = w3e23;\r\n\t/** @type {number} */ var d23_2 = (-w2e23);\r\n\r\n\t// Triangle123\r\n\t/** @type {number} */ var n123 = box2d.b2CrossVV(e12, e13);\r\n\r\n\t/** @type {number} */ var d123_1 = n123 * box2d.b2CrossVV(w2, w3);\r\n\t/** @type {number} */ var d123_2 = n123 * box2d.b2CrossVV(w3, w1);\r\n\t/** @type {number} */ var d123_3 = n123 * box2d.b2CrossVV(w1, w2);\r\n\r\n\t// w1 region\r\n\tif (d12_2 <= 0 && d13_2 <= 0)\r\n\t{\r\n\t\tthis.m_v1.a = 1;\r\n\t\tthis.m_count = 1;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// e12\r\n\tif (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0)\r\n\t{\r\n\t\t/** @type {number} */ var inv_d12 = 1 / (d12_1 + d12_2);\r\n\t\tthis.m_v1.a = d12_1 * inv_d12;\r\n\t\tthis.m_v2.a = d12_2 * inv_d12;\r\n\t\tthis.m_count = 2;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// e13\r\n\tif (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0)\r\n\t{\r\n\t\t/** @type {number} */ var inv_d13 = 1 / (d13_1 + d13_2);\r\n\t\tthis.m_v1.a = d13_1 * inv_d13;\r\n\t\tthis.m_v3.a = d13_2 * inv_d13;\r\n\t\tthis.m_count = 2;\r\n\t\tthis.m_v2.Copy(this.m_v3);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// w2 region\r\n\tif (d12_1 <= 0 && d23_2 <= 0)\r\n\t{\r\n\t\tthis.m_v2.a = 1;\r\n\t\tthis.m_count = 1;\r\n\t\tthis.m_v1.Copy(this.m_v2);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// w3 region\r\n\tif (d13_1 <= 0 && d23_1 <= 0)\r\n\t{\r\n\t\tthis.m_v3.a = 1;\r\n\t\tthis.m_count = 1;\r\n\t\tthis.m_v1.Copy(this.m_v3);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// e23\r\n\tif (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0)\r\n\t{\r\n\t\t/** @type {number} */ var inv_d23 = 1 / (d23_1 + d23_2);\r\n\t\tthis.m_v2.a = d23_1 * inv_d23;\r\n\t\tthis.m_v3.a = d23_2 * inv_d23;\r\n\t\tthis.m_count = 2;\r\n\t\tthis.m_v1.Copy(this.m_v3);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Must be in triangle123\r\n\t/** @type {number} */ var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);\r\n\tthis.m_v1.a = d123_1 * inv_d123;\r\n\tthis.m_v2.a = d123_2 * inv_d123;\r\n\tthis.m_v3.a = d123_3 * inv_d123;\r\n\tthis.m_count = 3;\r\n}\r\nbox2d.b2Simplex.s_e12 = new box2d.b2Vec2();\r\nbox2d.b2Simplex.s_e13 = new box2d.b2Vec2();\r\nbox2d.b2Simplex.s_e23 = new box2d.b2Vec2();\r\n\r\n/** \r\n * Compute the closest points between two shapes. Supports any combination of:\r\n * box2d.b2CircleShape, box2d.b2PolygonShape, box2d.b2EdgeShape. The simplex cache is input/output.\r\n * On the first call set box2d.b2SimplexCache.count to zero.\r\n * @export \r\n * @param {box2d.b2DistanceOutput} output \r\n * @param {box2d.b2SimplexCache} cache \r\n * @param {box2d.b2DistanceInput} input \r\n * @return {void} \r\n */\r\nbox2d.b2Distance = function (output, cache, input)\r\n{\r\n\t++box2d.b2_gjkCalls;\r\n\r\n\tvar proxyA = input.proxyA;\r\n\tvar proxyB = input.proxyB;\r\n\r\n\tvar transformA = input.transformA;\r\n\tvar transformB = input.transformB;\r\n\r\n\t// Initialize the simplex.\r\n\t/** @type {box2d.b2Simplex} */ var simplex = box2d.b2Distance.s_simplex;\r\n\tsimplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);\r\n\r\n\t// Get simplex vertices as an array.\r\n\t/** @type {Array.<box2d.b2SimplexVertex>} */ var vertices = simplex.m_vertices;\r\n\t/** @type {number} */ var k_maxIters = 20;\r\n\r\n\t// These store the vertices of the last simplex so that we\r\n\t// can check for duplicates and prevent cycling.\r\n\t/** @type {Array.<number>} */ var saveA = box2d.b2Distance.s_saveA;\r\n\t/** @type {Array.<number>} */ var saveB = box2d.b2Distance.s_saveB;\r\n\t/** @type {number} */ var saveCount = 0;\r\n\r\n\t/** @type {number} */ var distanceSqr1 = box2d.b2_maxFloat;\r\n\t/** @type {number} */ var distanceSqr2 = distanceSqr1;\r\n\r\n\t// Main iteration loop.\r\n\tvar iter = 0;\r\n\twhile (iter < k_maxIters)\r\n\t{\r\n\t\t// Copy simplex so we can identify duplicates.\r\n\t\tsaveCount = simplex.m_count;\r\n\t\tfor (var i = 0; i < saveCount; ++i)\r\n\t\t{\r\n\t\t\tsaveA[i] = vertices[i].indexA;\r\n\t\t\tsaveB[i] = vertices[i].indexB;\r\n\t\t}\r\n\r\n\t\tswitch (simplex.m_count)\r\n\t\t{\r\n\t\tcase 1:\r\n\t\t\tbreak;\r\n\r\n\t\tcase 2:\r\n\t\t\tsimplex.Solve2();\r\n\t\t\tbreak;\r\n\r\n\t\tcase 3:\r\n\t\t\tsimplex.Solve3();\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\t}\r\n\r\n\t\t// If we have 3 points, then the origin is in the corresponding triangle.\r\n\t\tif (simplex.m_count === 3)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Compute closest point.\r\n\t\t/** @type {box2d.b2Vec2} */ var p = simplex.GetClosestPoint(box2d.b2Distance.s_p);\r\n\t\tdistanceSqr2 = p.GetLengthSquared();\r\n\r\n\t\t// Ensure progress\r\n\t\t/*\r\n\t\tTODO: to fix compile warning\r\n\t\tif (distanceSqr2 > distanceSqr1)\r\n\t\t{\r\n\t\t\t//break;\r\n\t\t}\r\n\t\t*/\r\n\t\tdistanceSqr1 = distanceSqr2;\r\n\r\n\t\t// Get search direction.\r\n\t\t/** @type {box2d.b2Vec2} */ var d = simplex.GetSearchDirection(box2d.b2Distance.s_d);\r\n\r\n\t\t// Ensure the search direction is numerically fit.\r\n\t\tif (d.GetLengthSquared() < box2d.b2_epsilon_sq)\r\n\t\t{\r\n\t\t\t// The origin is probably contained by a line segment\r\n\t\t\t// or triangle. Thus the shapes are overlapped.\r\n\r\n\t\t\t// We can't return zero here even though there may be overlap.\r\n\t\t\t// In case the simplex is a point, segment, or triangle it is difficult\r\n\t\t\t// to determine if the origin is contained in the CSO or very close to it.\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Compute a tentative new simplex vertex using support points.\r\n\t\t/** @type {box2d.b2SimplexVertex} */ var vertex = vertices[simplex.m_count];\r\n\t\tvertex.indexA = proxyA.GetSupport(box2d.b2MulTRV(transformA.q, box2d.b2NegV(d, box2d.b2Vec2.s_t0), box2d.b2Distance.s_supportA));\r\n\t\tbox2d.b2MulXV(transformA, proxyA.GetVertex(vertex.indexA), vertex.wA);\r\n\t\tvertex.indexB = proxyB.GetSupport(box2d.b2MulTRV(transformB.q, d, box2d.b2Distance.s_supportB));\r\n\t\tbox2d.b2MulXV(transformB, proxyB.GetVertex(vertex.indexB), vertex.wB);\r\n\t\tbox2d.b2SubVV(vertex.wB, vertex.wA, vertex.w);\r\n\r\n\t\t// Iteration count is equated to the number of support point calls.\r\n\t\t++iter;\r\n\t\t++box2d.b2_gjkIters;\r\n\r\n\t\t// Check for duplicate support points. This is the main termination criteria.\r\n\t\t/** @type {boolean} */ var duplicate = false;\r\n\t\tfor (var i = 0; i < saveCount; ++i)\r\n\t\t{\r\n\t\t\tif (vertex.indexA === saveA[i] && vertex.indexB === saveB[i])\r\n\t\t\t{\r\n\t\t\t\tduplicate = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If we found a duplicate support point we must exit to avoid cycling.\r\n\t\tif (duplicate)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// New vertex is ok and needed.\r\n\t\t++simplex.m_count;\r\n\t}\r\n\r\n\tbox2d.b2_gjkMaxIters = box2d.b2Max(box2d.b2_gjkMaxIters, iter);\r\n\r\n\t// Prepare output.\r\n\tsimplex.GetWitnessPoints(output.pointA, output.pointB);\r\n\toutput.distance = box2d.b2DistanceVV(output.pointA, output.pointB);\r\n\toutput.iterations = iter;\r\n\r\n\t// Cache the simplex.\r\n\tsimplex.WriteCache(cache);\r\n\r\n\t// Apply radii if requested.\r\n\tif (input.useRadii)\r\n\t{\r\n\t\t/** @type {number} */ var rA = proxyA.m_radius;\r\n\t\t/** @type {number} */ var rB = proxyB.m_radius;\r\n\r\n\t\tif (output.distance > (rA + rB) && output.distance > box2d.b2_epsilon)\r\n\t\t{\r\n\t\t\t// Shapes are still no overlapped.\r\n\t\t\t// Move the witness points to the outer surface.\r\n\t\t\toutput.distance -= rA + rB;\r\n\t\t\t/** @type {box2d.b2Vec2} */ var normal = box2d.b2SubVV(output.pointB, output.pointA, box2d.b2Distance.s_normal);\r\n\t\t\tnormal.Normalize();\r\n\t\t\toutput.pointA.SelfMulAdd(rA, normal);\r\n\t\t\toutput.pointB.SelfMulSub(rB, normal);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Shapes are overlapped when radii are considered.\r\n\t\t\t// Move the witness points to the middle.\r\n\t\t\t/** type {box2d.b2Vec2} */ var p = box2d.b2MidVV(output.pointA, output.pointB, box2d.b2Distance.s_p);\r\n\t\t\toutput.pointA.Copy(p);\r\n\t\t\toutput.pointB.Copy(p);\r\n\t\t\toutput.distance = 0;\r\n\t\t}\r\n\t}\r\n}\r\nbox2d.b2Distance.s_simplex = new box2d.b2Simplex();\r\nbox2d.b2Distance.s_saveA = box2d.b2MakeNumberArray(3);\r\nbox2d.b2Distance.s_saveB = box2d.b2MakeNumberArray(3);\r\nbox2d.b2Distance.s_p = new box2d.b2Vec2();\r\nbox2d.b2Distance.s_d = new box2d.b2Vec2();\r\nbox2d.b2Distance.s_normal = new box2d.b2Vec2();\r\nbox2d.b2Distance.s_supportA = new box2d.b2Vec2();\r\nbox2d.b2Distance.s_supportB = new box2d.b2Vec2();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2WeldJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Weld joint definition. You need to specify local anchor \r\n * points where they are attached and the relative body angle. \r\n * The position of the anchor points is important for computing \r\n * the reaction torque. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2WeldJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_weldJoint); // base class constructor\r\n\r\n\tthis.localAnchorA = new box2d.b2Vec2();\r\n\tthis.localAnchorB = new box2d.b2Vec2();\r\n}\r\n\r\ngoog.inherits(box2d.b2WeldJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJointDef.prototype.localAnchorA = null;\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJointDef.prototype.localAnchorB = null;\r\n\r\n/** \r\n * The bodyB angle minus bodyA angle in the reference state \r\n * (radians). \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJointDef.prototype.referenceAngle = 0;\r\n\r\n/** \r\n * The mass-spring-damper frequency in Hertz. Rotation only. \r\n * Disable softness with a value of 0. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJointDef.prototype.frequencyHz = 0;\r\n\r\n/** \r\n * The damping ratio. 0 = no damping, 1 = critical damping. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJointDef.prototype.dampingRatio = 0;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} bA \r\n * @param {box2d.b2Body} bB \r\n * @param {box2d.b2Vec2} anchor \r\n */\r\nbox2d.b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor)\r\n{\r\n\tthis.bodyA = bA;\r\n\tthis.bodyB = bB;\r\n\tthis.bodyA.GetLocalPoint(anchor, this.localAnchorA);\r\n\tthis.bodyB.GetLocalPoint(anchor, this.localAnchorB);\r\n\tthis.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians();\r\n}\r\n\r\n/** \r\n * A weld joint essentially glues two bodies together. A weld \r\n * joint may distort somewhat because the island constraint \r\n * solver is approximate. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2WeldJointDef} def \r\n */\r\nbox2d.b2WeldJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_frequencyHz = def.frequencyHz;\r\n\tthis.m_dampingRatio = def.dampingRatio;\r\n\r\n\tthis.m_localAnchorA = def.localAnchorA.Clone();\r\n\tthis.m_localAnchorB = def.localAnchorB.Clone();\r\n\tthis.m_referenceAngle = def.referenceAngle;\r\n\tthis.m_impulse = new box2d.b2Vec3(0, 0, 0);\r\n\r\n\tthis.m_rA = new box2d.b2Vec2();\r\n\tthis.m_rB = new box2d.b2Vec2();\r\n\tthis.m_localCenterA = new box2d.b2Vec2();\r\n\tthis.m_localCenterB = new box2d.b2Vec2();\r\n\tthis.m_mass = new box2d.b2Mat33();\r\n\r\n\tthis.m_qA = new box2d.b2Rot();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_lalcA = new box2d.b2Vec2();\r\n\tthis.m_lalcB = new box2d.b2Vec2();\r\n\tthis.m_K = new box2d.b2Mat33();\r\n}\r\n\r\ngoog.inherits(box2d.b2WeldJoint, box2d.b2Joint);\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_frequencyHz = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_dampingRatio = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_bias = 0;\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_localAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_localAnchorB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_referenceAngle = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_gamma = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec3}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_impulse = null;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_rB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_invIB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat33}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_mass = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_lalcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_lalcB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat33}\r\n */\r\nbox2d.b2WeldJoint.prototype.m_K = null;\r\n\r\n/**\r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2WeldJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassA = this.m_bodyA.m_invMass;\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIA = this.m_bodyA.m_invI;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n//\tm_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tbox2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tm_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tbox2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n\t// J = [-I -r1_skew I r2_skew]\r\n\t//     [ 0       -1 0       1]\r\n\t// r_skew = [-ry; rx]\r\n\r\n\t// Matlab\r\n\t// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]\r\n\t//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]\r\n\t//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t/*b2Mat33*/ var K = this.m_K;\r\n\tK.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\r\n\tK.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\r\n\tK.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\r\n\tK.ex.y = K.ey.x;\r\n\tK.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\r\n\tK.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\r\n\tK.ex.z = K.ez.x;\r\n\tK.ey.z = K.ez.y;\r\n\tK.ez.z = iA + iB;\r\n\r\n\tif (this.m_frequencyHz > 0)\r\n\t{\r\n\t\tK.GetInverse22(this.m_mass);\r\n\r\n\t\t/*float32*/ var invM = iA + iB;\r\n\t\t/*float32*/ var m = invM > 0 ? 1 / invM : 0;\r\n\r\n\t\t/*float32*/ var C = aB - aA - this.m_referenceAngle;\r\n\r\n\t\t// Frequency\r\n\t\t/*float32*/ var omega = 2 * box2d.b2_pi * this.m_frequencyHz;\r\n\r\n\t\t// Damping coefficient\r\n\t\t/*float32*/ var d = 2 * m * this.m_dampingRatio * omega;\r\n\r\n\t\t// Spring stiffness\r\n\t\t/*float32*/ var k = m * omega * omega;\r\n\r\n\t\t// magic formulas\r\n\t\t/*float32*/ var h = data.step.dt;\r\n\t\tthis.m_gamma = h * (d + h * k);\r\n\t\tthis.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0;\r\n\t\tthis.m_bias = C * h * k * this.m_gamma;\r\n\r\n\t\tinvM += this.m_gamma;\r\n\t\tthis.m_mass.ez.z = invM !== 0 ? 1 / invM : 0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tK.GetSymInverse33(this.m_mass);\r\n\t\tthis.m_gamma = 0;\r\n\t\tthis.m_bias = 0;\r\n\t}\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\t// Scale impulses to support a variable time step.\r\n\t\tthis.m_impulse.SelfMul(data.step.dtRatio);\r\n\r\n//\t\tbox2d.b2Vec2 P(m_impulse.x, m_impulse.y);\r\n\t\tvar P = box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * (box2d.b2CrossVV(this.m_rA, P) + this.m_impulse.z);\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * (box2d.b2CrossVV(this.m_rB, P) + this.m_impulse.z);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse.SetZero();\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2WeldJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\tif (this.m_frequencyHz > 0)\r\n\t{\r\n\t\t/*float32*/ var Cdot2 = wB - wA;\r\n\r\n\t\t/*float32*/ var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);\r\n\t\tthis.m_impulse.z += impulse2;\r\n\r\n\t\twA -= iA * impulse2;\r\n\t\twB += iB * impulse2;\r\n\r\n//\t\tb2Vec2 Cdot1 = vB + b2CrossSV(wB, this.m_rB) - vA - b2CrossSV(wA, this.m_rA);\r\n\t\tvar Cdot1 = box2d.b2SubVV(\r\n\t\t\tbox2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1),\r\n\t\t\tbox2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1)\r\n\r\n//\t\tb2Vec2 impulse1 = -b2Mul22(m_mass, Cdot1);\r\n\t\tvar impulse1 = box2d.b2MulM33XY(this.m_mass, Cdot1.x, Cdot1.y, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1).SelfNeg();\r\n\t\tthis.m_impulse.x += impulse1.x;\r\n\t\tthis.m_impulse.y += impulse1.y;\r\n\r\n//\t\tb2Vec2 P = impulse1;\r\n\t\tvar P = impulse1;\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n//\t\twA -= iA * b2Cross(m_rA, P);\r\n\t\twA -= iA * box2d.b2CrossVV(this.m_rA, P);\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n//\t\twB += iB * b2Cross(m_rB, P);\r\n\t\twB += iB * box2d.b2CrossVV(this.m_rB, P);\r\n\t}\r\n\telse\r\n\t{\r\n//\t\tb2Vec2 Cdot1 = vB + b2Cross(wB, this.m_rB) - vA - b2Cross(wA, this.m_rA);\r\n\t\tvar Cdot1 = box2d.b2SubVV(\r\n\t\t\tbox2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1),\r\n\t\t\tbox2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1)\r\n\t\t/*float32*/ var Cdot2 = wB - wA;\r\n//\t\tb2Vec3 var Cdot(Cdot1.x, Cdot1.y, Cdot2);\r\n\t\r\n//\t\tb2Vec3 impulse = -b2Mul(m_mass, Cdot);\r\n\t\tvar impulse = box2d.b2MulM33XYZ(this.m_mass, Cdot1.x, Cdot1.y, Cdot2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();\r\n\t\tthis.m_impulse.SelfAdd(impulse);\r\n\t\r\n//\t\tbox2d.b2Vec2 P(impulse.x, impulse.y);\r\n\t\tvar P = box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P.SetXY(impulse.x, impulse.y);\r\n\t\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * (box2d.b2CrossVV(this.m_rA, P) + impulse.z);\r\n\t\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * (box2d.b2CrossVV(this.m_rB, P) + impulse.z);\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2();\r\nbox2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1 = new box2d.b2Vec2();\r\nbox2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec3();\r\nbox2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2WeldJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n//\tb2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tb2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n\t/*float32*/ var positionError, angularError;\r\n\r\n\t/*b2Mat33*/ var K = this.m_K;\r\n\tK.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\r\n\tK.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\r\n\tK.ez.x = -rA.y * iA - rB.y * iB;\r\n\tK.ex.y = K.ey.x;\r\n\tK.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\r\n\tK.ez.y = rA.x * iA + rB.x * iB;\r\n\tK.ex.z = K.ez.x;\r\n\tK.ey.z = K.ez.y;\r\n\tK.ez.z = iA + iB;\r\n\r\n\tif (this.m_frequencyHz > 0)\r\n\t{\r\n//\t\tb2Vec2 C1 =  cB + rB - cA - rA;\r\n\t\tvar C1 = \r\n\t\t\tbox2d.b2SubVV(\r\n\t\t\t\tbox2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), \r\n\t\t\t\tbox2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1);\r\n\t\tpositionError = C1.GetLength();\r\n\t\tangularError = 0;\r\n\r\n//\t\tb2Vec2 P = -K.Solve22(C1);\r\n\t\tvar P = K.Solve22(C1.x, C1.y, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P).SelfNeg();\r\n\r\n//\t\tcA -= mA * P;\r\n\t\tcA.SelfMulSub(mA, P);\r\n\t\taA -= iA * box2d.b2CrossVV(rA, P);\r\n\r\n//\t\tcB += mB * P;\r\n\t\tcB.SelfMulAdd(mB, P);\r\n\t\taB += iB * box2d.b2CrossVV(rB, P);\r\n\t}\r\n\telse\r\n\t{\r\n//\t\tb2Vec2 C1 =  cB + rB - cA - rA;\r\n\t\tvar C1 = \r\n\t\t\tbox2d.b2SubVV(\r\n\t\t\t\tbox2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), \r\n\t\t\t\tbox2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1);\r\n\t\t/*float32*/ var C2 = aB - aA - this.m_referenceAngle;\r\n\t\r\n\t\tpositionError = C1.GetLength();\r\n\t\tangularError = box2d.b2Abs(C2);\r\n\t\r\n//\t\tb2Vec3 C(C1.x, C1.y, C2);\r\n\t\r\n//\t\tb2Vec3 impulse = -K.Solve33(C);\r\n\t\t/*box2d.b2Vec3*/ var impulse = K.Solve33(C1.x, C1.y, C2, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();\r\n\t\r\n//\t\tb2Vec2 P(impulse.x, impulse.y);\r\n\t\tvar P = box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P.SetXY(impulse.x, impulse.y);\r\n\t\r\n//\t\tcA -= mA * P;\r\n\t\tcA.SelfMulSub(mA, P);\r\n\t\taA -= iA * (box2d.b2CrossVV(this.m_rA, P) + impulse.z);\r\n\t\r\n//\t\tcB += mB * P;\r\n\t\tcB.SelfMulAdd(mB, P);\r\n\t\taB += iB * (box2d.b2CrossVV(this.m_rB, P) + impulse.z);\r\n\t}\r\n\r\n//\tdata.positions[this.m_indexA].c = cA;\r\n\tdata.positions[this.m_indexA].a = aA;\r\n//\tdata.positions[this.m_indexB].c = cB;\r\n\tdata.positions[this.m_indexB].a = aB;\r\n\r\n\treturn positionError <= box2d.b2_linearSlop && angularError <= box2d.b2_angularSlop;\r\n}\r\nbox2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1 = new box2d.b2Vec2();\r\nbox2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();\r\nbox2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3();\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2WeldJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2WeldJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2WeldJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n//\tbox2d.b2Vec2 P(this.m_impulse.x, this.m_impulse.y);\r\n//\treturn inv_dt * P;\r\n\treturn out.SetXY(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2WeldJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn inv_dt * this.m_impulse.z;\r\n}\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2WeldJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2WeldJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }\r\n\r\n/** \r\n * Get the reference angle. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.GetReferenceAngle = function () { return this.m_referenceAngle; }\r\n\r\n/** \r\n * Set/get frequency in Hz. \r\n * @return {void} \r\n * @param {number} hz \r\n */\r\nbox2d.b2WeldJoint.prototype.SetFrequency = function (hz) { this.m_frequencyHz = hz; }\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.GetFrequency = function () { return this.m_frequencyHz; }\r\n\r\n/** \r\n * Set/get damping ratio. \r\n * @return {void} \r\n * @param {number} ratio \r\n */\r\nbox2d.b2WeldJoint.prototype.SetDampingRatio = function (ratio) { this.m_dampingRatio = ratio; }\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2WeldJoint.prototype.GetDampingRatio = function () { return this.m_dampingRatio; }\r\n\r\n/** \r\n * Dump to b2Log \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2WeldJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\t\r\n\t\tbox2d.b2Log(\"  /*box2d.b2WeldJointDef*/ var jd = new box2d.b2WeldJointDef();\\n\");\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.localAnchorA.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n\t\tbox2d.b2Log(\"  jd.localAnchorB.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n\t\tbox2d.b2Log(\"  jd.referenceAngle = %.15f;\\n\", this.m_referenceAngle);\r\n\t\tbox2d.b2Log(\"  jd.frequencyHz = %.15f;\\n\", this.m_frequencyHz);\r\n\t\tbox2d.b2Log(\"  jd.dampingRatio = %.15f;\\n\", this.m_dampingRatio);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2RopeJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Rope joint definition. This requires two body anchor points \r\n * and a maximum lengths. \r\n * Note: by default the connected objects will not collide. see \r\n * collideConnected in box2d.b2JointDef. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2RopeJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_ropeJoint); // base class constructor\r\n\r\n\tthis.localAnchorA = new box2d.b2Vec2(-1, 0);\r\n\tthis.localAnchorB = new box2d.b2Vec2(1, 0);\r\n}\r\n\r\ngoog.inherits(box2d.b2RopeJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJointDef.prototype.localAnchorA = null;\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJointDef.prototype.localAnchorB = null;\r\n\r\n/** \r\n * The maximum length of the rope. \r\n * Warning: this must be larger than box2d.b2_linearSlop or the \r\n * joint will have no effect. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJointDef.prototype.maxLength = 0;\r\n\r\n/** \r\n * A rope joint enforces a maximum distance between two points \r\n * on two bodies. It has no other effect. \r\n * Warning: if you attempt to change the maximum length during \r\n * the simulation you will get some non-physical behavior. A \r\n * model that would allow you to dynamically modify the length \r\n * would have some sponginess, so I chose not to implement it \r\n * that way. See box2d.b2DistanceJoint if you want to \r\n * dynamically control length. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2RopeJointDef} def \r\n */\r\nbox2d.b2RopeJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_localAnchorA = def.localAnchorA.Clone();\r\n\tthis.m_localAnchorB = def.localAnchorB.Clone();\r\n\tthis.m_maxLength = def.maxLength;\r\n\r\n\tthis.m_u = new box2d.b2Vec2();\r\n\tthis.m_rA = new box2d.b2Vec2();\r\n\tthis.m_rB = new box2d.b2Vec2();\r\n\tthis.m_localCenterA = new box2d.b2Vec2();\r\n\tthis.m_localCenterB = new box2d.b2Vec2();\r\n\r\n\tthis.m_qA = new box2d.b2Rot();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_lalcA = new box2d.b2Vec2();\r\n\tthis.m_lalcB = new box2d.b2Vec2();\r\n}\r\n\r\ngoog.inherits(box2d.b2RopeJoint, box2d.b2Joint);\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_localAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_localAnchorB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_maxLength = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_length = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_impulse = 0;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_u = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_rB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_invIB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_mass = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2LimitState}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_state = box2d.b2LimitState.e_inactiveLimit;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_lalcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RopeJoint.prototype.m_lalcB = null;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2RopeJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassA = this.m_bodyA.m_invMass;\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIA = this.m_bodyA.m_invI;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n//\tthis.m_rA = b2Mul(qA, this.m_localAnchorA - this.m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tbox2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tthis.m_rB = b2Mul(qB, this.m_localAnchorB - this.m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tbox2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n//\tthis.m_u = cB + this.m_rB - cA - this.m_rA;\r\n\tthis.m_u.Copy(cB).SelfAdd(this.m_rB).SelfSub(cA).SelfSub(this.m_rA);\r\n\r\n\tthis.m_length = this.m_u.GetLength();\r\n\r\n\t/*float32*/ var C = this.m_length - this.m_maxLength;\r\n\tif (C > 0)\r\n\t{\r\n\t\tthis.m_state = box2d.b2LimitState.e_atUpperLimit;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_state = box2d.b2LimitState.e_inactiveLimit;\r\n\t}\r\n\r\n\tif (this.m_length > box2d.b2_linearSlop)\r\n\t{\r\n\t\tthis.m_u.SelfMul(1 / this.m_length);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_u.SetZero();\r\n\t\tthis.m_mass = 0;\r\n\t\tthis.m_impulse = 0;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Compute effective mass.\r\n\t/*float32*/ var crA = box2d.b2CrossVV(this.m_rA, this.m_u);\r\n\t/*float32*/ var crB = box2d.b2CrossVV(this.m_rB, this.m_u);\r\n\t/*float32*/ var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;\r\n\r\n\tthis.m_mass = invMass !== 0 ? 1 / invMass : 0;\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\t// Scale the impulse to support a variable time step.\r\n\t\tthis.m_impulse *= data.step.dtRatio;\r\n\r\n//\t\tb2Vec2 P = m_impulse * m_u;\r\n\t\tvar P = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P);\r\n//\t\tvA -= m_invMassA * P;\r\n\t\tvA.SelfMulSub(this.m_invMassA, P);\r\n\t\twA -= this.m_invIA * box2d.b2CrossVV(this.m_rA, P);\r\n//\t\tvB += m_invMassB * P;\r\n\t\tvB.SelfMulAdd(this.m_invMassB, P);\r\n\t\twB += this.m_invIB * box2d.b2CrossVV(this.m_rB, P);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse = 0;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2RopeJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t// Cdot = dot(u, v + cross(w, r))\r\n//\tb2Vec2 vpA = vA + b2Cross(wA, m_rA);\r\n\tvar vpA = box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA);\r\n//\tb2Vec2 vpB = vB + b2Cross(wB, m_rB);\r\n\tvar vpB = box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB);\r\n//\tfloat32 C = m_length - m_maxLength;\r\n\t/*float32*/ var C = this.m_length - this.m_maxLength;\r\n//\tfloat32 Cdot = b2Dot(m_u, vpB - vpA);\r\n\t/*float32*/ var Cdot = box2d.b2DotVV(this.m_u, box2d.b2SubVV(vpB, vpA, box2d.b2Vec2.s_t0));\r\n\r\n\t// Predictive constraint.\r\n\tif (C < 0)\r\n\t{\r\n\t\tCdot += data.step.inv_dt * C;\r\n\t}\r\n\r\n\t/*float32*/ var impulse = -this.m_mass * Cdot;\r\n\t/*float32*/ var oldImpulse = this.m_impulse;\r\n\tthis.m_impulse = box2d.b2Min(0, this.m_impulse + impulse);\r\n\timpulse = this.m_impulse - oldImpulse;\r\n\r\n//\tb2Vec2 P = impulse * m_u;\r\n\tvar P = box2d.b2MulSV(impulse, this.m_u, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P);\r\n//\tvA -= m_invMassA * P;\r\n\tvA.SelfMulSub(this.m_invMassA, P);\r\n\twA -= this.m_invIA * box2d.b2CrossVV(this.m_rA, P);\r\n//\tvB += m_invMassB * P;\r\n\tvB.SelfMulAdd(this.m_invMassB, P);\r\n\twB += this.m_invIB * box2d.b2CrossVV(this.m_rB, P);\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2();\r\nbox2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2();\r\nbox2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2RopeJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n//\tb2Vec2 rA = b2Mul(qA, this.m_localAnchorA - this.m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tb2Vec2 rB = b2Mul(qB, this.m_localAnchorB - this.m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n//\tb2Vec2 u = cB + rB - cA - rA;\r\n\t/*box2d.b2Vec2*/ var u = this.m_u.Copy(cB).SelfAdd(rB).SelfSub(cA).SelfSub(rA);\r\n\r\n\t/*float32*/ var length = u.Normalize();\r\n\t/*float32*/ var C = length - this.m_maxLength;\r\n\r\n\tC = box2d.b2Clamp(C, 0, box2d.b2_maxLinearCorrection);\r\n\r\n\t/*float32*/ var impulse = -this.m_mass * C;\r\n//\tb2Vec2 P = impulse * u;\r\n\tvar P = box2d.b2MulSV(impulse, u, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P);\r\n\r\n//\tcA -= m_invMassA * P;\r\n\tcA.SelfMulSub(this.m_invMassA, P);\r\n\taA -= this.m_invIA * box2d.b2CrossVV(rA, P);\r\n//\tcB += m_invMassB * P;\r\n\tcB.SelfMulAdd(this.m_invMassB, P);\r\n\taB += this.m_invIB * box2d.b2CrossVV(rB, P);\r\n\r\n//\tdata.positions[this.m_indexA].c = cA;\r\n\tdata.positions[this.m_indexA].a = aA;\r\n//\tdata.positions[this.m_indexB].c = cB;\r\n\tdata.positions[this.m_indexB].a = aB;\r\n\r\n\treturn length - this.m_maxLength < box2d.b2_linearSlop;\r\n}\r\nbox2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2RopeJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2RopeJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2RopeJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n\t/*box2d.b2Vec2*/ var F = box2d.b2MulSV((inv_dt * this.m_impulse), this.m_u, out);\r\n\treturn F;\r\n//\treturn out.SetXY(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2RopeJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2RopeJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2RopeJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }\r\n\r\n/** \r\n * Set/Get the maximum length of the rope. \r\n * @export \r\n * @return {void} \r\n * @param {number} length\r\n */\r\nbox2d.b2RopeJoint.prototype.SetMaxLength = function (length) { this.m_maxLength = length; }\r\n/** \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2RopeJoint.prototype.GetMaxLength = function ()\r\n{\r\n\treturn this.m_maxLength;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2LimitState}\r\n */\r\nbox2d.b2RopeJoint.prototype.GetLimitState = function ()\r\n{\r\n\treturn this.m_state;\r\n}\r\n\r\n/** \r\n * Dump joint to dmLog \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2RopeJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\t\r\n\t\tbox2d.b2Log(\"  /*box2d.b2RopeJointDef*/ var jd = new box2d.b2RopeJointDef();\\n\");\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.localAnchorA.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n\t\tbox2d.b2Log(\"  jd.localAnchorB.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n\t\tbox2d.b2Log(\"  jd.maxLength = %.15f;\\n\", this.m_maxLength);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2GravityController');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Controller');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Applies simplified gravity between every pair of bodies \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Controller} \r\n */\r\nbox2d.b2GravityController = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n};\r\n\r\ngoog.inherits(box2d.b2GravityController, box2d.b2Controller);\r\n\r\n/** \r\n * Specifies the strength of the gravitiation force \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2GravityController.prototype.G = 1;\r\n/** \r\n * If true, gravity is proportional to r^-2, otherwise r^-1 \r\n * @export \r\n * @type {boolean} \r\n */\r\nbox2d.b2GravityController.prototype.invSqr = true;\r\n\r\n/** \r\n * @see b2Controller::Step \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TimeStep} step \r\n */\r\nbox2d.b2GravityController.prototype.Step = function (step)\r\n{\r\n\tif (this.invSqr)\r\n\t{\r\n\t\tfor (var i = this.m_bodyList; i; i = i.nextBody)\r\n\t\t{\r\n\t\t\tvar body1 = i.body;\r\n\t\t\tvar p1 = body1.GetWorldCenter();\r\n\t\t\tvar mass1 = body1.GetMass();\r\n\t\t\tfor (var j = this.m_bodyList; j !== i; j = j.nextBody)\r\n\t\t\t{\r\n\t\t\t\tvar body2 = j.body;\r\n\t\t\t\tvar p2 = body2.GetWorldCenter();\r\n\t\t\t\tvar mass2 = body2.GetMass();\r\n\t\t\t\tvar dx = p2.x - p1.x;\r\n\t\t\t\tvar dy = p2.y - p1.y;\r\n\t\t\t\tvar r2 = dx * dx + dy * dy;\r\n\t\t\t\tif (r2 < box2d.b2_epsilon)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar f = box2d.b2GravityController.prototype.Step.s_f.SetXY(dx, dy);\r\n\t\t\t\tf.SelfMul(this.G / r2 / box2d.b2Sqrt(r2) * mass1 * mass2);\r\n\t\t\t\tif (body1.IsAwake())\r\n\t\t\t\t\tbody1.ApplyForce(f, p1);\r\n\t\t\t\tif (body2.IsAwake())\r\n\t\t\t\t\tbody2.ApplyForce(f.SelfMul(-1), p2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor (var i = this.m_bodyList; i; i = i.nextBody)\r\n\t\t{\r\n\t\t\tvar body1 = i.body;\r\n\t\t\tvar p1 = body1.GetWorldCenter();\r\n\t\t\tvar mass1 = body1.GetMass();\r\n\t\t\tfor (var j = this.m_bodyList; j !== i; j = j.nextBody)\r\n\t\t\t{\r\n\t\t\t\tvar body2 = j.body;\r\n\t\t\t\tvar p2 = body2.GetWorldCenter();\r\n\t\t\t\tvar mass2 = body2.GetMass();\r\n\t\t\t\tvar dx = p2.x - p1.x;\r\n\t\t\t\tvar dy = p2.y - p1.y;\r\n\t\t\t\tvar r2 = dx * dx + dy * dy;\r\n\t\t\t\tif (r2 < box2d.b2_epsilon)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar f = box2d.b2GravityController.prototype.Step.s_f.SetXY(dx, dy);\r\n\t\t\t\tf.SelfMul(this.G / r2 * mass1 * mass2);\r\n\t\t\t\tif (body1.IsAwake())\r\n\t\t\t\t\tbody1.ApplyForce(f, p1);\r\n\t\t\t\tif (body2.IsAwake())\r\n\t\t\t\t\tbody2.ApplyForce(f.SelfMul(-1), p2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nbox2d.b2GravityController.prototype.Step.s_f = new box2d.b2Vec2();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2TimeStep');\r\n\r\ngoog.require('box2d.b2Settings');\r\n\r\n/** \r\n * Profiling data. Times are in milliseconds. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Profile = function ()\r\n{\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Profile.prototype.step = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Profile.prototype.collide = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Profile.prototype.solve = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Profile.prototype.solveInit = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Profile.prototype.solveVelocity = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Profile.prototype.solvePosition = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Profile.prototype.broadphase = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Profile.prototype.solveTOI = 0;\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Profile}\r\n */\r\nbox2d.b2Profile.prototype.Reset = function ()\r\n{\r\n\tthis.step = 0;\r\n\tthis.collide = 0;\r\n\tthis.solve = 0;\r\n\tthis.solveInit = 0;\r\n\tthis.solveVelocity = 0;\r\n\tthis.solvePosition = 0;\r\n\tthis.broadphase = 0;\r\n\tthis.solveTOI = 0;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * This is an internal structure. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2TimeStep = function ()\r\n{\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2TimeStep.prototype.dt = 0; // time step\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2TimeStep.prototype.inv_dt = 0; // inverse time step (0 if dt === 0).\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2TimeStep.prototype.dtRatio = 0; // dt * inv_dt0\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2TimeStep.prototype.velocityIterations = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2TimeStep.prototype.positionIterations = 0;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2TimeStep.prototype.warmStarting = false;\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2TimeStep} \r\n * @param {box2d.b2TimeStep} step \r\n */\r\nbox2d.b2TimeStep.prototype.Copy = function (step)\r\n{\r\n\tthis.dt = step.dt;\t\t\t\t// time step                        \r\n\tthis.inv_dt = step.inv_dt;  \t// inverse time step (0 if dt === 0).\r\n\tthis.dtRatio = step.dtRatio;\t// dt * inv_dt0\r\n\tthis.positionIterations = step.positionIterations;\r\n\tthis.velocityIterations = step.velocityIterations;\r\n\tthis.warmStarting = step.warmStarting;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * This is an internal structure. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Position = function ()\r\n{\r\n\tthis.c = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2Position.prototype.c = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Position.prototype.a = 0;\r\n\r\n/** \r\n * @export \r\n * @return {Array.<box2d.b2Position>}\r\n * @param {number} length \r\n */\r\nbox2d.b2Position.MakeArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return new box2d.b2Position(); } );\r\n}\r\n\r\n/** \r\n * This is an internal structure. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Velocity = function ()\r\n{\r\n\tthis.v = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2Velocity.prototype.v = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Velocity.prototype.w = 0;\r\n\r\n/** \r\n * @export \r\n * @return {Array.<box2d.b2Velocity>}\r\n * @param {number} length \r\n */\r\nbox2d.b2Velocity.MakeArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return new box2d.b2Velocity(); } );\r\n}\r\n\r\n/** \r\n * Solver Data \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2SolverData = function ()\r\n{\r\n\tthis.step = new box2d.b2TimeStep();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2TimeStep}\r\n */\r\nbox2d.b2SolverData.prototype.step = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Position>}\r\n */\r\nbox2d.b2SolverData.prototype.positions = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Velocity>}\r\n */\r\nbox2d.b2SolverData.prototype.velocities = null;\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Collision');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2Distance');\r\n\r\n/**\r\n * Structures and functions used for computing contact points, \r\n * distance queries, and TOI queries. \r\n */\r\n\r\n/** \r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2ContactFeatureType = \r\n{\r\n\te_vertex\t: 0,\r\n\te_face\t\t: 1\r\n};\r\ngoog.exportProperty(box2d.b2ContactFeatureType, 'e_vertex', box2d.b2ContactFeatureType.e_vertex);\r\ngoog.exportProperty(box2d.b2ContactFeatureType, 'e_face'  , box2d.b2ContactFeatureType.e_face  );\r\n\r\n/** \r\n * The features that intersect to form the contact point \r\n * This must be 4 bytes or less.\r\n * @export \r\n * @constructor \r\n * @param {box2d.b2ContactID} id \r\n */\r\nbox2d.b2ContactFeature = function (id)\r\n{\r\n\tthis._id = id;\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactID}\r\n */\r\nbox2d.b2ContactFeature.prototype._id = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactFeature.prototype._indexA = 0; ///< Feature index on shapeA   \r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactFeature.prototype._indexB = 0; ///< Feature index on shapeB   \r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactFeature.prototype._typeA = 0; ///< The feature type on shapeA\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactFeature.prototype._typeB = 0; ///< The feature type on shapeB\r\n\r\nObject.defineProperty(\r\n\tbox2d.b2ContactFeature.prototype, 'indexA',\r\n\t{\r\n\t\tenumerable: false,\r\n\t\tconfigurable: true,\r\n\t\t/** @this {box2d.b2ContactFeature} */\r\n\t\tget: function ()\r\n\t\t{\r\n\t\t\treturn this._indexA;\r\n\t\t},\r\n\t\t/** @this {box2d.b2ContactFeature} */\r\n\t\tset: function (value)\r\n\t\t{\r\n\t\t\tthis._indexA = value;\r\n\t\t\t// update the b2ContactID\r\n\t\t\tthis._id._key = (this._id._key & 0xffffff00) | (this._indexA & 0x000000ff);\r\n\t\t}\r\n\t}\r\n);\r\n\r\nObject.defineProperty(\r\n\tbox2d.b2ContactFeature.prototype, 'indexB',\r\n\t{\r\n\t\tenumerable: false,\r\n\t\tconfigurable: true,\r\n\t\t/** @this {box2d.b2ContactFeature} */\r\n\t\tget: function ()\r\n\t\t{\r\n\t\t\treturn this._indexB;\r\n\t\t},\r\n\t\t/** @this {box2d.b2ContactFeature} */\r\n\t\tset: function (value)\r\n\t\t{\r\n\t\t\tthis._indexB = value;\r\n\t\t\t// update the b2ContactID\r\n\t\t\tthis._id._key = (this._id._key & 0xffff00ff) | ((this._indexB << 8) & 0x0000ff00);\r\n\t\t}\r\n\t}\r\n);\r\n\r\nObject.defineProperty(\r\n\tbox2d.b2ContactFeature.prototype, 'typeA',\r\n\t{\r\n\t\tenumerable: false,\r\n\t\tconfigurable: true,\r\n\t\t/** @this {box2d.b2ContactFeature} */\r\n\t\tget: function ()\r\n\t\t{\r\n\t\t\treturn this._typeA;\r\n\t\t},\r\n\t\t/** @this {box2d.b2ContactFeature} */\r\n\t\tset: function (value)\r\n\t\t{\r\n\t\t\tthis._typeA = value;\r\n\t\t\t// update the b2ContactID\r\n\t\t\tthis._id._key = (this._id._key & 0xff00ffff) | ((this._typeA << 16) & 0x00ff0000);\r\n\t\t}\r\n\t}\r\n);\r\n\r\nObject.defineProperty(\r\n\tbox2d.b2ContactFeature.prototype, 'typeB',\r\n\t{\r\n\t\tenumerable: false,\r\n\t\tconfigurable: true,\r\n\t\t/** @this {box2d.b2ContactFeature} */\r\n\t\tget: function ()\r\n\t\t{\r\n\t\t\treturn this._typeB;\r\n\t\t},\r\n\t\t/** @this {box2d.b2ContactFeature} */\r\n\t\tset: function (value)\r\n\t\t{\r\n\t\t\tthis._typeB = value;\r\n\t\t\t// update the b2ContactID\r\n\t\t\tthis._id._key = (this._id._key & 0x00ffffff) | ((this._typeB << 24) & 0xff000000);\r\n\t\t}\r\n\t}\r\n);\r\n\r\n/** \r\n * Contact ids to facilitate warm starting. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2ContactID = function ()\r\n{\r\n\tthis.cf = new box2d.b2ContactFeature(this);\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactFeature}\r\n */\r\nbox2d.b2ContactID.prototype.cf = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactID.prototype.key = 0; ///< Used to quickly compare contact ids.\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2ContactID}\r\n * @param {box2d.b2ContactID} o\r\n */\r\nbox2d.b2ContactID.prototype.Copy = function (o)\r\n{\r\n\tthis.key = o.key;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2ContactID}\r\n */\r\nbox2d.b2ContactID.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2ContactID().Copy(this);\r\n}\r\n\r\nObject.defineProperty(\r\n\tbox2d.b2ContactID.prototype, 'key',\r\n\t{\r\n\t\tenumerable: false,\r\n\t\tconfigurable: true,\r\n\t\t/** @this {box2d.b2ContactID} */\r\n\t\tget: function ()\r\n\t\t{\r\n\t\t\treturn this._key;\r\n\t\t},\r\n\t\t/** @this {box2d.b2ContactID} */\r\n\t\tset: function (value)\r\n\t\t{\r\n\t\t\tthis._key = value;\r\n\t\t\t// update the b2ContactFeature\r\n\t\t\tthis.cf._indexA = this._key & 0x000000ff;\r\n\t\t\tthis.cf._indexB = (this._key >> 8) & 0x000000ff;\r\n\t\t\tthis.cf._typeA = (this._key >> 16) & 0x000000ff;\r\n\t\t\tthis.cf._typeB = (this._key >> 24) & 0x000000ff;\r\n\t\t}\r\n\t}\r\n);\r\n\r\n/**\r\n * A manifold point is a contact point belonging to a contact\r\n * manifold. It holds details related to the geometry and dynamics\r\n * of the contact points.\r\n * The local point usage depends on the manifold type:\r\n * -e_circles: the local center of circleB\r\n * -e_faceA: the local center of cirlceB or the clip point of polygonB\r\n * -e_faceB: the clip point of polygonA\r\n * This structure is stored across time steps, so we keep it small.\r\n * Note: the impulses are used for internal caching and may not\r\n * provide reliable contact forces, especially for high speed collisions.\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ManifoldPoint = function ()\r\n{\r\n\tthis.localPoint = new box2d.b2Vec2();\r\n\tthis.id = new box2d.b2ContactID();\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ManifoldPoint.prototype.localPoint = null; ///< usage depends on manifold type\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ManifoldPoint.prototype.normalImpulse = 0; ///< the non-penetration impulse\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ManifoldPoint.prototype.tangentImpulse = 0; ///< the friction impulse\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactID}\r\n */\r\nbox2d.b2ManifoldPoint.prototype.id = null; ///< uniquely identifies a contact point between two shapes\r\n\r\n/**\r\n * @export \r\n * @return {Array.<box2d.b2ManifoldPoint>}\r\n * @param {number} length \r\n */\r\nbox2d.b2ManifoldPoint.MakeArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return new box2d.b2ManifoldPoint(); } );\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2ManifoldPoint.prototype.Reset = function ()\r\n{\r\n\tthis.localPoint.SetZero();\r\n\tthis.normalImpulse = 0;\r\n\tthis.tangentImpulse = 0;\r\n\tthis.id.key = 0;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2ManifoldPoint}\r\n * @param {box2d.b2ManifoldPoint} o \r\n */\r\nbox2d.b2ManifoldPoint.prototype.Copy = function (o)\r\n{\r\n\tthis.localPoint.Copy(o.localPoint);\r\n\tthis.normalImpulse = o.normalImpulse;\r\n\tthis.tangentImpulse = o.tangentImpulse;\r\n\tthis.id.Copy(o.id);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2ManifoldType = \r\n{\r\n\te_unknown\t: -1,\r\n\te_circles\t: 0,\r\n\te_faceA\t\t: 1,\r\n\te_faceB\t\t: 2\r\n};\r\ngoog.exportProperty(box2d.b2ManifoldType, 'e_unknown', box2d.b2ManifoldType.e_unknown);\r\ngoog.exportProperty(box2d.b2ManifoldType, 'e_circles', box2d.b2ManifoldType.e_circles);\r\ngoog.exportProperty(box2d.b2ManifoldType, 'e_faceA'  , box2d.b2ManifoldType.e_faceA  );\r\ngoog.exportProperty(box2d.b2ManifoldType, 'e_faceB'  , box2d.b2ManifoldType.e_faceB  );\r\n\r\n/** \r\n * A manifold for two touching convex shapes.\r\n * Box2D supports multiple types of contact:\r\n * - clip point versus plane with radius\r\n * - point versus point with radius (circles)\r\n * The local point usage depends on the manifold type:\r\n * -e_circles: the local center of circleA\r\n * -e_faceA: the center of faceA\r\n * -e_faceB: the center of faceB\r\n * Similarly the local normal usage:\r\n * -e_circles: not used\r\n * -e_faceA: the normal on polygonA\r\n * -e_faceB: the normal on polygonB\r\n * We store contacts in this way so that position correction can\r\n * account for movement, which is critical for continuous physics.\r\n * All contact scenarios must be expressed in one of these types.\r\n * This structure is stored across time steps, so we keep it small.\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Manifold = function ()\r\n{\r\n\tthis.points = box2d.b2ManifoldPoint.MakeArray(box2d.b2_maxManifoldPoints);\r\n\tthis.localNormal = new box2d.b2Vec2();\r\n\tthis.localPoint = new box2d.b2Vec2();\r\n\tthis.type = box2d.b2ManifoldType.e_unknown;\r\n\tthis.pointCount = 0;\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2ManifoldPoint>}\r\n */\r\nbox2d.b2Manifold.prototype.points = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2Manifold.prototype.localNormal = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2Manifold.prototype.localPoint = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2ManifoldType}\r\n */\r\nbox2d.b2Manifold.prototype.type = box2d.b2ManifoldType.e_unknown;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Manifold.prototype.pointCount = 0;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Manifold.prototype.Reset = function ()\r\n{\r\n\tfor (var i = 0, ict = box2d.b2_maxManifoldPoints; i < ict; ++i)\r\n\t{\r\n\t\t//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.points[i] instanceof box2d.b2ManifoldPoint); }\r\n\t\tthis.points[i].Reset();\r\n\t}\r\n\tthis.localNormal.SetZero();\r\n\tthis.localPoint.SetZero();\r\n\tthis.type = box2d.b2ManifoldType.e_unknown;\r\n\tthis.pointCount = 0;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Manifold} \r\n * @param {box2d.b2Manifold} o \r\n */\r\nbox2d.b2Manifold.prototype.Copy = function (o)\r\n{\r\n\tthis.pointCount = o.pointCount;\r\n\tfor (var i = 0, ict = box2d.b2_maxManifoldPoints; i < ict; ++i)\r\n\t{\r\n\t\t//if (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.points[i] instanceof box2d.b2ManifoldPoint); }\r\n\t\tthis.points[i].Copy(o.points[i]);\r\n\t}\r\n\tthis.localNormal.Copy(o.localNormal);\r\n\tthis.localPoint.Copy(o.localPoint);\r\n\tthis.type = o.type;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Manifold}\r\n */\r\nbox2d.b2Manifold.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2Manifold().Copy(this);\r\n}\r\n\r\n/** \r\n * This is used to compute the current state of a contact \r\n * manifold. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2WorldManifold = function ()\r\n{\r\n\tthis.normal = new box2d.b2Vec2();\r\n\tthis.points = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints);\r\n\tthis.separations = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints);\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WorldManifold.prototype.normal = null; ///< world vector pointing from A to B\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2WorldManifold.prototype.points = null; ///< world contact point (point of intersection)\r\n/**\r\n * @export \r\n * @type {Array.<number>}\r\n */\r\nbox2d.b2WorldManifold.prototype.separations = null; ///< a negative value indicates overlap, in meters\r\n\r\n/** \r\n * Evaluate the manifold with supplied transforms. This assumes \r\n * modest motion from the original state. This does not change \r\n * the point count, impulses, etc. The radii must come from the \r\n * shapes that generated the manifold. \r\n * @export \r\n * @param {box2d.b2Manifold} manifold\r\n * @param {box2d.b2Transform} xfA\r\n * @param {number} radiusA\r\n * @param {box2d.b2Transform} xfB\r\n * @param {number} radiusB \r\n * @return {void} \r\n */\r\nbox2d.b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB)\r\n{\r\n\tif (manifold.pointCount === 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tswitch (manifold.type)\r\n\t{\r\n\tcase box2d.b2ManifoldType.e_circles:\r\n\t\t{\r\n\t\t\tthis.normal.SetXY(1, 0);\r\n\t\t\tvar pointA = box2d.b2MulXV(xfA, manifold.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointA);\r\n\t\t\tvar pointB = box2d.b2MulXV(xfB, manifold.points[0].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointB);\r\n\t\t\tif (box2d.b2DistanceSquaredVV(pointA, pointB) > box2d.b2_epsilon_sq)\r\n\t\t\t{\r\n\t\t\t\tbox2d.b2SubVV(pointB, pointA, this.normal).SelfNormalize();\r\n\t\t\t}\r\n\r\n\t\t\tvar cA = box2d.b2AddVMulSV(pointA, radiusA, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA);\r\n\t\t\tvar cB = box2d.b2SubVMulSV(pointB, radiusB, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);\r\n\t\t\tbox2d.b2MidVV(cA, cB, this.points[0]);\r\n\t\t\tthis.separations[0] = box2d.b2DotVV(box2d.b2SubVV(cB, cA, box2d.b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2ManifoldType.e_faceA:\r\n\t\t{\r\n\t\t\tbox2d.b2MulRV(xfA.q, manifold.localNormal, this.normal);\r\n\t\t\tvar planePoint = box2d.b2MulXV(xfA, manifold.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint);\r\n\r\n\t\t\tfor (var i = 0, ict = manifold.pointCount; i < ict; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar clipPoint = box2d.b2MulXV(xfB, manifold.points[i].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint);\r\n\t\t\t\tvar s = radiusA - box2d.b2DotVV(box2d.b2SubVV(clipPoint, planePoint, box2d.b2Vec2.s_t0), this.normal);\r\n\t\t\t\tvar cA = box2d.b2AddVMulSV(clipPoint, s, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA);\r\n\t\t\t\tvar cB = box2d.b2SubVMulSV(clipPoint, radiusB, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);\r\n\t\t\t\tbox2d.b2MidVV(cA, cB, this.points[i]);\r\n\t\t\t\tthis.separations[i] = box2d.b2DotVV(box2d.b2SubVV(cB, cA, box2d.b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2ManifoldType.e_faceB:\r\n\t\t{\r\n\t\t\tbox2d.b2MulRV(xfB.q, manifold.localNormal, this.normal);\r\n\t\t\tvar planePoint = box2d.b2MulXV(xfB, manifold.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint);\r\n\r\n\t\t\tfor (var i = 0, ict = manifold.pointCount; i < ict; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar clipPoint = box2d.b2MulXV(xfA, manifold.points[i].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint);\r\n\t\t\t\tvar s = radiusB - box2d.b2DotVV(box2d.b2SubVV(clipPoint, planePoint, box2d.b2Vec2.s_t0), this.normal);\r\n\t\t\t\tvar cB = box2d.b2AddVMulSV(clipPoint, s, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);\r\n\t\t\t\tvar cA = box2d.b2SubVMulSV(clipPoint, radiusA, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA);\r\n\t\t\t\tbox2d.b2MidVV(cA, cB, this.points[i]);\r\n\t\t\t\tthis.separations[i] = box2d.b2DotVV(box2d.b2SubVV(cA, cB, box2d.b2Vec2.s_t0), this.normal); // b2Dot(cA - cB, normal);\r\n\t\t\t}\r\n\r\n\t\t\t// Ensure normal points from A to B.\r\n\t\t\tthis.normal.SelfNeg();\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n}\r\nbox2d.b2WorldManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2();\r\nbox2d.b2WorldManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2();\r\nbox2d.b2WorldManifold.prototype.Initialize.s_cA = new box2d.b2Vec2();\r\nbox2d.b2WorldManifold.prototype.Initialize.s_cB = new box2d.b2Vec2();\r\nbox2d.b2WorldManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2();\r\nbox2d.b2WorldManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2();\r\n\r\n/** \r\n * This is used for determining the state of contact points. \r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2PointState = \r\n{\r\n\tb2_nullState\t: 0, ///< point does not exist\r\n\tb2_addState\t\t: 1, ///< point was added in the update\r\n\tb2_persistState\t: 2, ///< point persisted across the update\r\n\tb2_removeState\t: 3  ///< point was removed in the update\r\n};\r\ngoog.exportProperty(box2d.b2PointState, 'b2_nullState   ', box2d.b2PointState.b2_nullState   );\r\ngoog.exportProperty(box2d.b2PointState, 'b2_addState    ', box2d.b2PointState.b2_addState    );\r\ngoog.exportProperty(box2d.b2PointState, 'b2_persistState', box2d.b2PointState.b2_persistState);\r\ngoog.exportProperty(box2d.b2PointState, 'b2_removeState ', box2d.b2PointState.b2_removeState );\r\n\r\n/** \r\n * Compute the point states given two manifolds. The states \r\n * pertain to the transition from manifold1 to manifold2. So \r\n * state1 is either persist or remove while state2 is either add \r\n * or persist. \r\n * @export \r\n * @return {void}\r\n * @param {Array.<box2d.b2PointState>} state1 \r\n * @param {Array.<box2d.b2PointState>} state2 \r\n * @param {box2d.b2Manifold} manifold1 \r\n * @param {box2d.b2Manifold} manifold2 \r\n */\r\nbox2d.b2GetPointStates = function (state1, state2, manifold1, manifold2)\r\n{\r\n\t// Detect persists and removes.\r\n\tfor (var i = 0, ict = manifold1.pointCount; i < ict; ++i)\r\n\t{\r\n\t\tvar id = manifold1.points[i].id;\r\n\t\tvar key = id.key;\r\n\r\n\t\tstate1[i] = box2d.b2PointState.b2_removeState;\r\n\r\n\t\tfor (var j = 0, jct = manifold2.pointCount; j < jct; ++j)\r\n\t\t{\r\n\t\t\tif (manifold2.points[j].id.key === key)\r\n\t\t\t{\r\n\t\t\t\tstate1[i] = box2d.b2PointState.b2_persistState;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (var ict = box2d.b2_maxManifoldPoints; i < ict; ++i)\r\n\t{\r\n\t\tstate1[i] = box2d.b2PointState.b2_nullState;\r\n\t}\r\n\r\n\t// Detect persists and adds.\r\n\tfor (var i = 0, ict = manifold2.pointCount; i < ict; ++i)\r\n\t{\r\n\t\tvar id = manifold2.points[i].id;\r\n\t\tvar key = id.key;\r\n\r\n\t\tstate2[i] = box2d.b2PointState.b2_addState;\r\n\r\n\t\tfor (var j = 0, jct = manifold1.pointCount; j < jct; ++j)\r\n\t\t{\r\n\t\t\tif (manifold1.points[j].id.key === key)\r\n\t\t\t{\r\n\t\t\t\tstate2[i] = box2d.b2PointState.b2_persistState;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (var ict = box2d.b2_maxManifoldPoints; i < ict; ++i)\r\n\t{\r\n\t\tstate2[i] = box2d.b2PointState.b2_nullState;\r\n\t}\r\n}\r\n\r\n/** \r\n * Used for computing contact manifolds. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ClipVertex = function ()\r\n{\r\n\tthis.v = new box2d.b2Vec2();\r\n\tthis.id = new box2d.b2ContactID();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ClipVertex.prototype.v = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactID}\r\n */\r\nbox2d.b2ClipVertex.prototype.id = null;\r\n\r\n/**\r\n * @export \r\n * @return {Array.<box2d.b2ClipVertex>} \r\n * @param {number=} length \r\n */\r\nbox2d.b2ClipVertex.MakeArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return new box2d.b2ClipVertex(); });\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2ClipVertex}\r\n * @param {box2d.b2ClipVertex} other \r\n */\r\nbox2d.b2ClipVertex.prototype.Copy = function (other)\r\n{\r\n\tthis.v.Copy(other.v);\r\n\tthis.id.Copy(other.id);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Ray-cast input data. The ray extends from p1 to p1 + \r\n * maxFraction * (p2 - p1). \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2RayCastInput = function ()\r\n{\r\n\tthis.p1 = new box2d.b2Vec2();\r\n\tthis.p2 = new box2d.b2Vec2();\r\n\tthis.maxFraction = 1;\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RayCastInput.prototype.p1 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RayCastInput.prototype.p2 = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RayCastInput.prototype.maxFraction = 1;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2RayCastInput} \r\n * @param {box2d.b2RayCastInput} o\r\n */\r\nbox2d.b2RayCastInput.prototype.Copy = function (o)\r\n{\r\n\tthis.p1.Copy(o.p1);\r\n\tthis.p2.Copy(o.p2);\r\n\tthis.maxFraction = o.maxFraction;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Ray-cast output data. The ray hits at p1 + fraction * (p2 - \r\n * p1), where p1 and p2 come from box2d.b2RayCastInput. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2RayCastOutput = function ()\r\n{\r\n\tthis.normal = new box2d.b2Vec2();\r\n\tthis.fraction = 0;\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2RayCastOutput.prototype.normal = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2RayCastOutput.prototype.fraction = 0;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2RayCastOutput} \r\n * @param {box2d.b2RayCastOutput} o \r\n */\r\nbox2d.b2RayCastOutput.prototype.Copy = function (o)\r\n{\r\n\tthis.normal.Copy(o.normal);\r\n\tthis.fraction = o.fraction;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * An axis aligned bounding box. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2AABB = function ()\r\n{\r\n\tthis.lowerBound = new box2d.b2Vec2();\r\n\tthis.upperBound = new box2d.b2Vec2();\r\n\r\n\tthis.m_out_center = new box2d.b2Vec2();\r\n\tthis.m_out_extent = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2AABB.prototype.lowerBound = null; ///< the lower vertex\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2AABB.prototype.upperBound = null; ///< the upper vertex\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2AABB.prototype.m_out_center = null; // access using GetCenter()\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2AABB.prototype.m_out_extent = null; // access using GetExtents()\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2AABB} \r\n * @param {box2d.b2AABB} o \r\n */\r\nbox2d.b2AABB.prototype.Copy = function (o)\r\n{\r\n\tthis.lowerBound.Copy(o.lowerBound);\r\n\tthis.upperBound.Copy(o.upperBound);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Verify that the bounds are sorted. \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2AABB.prototype.IsValid = function ()\r\n{\r\n\tvar d_x = this.upperBound.x - this.lowerBound.x;\r\n\tvar d_y = this.upperBound.y - this.lowerBound.y;\r\n\tvar valid = d_x >= 0 && d_y >= 0;\r\n\tvalid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();\r\n\treturn valid;\r\n}\r\n\r\n/** \r\n * Get the center of the AABB. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n */\r\nbox2d.b2AABB.prototype.GetCenter = function ()\r\n{\r\n\treturn box2d.b2MidVV(this.lowerBound, this.upperBound, this.m_out_center);\r\n}\r\n\r\n/** \r\n * Get the extents of the AABB (half-widths). \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n */\r\nbox2d.b2AABB.prototype.GetExtents = function ()\r\n{\r\n\treturn box2d.b2ExtVV(this.lowerBound, this.upperBound, this.m_out_extent);\r\n}\r\n\r\n/** \r\n * Get the perimeter length \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2AABB.prototype.GetPerimeter = function ()\r\n{\r\n\tvar wx = this.upperBound.x - this.lowerBound.x;\r\n\tvar wy = this.upperBound.y - this.lowerBound.y;\r\n\treturn 2 * (wx + wy);\r\n}\r\n\r\n/** \r\n * Combine an AABB into this one. \r\n * @export \r\n * @return {box2d.b2AABB} \r\n * @param {box2d.b2AABB} aabb\r\n */\r\nbox2d.b2AABB.prototype.Combine1 = function (aabb)\r\n{\r\n\tthis.lowerBound.x = box2d.b2Min(this.lowerBound.x, aabb.lowerBound.x);\r\n\tthis.lowerBound.y = box2d.b2Min(this.lowerBound.y, aabb.lowerBound.y);\r\n\tthis.upperBound.x = box2d.b2Max(this.upperBound.x, aabb.upperBound.x);\r\n\tthis.upperBound.y = box2d.b2Max(this.upperBound.y, aabb.upperBound.y);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Combine two AABBs into this one. \r\n * @export \r\n * @return {box2d.b2AABB} \r\n * @param {box2d.b2AABB} aabb1\r\n * @param {box2d.b2AABB} aabb2\r\n */\r\nbox2d.b2AABB.prototype.Combine2 = function (aabb1, aabb2)\r\n{\r\n\tthis.lowerBound.x = box2d.b2Min(aabb1.lowerBound.x, aabb2.lowerBound.x);\r\n\tthis.lowerBound.y = box2d.b2Min(aabb1.lowerBound.y, aabb2.lowerBound.y);\r\n\tthis.upperBound.x = box2d.b2Max(aabb1.upperBound.x, aabb2.upperBound.x);\r\n\tthis.upperBound.y = box2d.b2Max(aabb1.upperBound.y, aabb2.upperBound.y);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2AABB}\r\n * @param {box2d.b2AABB} aabb1\r\n * @param {box2d.b2AABB} aabb2\r\n * @param {box2d.b2AABB} out\r\n */\r\nbox2d.b2AABB.Combine = function (aabb1, aabb2, out)\r\n{\r\n\tout.Combine2(aabb1, aabb2);\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * Does this aabb contain the provided AABB. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2AABB} aabb \r\n */\r\nbox2d.b2AABB.prototype.Contains = function (aabb)\r\n{\r\n\tvar result = true;\r\n\tresult = result && this.lowerBound.x <= aabb.lowerBound.x;\r\n\tresult = result && this.lowerBound.y <= aabb.lowerBound.y;\r\n\tresult = result && aabb.upperBound.x <= this.upperBound.x;\r\n\tresult = result && aabb.upperBound.y <= this.upperBound.y;\r\n\treturn result;\r\n}\r\n\r\n/** \r\n * From Real-time Collision Detection, p179. \r\n * @export \r\n * @return {boolean}\r\n * @param {box2d.b2RayCastOutput} output\r\n * @param {box2d.b2RayCastInput} input\r\n */\r\nbox2d.b2AABB.prototype.RayCast = function (output, input)\r\n{\r\n\tvar tmin = (-box2d.b2_maxFloat);\r\n\tvar tmax = box2d.b2_maxFloat;\r\n\r\n\tvar p_x = input.p1.x;\r\n\tvar p_y = input.p1.y;\r\n\tvar d_x = input.p2.x - input.p1.x;\r\n\tvar d_y = input.p2.y - input.p1.y;\r\n\tvar absD_x = box2d.b2Abs(d_x);\r\n\tvar absD_y = box2d.b2Abs(d_y);\r\n\r\n\tvar normal = output.normal;\r\n\r\n\tif (absD_x < box2d.b2_epsilon)\r\n\t{\r\n\t\t// Parallel.\r\n\t\tif (p_x < this.lowerBound.x || this.upperBound.x < p_x)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvar inv_d = 1 / d_x;\r\n\t\tvar t1 = (this.lowerBound.x - p_x) * inv_d;\r\n\t\tvar t2 = (this.upperBound.x - p_x) * inv_d;\r\n\r\n\t\t// Sign of the normal vector.\r\n\t\tvar s = (-1);\r\n\r\n\t\tif (t1 > t2)\r\n\t\t{\r\n\t\t\tvar t3 = t1;\r\n\t\t\tt1 = t2;\r\n\t\t\tt2 = t3;\r\n\t\t\ts = 1;\r\n\t\t}\r\n\r\n\t\t// Push the min up\r\n\t\tif (t1 > tmin)\r\n\t\t{\r\n\t\t\tnormal.x = s;\r\n\t\t\tnormal.y = 0;\r\n\t\t\ttmin = t1;\r\n\t\t}\r\n\r\n\t\t// Pull the max down\r\n\t\ttmax = box2d.b2Min(tmax, t2);\r\n\r\n\t\tif (tmin > tmax)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tif (absD_y < box2d.b2_epsilon)\r\n\t{\r\n\t\t// Parallel.\r\n\t\tif (p_y < this.lowerBound.y || this.upperBound.y < p_y)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvar inv_d = 1 / d_y;\r\n\t\tvar t1 = (this.lowerBound.y - p_y) * inv_d;\r\n\t\tvar t2 = (this.upperBound.y - p_y) * inv_d;\r\n\r\n\t\t// Sign of the normal vector.\r\n\t\tvar s = (-1);\r\n\r\n\t\tif (t1 > t2)\r\n\t\t{\r\n\t\t\tvar t3 = t1;\r\n\t\t\tt1 = t2;\r\n\t\t\tt2 = t3;\r\n\t\t\ts = 1;\r\n\t\t}\r\n\r\n\t\t// Push the min up\r\n\t\tif (t1 > tmin)\r\n\t\t{\r\n\t\t\tnormal.x = 0;\r\n\t\t\tnormal.y = s;\r\n\t\t\ttmin = t1;\r\n\t\t}\r\n\r\n\t\t// Pull the max down\r\n\t\ttmax = box2d.b2Min(tmax, t2);\r\n\r\n\t\tif (tmin > tmax)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t// Does the ray start inside the box?\r\n\t// Does the ray intersect beyond the max fraction?\r\n\tif (tmin < 0 || input.maxFraction < tmin)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Intersection.\r\n\toutput.fraction = tmin;\r\n\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2AABB} other \r\n */\r\nbox2d.b2AABB.prototype.TestOverlap = function (other)\r\n{\r\n\tvar d1_x = other.lowerBound.x - this.upperBound.x;\r\n\tvar d1_y = other.lowerBound.y - this.upperBound.y;\r\n\tvar d2_x = this.lowerBound.x - other.upperBound.x;\r\n\tvar d2_y = this.lowerBound.y - other.upperBound.y;\r\n\r\n\tif (d1_x > 0 || d1_y > 0)\r\n\t\treturn false;\r\n\r\n\tif (d2_x > 0 || d2_y > 0)\r\n\t\treturn false;\r\n\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2AABB} a\r\n * @param {box2d.b2AABB} b \r\n */\r\nbox2d.b2TestOverlapAABB = function (a, b)\r\n{\r\n\tvar d1_x = b.lowerBound.x - a.upperBound.x;\r\n\tvar d1_y = b.lowerBound.y - a.upperBound.y;\r\n\tvar d2_x = a.lowerBound.x - b.upperBound.x;\r\n\tvar d2_y = a.lowerBound.y - b.upperBound.y;\r\n\r\n\tif (d1_x > 0 || d1_y > 0)\r\n\t\treturn false;\r\n\r\n\tif (d2_x > 0 || d2_y > 0)\r\n\t\treturn false;\r\n\r\n\treturn true;\r\n}\r\n\r\n/** \r\n * Clipping for contact manifolds. \r\n * Sutherland-Hodgman clipping. \r\n * @export \r\n * @return {number} \r\n * @param {Array.<box2d.b2ClipVertex>} vOut \r\n * @param {Array.<box2d.b2ClipVertex>} vIn\r\n * @param {box2d.b2Vec2} normal \r\n * @param {number} offset \r\n * @param {number} vertexIndexA \r\n */\r\nbox2d.b2ClipSegmentToLine = function (vOut, vIn, normal, offset, vertexIndexA)\r\n{\r\n\t// Start with no output points\r\n\tvar numOut = 0;\r\n\r\n\tvar vIn0 = vIn[0];\r\n\tvar vIn1 = vIn[1];\r\n\r\n\t// Calculate the distance of end points to the line\r\n\tvar distance0 = box2d.b2DotVV(normal, vIn0.v) - offset;\r\n\tvar distance1 = box2d.b2DotVV(normal, vIn1.v) - offset;\r\n\r\n\t// If the points are behind the plane\r\n\tif (distance0 <= 0) vOut[numOut++].Copy(vIn0);\r\n\tif (distance1 <= 0) vOut[numOut++].Copy(vIn1);\r\n\r\n\t// If the points are on different sides of the plane\r\n\tif (distance0 * distance1 < 0)\r\n\t{\r\n\t\t// Find intersection point of edge and plane\r\n\t\tvar interp = distance0 / (distance0 - distance1);\r\n\t\tvar v = vOut[numOut].v;\r\n\t\tv.x = vIn0.v.x + interp * (vIn1.v.x - vIn0.v.x);\r\n\t\tv.y = vIn0.v.y + interp * (vIn1.v.y - vIn0.v.y);\r\n\r\n\t\t// VertexA is hitting edgeB.\r\n\t\tvar id = vOut[numOut].id;\r\n\t\tid.cf.indexA = vertexIndexA;\r\n\t\tid.cf.indexB = vIn0.id.cf.indexB;\r\n\t\tid.cf.typeA = box2d.b2ContactFeatureType.e_vertex;\r\n\t\tid.cf.typeB = box2d.b2ContactFeatureType.e_face;\r\n\t\t++numOut;\r\n\t}\r\n\r\n\treturn numOut;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2Shape} shapeA \r\n * @param {box2d.b2Shape} shapeB \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2TestOverlapShape = function (shapeA, indexA, shapeB, indexB, xfA, xfB)\r\n{\r\n\tvar input = box2d.b2TestOverlapShape.s_input.Reset();\r\n\tinput.proxyA.SetShape(shapeA, indexA);\r\n\tinput.proxyB.SetShape(shapeB, indexB);\r\n\tinput.transformA.Copy(xfA);\r\n\tinput.transformB.Copy(xfB);\r\n\tinput.useRadii = true;\r\n\r\n\tvar simplexCache = box2d.b2TestOverlapShape.s_simplexCache.Reset();\r\n\tsimplexCache.count = 0;\r\n\r\n\tvar output = box2d.b2TestOverlapShape.s_output.Reset();\r\n\r\n\tbox2d.b2Distance(output, simplexCache, input);\r\n\r\n\treturn output.distance < 10 * box2d.b2_epsilon;\r\n}\r\nbox2d.b2TestOverlapShape.s_input = new box2d.b2DistanceInput();\r\nbox2d.b2TestOverlapShape.s_simplexCache = new box2d.b2SimplexCache();\r\nbox2d.b2TestOverlapShape.s_output = new box2d.b2DistanceOutput();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Timer');\r\n\r\ngoog.require('box2d.b2Settings');\r\n\r\n/** \r\n * Timer for profiling. This has platform specific code and may \r\n * not work on every platform. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Timer = function ()\r\n{\r\n\tthis.m_start = new Date().getTime();\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Timer.prototype.m_start = 0;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Timer}\r\n */\r\nbox2d.b2Timer.prototype.Reset = function ()\r\n{\r\n\tthis.m_start = new Date().getTime();\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Timer.prototype.GetMilliseconds = function ()\r\n{\r\n\treturn new Date().getTime() - this.m_start;\r\n}\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Counter = function ()\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Counter.prototype.m_count = 0;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Counter.prototype.m_min_count = 0;\r\n/**\r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2Counter.prototype.m_max_count = 0;\r\n\r\n/**\r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2Counter.prototype.GetCount = function ()\r\n{\r\n\treturn this.m_count;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2Counter.prototype.GetMinCount = function ()\r\n{\r\n\treturn this.m_min_count;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2Counter.prototype.GetMaxCount = function ()\r\n{\r\n\treturn this.m_max_count;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2Counter.prototype.ResetCount = function ()\r\n{\r\n\tvar count = this.m_count;\r\n\tthis.m_count = 0;\r\n\treturn count;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Counter.prototype.ResetMinCount = function ()\r\n{\r\n\tthis.m_min_count = 0;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Counter.prototype.ResetMaxCount = function ()\r\n{\r\n\tthis.m_max_count = 0;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Counter.prototype.Increment = function ()\r\n{\r\n\tthis.m_count++;\r\n\r\n\tif (this.m_max_count < this.m_count)\r\n\t{\r\n\t\tthis.m_max_count = this.m_count;\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Counter.prototype.Decrement = function ()\r\n{\r\n\tthis.m_count--;\r\n\r\n\tif (this.m_min_count > this.m_count)\r\n\t{\r\n\t\tthis.m_min_count = this.m_count;\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2TimeOfImpact');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Distance');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2Timer');\r\n\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2_toiTime = 0.0;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2_toiMaxTime = 0.0;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2_toiCalls = 0;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2_toiIters = 0;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2_toiMaxIters = 0;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2_toiRootIters = 0;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2_toiMaxRootIters = 0;\r\n\r\n/** \r\n * Input parameters for b2TimeOfImpact \r\n * @export\r\n * @constructor\r\n */\r\nbox2d.b2TOIInput = function ()\r\n{\r\n\tthis.proxyA = new box2d.b2DistanceProxy();\r\n\tthis.proxyB = new box2d.b2DistanceProxy();\r\n\tthis.sweepA = new box2d.b2Sweep();\r\n\tthis.sweepB = new box2d.b2Sweep();\r\n};\r\n\r\n/**\r\n * @export\r\n * @type {box2d.b2DistanceProxy}\r\n */\r\nbox2d.b2TOIInput.prototype.proxyA = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2DistanceProxy}\r\n */\r\nbox2d.b2TOIInput.prototype.proxyB = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2Sweep}\r\n */\r\nbox2d.b2TOIInput.prototype.sweepA = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2Sweep}\r\n */\r\nbox2d.b2TOIInput.prototype.sweepB = null;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2TOIInput.prototype.tMax = 0; // defines sweep interval [0, tMax]\r\n\r\n/**\r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2TOIOutputState = \r\n{\r\n\te_unknown\t\t: 0,\r\n\te_failed\t\t: 1,\r\n\te_overlapped\t: 2,\r\n\te_touching\t\t: 3,\r\n\te_separated\t\t: 4\r\n};\r\ngoog.exportProperty(box2d.b2TOIOutputState, 'e_unknown'   , box2d.b2TOIOutputState.e_unknown   );\r\ngoog.exportProperty(box2d.b2TOIOutputState, 'e_failed'    , box2d.b2TOIOutputState.e_failed    );\r\ngoog.exportProperty(box2d.b2TOIOutputState, 'e_overlapped', box2d.b2TOIOutputState.e_overlapped);\r\ngoog.exportProperty(box2d.b2TOIOutputState, 'e_touching'  , box2d.b2TOIOutputState.e_touching  );\r\ngoog.exportProperty(box2d.b2TOIOutputState, 'e_separated' , box2d.b2TOIOutputState.e_separated );\r\n\r\n/** \r\n * Output parameters for b2TimeOfImpact. \r\n * @export\r\n * @constructor\r\n */\r\nbox2d.b2TOIOutput = function ()\r\n{\r\n};\r\n\r\n/**\r\n * @export\r\n * @type {box2d.b2TOIOutputState}\r\n */\r\nbox2d.b2TOIOutput.prototype.state = box2d.b2TOIOutputState.e_unknown;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2TOIOutput.prototype.t = 0;\r\n\r\n/**\r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2SeparationFunctionType = \r\n{\r\n\te_unknown\t: -1,\r\n\te_points\t: 0,\r\n\te_faceA\t\t: 1,\r\n\te_faceB\t\t: 2\r\n};\r\ngoog.exportProperty(box2d.b2SeparationFunctionType, 'e_unknown', box2d.b2SeparationFunctionType.e_unknown);\r\ngoog.exportProperty(box2d.b2SeparationFunctionType, 'e_points' , box2d.b2SeparationFunctionType.e_points );\r\ngoog.exportProperty(box2d.b2SeparationFunctionType, 'e_faceA'  , box2d.b2SeparationFunctionType.e_faceA  );\r\ngoog.exportProperty(box2d.b2SeparationFunctionType, 'e_faceB'  , box2d.b2SeparationFunctionType.e_faceB  );\r\n\r\n/**\r\n * @export\r\n * @constructor\r\n */\r\nbox2d.b2SeparationFunction = function ()\r\n{\r\n\tthis.m_sweepA = new box2d.b2Sweep();\r\n\tthis.m_sweepB = new box2d.b2Sweep();\r\n\tthis.m_localPoint = new box2d.b2Vec2();\r\n\tthis.m_axis = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export\r\n * @type {box2d.b2DistanceProxy}\r\n */\r\nbox2d.b2SeparationFunction.prototype.m_proxyA = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2DistanceProxy}\r\n */\r\nbox2d.b2SeparationFunction.prototype.m_proxyB = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2Sweep}\r\n */\r\nbox2d.b2SeparationFunction.prototype.m_sweepA = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2Sweep}\r\n */\r\nbox2d.b2SeparationFunction.prototype.m_sweepB = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2SeparationFunctionType}\r\n */\r\nbox2d.b2SeparationFunction.prototype.m_type = box2d.b2SeparationFunctionType.e_unknown;\r\n/**\r\n * @export\r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2SeparationFunction.prototype.m_localPoint = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2SeparationFunction.prototype.m_axis = null;\r\n\r\n/** \r\n * TODO_ERIN might not need to return the separation \r\n * @export\r\n * @return {number}\r\n * @param {box2d.b2SimplexCache} cache\r\n * @param {box2d.b2DistanceProxy} proxyA\r\n * @param {box2d.b2Sweep} sweepA\r\n * @param {box2d.b2DistanceProxy} proxyB\r\n * @param {box2d.b2Sweep} sweepB\r\n * @param {number} t1\r\n */\r\nbox2d.b2SeparationFunction.prototype.Initialize = function (cache, proxyA, sweepA, proxyB, sweepB, t1)\r\n{\r\n\tthis.m_proxyA = proxyA;\r\n\tthis.m_proxyB = proxyB;\r\n\t/** @type {number} */ var count = cache.count;\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 < count && count < 3); }\r\n\r\n\tthis.m_sweepA.Copy(sweepA);\r\n\tthis.m_sweepB.Copy(sweepB);\r\n\r\n\t/** @type {box2d.b2Transform} */ var xfA = box2d.b2TimeOfImpact.s_xfA;\r\n\t/** @type {box2d.b2Transform} */ var xfB = box2d.b2TimeOfImpact.s_xfB;\r\n\tthis.m_sweepA.GetTransform(xfA, t1);\r\n\tthis.m_sweepB.GetTransform(xfB, t1);\r\n\r\n\tif (count === 1)\r\n\t{\r\n\t\tthis.m_type = box2d.b2SeparationFunctionType.e_points;\r\n\t\t/** @type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);\r\n\t\t/** @type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);\r\n\t\t/** @type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);\r\n\t\t/** @type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);\r\n\t\tbox2d.b2SubVV(pointB, pointA, this.m_axis);\r\n\t\t/** @type {number} */ var s = this.m_axis.Normalize();\r\n\t\treturn s;\r\n\t}\r\n\telse if (cache.indexA[0] === cache.indexA[1])\r\n\t{\r\n\t\t// Two points on B and one on A.\r\n\t\tthis.m_type = box2d.b2SeparationFunctionType.e_faceB;\r\n\t\t/** @type {box2d.b2Vec2} */ var localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);\r\n\t\t/** @type {box2d.b2Vec2} */ var localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);\r\n\r\n\t\tbox2d.b2CrossVOne(box2d.b2SubVV(localPointB2, localPointB1, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize();\r\n\t\t/** @type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfB.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);\r\n\r\n\t\tbox2d.b2MidVV(localPointB1, localPointB2, this.m_localPoint);\r\n\t\t/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB);\r\n\r\n\t\t/** type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);\r\n\t\t/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);\r\n\r\n\t\t/** type {number} */ var s = box2d.b2DotVV(box2d.b2SubVV(pointA, pointB, box2d.b2Vec2.s_t0), normal);\r\n\t\tif (s < 0)\r\n\t\t{\r\n\t\t\tthis.m_axis.SelfNeg();\r\n\t\t\ts = -s;\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Two points on A and one or two points on B.\r\n\t\tthis.m_type = box2d.b2SeparationFunctionType.e_faceA;\r\n\t\t/** @type {box2d.b2Vec2} */ var localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);\r\n\t\t/** @type {box2d.b2Vec2} */ var localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);\r\n\r\n\t\tbox2d.b2CrossVOne(box2d.b2SubVV(localPointA2, localPointA1, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize();\r\n\t\t/** type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfA.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);\r\n\r\n\t\tbox2d.b2MidVV(localPointA1, localPointA2, this.m_localPoint);\r\n\t\t/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA);\r\n\r\n\t\t/** type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);\r\n\t\t/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);\r\n\r\n\t\t/** type {number} */ var s = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), normal);\r\n\t\tif (s < 0)\r\n\t\t{\r\n\t\t\tthis.m_axis.SelfNeg();\r\n\t\t\ts = -s;\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {number}\r\n * @param {Array.<number>} indexA\r\n * @param {Array.<number>} indexB\r\n * @param {number} t\r\n */\r\nbox2d.b2SeparationFunction.prototype.FindMinSeparation = function (indexA, indexB, t)\r\n{\r\n\t/** @type {box2d.b2Transform} */ var xfA = box2d.b2TimeOfImpact.s_xfA;\r\n\t/** @type {box2d.b2Transform} */ var xfB = box2d.b2TimeOfImpact.s_xfB;\r\n\tthis.m_sweepA.GetTransform(xfA, t);\r\n\tthis.m_sweepB.GetTransform(xfB, t);\r\n\r\n\tswitch (this.m_type)\r\n\t{\r\n\tcase box2d.b2SeparationFunctionType.e_points:\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2Vec2} */ var axisA = box2d.b2MulTRV(xfA.q, this.m_axis, box2d.b2TimeOfImpact.s_axisA);\r\n\t\t\t/** @type {box2d.b2Vec2} */ var axisB = box2d.b2MulTRV(xfB.q, box2d.b2NegV(this.m_axis, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);\r\n\r\n\t\t\tindexA[0] = this.m_proxyA.GetSupport(axisA);\r\n\t\t\tindexB[0] = this.m_proxyB.GetSupport(axisB);\r\n\r\n\t\t\t/** @type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(indexA[0]);\r\n\t\t\t/** @type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(indexB[0]);\r\n\r\n\t\t\t/** @type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);\r\n\t\t\t/** @type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);\r\n\r\n\t\t\t/** @type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), this.m_axis)\r\n\t\t\treturn separation;\r\n\t\t}\r\n\r\n\tcase box2d.b2SeparationFunctionType.e_faceA:\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfA.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);\r\n\t\t\t/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA);\r\n\r\n\t\t\t/** type {box2d.b2Vec2} */ var axisB = box2d.b2MulTRV(xfB.q, box2d.b2NegV(normal, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);\r\n\r\n\t\t\tindexA[0] = -1;\r\n\t\t\tindexB[0] = this.m_proxyB.GetSupport(axisB);\r\n\r\n\t\t\t/** type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(indexB[0]);\r\n\t\t\t/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);\r\n\r\n\t\t\t/** type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), normal)\r\n\t\t\treturn separation;\r\n\t\t}\r\n\r\n\tcase box2d.b2SeparationFunctionType.e_faceB:\r\n\t\t{\r\n\t\t\t/** type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfB.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);\r\n\t\t\t/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB);\r\n\r\n\t\t\t/** type {box2d.b2Vec2} */ var axisA = box2d.b2MulTRV(xfA.q, box2d.b2NegV(normal, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisA);\r\n\r\n\t\t\tindexB[0] = -1;\r\n\t\t\tindexA[0] = this.m_proxyA.GetSupport(axisA);\r\n\r\n\t\t\t/** type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(indexA[0]);\r\n\t\t\t/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);\r\n\r\n\t\t\t/** type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointA, pointB, box2d.b2Vec2.s_t0), normal)\r\n\t\t\treturn separation;\r\n\t\t}\r\n\r\n\tdefault:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\tindexA[0] = -1;\r\n\t\tindexB[0] = -1;\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {number}\r\n * @param {number} indexA\r\n * @param {number} indexB\r\n * @param {number} t\r\n */\r\nbox2d.b2SeparationFunction.prototype.Evaluate = function (indexA, indexB, t)\r\n{\r\n\t/** @type {box2d.b2Transform} */ var xfA = box2d.b2TimeOfImpact.s_xfA;\r\n\t/** @type {box2d.b2Transform} */ var xfB = box2d.b2TimeOfImpact.s_xfB;\r\n\tthis.m_sweepA.GetTransform(xfA, t);\r\n\tthis.m_sweepB.GetTransform(xfB, t);\r\n\r\n\tswitch (this.m_type)\r\n\t{\r\n\tcase box2d.b2SeparationFunctionType.e_points:\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(indexA);\r\n\t\t\t/** @type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(indexB);\r\n\r\n\t\t\t/** @type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);\r\n\t\t\t/** @type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);\r\n\t\t\t/** @type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), this.m_axis)\r\n\r\n\t\t\treturn separation;\r\n\t\t}\r\n\r\n\tcase box2d.b2SeparationFunctionType.e_faceA:\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfA.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);\r\n\t\t\t/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA);\r\n\r\n\t\t\t/** type {box2d.b2Vec2} */ var localPointB = this.m_proxyB.GetVertex(indexB);\r\n\t\t\t/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, localPointB, box2d.b2TimeOfImpact.s_pointB);\r\n\r\n\t\t\t/** type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), normal)\r\n\t\t\treturn separation;\r\n\t\t}\r\n\r\n\tcase box2d.b2SeparationFunctionType.e_faceB:\r\n\t\t{\r\n\t\t\t/** type {box2d.b2Vec2} */ var normal = box2d.b2MulRV(xfB.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);\r\n\t\t\t/** type {box2d.b2Vec2} */ var pointB = box2d.b2MulXV(xfB, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB);\r\n\r\n\t\t\t/** type {box2d.b2Vec2} */ var localPointA = this.m_proxyA.GetVertex(indexA);\r\n\t\t\t/** type {box2d.b2Vec2} */ var pointA = box2d.b2MulXV(xfA, localPointA, box2d.b2TimeOfImpact.s_pointA);\r\n\r\n\t\t\t/** type {number} */ var separation = box2d.b2DotVV(box2d.b2SubVV(pointA, pointB, box2d.b2Vec2.s_t0), normal)\r\n\t\t\treturn separation;\r\n\t\t}\r\n\r\n\tdefault:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n/**\r\n * Compute the upper bound on time before two shapes penetrate. \r\n * Time is represented as a fraction between [0,tMax]. This uses\r\n * a swept separating axis and may miss some intermediate, \r\n * non-tunneling collision. If you change the time interval, you \r\n * should call this function again. \r\n * Note: use box2d.b2Distance to compute the contact point and \r\n * normal at the time of impact. \r\n * @export\r\n * @return {void}\r\n * @param {box2d.b2TOIOutput} output\r\n * @param {box2d.b2TOIInput} input\r\n */\r\nbox2d.b2TimeOfImpact = function (output, input)\r\n{\r\n\tvar timer = box2d.b2TimeOfImpact.s_timer.Reset();\r\n\r\n\t++box2d.b2_toiCalls;\r\n\r\n\toutput.state = box2d.b2TOIOutputState.e_unknown;\r\n\toutput.t = input.tMax;\r\n\r\n\t/** @type {box2d.b2DistanceProxy} */ var proxyA = input.proxyA;\r\n\t/** @type {box2d.b2DistanceProxy} */ var proxyB = input.proxyB;\r\n\r\n\t/** @type {box2d.b2Sweep} */ var sweepA = box2d.b2TimeOfImpact.s_sweepA.Copy(input.sweepA);\r\n\t/** @type {box2d.b2Sweep} */ var sweepB = box2d.b2TimeOfImpact.s_sweepB.Copy(input.sweepB);\r\n\r\n\t// Large rotations can make the root finder fail, so we normalize the\r\n\t// sweep angles.\r\n\tsweepA.Normalize();\r\n\tsweepB.Normalize();\r\n\r\n\t/** @type {number} */ var tMax = input.tMax;\r\n\r\n\t/** @type {number} */ var totalRadius = proxyA.m_radius + proxyB.m_radius;\r\n\t/** @type {number} */ var target = box2d.b2Max(box2d.b2_linearSlop, totalRadius - 3 * box2d.b2_linearSlop);\r\n\t/** @type {number} */ var tolerance = 0.25 * box2d.b2_linearSlop;\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(target > tolerance); }\r\n\r\n\t/** @type {number} */ var t1 = 0;\r\n\t/** @type {number} */ var k_maxIterations = 20; // TODO_ERIN b2Settings\r\n\t/** @type {number} */ var iter = 0;\r\n\r\n\t// Prepare input for distance query.\r\n\t/** @type {box2d.b2SimplexCache} */ var cache = box2d.b2TimeOfImpact.s_cache;\r\n\tcache.count = 0;\r\n\t/** @type {box2d.b2DistanceInput} */ var distanceInput = box2d.b2TimeOfImpact.s_distanceInput;\r\n\tdistanceInput.proxyA = input.proxyA;\r\n\tdistanceInput.proxyB = input.proxyB;\r\n\tdistanceInput.useRadii = false;\r\n\r\n\t// The outer loop progressively attempts to compute new separating axes.\r\n\t// This loop terminates when an axis is repeated (no progress is made).\r\n\tfor (;;)\r\n\t{\r\n\t\t/** @type {box2d.b2Transform} */ var xfA = box2d.b2TimeOfImpact.s_xfA;\r\n\t\t/** @type {box2d.b2Transform} */ var xfB = box2d.b2TimeOfImpact.s_xfB;\r\n\t\tsweepA.GetTransform(xfA, t1);\r\n\t\tsweepB.GetTransform(xfB, t1);\r\n\r\n\t\t// Get the distance between shapes. We can also use the results\r\n\t\t// to get a separating axis.\r\n\t\tdistanceInput.transformA.Copy(xfA);\r\n\t\tdistanceInput.transformB.Copy(xfB);\r\n\t\t/** @type {box2d.b2DistanceOutput} */ var distanceOutput = box2d.b2TimeOfImpact.s_distanceOutput;\r\n\t\tbox2d.b2Distance(distanceOutput, cache, distanceInput);\r\n\r\n\t\t// If the shapes are overlapped, we give up on continuous collision.\r\n\t\tif (distanceOutput.distance <= 0)\r\n\t\t{\r\n\t\t\t// Failure!\r\n\t\t\toutput.state = box2d.b2TOIOutputState.e_overlapped;\r\n\t\t\toutput.t = 0;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (distanceOutput.distance < target + tolerance)\r\n\t\t{\r\n\t\t\t// Victory!\r\n\t\t\toutput.state = box2d.b2TOIOutputState.e_touching;\r\n\t\t\toutput.t = t1;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Initialize the separating axis.\r\n\t\t/** @type {box2d.b2SeparationFunction} */ var fcn = box2d.b2TimeOfImpact.s_fcn;\r\n\t\tfcn.Initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\r\n/*\r\n#if 0\r\n\t\t// Dump the curve seen by the root finder\r\n\t\t{\r\n\t\t\tconst int32 N = 100;\r\n\t\t\tfloat32 dx = 1.0f / N;\r\n\t\t\tfloat32 xs[N+1];\r\n\t\t\tfloat32 fs[N+1];\r\n\r\n\t\t\tfloat32 x = 0.0f;\r\n\r\n\t\t\tfor (int32 i = 0; i <= N; ++i)\r\n\t\t\t{\r\n\t\t\t\tsweepA.GetTransform(&xfA, x);\r\n\t\t\t\tsweepB.GetTransform(&xfB, x);\r\n\t\t\t\tfloat32 f = fcn.Evaluate(xfA, xfB) - target;\r\n\r\n\t\t\t\tprintf(\"%g %g\\n\", x, f);\r\n\r\n\t\t\t\txs[i] = x;\r\n\t\t\t\tfs[i] = f;\r\n\r\n\t\t\t\tx += dx;\r\n\t\t\t}\r\n\t\t}\r\n#endif\r\n*/\r\n\r\n\t\t// Compute the TOI on the separating axis. We do this by successively\r\n\t\t// resolving the deepest point. This loop is bounded by the number of vertices.\r\n\t\t/** @type {boolean} */ var done = false;\r\n\t\t/** @type {number} */ var t2 = tMax;\r\n\t\t/** @type {number} */ var pushBackIter = 0;\r\n\t\tfor (;;)\r\n\t\t{\r\n\t\t\t// Find the deepest point at t2. Store the witness point indices.\r\n\t\t\t/** @type Array.<number>} */ var indexA = box2d.b2TimeOfImpact.s_indexA;\r\n\t\t\t/** @type Array.<number>} */ var indexB = box2d.b2TimeOfImpact.s_indexB;\r\n\t\t\t/** @type {number} */ var s2 = fcn.FindMinSeparation(indexA, indexB, t2);\r\n\r\n\t\t\t// Is the final configuration separated?\r\n\t\t\tif (s2 > (target + tolerance))\r\n\t\t\t{\r\n\t\t\t\t// Victory!\r\n\t\t\t\toutput.state = box2d.b2TOIOutputState.e_separated;\r\n\t\t\t\toutput.t = tMax;\r\n\t\t\t\tdone = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Has the separation reached tolerance?\r\n\t\t\tif (s2 > (target - tolerance))\r\n\t\t\t{\r\n\t\t\t\t// Advance the sweeps\r\n\t\t\t\tt1 = t2;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Compute the initial separation of the witness points.\r\n\t\t\t/** @type {number} */ var s1 = fcn.Evaluate(indexA[0], indexB[0], t1);\r\n\r\n\t\t\t// Check for initial overlap. This might happen if the root finder\r\n\t\t\t// runs out of iterations.\r\n\t\t\tif (s1 < (target - tolerance))\r\n\t\t\t{\r\n\t\t\t\toutput.state = box2d.b2TOIOutputState.e_failed;\r\n\t\t\t\toutput.t = t1;\r\n\t\t\t\tdone = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Check for touching\r\n\t\t\tif (s1 <= (target + tolerance))\r\n\t\t\t{\r\n\t\t\t\t// Victory! t1 should hold the TOI (could be 0.0).\r\n\t\t\t\toutput.state = box2d.b2TOIOutputState.e_touching;\r\n\t\t\t\toutput.t = t1;\r\n\t\t\t\tdone = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Compute 1D root of: f(x) - target = 0\r\n\t\t\t/** @type {number} */ var rootIterCount = 0;\r\n\t\t\t/** @type {number} */ var a1 = t1;\r\n\t\t\t/** @type {number} */ var a2 = t2;\r\n\t\t\tfor (;;)\r\n\t\t\t{\r\n\t\t\t\t// Use a mix of the secant rule and bisection.\r\n\t\t\t\t/** @type {number} */ var t = 0;\r\n\t\t\t\tif (rootIterCount & 1)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Secant rule to improve convergence.\r\n\t\t\t\t\tt = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// Bisection to guarantee progress.\r\n\t\t\t\t\tt = 0.5 * (a1 + a2);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++rootIterCount;\r\n\t\t\t\t++box2d.b2_toiRootIters;\r\n\r\n\t\t\t\t/** @type {number} */ var s = fcn.Evaluate(indexA[0], indexB[0], t);\r\n\r\n\t\t\t\tif (box2d.b2Abs(s - target) < tolerance)\r\n\t\t\t\t{\r\n\t\t\t\t\t// t2 holds a tentative value for t1\r\n\t\t\t\t\tt2 = t;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Ensure we continue to bracket the root.\r\n\t\t\t\tif (s > target)\r\n\t\t\t\t{\r\n\t\t\t\t\ta1 = t;\r\n\t\t\t\t\ts1 = s;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ta2 = t;\r\n\t\t\t\t\ts2 = s;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (rootIterCount === 50)\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbox2d.b2_toiMaxRootIters = box2d.b2Max(box2d.b2_toiMaxRootIters, rootIterCount);\r\n\r\n\t\t\t++pushBackIter;\r\n\r\n\t\t\tif (pushBackIter === box2d.b2_maxPolygonVertices)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t++iter;\r\n\t\t++box2d.b2_toiIters;\r\n\r\n\t\tif (done)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (iter === k_maxIterations)\r\n\t\t{\r\n\t\t\t// Root finder got stuck. Semi-victory.\r\n\t\t\toutput.state = box2d.b2TOIOutputState.e_failed;\r\n\t\t\toutput.t = t1;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tbox2d.b2_toiMaxIters = box2d.b2Max(box2d.b2_toiMaxIters, iter);\r\n\r\n\tvar time = timer.GetMilliseconds();\r\n\tbox2d.b2_toiMaxTime = box2d.b2Max(box2d.b2_toiMaxTime, time);\r\n\tbox2d.b2_toiTime += time;\r\n}\r\nbox2d.b2TimeOfImpact.s_timer = new box2d.b2Timer();\r\nbox2d.b2TimeOfImpact.s_cache = new box2d.b2SimplexCache();\r\nbox2d.b2TimeOfImpact.s_distanceInput = new box2d.b2DistanceInput();\r\nbox2d.b2TimeOfImpact.s_distanceOutput = new box2d.b2DistanceOutput();\r\nbox2d.b2TimeOfImpact.s_xfA = new box2d.b2Transform();\r\nbox2d.b2TimeOfImpact.s_xfB = new box2d.b2Transform();\r\nbox2d.b2TimeOfImpact.s_indexA = box2d.b2MakeNumberArray(1);\r\nbox2d.b2TimeOfImpact.s_indexB = box2d.b2MakeNumberArray(1);\r\nbox2d.b2TimeOfImpact.s_fcn = new box2d.b2SeparationFunction();\r\nbox2d.b2TimeOfImpact.s_sweepA = new box2d.b2Sweep();\r\nbox2d.b2TimeOfImpact.s_sweepB = new box2d.b2Sweep();\r\nbox2d.b2TimeOfImpact.s_pointA = new box2d.b2Vec2();\r\nbox2d.b2TimeOfImpact.s_pointB = new box2d.b2Vec2();\r\nbox2d.b2TimeOfImpact.s_normal = new box2d.b2Vec2();\r\nbox2d.b2TimeOfImpact.s_axisA = new box2d.b2Vec2();\r\nbox2d.b2TimeOfImpact.s_axisB = new box2d.b2Vec2();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Contact');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Collision');\r\ngoog.require('box2d.b2TimeOfImpact');\r\n\r\n/**\r\n * Friction mixing law. The idea is to allow either fixture to\r\n * drive the restitution to zero. For example, anything slides\r\n * on ice.\r\n * @export\r\n * @return {number}\r\n * @param {number} friction1\r\n * @param {number} friction2\r\n */\r\nbox2d.b2MixFriction = function (friction1, friction2)\r\n{\r\n\treturn box2d.b2Sqrt(friction1 * friction2);\r\n}\r\n\r\n/**\r\n * Restitution mixing law. The idea is allow for anything to\r\n * bounce off an inelastic surface. For example, a superball\r\n * bounces on anything.\r\n * @export\r\n * @return {number}\r\n * @param {number} restitution1\r\n * @param {number} restitution2\r\n */\r\nbox2d.b2MixRestitution = function (restitution1, restitution2)\r\n{\r\n\treturn restitution1 > restitution2 ? restitution1 : restitution2;\r\n}\r\n\r\n/**\r\n * A contact edge is used to connect bodies and contacts\r\n * together in a contact graph where each body is a node and\r\n * each contact is an edge. A contact edge belongs to a doubly\r\n * linked list maintained in each attached body. Each contact\r\n * has two contact nodes, one for each attached body.\r\n * @export\r\n * @constructor\r\n */\r\nbox2d.b2ContactEdge = function ()\r\n{\r\n};\r\n\r\n/**\r\n * @export\r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2ContactEdge.prototype.other = null; ///< provides quick access to the other body attached.\r\n/**\r\n * @export\r\n * @type {box2d.b2Contact}\r\n */\r\nbox2d.b2ContactEdge.prototype.contact = null; ///< the contact\r\n/**\r\n * @export\r\n * @type {box2d.b2ContactEdge}\r\n */\r\nbox2d.b2ContactEdge.prototype.prev = null; ///< the previous contact edge in the body's contact list\r\n/**\r\n * @export\r\n * @type {box2d.b2ContactEdge}\r\n */\r\nbox2d.b2ContactEdge.prototype.next = null; ///< the next contact edge in the body's contact list\r\n\r\n/**\r\n * Flags stored in m_flags\r\n * @enum\r\n */\r\nbox2d.b2ContactFlag = \r\n{\r\n\te_none\t\t\t: 0,\r\n\te_islandFlag\t: 0x0001, /// Used when crawling contact graph when forming islands.\r\n\te_touchingFlag\t: 0x0002, /// Set when the shapes are touching.\r\n\te_enabledFlag\t: 0x0004, /// This contact can be disabled (by user)\r\n\te_filterFlag\t: 0x0008, /// This contact needs filtering because a fixture filter was changed.\r\n\te_bulletHitFlag\t: 0x0010, /// This bullet contact had a TOI event\r\n\te_toiFlag\t\t: 0x0020  /// This contact has a valid TOI in m_toi\r\n};\r\ngoog.exportProperty(box2d.b2ContactFlag, 'e_none'         , box2d.b2ContactFlag.e_none         );\r\ngoog.exportProperty(box2d.b2ContactFlag, 'e_islandFlag'   , box2d.b2ContactFlag.e_islandFlag   );\r\ngoog.exportProperty(box2d.b2ContactFlag, 'e_touchingFlag' , box2d.b2ContactFlag.e_touchingFlag );\r\ngoog.exportProperty(box2d.b2ContactFlag, 'e_enabledFlag'  , box2d.b2ContactFlag.e_enabledFlag  );\r\ngoog.exportProperty(box2d.b2ContactFlag, 'e_filterFlag'   , box2d.b2ContactFlag.e_filterFlag   );\r\ngoog.exportProperty(box2d.b2ContactFlag, 'e_bulletHitFlag', box2d.b2ContactFlag.e_bulletHitFlag);\r\ngoog.exportProperty(box2d.b2ContactFlag, 'e_toiFlag'      , box2d.b2ContactFlag.e_toiFlag      );\r\n\r\n/**\r\n * The class manages contact between two shapes. A contact\r\n * exists for each overlapping AABB in the broad-phase (except\r\n * if filtered). Therefore a contact object may exist that has\r\n * no contact points.\r\n * @export\r\n * @constructor\r\n */\r\nbox2d.b2Contact = function ()\r\n{\r\n\tthis.m_nodeA = new box2d.b2ContactEdge();\r\n\tthis.m_nodeB = new box2d.b2ContactEdge();\r\n\tthis.m_manifold = new box2d.b2Manifold();\r\n\tthis.m_oldManifold = new box2d.b2Manifold();\r\n}\r\n\r\n/**\r\n * @export\r\n * @type {box2d.b2ContactFlag}\r\n */\r\nbox2d.b2Contact.prototype.m_flags = box2d.b2ContactFlag.e_none;\r\n\r\n/**\r\n * World pool and list pointers.\r\n * @export\r\n * @type {box2d.b2Contact}\r\n */\r\nbox2d.b2Contact.prototype.m_prev = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2Contact}\r\n */\r\nbox2d.b2Contact.prototype.m_next = null;\r\n\r\n/**\r\n * Nodes for connecting bodies.\r\n * @export\r\n * @type {box2d.b2ContactEdge}\r\n */\r\nbox2d.b2Contact.prototype.m_nodeA = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2ContactEdge}\r\n */\r\nbox2d.b2Contact.prototype.m_nodeB = null;\r\n\r\n/**\r\n * @export\r\n * @type {box2d.b2Fixture}\r\n */\r\nbox2d.b2Contact.prototype.m_fixtureA = null;\r\n/**\r\n * @export\r\n * @type {box2d.b2Fixture}\r\n */\r\nbox2d.b2Contact.prototype.m_fixtureB = null;\r\n\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2Contact.prototype.m_indexA = 0;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2Contact.prototype.m_indexB = 0;\r\n\r\n/**\r\n * @export\r\n * @type {box2d.b2Manifold}\r\n */\r\nbox2d.b2Contact.prototype.m_manifold = null;\r\n\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2Contact.prototype.m_toiCount = 0;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2Contact.prototype.m_toi = 0;\r\n\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2Contact.prototype.m_friction = 0;\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2Contact.prototype.m_restitution = 0;\r\n\r\n/**\r\n * @export\r\n * @type {number}\r\n */\r\nbox2d.b2Contact.prototype.m_tangentSpeed = 0;\r\n\r\n/**\r\n * @export\r\n * @type {box2d.b2Manifold}\r\n */\r\nbox2d.b2Contact.prototype.m_oldManifold = null;\r\n\r\n/**\r\n * Get the contact manifold. Do not modify the manifold unless\r\n * you understand the internals of Box2D.\r\n * @export\r\n * @return {box2d.b2Manifold}\r\n */\r\nbox2d.b2Contact.prototype.GetManifold = function ()\r\n{\r\n\treturn this.m_manifold;\r\n}\r\n\r\n/**\r\n * Get the world manifold.\r\n * @export\r\n * @return {void}\r\n * @param {box2d.b2WorldManifold} worldManifold\r\n */\r\nbox2d.b2Contact.prototype.GetWorldManifold = function (worldManifold)\r\n{\r\n\tvar bodyA = this.m_fixtureA.GetBody();\r\n\tvar bodyB = this.m_fixtureB.GetBody();\r\n\tvar shapeA = this.m_fixtureA.GetShape();\r\n\tvar shapeB = this.m_fixtureB.GetShape();\r\n\tworldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);\r\n}\r\n\r\n/**\r\n * Is this contact touching?\r\n * @export\r\n * @return {boolean}\r\n */\r\nbox2d.b2Contact.prototype.IsTouching = function ()\r\n{\r\n\treturn (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag;\r\n}\r\n\r\n/**\r\n * Enable/disable this contact. This can be used inside the\r\n * pre-solve contact listener. The contact is only disabled for\r\n * the current time step (or sub-step in continuous collisions).\r\n * @export\r\n * @return {void}\r\n * @param {boolean} flag\r\n */\r\nbox2d.b2Contact.prototype.SetEnabled = function (flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2ContactFlag.e_enabledFlag;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_flags &= ~box2d.b2ContactFlag.e_enabledFlag;\r\n\t}\r\n}\r\n\r\n/**\r\n * Has this contact been disabled?\r\n * @export\r\n * @return {boolean}\r\n */\r\nbox2d.b2Contact.prototype.IsEnabled = function ()\r\n{\r\n\treturn (this.m_flags & box2d.b2ContactFlag.e_enabledFlag) === box2d.b2ContactFlag.e_enabledFlag;\r\n}\r\n\r\n/**\r\n * Get the next contact in the world's contact list.\r\n * @export\r\n * @return {box2d.b2Contact}\r\n */\r\nbox2d.b2Contact.prototype.GetNext = function ()\r\n{\r\n\treturn this.m_next;\r\n}\r\n\r\n/**\r\n * Get fixture A in this contact.\r\n * @export\r\n * @return {box2d.b2Fixture}\r\n */\r\nbox2d.b2Contact.prototype.GetFixtureA = function ()\r\n{\r\n\treturn this.m_fixtureA;\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {number}\r\n */\r\nbox2d.b2Contact.prototype.GetChildIndexA = function ()\r\n{\r\n\treturn this.m_indexA;\r\n}\r\n\r\n/**\r\n * Get fixture B in this contact.\r\n * @export\r\n * @return {box2d.b2Fixture}\r\n */\r\nbox2d.b2Contact.prototype.GetFixtureB = function ()\r\n{\r\n\treturn this.m_fixtureB;\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {number}\r\n */\r\nbox2d.b2Contact.prototype.GetChildIndexB = function ()\r\n{\r\n\treturn this.m_indexB;\r\n}\r\n\r\n/**\r\n * Evaluate this contact with your own manifold and transforms.\r\n * @export\r\n * @return {void}\r\n * @param {box2d.b2Manifold} manifold\r\n * @param {box2d.b2Transform} xfA\r\n * @param {box2d.b2Transform} xfB\r\n */\r\nbox2d.b2Contact.prototype.Evaluate = function (manifold, xfA, xfB)\r\n{\r\n}\r\n\r\n/**\r\n * Flag this contact for filtering. Filtering will occur the\r\n * next time step.\r\n * @export\r\n * @return {void}\r\n */\r\nbox2d.b2Contact.prototype.FlagForFiltering = function ()\r\n{\r\n\tthis.m_flags |= box2d.b2ContactFlag.e_filterFlag;\r\n}\r\n\r\n/**\r\n * Override the default friction mixture. You can call this in\r\n * box2d.b2ContactListener::PreSolve.\r\n * This value persists until set or reset.\r\n * @export\r\n * @return {void}\r\n * @param {number} friction\r\n */\r\nbox2d.b2Contact.prototype.SetFriction = function (friction)\r\n{\r\n\tthis.m_friction = friction;\r\n}\r\n\r\n/**\r\n * Get the friction.\r\n * @export\r\n * @return {number}\r\n */\r\nbox2d.b2Contact.prototype.GetFriction = function ()\r\n{\r\n\treturn this.m_friction;\r\n}\r\n\r\n/**\r\n * Reset the friction mixture to the default value.\r\n * @export\r\n * @return {void}\r\n */\r\nbox2d.b2Contact.prototype.ResetFriction = function ()\r\n{\r\n\tthis.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\r\n}\r\n\r\n/**\r\n * Override the default restitution mixture. You can call this\r\n * in box2d.b2ContactListener::PreSolve.\r\n * The value persists until you set or reset.\r\n * @export\r\n * @return {void}\r\n * @param {number} restitution\r\n */\r\nbox2d.b2Contact.prototype.SetRestitution = function (restitution)\r\n{\r\n\tthis.m_restitution = restitution;\r\n}\r\n\r\n/**\r\n * Get the restitution.\r\n * @export\r\n * @return {number}\r\n */\r\nbox2d.b2Contact.prototype.GetRestitution = function ()\r\n{\r\n\treturn this.m_restitution;\r\n}\r\n\r\n/**\r\n * Reset the restitution to the default value.\r\n * @export\r\n * @return {void}\r\n */\r\nbox2d.b2Contact.prototype.ResetRestitution = function ()\r\n{\r\n\tthis.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\r\n}\r\n\r\n/**\r\n * Set the desired tangent speed for a conveyor belt behavior.\r\n * In meters per second.\r\n * @export\r\n * @return {void}\r\n * @param {number} speed\r\n */\r\nbox2d.b2Contact.prototype.SetTangentSpeed = function (speed)\r\n{\r\n\tthis.m_tangentSpeed = speed;\r\n}\r\n\r\n/**\r\n * Get the desired tangent speed. In meters per second.\r\n * @export\r\n * @return {number}\r\n */\r\nbox2d.b2Contact.prototype.GetTangentSpeed = function ()\r\n{\r\n\treturn this.m_tangentSpeed;\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {void}\r\n * @param {box2d.b2Fixture} fixtureA\r\n * @param {box2d.b2Fixture} fixtureB\r\n */\r\nbox2d.b2Contact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)\r\n{\r\n\tthis.m_flags = box2d.b2ContactFlag.e_enabledFlag;\r\n\r\n\tthis.m_fixtureA = fixtureA;\r\n\tthis.m_fixtureB = fixtureB;\r\n\r\n\tthis.m_indexA = indexA;\r\n\tthis.m_indexB = indexB;\r\n\r\n\tthis.m_manifold.pointCount = 0;\r\n\r\n\tthis.m_prev = null;\r\n\tthis.m_next = null;\r\n\r\n\tthis.m_nodeA.contact = null;\r\n\tthis.m_nodeA.prev = null;\r\n\tthis.m_nodeA.next = null;\r\n\tthis.m_nodeA.other = null;\r\n\r\n\tthis.m_nodeB.contact = null;\r\n\tthis.m_nodeB.prev = null;\r\n\tthis.m_nodeB.next = null;\r\n\tthis.m_nodeB.other = null;\r\n\r\n\tthis.m_toiCount = 0;\r\n\r\n\tthis.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\r\n\tthis.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\r\n}\r\n\r\n/**\r\n * Update the contact manifold and touching status.\r\n * Note: do not assume the fixture AABBs are overlapping or are\r\n * valid.\r\n * @export\r\n * @return {void}\r\n * @param {box2d.b2ContactListener} listener\r\n */\r\nbox2d.b2Contact.prototype.Update = function (listener)\r\n{\r\n\tvar tManifold = this.m_oldManifold;\r\n\tthis.m_oldManifold = this.m_manifold;\r\n\tthis.m_manifold = tManifold;\r\n\r\n\t// Re-enable this contact.\r\n\tthis.m_flags |= box2d.b2ContactFlag.e_enabledFlag;\r\n\r\n\tvar touching = false;\r\n\tvar wasTouching = (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag;\r\n\r\n\tvar sensorA = this.m_fixtureA.IsSensor();\r\n\tvar sensorB = this.m_fixtureB.IsSensor();\r\n\tvar sensor = sensorA || sensorB;\r\n\r\n\tvar bodyA = this.m_fixtureA.GetBody();\r\n\tvar bodyB = this.m_fixtureB.GetBody();\r\n\tvar xfA = bodyA.GetTransform();\r\n\tvar xfB = bodyB.GetTransform();\r\n\r\n//\tvar aabbOverlap = box2d.b2TestOverlapAABB(this.m_fixtureA.GetAABB(0), this.m_fixtureB.GetAABB(0));\r\n\r\n\t// Is this contact a sensor?\r\n\tif (sensor)\r\n\t{\r\n//\t\tif (aabbOverlap)\r\n//\t\t{\r\n\t\t\tvar shapeA = this.m_fixtureA.GetShape();\r\n\t\t\tvar shapeB = this.m_fixtureB.GetShape();\r\n\t\t\ttouching = box2d.b2TestOverlapShape(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\r\n//\t\t}\r\n\r\n\t\t// Sensors don't generate manifolds.\r\n\t\tthis.m_manifold.pointCount = 0;\r\n\t}\r\n\telse\r\n\t{\r\n//\t\tif (aabbOverlap)\r\n//\t\t{\r\n\t\t\tthis.Evaluate(this.m_manifold, xfA, xfB);\r\n\t\t\ttouching = this.m_manifold.pointCount > 0;\r\n\r\n\t\t\t// Match old contact ids to new contact ids and copy the\r\n\t\t\t// stored impulses to warm start the solver.\r\n\t\t\tfor (var i = 0; i < this.m_manifold.pointCount; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar mp2 = this.m_manifold.points[i];\r\n\t\t\t\tmp2.normalImpulse = 0;\r\n\t\t\t\tmp2.tangentImpulse = 0;\r\n\t\t\t\tvar id2 = mp2.id;\r\n\r\n\t\t\t\tfor (var j = 0; j < this.m_oldManifold.pointCount; ++j)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar mp1 = this.m_oldManifold.points[j];\r\n\r\n\t\t\t\t\tif (mp1.id.key === id2.key)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmp2.normalImpulse = mp1.normalImpulse;\r\n\t\t\t\t\t\tmp2.tangentImpulse = mp1.tangentImpulse;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n//\t\t}\r\n//\t\telse\r\n//\t\t{\r\n//\t\t\tthis.m_manifold.pointCount = 0;\r\n//\t\t}\r\n\r\n\t\tif (touching !== wasTouching)\r\n\t\t{\r\n\t\t\tbodyA.SetAwake(true);\r\n\t\t\tbodyB.SetAwake(true);\r\n\t\t}\r\n\t}\r\n\r\n\tif (touching)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2ContactFlag.e_touchingFlag;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_flags &= ~box2d.b2ContactFlag.e_touchingFlag;\r\n\t}\r\n\r\n\tif (wasTouching === false && touching === true && listener)\r\n\t{\r\n\t\tlistener.BeginContact(this);\r\n\t}\r\n\r\n\tif (wasTouching === true && touching === false && listener)\r\n\t{\r\n\t\tlistener.EndContact(this);\r\n\t}\r\n\r\n\tif (sensor === false && touching && listener)\r\n\t{\r\n\t\tlistener.PreSolve(this, this.m_oldManifold);\r\n\t}\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {number}\r\n * @param {box2d.b2Sweep} sweepA\r\n * @param {box2d.b2Sweep} sweepB\r\n */\r\nbox2d.b2Contact.prototype.ComputeTOI = function (sweepA, sweepB)\r\n{\r\n\tvar input = box2d.b2Contact.prototype.ComputeTOI.s_input;\r\n\tinput.proxyA.SetShape(this.m_fixtureA.GetShape(), this.m_indexA);\r\n\tinput.proxyB.SetShape(this.m_fixtureB.GetShape(), this.m_indexB);\r\n\tinput.sweepA.Copy(sweepA);\r\n\tinput.sweepB.Copy(sweepB);\r\n\tinput.tMax = box2d.b2_linearSlop;\r\n\r\n\tvar output = box2d.b2Contact.prototype.ComputeTOI.s_output;\r\n\r\n\tbox2d.b2TimeOfImpact(output, input);\r\n\r\n\treturn output.t;\r\n}\r\nbox2d.b2Contact.prototype.ComputeTOI.s_input = new box2d.b2TOIInput();\r\nbox2d.b2Contact.prototype.ComputeTOI.s_output = new box2d.b2TOIOutput();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2PolygonAndCircleContact');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Contact');\r\n\r\n/**\r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Contact} \r\n */\r\nbox2d.b2PolygonAndCircleContact = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n};\r\n\r\ngoog.inherits(box2d.b2PolygonAndCircleContact, box2d.b2Contact);\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Contact} \r\n * @param allocator \r\n */\r\nbox2d.b2PolygonAndCircleContact.Create = function (allocator)\r\n{\r\n\treturn new box2d.b2PolygonAndCircleContact();\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n * @param allocator \r\n */\r\nbox2d.b2PolygonAndCircleContact.Destroy = function (contact, allocator)\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixtureA\r\n * @param {box2d.b2Fixture} fixtureB\r\n */\r\nbox2d.b2PolygonAndCircleContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)\r\n{\r\n\tgoog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_polygonShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_circleShape); }\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2PolygonAndCircleContact.prototype.Evaluate = function (manifold, xfA, xfB)\r\n{\r\n\tvar shapeA = this.m_fixtureA.GetShape();\r\n\tvar shapeB = this.m_fixtureB.GetShape();\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2PolygonShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2CircleShape); }\r\n\tbox2d.b2CollidePolygonAndCircle(\r\n\t\tmanifold, \r\n\t\t(shapeA instanceof box2d.b2PolygonShape)? shapeA : null, xfA, \r\n\t\t(shapeB instanceof box2d.b2CircleShape)? shapeB : null, xfB);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2EdgeAndPolygonContact');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Contact');\r\n\r\n/**\r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Contact} \r\n */\r\nbox2d.b2EdgeAndPolygonContact = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n};\r\n\r\ngoog.inherits(box2d.b2EdgeAndPolygonContact, box2d.b2Contact);\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Contact} \r\n * @param allocator \r\n */\r\nbox2d.b2EdgeAndPolygonContact.Create = function (allocator)\r\n{\r\n\treturn new box2d.b2EdgeAndPolygonContact();\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n * @param allocator \r\n */\r\nbox2d.b2EdgeAndPolygonContact.Destroy = function (contact, allocator)\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixtureA\r\n * @param {box2d.b2Fixture} fixtureB\r\n */\r\nbox2d.b2EdgeAndPolygonContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)\r\n{\r\n\tgoog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_edgeShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_polygonShape); }\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2EdgeAndPolygonContact.prototype.Evaluate = function (manifold, xfA, xfB)\r\n{\r\n\tvar shapeA = this.m_fixtureA.GetShape();\r\n\tvar shapeB = this.m_fixtureB.GetShape();\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2EdgeShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2PolygonShape); }\r\n\tbox2d.b2CollideEdgeAndPolygon(\r\n\t\tmanifold, \r\n\t\t(shapeA instanceof box2d.b2EdgeShape)? shapeA : null, xfA, \r\n\t\t(shapeB instanceof box2d.b2PolygonShape)? shapeB : null, xfB);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Shape');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2Distance');\r\n\r\n/** \r\n * This holds the mass data computed for a shape. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2MassData = function ()\r\n{\r\n\tthis.center = new box2d.b2Vec2(0, 0);\r\n};\r\n\r\n/** \r\n * The mass of the shape, usually in kilograms. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MassData.prototype.mass = 0;\r\n\r\n/** \r\n * The position of the shape's centroid relative to the shape's \r\n * origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MassData.prototype.center = null;\r\n\r\n/** \r\n * The rotational inertia of the shape about the local origin. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MassData.prototype.I = 0;\r\n\r\n/** \r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2ShapeType = \r\n{\r\n\te_unknown\t\t\t: -1,\r\n\te_circleShape\t\t: 0,\r\n\te_edgeShape\t\t\t: 1,\r\n\te_polygonShape\t\t: 2,\r\n\te_chainShape\t\t: 3,\r\n\te_shapeTypeCount\t: 4\r\n};\r\ngoog.exportProperty(box2d.b2ShapeType, 'e_unknown'       , box2d.b2ShapeType.e_unknown       );\r\ngoog.exportProperty(box2d.b2ShapeType, 'e_circleShape'   , box2d.b2ShapeType.e_circleShape   );\r\ngoog.exportProperty(box2d.b2ShapeType, 'e_edgeShape'     , box2d.b2ShapeType.e_edgeShape     );\r\ngoog.exportProperty(box2d.b2ShapeType, 'e_polygonShape'  , box2d.b2ShapeType.e_polygonShape  );\r\ngoog.exportProperty(box2d.b2ShapeType, 'e_chainShape'    , box2d.b2ShapeType.e_chainShape    );\r\ngoog.exportProperty(box2d.b2ShapeType, 'e_shapeTypeCount', box2d.b2ShapeType.e_shapeTypeCount);\r\n\r\n/** \r\n * A shape is used for collision detection. You can create a \r\n * shape however you like. \r\n * Shapes used for simulation in box2d.b2World are created \r\n * automatically when a box2d.b2Fixture is created. Shapes may \r\n * encapsulate a one or more child shapes. \r\n * @export \r\n * @constructor \r\n * @param {box2d.b2ShapeType} type \r\n * @param {number} radius \r\n */\r\nbox2d.b2Shape = function (type, radius)\r\n{\r\n\tthis.m_type = type;\r\n\tthis.m_radius = radius;\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2ShapeType}\r\n */\r\nbox2d.b2Shape.prototype.m_type = box2d.b2ShapeType.e_unknown;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Shape.prototype.m_radius = 0;\r\n\r\n/** \r\n * Clone the concrete shape using the provided allocator. \r\n * @export \r\n * @return {box2d.b2Shape}\r\n */\r\nbox2d.b2Shape.prototype.Clone = function ()\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Shape} \r\n * @param {box2d.b2Shape} other \r\n */\r\nbox2d.b2Shape.prototype.Copy = function (other)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_type === other.m_type); }\r\n\tthis.m_radius = other.m_radius;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Get the type of this shape. You can use this to down cast to \r\n * the concrete shape. \r\n * @export \r\n * @return {box2d.b2ShapeType} the shape type.\r\n */\r\nbox2d.b2Shape.prototype.GetType = function ()\r\n{\r\n\treturn this.m_type;\r\n}\r\n\r\n/** \r\n * Get the number of child primitives. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Shape.prototype.GetChildCount = function ()\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, \"pure virtual\"); }\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * Test a point for containment in this shape. This only works \r\n * for convex shapes. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2Transform} xf the shape world transform.\r\n * @param {box2d.b2Vec2} p a point in world coordinates.\r\n */\r\nbox2d.b2Shape.prototype.TestPoint = function (xf, p)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, \"pure virtual\"); }\r\n\treturn false;\r\n}\r\n\r\n/** \r\n * Cast a ray against a child shape. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2RayCastOutput} output the ray-cast results.\r\n * @param {box2d.b2RayCastInput} input the ray-cast input parameters.\r\n * @param {box2d.b2Transform} transform the transform to be applied to the shape.\r\n * @param {number} childIndex the child shape index\r\n */\r\nbox2d.b2Shape.prototype.RayCast = function (output, input, transform, childIndex)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, \"pure virtual\"); }\r\n\treturn false;\r\n}\r\n\r\n/** \r\n * Given a transform, compute the associated axis aligned \r\n * bounding box for a child shape. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2AABB} aabb returns the axis aligned box.\r\n * @param {box2d.b2Transform} xf the world transform of the shape.\r\n * @param {number} childIndex the child shape\r\n */\r\nbox2d.b2Shape.prototype.ComputeAABB = function (aabb, xf, childIndex)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, \"pure virtual\"); }\r\n}\r\n\r\n/** \r\n * Compute the mass properties of this shape using its \r\n * dimensions and density. \r\n * The inertia tensor is computed about the local origin.\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2MassData} massData returns the mass data for this shape.\r\n * @param {number} density the density in kilograms per meter squared.\r\n */\r\nbox2d.b2Shape.prototype.ComputeMass = function (massData, density)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, \"pure virtual\"); }\r\n}\r\n\r\n/**\r\n * @return {void} \r\n * @param {box2d.b2DistanceProxy} proxy \r\n * @param {number} index \r\n */\r\nbox2d.b2Shape.prototype.SetupDistanceProxy = function (proxy, index)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, \"pure virtual\"); }\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} normal\r\n * @param {number} offset\r\n * @param {box2d.b2Transform} xf\r\n * @param {box2d.b2Vec2} c\r\n */\r\nbox2d.b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, \"pure virtual\"); }\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * Dump this shape to the log file. \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2Shape.prototype.Dump = function ()\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false, \"pure virtual\"); }\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2PolygonShape');\r\n\r\ngoog.require('box2d.b2Shape');\r\n\r\n/** \r\n * A convex polygon. It is assumed that the interior of the \r\n * polygon is to the left of each edge. \r\n * Polygons have a maximum number of vertices equal to \r\n * box2d.b2_maxPolygonVertices. In most cases you should not \r\n * need many vertices for a convex polygon. \r\n * @export \r\n * @constructor\r\n * @extends {box2d.b2Shape} \r\n */\r\nbox2d.b2PolygonShape = function ()\r\n{\r\n\tgoog.base(this, box2d.b2ShapeType.e_polygonShape, box2d.b2_polygonRadius); // base class constructor\r\n\r\n\tthis.m_centroid = new box2d.b2Vec2(0, 0);\r\n\tthis.m_vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);\r\n\tthis.m_normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);\r\n}\r\n\r\ngoog.inherits(box2d.b2PolygonShape, box2d.b2Shape);\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PolygonShape.prototype.m_centroid = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2PolygonShape.prototype.m_vertices = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2PolygonShape.prototype.m_normals = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PolygonShape.prototype.m_count = 0;\r\n\r\n/** \r\n * Implement box2d.b2Shape. \r\n * @export \r\n * @return {box2d.b2Shape} \r\n */\r\nbox2d.b2PolygonShape.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2PolygonShape().Copy(this);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Shape} \r\n * @param {box2d.b2Shape} other\r\n */\r\nbox2d.b2PolygonShape.prototype.Copy = function (other)\r\n{\r\n\tgoog.base(this, 'Copy', other);\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(other instanceof box2d.b2PolygonShape); }\r\n\r\n\tthis.m_centroid.Copy(other.m_centroid);\r\n\tthis.m_count = other.m_count;\r\n\tfor (var i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tthis.m_vertices[i].Copy(other.m_vertices[i]);\r\n\t\tthis.m_normals[i].Copy(other.m_normals[i]);\r\n\t}\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Build vertices to represent an axis-aligned box centered on \r\n * the local origin. \r\n * @export \r\n * @return {box2d.b2PolygonShape} \r\n * @param {number} hx the half-width.\r\n * @param {number} hy the half-height.\r\n */\r\nbox2d.b2PolygonShape.prototype.SetAsBox = function (hx, hy)\r\n{\r\n\tthis.m_count = 4;\r\n\tthis.m_vertices[0].SetXY((-hx), (-hy));\r\n\tthis.m_vertices[1].SetXY(hx, (-hy));\r\n\tthis.m_vertices[2].SetXY(hx, hy);\r\n\tthis.m_vertices[3].SetXY((-hx), hy);\r\n\tthis.m_normals[0].SetXY(0, (-1));\r\n\tthis.m_normals[1].SetXY(1, 0);\r\n\tthis.m_normals[2].SetXY(0, 1);\r\n\tthis.m_normals[3].SetXY((-1), 0);\r\n\tthis.m_centroid.SetZero();\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Build vertices to represent an oriented box. \r\n * @export \r\n * @return {box2d.b2PolygonShape} \r\n * @param {number} hx the half-width.\r\n * @param {number} hy the half-height.\r\n * @param {box2d.b2Vec2} center the center of the box in local coordinates.\r\n * @param {number} angle the rotation of the box in local coordinates.\r\n */\r\nbox2d.b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle)\r\n{\r\n\tthis.m_count = 4;\r\n\tthis.m_vertices[0].SetXY((-hx), (-hy));\r\n\tthis.m_vertices[1].SetXY(hx, (-hy));\r\n\tthis.m_vertices[2].SetXY(hx, hy);\r\n\tthis.m_vertices[3].SetXY((-hx), hy);\r\n\tthis.m_normals[0].SetXY(0, (-1));\r\n\tthis.m_normals[1].SetXY(1, 0);\r\n\tthis.m_normals[2].SetXY(0, 1);\r\n\tthis.m_normals[3].SetXY((-1), 0);\r\n\tthis.m_centroid.Copy(center);\r\n\r\n\tvar xf = new box2d.b2Transform();\r\n\txf.SetPosition(center);\r\n\txf.SetRotationAngleRadians(angle);\r\n\r\n\t// Transform vertices and normals.\r\n\tfor (var i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tbox2d.b2MulXV(xf, this.m_vertices[i], this.m_vertices[i]);\r\n\t\tbox2d.b2MulRV(xf.q, this.m_normals[i], this.m_normals[i]);\r\n\t}\r\n\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * Create a convex hull from the given array of local points.\r\n * The count must be in the range [3, b2_maxPolygonVertices].\r\n * warning the points may be re-ordered, even if they form a \r\n * convex polygon \r\n * warning collinear points are handled but not removed. \r\n * Collinear points may lead to poor stacking behavior. \r\n * @export \r\n * @return {box2d.b2PolygonShape} \r\n * @param {Array.<box2d.b2Vec2>} vertices\r\n * @param {number=} count\r\n */\r\nbox2d.b2PolygonShape.prototype.Set = function (vertices, count)\r\n{\r\n\tif (count === undefined) count = vertices.length;\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(3 <= count && count <= box2d.b2_maxPolygonVertices); }\r\n\tif (count < 3)\r\n\t{\r\n\t\treturn this.SetAsBox(1, 1);\r\n\t}\r\n\t\r\n\tvar n = box2d.b2Min(count, box2d.b2_maxPolygonVertices);\r\n\r\n\t// Perform welding and copy vertices into local buffer.\r\n\tvar ps = box2d.b2PolygonShape.prototype.Set.s_ps;\r\n\tvar tempCount = 0;\r\n\tfor (var i = 0; i < n; ++i)\r\n\t{\r\n\t\tvar /*b2Vec2*/ v = vertices[i];\r\n\r\n\t\tvar /*bool*/ unique = true;\r\n\t\tfor (var /*int32*/ j = 0; j < tempCount; ++j)\r\n\t\t{\r\n\t\t\tif (box2d.b2DistanceSquaredVV(v, ps[j]) < 0.5 * box2d.b2_linearSlop)\r\n\t\t\t{\r\n\t\t\t\tunique = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (unique)\r\n\t\t{\r\n\t\t\tps[tempCount++].Copy(v); // ps[tempCount++] = v;\r\n\t\t}\r\n\t}\r\n\r\n\tn = tempCount;\r\n\tif (n < 3)\r\n\t{\r\n\t\t// Polygon is degenerate.\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\treturn this.SetAsBox(1.0, 1.0);\r\n\t}\r\n\r\n\t// Create the convex hull using the Gift wrapping algorithm\r\n\t// http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\r\n\r\n\t// Find the right most point on the hull\r\n\tvar i0 = 0;\r\n\tvar x0 = ps[0].x;\r\n\tfor (var i = 1; i < n; ++i)\r\n\t{\r\n\t\tvar x = ps[i].x;\r\n\t\tif (x > x0 || (x === x0 && ps[i].y < ps[i0].y))\r\n\t\t{\r\n\t\t\ti0 = i;\r\n\t\t\tx0 = x;\r\n\t\t}\r\n\t}\r\n\r\n\tvar hull = box2d.b2PolygonShape.prototype.Set.s_hull;\r\n\tvar m = 0;\r\n\tvar ih = i0;\r\n\r\n\tfor (;;)\r\n\t{\r\n\t\thull[m] = ih;\r\n\r\n\t\tvar ie = 0;\r\n\t\tfor (var j = 1; j < n; ++j)\r\n\t\t{\r\n\t\t\tif (ie === ih)\r\n\t\t\t{\r\n\t\t\t\tie = j;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tvar r = box2d.b2SubVV(ps[ie], ps[hull[m]], box2d.b2PolygonShape.prototype.Set.s_r);\r\n\t\t\tvar v = box2d.b2SubVV(ps[j], ps[hull[m]], box2d.b2PolygonShape.prototype.Set.s_v);\r\n\t\t\tvar c = box2d.b2CrossVV(r, v);\r\n\t\t\tif (c < 0)\r\n\t\t\t{\r\n\t\t\t\tie = j;\r\n\t\t\t}\r\n\r\n\t\t\t// Collinearity check\r\n\t\t\tif (c === 0 && v.GetLengthSquared() > r.GetLengthSquared())\r\n\t\t\t{\r\n\t\t\t\tie = j;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t++m;\r\n\t\tih = ie;\r\n\r\n\t\tif (ie === i0)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tthis.m_count = m;\r\n\r\n\t// Copy vertices.\r\n\tfor (var i = 0; i < m; ++i)\r\n\t{\r\n\t\tthis.m_vertices[i].Copy(ps[hull[i]]);\r\n\t}\r\n\r\n\t// Compute normals. Ensure the edges have non-zero length.\r\n\tfor (var i = 0, ict = m; i < ict; ++i)\r\n\t{\r\n\t\tvar vertexi1 = this.m_vertices[i];\r\n\t\tvar vertexi2 = this.m_vertices[(i + 1) % ict];\r\n\t\tvar edge = box2d.b2SubVV(vertexi2, vertexi1, box2d.b2Vec2.s_t0); // edge uses s_t0\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(edge.GetLengthSquared() > box2d.b2_epsilon_sq); }\r\n\t\tbox2d.b2CrossVOne(edge, this.m_normals[i]).SelfNormalize();\r\n\t}\r\n\r\n\t// Compute the polygon centroid.\r\n\tbox2d.b2PolygonShape.ComputeCentroid(this.m_vertices, m, this.m_centroid);\r\n\r\n\treturn this;\r\n}\r\nbox2d.b2PolygonShape.prototype.Set.s_ps = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);\r\nbox2d.b2PolygonShape.prototype.Set.s_hull = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);\r\nbox2d.b2PolygonShape.prototype.Set.s_r = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.Set.s_v = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2PolygonShape} \r\n * @param {Array.<box2d.b2Vec2>} vertices\r\n * @param {number=} count \r\n */\r\nbox2d.b2PolygonShape.prototype.SetAsVector = function (vertices, count)\r\n{\r\n\tthis.Set(vertices, count);\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2PolygonShape} \r\n * @param {Array.<box2d.b2Vec2>} vertices\r\n * @param {number=} count \r\n */\r\nbox2d.b2PolygonShape.prototype.SetAsArray = function (vertices, count)\r\n{\r\n\tthis.Set(vertices, count);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Implement box2d.b2Shape. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PolygonShape.prototype.GetChildCount = function ()\r\n{\r\n\treturn 1;\r\n}\r\n\r\n/** \r\n * @see box2d.b2Shape::TestPoint \r\n * @export \r\n * @return {boolean}\r\n * @param {box2d.b2Transform} xf\r\n * @param {box2d.b2Vec2} p\r\n */\r\nbox2d.b2PolygonShape.prototype.TestPoint = function (xf, p)\r\n{\r\n\tvar pLocal = box2d.b2MulTXV(xf, p, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal);\r\n\r\n\tfor (var i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tvar dot = box2d.b2DotVV(this.m_normals[i], box2d.b2SubVV(pLocal, this.m_vertices[i], box2d.b2Vec2.s_t0));\r\n\t\tif (dot > 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\nbox2d.b2PolygonShape.prototype.TestPoint.s_pLocal = new box2d.b2Vec2();\r\n\r\n/** \r\n * Implement box2d.b2Shape. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2RayCastOutput} output \r\n * @param {box2d.b2RayCastInput} input \r\n * @param {box2d.b2Transform} xf \r\n * @param {number} childIndex \r\n */\r\nbox2d.b2PolygonShape.prototype.RayCast = function (output, input, xf, childIndex)\r\n{\r\n\t// Put the ray into the polygon's frame of reference.\r\n\tvar p1 = box2d.b2MulTXV(xf, input.p1, box2d.b2PolygonShape.prototype.RayCast.s_p1);\r\n\tvar p2 = box2d.b2MulTXV(xf, input.p2, box2d.b2PolygonShape.prototype.RayCast.s_p2);\r\n\tvar d = box2d.b2SubVV(p2, p1, box2d.b2PolygonShape.prototype.RayCast.s_d);\r\n\r\n\tvar lower = 0, upper = input.maxFraction;\r\n\r\n\tvar index = -1;\r\n\r\n\tfor (var i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\t// p = p1 + a * d\r\n\t\t// dot(normal, p - v) = 0\r\n\t\t// dot(normal, p1 - v) + a * dot(normal, d) = 0\r\n\t\tvar numerator = box2d.b2DotVV(this.m_normals[i], box2d.b2SubVV(this.m_vertices[i], p1, box2d.b2Vec2.s_t0));\r\n\t\tvar denominator = box2d.b2DotVV(this.m_normals[i], d);\r\n\r\n\t\tif (denominator === 0)\r\n\t\t{\r\n\t\t\tif (numerator < 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Note: we want this predicate without division:\r\n\t\t\t// lower < numerator / denominator, where denominator < 0\r\n\t\t\t// Since denominator < 0, we have to flip the inequality:\r\n\t\t\t// lower < numerator / denominator <==> denominator * lower > numerator.\r\n\t\t\tif (denominator < 0 && numerator < lower * denominator)\r\n\t\t\t{\r\n\t\t\t\t// Increase lower.\r\n\t\t\t\t// The segment enters this half-space.\r\n\t\t\t\tlower = numerator / denominator;\r\n\t\t\t\tindex = i;\r\n\t\t\t}\r\n\t\t\telse if (denominator > 0 && numerator < upper * denominator)\r\n\t\t\t{\r\n\t\t\t\t// Decrease upper.\r\n\t\t\t\t// The segment exits this half-space.\r\n\t\t\t\tupper = numerator / denominator;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// The use of epsilon here causes the assert on lower to trip\r\n\t\t// in some cases. Apparently the use of epsilon was to make edge\r\n\t\t// shapes work, but now those are handled separately.\r\n\t\t//if (upper < lower - box2d.b2_epsilon)\r\n\t\tif (upper < lower)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= lower && lower <= input.maxFraction); }\r\n\r\n\tif (index >= 0)\r\n\t{\r\n\t\toutput.fraction = lower;\r\n\t\tbox2d.b2MulRV(xf.q, this.m_normals[index], output.normal);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbox2d.b2PolygonShape.prototype.RayCast.s_p1 = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.RayCast.s_p2 = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.RayCast.s_d = new box2d.b2Vec2();\r\n\r\n/** \r\n * @see box2d.b2Shape::ComputeAABB \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2AABB} aabb \r\n * @param {box2d.b2Transform} xf \r\n * @param {number} childIndex \r\n */\r\nbox2d.b2PolygonShape.prototype.ComputeAABB = function (aabb, xf, childIndex)\r\n{\r\n\tvar lower = box2d.b2MulXV(xf, this.m_vertices[0], aabb.lowerBound);\r\n\tvar upper = aabb.upperBound.Copy(lower);\r\n\r\n\tfor (var i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tvar v = box2d.b2MulXV(xf, this.m_vertices[i], box2d.b2PolygonShape.prototype.ComputeAABB.s_v);\r\n\t\tbox2d.b2MinV(v, lower, lower);\r\n\t\tbox2d.b2MaxV(v, upper, upper);\r\n\t}\r\n\r\n\tvar r = this.m_radius;\r\n\tlower.SelfSubXY(r, r);\r\n\tupper.SelfAddXY(r, r);\r\n}\r\nbox2d.b2PolygonShape.prototype.ComputeAABB.s_v = new box2d.b2Vec2();\r\n\r\n/** \r\n * @see box2d.b2Shape::ComputeMass \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2MassData} massData \r\n * @param {number} density \r\n */\r\nbox2d.b2PolygonShape.prototype.ComputeMass = function (massData, density)\r\n{\r\n\t// Polygon mass, centroid, and inertia.\r\n\t// Let rho be the polygon density in mass per unit area.\r\n\t// Then:\r\n\t// mass = rho * int(dA)\r\n\t// centroid.x = (1/mass) * rho * int(x * dA)\r\n\t// centroid.y = (1/mass) * rho * int(y * dA)\r\n\t// I = rho * int((x*x + y*y) * dA)\r\n\t//\r\n\t// We can compute these integrals by summing all the integrals\r\n\t// for each triangle of the polygon. To evaluate the integral\r\n\t// for a single triangle, we make a change of variables to\r\n\t// the (u,v) coordinates of the triangle:\r\n\t// x = x0 + e1x * u + e2x * v\r\n\t// y = y0 + e1y * u + e2y * v\r\n\t// where 0 <= u && 0 <= v && u + v <= 1.\r\n\t//\r\n\t// We integrate u from [0,1-v] and then v from [0,1].\r\n\t// We also need to use the Jacobian of the transformation:\r\n\t// D = cross(e1, e2)\r\n\t//\r\n\t// Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)\r\n\t//\r\n\t// The rest of the derivation is handled by computer algebra.\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_count >= 3); }\r\n\r\n\tvar center = box2d.b2PolygonShape.prototype.ComputeMass.s_center.SetZero();\r\n\tvar area = 0;\r\n\tvar I = 0;\r\n\r\n\t// s is the reference point for forming triangles.\r\n\t// It's location doesn't change the result (except for rounding error).\r\n\tvar s = box2d.b2PolygonShape.prototype.ComputeMass.s_s.SetZero();\r\n\r\n\t// This code would put the reference point inside the polygon.\r\n\tfor (var i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\ts.SelfAdd(this.m_vertices[i]);\r\n\t}\r\n\ts.SelfMul(1 / this.m_count);\r\n\r\n\tvar k_inv3 = 1 / 3;\r\n\r\n\tfor (var i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\t// Triangle vertices.\r\n\t\tvar e1 = box2d.b2SubVV(this.m_vertices[i], s, box2d.b2PolygonShape.prototype.ComputeMass.s_e1);\r\n\t\tvar e2 = box2d.b2SubVV(this.m_vertices[(i + 1) % ict], s, box2d.b2PolygonShape.prototype.ComputeMass.s_e2);\r\n\r\n\t\tvar D = box2d.b2CrossVV(e1, e2);\r\n\r\n\t\tvar triangleArea = 0.5 * D;\r\n\t\tarea += triangleArea;\r\n\r\n\t\t// Area weighted centroid\r\n\t\tcenter.SelfAdd(box2d.b2MulSV(triangleArea * k_inv3, box2d.b2AddVV(e1, e2, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1));\r\n\r\n\t\tvar ex1 = e1.x;\r\n\t\tvar ey1 = e1.y;\r\n\t\tvar ex2 = e2.x;\r\n\t\tvar ey2 = e2.y;\r\n\r\n\t\tvar intx2 = ex1*ex1 + ex2*ex1 + ex2*ex2;\r\n\t\tvar inty2 = ey1*ey1 + ey2*ey1 + ey2*ey2;\r\n\r\n\t\tI += (0.25 * k_inv3 * D) * (intx2 + inty2);\r\n\t}\r\n\r\n\t// Total mass\r\n\tmassData.mass = density * area;\r\n\r\n\t// Center of mass\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(area > box2d.b2_epsilon); }\r\n\tcenter.SelfMul(1 / area);\r\n\tbox2d.b2AddVV(center, s, massData.center);\r\n\r\n\t// Inertia tensor relative to the local origin (point s).\r\n\tmassData.I = density * I;\r\n\t\r\n\t// Shift to center of mass then to original body origin.\r\n\tmassData.I += massData.mass * (box2d.b2DotVV(massData.center, massData.center) - box2d.b2DotVV(center, center));\r\n}\r\nbox2d.b2PolygonShape.prototype.ComputeMass.s_center = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.ComputeMass.s_s = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.ComputeMass.s_e1 = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.ComputeMass.s_e2 = new box2d.b2Vec2();\r\n\r\n/** \r\n * Validate convexity. This is a very time consuming operation. \r\n * @export \r\n * @return {boolean} true if valid\r\n */\r\nbox2d.b2PolygonShape.prototype.Validate = function ()\r\n{\r\n\tfor (var i = 0; i < this.m_count; ++i)\r\n\t{\r\n\t\tvar i1 = i;\r\n\t\tvar i2 = (i + 1) % this.m_count;\r\n\t\tvar p = this.m_vertices[i1];\r\n\t\tvar e = box2d.b2SubVV(this.m_vertices[i2], p, box2d.b2PolygonShape.prototype.Validate.s_e);\r\n\r\n\t\tfor (var j = 0; j < this.m_count; ++j)\r\n\t\t{\r\n\t\t\tif (j === i1 || j === i2)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tvar v = box2d.b2SubVV(this.m_vertices[j], p, box2d.b2PolygonShape.prototype.Validate.s_v);\r\n\t\t\tvar c = box2d.b2CrossVV(e, v);\r\n\t\t\tif (c < 0)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\nbox2d.b2PolygonShape.prototype.Validate.s_e = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.Validate.s_v = new box2d.b2Vec2();\r\n\r\n/**\r\n * @return {void} \r\n * @param {box2d.b2DistanceProxy} proxy \r\n * @param {number} index \r\n */\r\nbox2d.b2PolygonShape.prototype.SetupDistanceProxy = function (proxy, index)\r\n{\r\n\tproxy.m_vertices = this.m_vertices;\r\n\tproxy.m_count = this.m_count;\r\n\tproxy.m_radius = this.m_radius;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} normal\r\n * @param {number} offset\r\n * @param {box2d.b2Transform} xf\r\n * @param {box2d.b2Vec2} c\r\n */\r\nbox2d.b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)\r\n{\r\n\t// Transform plane into shape co-ordinates\r\n\tvar normalL = box2d.b2MulTRV(xf.q, normal, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL);\r\n\tvar offsetL = offset - box2d.b2DotVV(normal, xf.p);\r\n\r\n\tvar depths = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths;\r\n\tvar diveCount = 0;\r\n\tvar intoIndex = -1;\r\n\tvar outoIndex = -1;\r\n\r\n\tvar lastSubmerged = false;\r\n\tfor (var i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tdepths[i] = box2d.b2DotVV(normalL, this.m_vertices[i]) - offsetL;\r\n\t\tvar isSubmerged = depths[i] < (-box2d.b2_epsilon);\r\n\t\tif (i > 0)\r\n\t\t{\r\n\t\t\tif (isSubmerged)\r\n\t\t\t{\r\n\t\t\t\tif (!lastSubmerged)\r\n\t\t\t\t{\r\n\t\t\t\t\tintoIndex = i - 1;\r\n\t\t\t\t\tdiveCount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (lastSubmerged)\r\n\t\t\t\t{\r\n\t\t\t\t\toutoIndex = i - 1;\r\n\t\t\t\t\tdiveCount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlastSubmerged = isSubmerged;\r\n\t}\r\n\tswitch (diveCount)\r\n\t{\r\n\tcase 0:\r\n\t\tif (lastSubmerged)\r\n\t\t{\r\n\t\t\t// Completely submerged\r\n\t\t\tvar md = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md;\r\n\t\t\tthis.ComputeMass(md, 1);\r\n\t\t\tbox2d.b2MulXV(xf, md.center, c);\r\n\t\t\treturn md.mass;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//Completely dry\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tif (intoIndex === (-1))\r\n\t\t{\r\n\t\t\tintoIndex = this.m_count - 1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toutoIndex = this.m_count - 1;\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\tvar intoIndex2 = ((intoIndex + 1) % this.m_count);\r\n\tvar outoIndex2 = ((outoIndex + 1) % this.m_count);\r\n\tvar intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);\r\n\tvar outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);\r\n\r\n\tvar intoVec = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec.SetXY(\r\n\t\tthis.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, \r\n\t\tthis.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);\r\n\tvar outoVec = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec.SetXY(\r\n\t\tthis.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, \r\n\t\tthis.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);\r\n\r\n\t// Initialize accumulator\r\n\tvar area = 0;\r\n\tvar center = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center.SetZero();\r\n\tvar p2 = this.m_vertices[intoIndex2];\r\n\tvar p3 = null;\r\n\r\n\t// An awkward loop from intoIndex2+1 to outIndex2\r\n\tvar i = intoIndex2;\r\n\twhile (i !== outoIndex2)\r\n\t{\r\n\t\ti = (i + 1) % this.m_count;\r\n\t\tif (i === outoIndex2)\r\n\t\t\tp3 = outoVec;\r\n\t\telse\r\n\t\t\tp3\t= this.m_vertices[i];\r\n\r\n\t\tvar triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));\r\n\t\tarea += triangleArea;\r\n\t\t// Area weighted centroid\r\n\t\tcenter.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;\r\n\t\tcenter.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;\r\n\r\n\t\tp2 = p3;\r\n\t}\r\n\r\n\t//Normalize and transform centroid\r\n\tcenter.SelfMul(1 / area);\r\n\tbox2d.b2MulXV(xf, center, c);\r\n\r\n\treturn area;\r\n}\r\nbox2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);\r\nbox2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md = new box2d.b2MassData();\r\nbox2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center = new box2d.b2Vec2();\r\n\r\n/** \r\n * Dump this shape to the log file. \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2PolygonShape.prototype.Dump = function ()\r\n{\r\n\tbox2d.b2Log(\"    /*box2d.b2PolygonShape*/ var shape = new box2d.b2PolygonShape();\\n\");\r\n\tbox2d.b2Log(\"    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\\n\", box2d.b2_maxPolygonVertices);\r\n\tfor (var i = 0; i < this.m_count; ++i)\r\n\t{\r\n\t\tbox2d.b2Log(\"    vs[%d].SetXY(%.15f, %.15f);\\n\", i, this.m_vertices[i].x, this.m_vertices[i].y);\r\n\t}\r\n\tbox2d.b2Log(\"    shape.Set(vs, %d);\\n\", this.m_count);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {Array.<box2d.b2Vec2>} vs \r\n * @param {number} count \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PolygonShape.ComputeCentroid = function (vs, count, out)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(count >= 3); }\r\n\r\n\tvar c = out; c.SetZero();\r\n\tvar area = 0;\r\n\r\n\t// s is the reference point for forming triangles.\r\n\t// It's location doesn't change the result (except for rounding error).\r\n\tvar pRef = box2d.b2PolygonShape.ComputeCentroid.s_pRef.SetZero();\r\n/*\r\n#if 0\r\n\t// This code would put the reference point inside the polygon.\r\n\tfor (var i = 0; i < count; ++i)\r\n\t{\r\n    \tpRef.SelfAdd(vs[i]);\r\n\t}\r\n\tpRef.SelfMul(1 / count);\r\n#endif\r\n*/\r\n\r\n\tvar inv3 = 1 / 3;\r\n\r\n\tfor (var i = 0; i < count; ++i)\r\n\t{\r\n\t\t// Triangle vertices.\r\n\t\tvar p1 = pRef;\r\n\t\tvar p2 = vs[i];\r\n\t\tvar p3 = vs[(i + 1) % count];\r\n\r\n\t\tvar e1 = box2d.b2SubVV(p2, p1, box2d.b2PolygonShape.ComputeCentroid.s_e1);\r\n\t\tvar e2 = box2d.b2SubVV(p3, p1, box2d.b2PolygonShape.ComputeCentroid.s_e2);\r\n\r\n\t\tvar D = box2d.b2CrossVV(e1, e2);\r\n\r\n\t\tvar triangleArea = 0.5 * D;\r\n\t\tarea += triangleArea;\r\n\r\n\t\t// Area weighted centroid\r\n\t\tc.x += triangleArea * inv3 * (p1.x + p2.x + p3.x);\r\n\t\tc.y += triangleArea * inv3 * (p1.y + p2.y + p3.y);\r\n\t}\r\n\r\n\t// Centroid\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(area > box2d.b2_epsilon); }\r\n\tc.SelfMul(1 / area);\r\n\treturn c;\r\n}\r\nbox2d.b2PolygonShape.ComputeCentroid.s_pRef = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.ComputeCentroid.s_e1 = new box2d.b2Vec2();\r\nbox2d.b2PolygonShape.ComputeCentroid.s_e2 = new box2d.b2Vec2();\r\n\r\n/*\r\nbox2d.b2PolygonShape.ComputeOBB = function (obb, vs, count)\r\n{\r\n\tvar i = 0;\r\n\tvar p = new Array(count + 1);\r\n\tfor (i = 0; i < count; ++i)\r\n\t{\r\n\t\tp[i] = vs[i];\r\n\t}\r\n\tp[count] = p[0];\r\n\tvar minArea = box2d.b2_maxFloat;\r\n\tfor (i = 1; i <= count; ++i)\r\n\t{\r\n\t\tvar root = p[i - 1];\r\n\t\tvar uxX = p[i].x - root.x;\r\n\t\tvar uxY = p[i].y - root.y;\r\n\t\tvar length = box2d.b2Sqrt(uxX * uxX + uxY * uxY);\r\n\t\tuxX /= length;\r\n\t\tuxY /= length;\r\n\t\tvar uyX = (-uxY);\r\n\t\tvar uyY = uxX;\r\n\t\tvar lowerX = box2d.b2_maxFloat;\r\n\t\tvar lowerY = box2d.b2_maxFloat;\r\n\t\tvar upperX = (-box2d.b2_maxFloat);\r\n\t\tvar upperY = (-box2d.b2_maxFloat);\r\n\t\tfor (var j = 0; j < count; ++j)\r\n\t\t{\r\n\t\t\tvar dX = p[j].x - root.x;\r\n\t\t\tvar dY = p[j].y - root.y;\r\n\t\t\tvar rX = (uxX * dX + uxY * dY);\r\n\t\t\tvar rY = (uyX * dX + uyY * dY);\r\n\t\t\tif (rX < lowerX) lowerX = rX;\r\n\t\t\tif (rY < lowerY) lowerY = rY;\r\n\t\t\tif (rX > upperX) upperX = rX;\r\n\t\t\tif (rY > upperY) upperY = rY;\r\n\t\t}\r\n\t\tvar area = (upperX - lowerX) * (upperY - lowerY);\r\n\t\tif (area < 0.95 * minArea)\r\n\t\t{\r\n\t\t\tminArea = area;\r\n\t\t\tobb.R.ex.x = uxX;\r\n\t\t\tobb.R.ex.y = uxY;\r\n\t\t\tobb.R.ey.x = uyX;\r\n\t\t\tobb.R.ey.y = uyY;\r\n\t\t\tvar center_x = 0.5 * (lowerX + upperX);\r\n\t\t\tvar center_y = 0.5 * (lowerY + upperY);\r\n\t\t\tvar tMat = obb.R;\r\n\t\t\tobb.center.x = root.x + (tMat.ex.x * center_x + tMat.ey.x * center_y);\r\n\t\t\tobb.center.y = root.y + (tMat.ex.y * center_x + tMat.ey.y * center_y);\r\n\t\t\tobb.extents.x = 0.5 * (upperX - lowerX);\r\n\t\t\tobb.extents.y = 0.5 * (upperY - lowerY);\r\n\t\t}\r\n\t}\r\n}\r\n*/\r\n\r\n/*\r\n * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty.  In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n * 1. The origin of this software must not be misrepresented; you must not\r\n * claim that you wrote the original software. If you use this software\r\n * in a product, an acknowledgment in the product documentation would be\r\n * appreciated but is not required.\r\n * 2. Altered source versions must be plainly marked as such, and must not be\r\n * misrepresented as being the original software.\r\n * 3. This notice may not be removed or altered from any source distribution.\r\n */\r\n\r\ngoog.provide('box2d.b2CollideEdge');\r\n\r\ngoog.require('box2d.b2Collision');\r\n\r\n/** \r\n * Compute the collision manifold between an edge and a circle. \r\n * Compute contact points for edge versus circle. \r\n * This accounts for edge connectivity.\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2EdgeShape} edgeA\r\n * @param {box2d.b2Transform} xfA\r\n * @param {box2d.b2CircleShape} circleB\r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2CollideEdgeAndCircle = function (manifold, edgeA, xfA, circleB, xfB)\r\n{\r\n\tmanifold.pointCount = 0;\r\n\t\r\n\t// Compute circle in frame of edge\r\n\t/** @type {box2d.b2Vec2} */ var Q = box2d.b2MulTXV(xfA, box2d.b2MulXV(xfB, circleB.m_p, box2d.b2Vec2.s_t0), box2d.b2CollideEdgeAndCircle.s_Q);\r\n\t\r\n\t/** @type {box2d.b2Vec2} */ var A = edgeA.m_vertex1;\r\n\t/** @type {box2d.b2Vec2} */ var B = edgeA.m_vertex2;\r\n\t/** @type {box2d.b2Vec2} */ var e = box2d.b2SubVV(B, A, box2d.b2CollideEdgeAndCircle.s_e);\r\n\t\r\n\t// Barycentric coordinates\r\n\t/** @type {number} */ var u = box2d.b2DotVV(e, box2d.b2SubVV(B, Q, box2d.b2Vec2.s_t0));\r\n\t/** @type {number} */ var v = box2d.b2DotVV(e, box2d.b2SubVV(Q, A, box2d.b2Vec2.s_t0));\r\n\t\r\n\t/** @type {number} */ var radius = edgeA.m_radius + circleB.m_radius;\r\n\t\r\n//\t/** @type {box2d.b2ContactFeature} */ var cf = new box2d.b2ContactFeature();\r\n\t/** @type {box2d.b2ContactID} */ var id = box2d.b2CollideEdgeAndCircle.s_id;\r\n\tid.cf.indexB = 0;\r\n\tid.cf.typeB = box2d.b2ContactFeatureType.e_vertex;\r\n\t\r\n\t// Region A\r\n\tif (v <= 0)\r\n\t{\r\n\t\t/** @type {box2d.b2Vec2} */ var P = A;\r\n\t\t/** @type {box2d.b2Vec2} */ var d = box2d.b2SubVV(Q, P, box2d.b2CollideEdgeAndCircle.s_d);\r\n\t\t/** @type {number} */ var dd = box2d.b2DotVV(d, d);\r\n\t\tif (dd > radius * radius)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// Is there an edge connected to A?\r\n\t\tif (edgeA.m_hasVertex0)\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2Vec2} */ var A1 = edgeA.m_vertex0;\r\n\t\t\t/** @type {box2d.b2Vec2} */ var B1 = A;\r\n\t\t\t/** @type {box2d.b2Vec2} */ var e1 = box2d.b2SubVV(B1, A1, box2d.b2CollideEdgeAndCircle.s_e1);\r\n\t\t\t/** @type {number} */ var u1 = box2d.b2DotVV(e1, box2d.b2SubVV(B1, Q, box2d.b2Vec2.s_t0));\r\n\t\t\t\r\n\t\t\t// Is the circle in Region AB of the previous edge?\r\n\t\t\tif (u1 > 0)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tid.cf.indexA = 0;\r\n\t\tid.cf.typeA = box2d.b2ContactFeatureType.e_vertex;\r\n\t\tmanifold.pointCount = 1;\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_circles;\r\n\t\tmanifold.localNormal.SetZero();\r\n\t\tmanifold.localPoint.Copy(P);\r\n\t\tmanifold.points[0].id.Copy(id);\r\n//\t\tmanifold.points[0].id.key = 0;\r\n//\t\tmanifold.points[0].id.cf = cf;\r\n\t\tmanifold.points[0].localPoint.Copy(circleB.m_p);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// Region B\r\n\tif (u <= 0)\r\n\t{\r\n\t\t/** type {box2d.b2Vec2} */ var P = B;\r\n\t\t/** type {box2d.b2Vec2} */ var d = box2d.b2SubVV(Q, P, box2d.b2CollideEdgeAndCircle.s_d);\r\n\t\t/** type {number} */ var dd = box2d.b2DotVV(d, d);\r\n\t\tif (dd > radius * radius)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// Is there an edge connected to B?\r\n\t\tif (edgeA.m_hasVertex3)\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2Vec2} */ var B2 = edgeA.m_vertex3;\r\n\t\t\t/** @type {box2d.b2Vec2} */ var A2 = B;\r\n\t\t\t/** @type {box2d.b2Vec2} */ var e2 = box2d.b2SubVV(B2, A2, box2d.b2CollideEdgeAndCircle.s_e2);\r\n\t\t\t/** @type {number} */ var v2 = box2d.b2DotVV(e2, box2d.b2SubVV(Q, A2, box2d.b2Vec2.s_t0));\r\n\t\t\t\r\n\t\t\t// Is the circle in Region AB of the next edge?\r\n\t\t\tif (v2 > 0)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tid.cf.indexA = 1;\r\n\t\tid.cf.typeA = box2d.b2ContactFeatureType.e_vertex;\r\n\t\tmanifold.pointCount = 1;\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_circles;\r\n\t\tmanifold.localNormal.SetZero();\r\n\t\tmanifold.localPoint.Copy(P);\r\n\t\tmanifold.points[0].id.Copy(id);\r\n//\t\tmanifold.points[0].id.key = 0;\r\n//\t\tmanifold.points[0].id.cf = cf;\r\n\t\tmanifold.points[0].localPoint.Copy(circleB.m_p);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// Region AB\r\n\t/** @type {number} */ var den = box2d.b2DotVV(e, e);\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(den > 0); }\r\n\t/** type {box2d.b2Vec2} */ var P = box2d.b2CollideEdgeAndCircle.s_P;\r\n\tP.x = (1 / den) * (u * A.x + v * B.x);\r\n\tP.y = (1 / den) * (u * A.y + v * B.y);\r\n\t/** type {box2d.b2Vec2} */ var d = box2d.b2SubVV(Q, P, box2d.b2CollideEdgeAndCircle.s_d);\r\n\t/** type {number} */ var dd = box2d.b2DotVV(d, d);\r\n\tif (dd > radius * radius)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t/** @type {box2d.b2Vec2} */ var n = box2d.b2CollideEdgeAndCircle.s_n.SetXY(-e.y, e.x);\r\n\tif (box2d.b2DotVV(n, box2d.b2SubVV(Q, A, box2d.b2Vec2.s_t0)) < 0)\r\n\t{\r\n\t\tn.SetXY(-n.x, -n.y);\r\n\t}\r\n\tn.Normalize();\r\n\t\r\n\tid.cf.indexA = 0;\r\n\tid.cf.typeA = box2d.b2ContactFeatureType.e_face;\r\n\tmanifold.pointCount = 1;\r\n\tmanifold.type = box2d.b2ManifoldType.e_faceA;\r\n\tmanifold.localNormal.Copy(n);\r\n\tmanifold.localPoint.Copy(A);\r\n\tmanifold.points[0].id.Copy(id);\r\n//\tmanifold.points[0].id.key = 0;\r\n//\tmanifold.points[0].id.cf = cf;\r\n\tmanifold.points[0].localPoint.Copy(circleB.m_p);\r\n}\r\nbox2d.b2CollideEdgeAndCircle.s_Q = new box2d.b2Vec2();\r\nbox2d.b2CollideEdgeAndCircle.s_e = new box2d.b2Vec2();\r\nbox2d.b2CollideEdgeAndCircle.s_d = new box2d.b2Vec2();\r\nbox2d.b2CollideEdgeAndCircle.s_e1 = new box2d.b2Vec2();\r\nbox2d.b2CollideEdgeAndCircle.s_e2 = new box2d.b2Vec2();\r\nbox2d.b2CollideEdgeAndCircle.s_P = new box2d.b2Vec2();\r\nbox2d.b2CollideEdgeAndCircle.s_n = new box2d.b2Vec2();\r\nbox2d.b2CollideEdgeAndCircle.s_id = new box2d.b2ContactID();\r\n\r\n/** \r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2EPAxisType = \r\n{\r\n\te_unknown\t: 0, \r\n\te_edgeA\t\t: 1, \r\n\te_edgeB\t\t: 2\r\n};\r\ngoog.exportProperty(box2d.b2EPAxisType, 'e_unknown', box2d.b2EPAxisType.e_unknown);\r\ngoog.exportProperty(box2d.b2EPAxisType, 'e_edgeA'  , box2d.b2EPAxisType.e_edgeA  );\r\ngoog.exportProperty(box2d.b2EPAxisType, 'e_edgeB'  , box2d.b2EPAxisType.e_edgeB  );\r\n\t\r\n/** \r\n * This structure is used to keep track of the best separating \r\n * axis. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2EPAxis = function ()\r\n{\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2EPAxisType}\r\n */\r\nbox2d.b2EPAxis.prototype.type = box2d.b2EPAxisType.e_unknown;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2EPAxis.prototype.index = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2EPAxis.prototype.separation = 0;\r\n\r\n/** \r\n * This holds polygon B expressed in frame A. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2TempPolygon = function ()\r\n{\r\n\tthis.vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);\r\n\tthis.normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);\r\n\tthis.count = 0;\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2TempPolygon.prototype.vertices = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2TempPolygon.prototype.normals = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2TempPolygon.prototype.count = 0;\r\n\r\n/** \r\n * Reference face used for clipping \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ReferenceFace = function ()\r\n{\r\n\tthis.i1 = 0;\r\n\tthis.i2 = 0;\r\n\t\r\n\tthis.v1 = new box2d.b2Vec2();\r\n\tthis.v2 = new box2d.b2Vec2();\r\n\t\r\n\tthis.normal = new box2d.b2Vec2();\r\n\t\r\n\tthis.sideNormal1 = new box2d.b2Vec2();\r\n\tthis.sideOffset1 = 0;\r\n\t\r\n\tthis.sideNormal2 = new box2d.b2Vec2();\r\n\tthis.sideOffset2 = 0;\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ReferenceFace.prototype.i1 = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ReferenceFace.prototype.i2 = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ReferenceFace.prototype.v1 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ReferenceFace.prototype.v2 = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ReferenceFace.prototype.normal = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ReferenceFace.prototype.sideNormal1 = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ReferenceFace.prototype.sideOffset1 = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ReferenceFace.prototype.sideNormal2 = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ReferenceFace.prototype.sideOffset2 = 0;\r\n\r\n/**\r\n * @export\r\n * @enum\r\n */\r\nbox2d.b2EPColliderVertexType = \r\n{\r\n\te_isolated\t: 0,\r\n\te_concave\t: 1,\r\n\te_convex\t: 2\r\n};\r\ngoog.exportProperty(box2d.b2EPColliderVertexType, 'e_isolated', box2d.b2EPColliderVertexType.e_isolated);\r\ngoog.exportProperty(box2d.b2EPColliderVertexType, 'e_concave' , box2d.b2EPColliderVertexType.e_concave );\r\ngoog.exportProperty(box2d.b2EPColliderVertexType, 'e_convex'  , box2d.b2EPColliderVertexType.e_convex  );\r\n\t\r\n/** \r\n * This class collides and edge and a polygon, taking into \r\n * account edge adjacency. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2EPCollider = function ()\r\n{\r\n\tthis.m_polygonB = new box2d.b2TempPolygon();\r\n\t\r\n\tthis.m_xf = new box2d.b2Transform();\r\n\tthis.m_centroidB = new box2d.b2Vec2();\r\n\tthis.m_v0 = new box2d.b2Vec2(), this.m_v1 = new box2d.b2Vec2(), this.m_v2 = new box2d.b2Vec2(), this.m_v3 = new box2d.b2Vec2();\r\n\tthis.m_normal0 = new box2d.b2Vec2(), this.m_normal1 = new box2d.b2Vec2(), this.m_normal2 = new box2d.b2Vec2();\r\n\tthis.m_normal = new box2d.b2Vec2();\r\n\tthis.m_type1 = box2d.b2EPColliderVertexType.e_isolated, this.m_type2 = box2d.b2EPColliderVertexType.e_isolated;\r\n\tthis.m_lowerLimit = new box2d.b2Vec2(), this.m_upperLimit = new box2d.b2Vec2();\r\n\tthis.m_radius = 0;\r\n\tthis.m_front = false;\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2TempPolygon}\r\n */\r\nbox2d.b2EPCollider.prototype.m_polygonB = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Transform}\r\n */\r\nbox2d.b2EPCollider.prototype.m_xf = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_centroidB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_v0 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_v1 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_v2 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_v3 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_normal0 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_normal1 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_normal2 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_normal = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2EPColliderVertexType}\r\n */\r\nbox2d.b2EPCollider.prototype.m_type1 = box2d.b2EPColliderVertexType.e_isolated;\r\n/**\r\n * @export \r\n * @type {box2d.b2EPColliderVertexType}\r\n */\r\nbox2d.b2EPCollider.prototype.m_type2 = box2d.b2EPColliderVertexType.e_isolated;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_lowerLimit = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EPCollider.prototype.m_upperLimit = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2EPCollider.prototype.m_radius = 0;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2EPCollider.prototype.m_front = false;\r\n\r\n/** \r\n * Algorithm:\r\n * 1. Classify v1 and v2\r\n * 2. Classify polygon centroid as front or back\r\n * 3. Flip normal if necessary\r\n * 4. Initialize normal range to [-pi, pi] about face normal\r\n * 5. Adjust normal range according to adjacent edges\r\n * 6. Visit each separating axes, only accept axes within the range\r\n * 7. Return if _any_ axis indicates separation\r\n * 8. Clip\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2EdgeShape} edgeA \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2PolygonShape} polygonB \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2EPCollider.prototype.Collide = function (manifold, edgeA, xfA, polygonB, xfB)\r\n{\r\n\tbox2d.b2MulTXX(xfA, xfB, this.m_xf);\r\n\t\r\n\tbox2d.b2MulXV(this.m_xf, polygonB.m_centroid, this.m_centroidB);\r\n\t\r\n\tthis.m_v0.Copy(edgeA.m_vertex0);\r\n\tthis.m_v1.Copy(edgeA.m_vertex1);\r\n\tthis.m_v2.Copy(edgeA.m_vertex2);\r\n\tthis.m_v3.Copy(edgeA.m_vertex3);\r\n\t\r\n\t/** @type {boolean} */ var hasVertex0 = edgeA.m_hasVertex0;\r\n\t/** @type {boolean} */ var hasVertex3 = edgeA.m_hasVertex3;\r\n\t\r\n\t/** @type {box2d.b2Vec2} */ var edge1 = box2d.b2SubVV(this.m_v2, this.m_v1, box2d.b2EPCollider.s_edge1);\r\n\tedge1.Normalize();\r\n\tthis.m_normal1.SetXY(edge1.y, -edge1.x);\r\n\t/** @type {number} */ var offset1 = box2d.b2DotVV(this.m_normal1, box2d.b2SubVV(this.m_centroidB, this.m_v1, box2d.b2Vec2.s_t0));\r\n\t/** @type {number} */ var offset0 = 0;\r\n\t/** @type {number} */ var offset2 = 0;\r\n\t/** @type {boolean} */ var convex1 = false;\r\n\t/** @type {boolean} */ var convex2 = false;\r\n\t\r\n\t// Is there a preceding edge?\r\n\tif (hasVertex0)\r\n\t{\r\n\t\t/** @type {box2d.b2Vec2} */ var edge0 = box2d.b2SubVV(this.m_v1, this.m_v0, box2d.b2EPCollider.s_edge0);\r\n\t\tedge0.Normalize();\r\n\t\tthis.m_normal0.SetXY(edge0.y, -edge0.x);\r\n\t\tconvex1 = box2d.b2CrossVV(edge0, edge1) >= 0;\r\n\t\toffset0 = box2d.b2DotVV(this.m_normal0, box2d.b2SubVV(this.m_centroidB, this.m_v0, box2d.b2Vec2.s_t0));\r\n\t}\r\n\t\r\n\t// Is there a following edge?\r\n\tif (hasVertex3)\r\n\t{\r\n\t\t/** @type {box2d.b2Vec2} */ var edge2 = box2d.b2SubVV(this.m_v3, this.m_v2, box2d.b2EPCollider.s_edge2);\r\n\t\tedge2.Normalize();\r\n\t\tthis.m_normal2.SetXY(edge2.y, -edge2.x);\r\n\t\tconvex2 = box2d.b2CrossVV(edge1, edge2) > 0;\r\n\t\toffset2 = box2d.b2DotVV(this.m_normal2, box2d.b2SubVV(this.m_centroidB, this.m_v2, box2d.b2Vec2.s_t0));\r\n\t}\r\n\t\r\n\t// Determine front or back collision. Determine collision normal limits.\r\n\tif (hasVertex0 && hasVertex3)\r\n\t{\r\n\t\tif (convex1 && convex2)\r\n\t\t{\r\n\t\t\tthis.m_front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;\r\n\t\t\tif (this.m_front)\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal0);\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal2);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (convex1)\r\n\t\t{\r\n\t\t\tthis.m_front = offset0 >= 0 || (offset1 >= 0 && offset2 >= 0);\r\n\t\t\tif (this.m_front)\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal0);\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal2).SelfNeg();\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (convex2)\r\n\t\t{\r\n\t\t\tthis.m_front = offset2 >= 0 || (offset0 >= 0 && offset1 >= 0);\r\n\t\t\tif (this.m_front)\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal2);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal0).SelfNeg();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;\r\n\t\t\tif (this.m_front)\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal2).SelfNeg();\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal0).SelfNeg();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse if (hasVertex0)\r\n\t{\r\n\t\tif (convex1)\r\n\t\t{\r\n\t\t\tthis.m_front = offset0 >= 0 || offset1 >= 0;\r\n\t\t\tif (this.m_front)\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal0);\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_front = offset0 >= 0 && offset1 >= 0;\r\n\t\t\tif (this.m_front)\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal0).SelfNeg();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse if (hasVertex3)\r\n\t{\r\n\t\tif (convex2)\r\n\t\t{\r\n\t\t\tthis.m_front = offset1 >= 0 || offset2 >= 0;\r\n\t\t\tif (this.m_front)\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal2);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_front = offset1 >= 0 && offset2 >= 0;\r\n\t\t\tif (this.m_front)\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1);\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.m_normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t\t\tthis.m_lowerLimit.Copy(this.m_normal2).SelfNeg();\r\n\t\t\t\tthis.m_upperLimit.Copy(this.m_normal1);\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_front = offset1 >= 0;\r\n\t\tif (this.m_front)\r\n\t\t{\r\n\t\t\tthis.m_normal.Copy(this.m_normal1);\r\n\t\t\tthis.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t\tthis.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t\tthis.m_lowerLimit.Copy(this.m_normal1);\r\n\t\t\tthis.m_upperLimit.Copy(this.m_normal1);\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Get polygonB in frameA\r\n\tthis.m_polygonB.count = polygonB.m_count;\r\n\tfor (var i = 0, ict = polygonB.m_count; i < ict; ++i)\r\n\t{\r\n\t\tbox2d.b2MulXV(this.m_xf, polygonB.m_vertices[i], this.m_polygonB.vertices[i]);\r\n\t\tbox2d.b2MulRV(this.m_xf.q, polygonB.m_normals[i], this.m_polygonB.normals[i]);\r\n\t}\r\n\t\r\n\tthis.m_radius = 2 * box2d.b2_polygonRadius;\r\n\t\r\n\tmanifold.pointCount = 0;\r\n\t\r\n\t/** @type {box2d.b2EPAxis} */ var edgeAxis = this.ComputeEdgeSeparation(box2d.b2EPCollider.s_edgeAxis);\r\n\t\r\n\t// If no valid normal can be found than this edge should not collide.\r\n\tif (edgeAxis.type === box2d.b2EPAxisType.e_unknown)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tif (edgeAxis.separation > this.m_radius)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t/** @type {box2d.b2EPAxis} */ var polygonAxis = this.ComputePolygonSeparation(box2d.b2EPCollider.s_polygonAxis);\r\n\tif (polygonAxis.type !== box2d.b2EPAxisType.e_unknown && polygonAxis.separation > this.m_radius)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// Use hysteresis for jitter reduction.\r\n\t/** @type {number} */ var k_relativeTol = 0.98;\r\n\t/** @type {number} */ var k_absoluteTol = 0.001;\r\n\t\r\n\t/** @type {box2d.b2EPAxis} */ var primaryAxis;\r\n\tif (polygonAxis.type === box2d.b2EPAxisType.e_unknown)\r\n\t{\r\n\t\tprimaryAxis = edgeAxis;\r\n\t}\r\n\telse if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol)\r\n\t{\r\n\t\tprimaryAxis = polygonAxis;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tprimaryAxis = edgeAxis;\r\n\t}\r\n\t\r\n\t/** @type {Array.<box2d.b2ClipVertex>} */ var ie = box2d.b2EPCollider.s_ie;\r\n\t/** @type {box2d.b2ReferenceFace} */ var rf = box2d.b2EPCollider.s_rf;\r\n\tif (primaryAxis.type === box2d.b2EPAxisType.e_edgeA)\r\n\t{\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_faceA;\r\n\t\t\r\n\t\t// Search for the polygon normal that is most anti-parallel to the edge normal.\r\n\t\t/** @type {number} */ var bestIndex = 0;\r\n\t\t/** @type {number} */ var bestValue = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[0]);\r\n\t\tfor (var i = 1, ict = this.m_polygonB.count; i < ict; ++i)\r\n\t\t{\r\n\t\t\t/** @type {number} */ var value = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[i]);\r\n\t\t\tif (value < bestValue)\r\n\t\t\t{\r\n\t\t\t\tbestValue = value;\r\n\t\t\t\tbestIndex = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t/** @type {number} */ var i1 = bestIndex;\r\n\t\t/** @type {number} */ var i2 = (i1 + 1) % this.m_polygonB.count;\r\n\t\t\r\n\t\tvar ie0 = ie[0];\r\n\t\tie0.v.Copy(this.m_polygonB.vertices[i1]);\r\n\t\tie0.id.cf.indexA = 0;\r\n\t\tie0.id.cf.indexB = i1;\r\n\t\tie0.id.cf.typeA = box2d.b2ContactFeatureType.e_face;\r\n\t\tie0.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;\r\n\t\t\r\n\t\tvar ie1 = ie[1];\r\n\t\tie1.v.Copy(this.m_polygonB.vertices[i2]);\r\n\t\tie1.id.cf.indexA = 0;\r\n\t\tie1.id.cf.indexB = i2;\r\n\t\tie1.id.cf.typeA = box2d.b2ContactFeatureType.e_face;\r\n\t\tie1.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;\r\n\t\t\r\n\t\tif (this.m_front)\r\n\t\t{\r\n\t\t\trf.i1 = 0;\r\n\t\t\trf.i2 = 1;\r\n\t\t\trf.v1.Copy(this.m_v1);\r\n\t\t\trf.v2.Copy(this.m_v2);\r\n\t\t\trf.normal.Copy(this.m_normal1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\trf.i1 = 1;\r\n\t\t\trf.i2 = 0;\r\n\t\t\trf.v1.Copy(this.m_v2);\r\n\t\t\trf.v2.Copy(this.m_v1);\r\n\t\t\trf.normal.Copy(this.m_normal1).SelfNeg();\r\n\t\t}\t\t\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_faceB;\r\n\t\t\r\n\t\tvar ie0 = ie[0];\r\n\t\tie0.v.Copy(this.m_v1);\r\n\t\tie0.id.cf.indexA = 0;\r\n\t\tie0.id.cf.indexB = primaryAxis.index;\r\n\t\tie0.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex;\r\n\t\tie0.id.cf.typeB = box2d.b2ContactFeatureType.e_face;\r\n\t\t\r\n\t\tvar ie1 = ie[1];\r\n\t\tie1.v.Copy(this.m_v2);\r\n\t\tie1.id.cf.indexA = 0;\r\n\t\tie1.id.cf.indexB = primaryAxis.index;\t\t\r\n\t\tie1.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex;\r\n\t\tie1.id.cf.typeB = box2d.b2ContactFeatureType.e_face;\r\n\t\t\r\n\t\trf.i1 = primaryAxis.index;\r\n\t\trf.i2 = (rf.i1 + 1) % this.m_polygonB.count;\r\n\t\trf.v1.Copy(this.m_polygonB.vertices[rf.i1]);\r\n\t\trf.v2.Copy(this.m_polygonB.vertices[rf.i2]);\r\n\t\trf.normal.Copy(this.m_polygonB.normals[rf.i1]);\r\n\t}\r\n\t\r\n\trf.sideNormal1.SetXY(rf.normal.y, -rf.normal.x);\r\n\trf.sideNormal2.Copy(rf.sideNormal1).SelfNeg();\r\n\trf.sideOffset1 = box2d.b2DotVV(rf.sideNormal1, rf.v1);\r\n\trf.sideOffset2 = box2d.b2DotVV(rf.sideNormal2, rf.v2);\r\n\t\r\n\t// Clip incident edge against extruded edge1 side edges.\r\n\t/** @type {Array.<box2d.b2ClipVertex>} */ var clipPoints1 = box2d.b2EPCollider.s_clipPoints1;\r\n\t/** @type {Array.<box2d.b2ClipVertex>} */ var clipPoints2 = box2d.b2EPCollider.s_clipPoints2;\r\n\t/** @type {number} */ var np = 0;\r\n\t\r\n\t// Clip to box side 1\r\n\tnp = box2d.b2ClipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\r\n\t\r\n\tif (np < box2d.b2_maxManifoldPoints)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// Clip to negative box side 1\r\n\tnp = box2d.b2ClipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\r\n\t\r\n\tif (np < box2d.b2_maxManifoldPoints)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// Now clipPoints2 contains the clipped points.\r\n\tif (primaryAxis.type === box2d.b2EPAxisType.e_edgeA)\r\n\t{\r\n\t\tmanifold.localNormal.Copy(rf.normal);\r\n\t\tmanifold.localPoint.Copy(rf.v1);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmanifold.localNormal.Copy(polygonB.m_normals[rf.i1]);\r\n\t\tmanifold.localPoint.Copy(polygonB.m_vertices[rf.i1]);\r\n\t}\r\n\t\r\n\t/** @type {number} */ var pointCount = 0;\r\n\tfor (var i = 0, ict = box2d.b2_maxManifoldPoints; i < ict; ++i)\r\n\t{\r\n\t\t/** @type {number} */ var separation;\r\n\t\t\r\n\t\tseparation = box2d.b2DotVV(rf.normal, box2d.b2SubVV(clipPoints2[i].v, rf.v1, box2d.b2Vec2.s_t0));\r\n\t\t\r\n\t\tif (separation <= this.m_radius)\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2ManifoldPoint} */ var cp = manifold.points[pointCount];\r\n\t\t\t\r\n\t\t\tif (primaryAxis.type === box2d.b2EPAxisType.e_edgeA)\r\n\t\t\t{\r\n\t\t\t\tbox2d.b2MulTXV(this.m_xf, clipPoints2[i].v, cp.localPoint);\r\n\t\t\t\tcp.id = clipPoints2[i].id;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcp.localPoint.Copy(clipPoints2[i].v);\r\n\t\t\t\tcp.id.cf.typeA = clipPoints2[i].id.cf.typeB;\r\n\t\t\t\tcp.id.cf.typeB = clipPoints2[i].id.cf.typeA;\r\n\t\t\t\tcp.id.cf.indexA = clipPoints2[i].id.cf.indexB;\r\n\t\t\t\tcp.id.cf.indexB = clipPoints2[i].id.cf.indexA;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t++pointCount;\r\n\t\t}\r\n\t}\r\n\t\r\n\tmanifold.pointCount = pointCount;\r\n}\r\n\r\nbox2d.b2EPCollider.s_edge1 = new box2d.b2Vec2();\r\nbox2d.b2EPCollider.s_edge0 = new box2d.b2Vec2();\r\nbox2d.b2EPCollider.s_edge2 = new box2d.b2Vec2();\r\nbox2d.b2EPCollider.s_ie = box2d.b2ClipVertex.MakeArray(2);\r\nbox2d.b2EPCollider.s_rf = new box2d.b2ReferenceFace();\r\nbox2d.b2EPCollider.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);\r\nbox2d.b2EPCollider.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);\r\nbox2d.b2EPCollider.s_edgeAxis = new box2d.b2EPAxis();\r\nbox2d.b2EPCollider.s_polygonAxis = new box2d.b2EPAxis();\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2EPAxis}\r\n * @param {box2d.b2EPAxis} out \r\n */\r\nbox2d.b2EPCollider.prototype.ComputeEdgeSeparation = function (out)\r\n{\r\n\t/** @type {box2d.b2EPAxis} */ var axis = out;\r\n\taxis.type = box2d.b2EPAxisType.e_edgeA;\r\n\taxis.index = this.m_front ? 0 : 1;\r\n\taxis.separation = box2d.b2_maxFloat;\r\n\t\r\n\tfor (var i = 0, ict = this.m_polygonB.count; i < ict; ++i)\r\n\t{\r\n\t\t/** @type {number} */ var s = box2d.b2DotVV(this.m_normal, box2d.b2SubVV(this.m_polygonB.vertices[i], this.m_v1, box2d.b2Vec2.s_t0));\r\n\t\tif (s < axis.separation)\r\n\t\t{\r\n\t\t\taxis.separation = s;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn axis;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2EPAxis}\r\n * @param {box2d.b2EPAxis} out \r\n */\r\nbox2d.b2EPCollider.prototype.ComputePolygonSeparation = function (out)\r\n{\r\n\t/** @type {box2d.b2EPAxis} */ var axis = out;\r\n\taxis.type = box2d.b2EPAxisType.e_unknown;\r\n\taxis.index = -1;\r\n\taxis.separation = -box2d.b2_maxFloat;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var perp = box2d.b2EPCollider.s_perp.SetXY(-this.m_normal.y, this.m_normal.x);\r\n\r\n\tfor (var i = 0, ict = this.m_polygonB.count; i < ict; ++i)\r\n\t{\r\n\t\t/** @type {box2d.b2Vec2} */ var n = box2d.b2NegV(this.m_polygonB.normals[i], box2d.b2EPCollider.s_n);\r\n\t\t\r\n\t\t/** @type {number} */ var s1 = box2d.b2DotVV(n, box2d.b2SubVV(this.m_polygonB.vertices[i], this.m_v1, box2d.b2Vec2.s_t0));\r\n\t\t/** @type {number} */ var s2 = box2d.b2DotVV(n, box2d.b2SubVV(this.m_polygonB.vertices[i], this.m_v2, box2d.b2Vec2.s_t0));\r\n\t\t/** @type {number} */ var s = box2d.b2Min(s1, s2);\r\n\t\t\r\n\t\tif (s > this.m_radius)\r\n\t\t{\r\n\t\t\t// No collision\r\n\t\t\taxis.type = box2d.b2EPAxisType.e_edgeB;\r\n\t\t\taxis.index = i;\r\n\t\t\taxis.separation = s;\r\n\t\t\treturn axis;\r\n\t\t}\r\n\t\t\r\n\t\t// Adjacency\r\n\t\tif (box2d.b2DotVV(n, perp) >= 0)\r\n\t\t{\r\n\t\t\tif (box2d.b2DotVV(box2d.b2SubVV(n, this.m_upperLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (box2d.b2DotVV(box2d.b2SubVV(n, this.m_lowerLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (s > axis.separation)\r\n\t\t{\r\n\t\t\taxis.type = box2d.b2EPAxisType.e_edgeB;\r\n\t\t\taxis.index = i;\r\n\t\t\taxis.separation = s;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn axis;\r\n}\r\nbox2d.b2EPCollider.s_n = new box2d.b2Vec2();\r\nbox2d.b2EPCollider.s_perp = new box2d.b2Vec2();\r\n\r\n/** \r\n * Compute the collision manifold between an edge and a polygon.\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2EdgeShape} edgeA\r\n * @param {box2d.b2Transform} xfA\r\n * @param {box2d.b2PolygonShape} polygonB\r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2CollideEdgeAndPolygon = function (manifold, edgeA, xfA, polygonB, xfB)\r\n{\r\n\t/** @type {box2d.b2EPCollider} */ var collider = box2d.b2CollideEdgeAndPolygon.s_collider;\r\n\tcollider.Collide(manifold, edgeA, xfA, polygonB, xfB);\r\n}\r\nbox2d.b2CollideEdgeAndPolygon.s_collider = new box2d.b2EPCollider();\r\n\r\n/*\r\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2EdgeShape');\r\n\r\ngoog.require('box2d.b2Shape');\r\n\r\n/** \r\n * A line segment (edge) shape. These can be connected in chains \r\n * or loops to other edge shapes. The connectivity information \r\n * is used to ensure correct contact normals. \r\n * @export \r\n * @constructor\r\n * @extends {box2d.b2Shape} \r\n */\r\nbox2d.b2EdgeShape = function ()\r\n{\r\n\tgoog.base(this, box2d.b2ShapeType.e_edgeShape, box2d.b2_polygonRadius); // base class constructor\r\n\r\n\tthis.m_vertex1 = new box2d.b2Vec2();\r\n\tthis.m_vertex2 = new box2d.b2Vec2();\r\n\r\n\tthis.m_vertex0 = new box2d.b2Vec2();\r\n\tthis.m_vertex3 = new box2d.b2Vec2();\r\n}\r\n\r\ngoog.inherits(box2d.b2EdgeShape, box2d.b2Shape);\r\n\r\n/** \r\n * These are the edge vertices \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EdgeShape.prototype.m_vertex1 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EdgeShape.prototype.m_vertex2 = null;\r\n\r\n/** \r\n * Optional adjacent vertices. These are used for smooth \r\n * collision. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EdgeShape.prototype.m_vertex0 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2EdgeShape.prototype.m_vertex3 = null;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2EdgeShape.prototype.m_hasVertex0 = false;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2EdgeShape.prototype.m_hasVertex3 = false;\r\n\r\n/** \r\n * Set this as an isolated edge. \r\n * @export \r\n * @return {box2d.b2EdgeShape} \r\n * @param {box2d.b2Vec2} v1\r\n * @param {box2d.b2Vec2} v2 \r\n */\r\nbox2d.b2EdgeShape.prototype.Set = function (v1, v2)\r\n{\r\n\tthis.m_vertex1.Copy(v1);\r\n\tthis.m_vertex2.Copy(v2);\r\n\tthis.m_hasVertex0 = false;\r\n\tthis.m_hasVertex3 = false;\r\n\treturn this;\r\n}\r\n\r\nbox2d.b2EdgeShape.prototype.SetAsEdge = box2d.b2EdgeShape.prototype.Set;\r\n\r\n/** \r\n * Implement box2d.b2Shape. \r\n * @export \r\n * @return {box2d.b2Shape} \r\n */\r\nbox2d.b2EdgeShape.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2EdgeShape().Copy(this);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Shape} \r\n * @param {box2d.b2Shape} other\r\n */\r\nbox2d.b2EdgeShape.prototype.Copy = function (other)\r\n{\r\n\tgoog.base(this, 'Copy', other);\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(other instanceof box2d.b2EdgeShape); }\r\n\r\n\tthis.m_vertex1.Copy(other.m_vertex1);\r\n\tthis.m_vertex2.Copy(other.m_vertex2);\r\n\tthis.m_vertex0.Copy(other.m_vertex0);\r\n\tthis.m_vertex3.Copy(other.m_vertex3);\r\n\tthis.m_hasVertex0 = other.m_hasVertex0;\r\n\tthis.m_hasVertex3 = other.m_hasVertex3;\r\n\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * @see box2d.b2Shape::GetChildCount \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2EdgeShape.prototype.GetChildCount = function ()\r\n{\r\n\treturn 1;\r\n}\r\n\r\n/** \r\n * @see box2d.b2Shape::TestPoint \r\n * @export \r\n * @return {boolean}\r\n * @param {box2d.b2Transform} xf\r\n * @param {box2d.b2Vec2} p\r\n */\r\nbox2d.b2EdgeShape.prototype.TestPoint = function (xf, p)\r\n{\r\n\treturn false;\r\n}\r\n\r\n/** \r\n * Implement box2d.b2Shape.\r\n * p = p1 + t * d\r\n * v = v1 + s * e\r\n * p1 + t * d = v1 + s * e\r\n * s * e - t * d = p1 - v1\r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2RayCastOutput} output \r\n * @param {box2d.b2RayCastInput} input \r\n * @param {box2d.b2Transform} xf \r\n * @param {number} childIndex \r\n */\r\nbox2d.b2EdgeShape.prototype.RayCast = function (output, input, xf, childIndex)\r\n{\r\n\t// Put the ray into the edge's frame of reference.\r\n\tvar p1 = box2d.b2MulTXV(xf, input.p1, box2d.b2EdgeShape.prototype.RayCast.s_p1);\r\n\tvar p2 = box2d.b2MulTXV(xf, input.p2, box2d.b2EdgeShape.prototype.RayCast.s_p2);\r\n\tvar d = box2d.b2SubVV(p2, p1, box2d.b2EdgeShape.prototype.RayCast.s_d);\r\n\r\n\tvar v1 = this.m_vertex1;\r\n\tvar v2 = this.m_vertex2;\r\n\tvar e = box2d.b2SubVV(v2, v1, box2d.b2EdgeShape.prototype.RayCast.s_e);\r\n\tvar normal = output.normal.SetXY(e.y, -e.x).SelfNormalize();\r\n\r\n\t// q = p1 + t * d\r\n\t// dot(normal, q - v1) = 0\r\n\t// dot(normal, p1 - v1) + t * dot(normal, d) = 0\r\n\tvar numerator = box2d.b2DotVV(normal, box2d.b2SubVV(v1, p1, box2d.b2Vec2.s_t0));\r\n\tvar denominator = box2d.b2DotVV(normal, d);\r\n\r\n\tif (denominator === 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar t = numerator / denominator;\r\n\tif (t < 0 || input.maxFraction < t)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar q = box2d.b2AddVMulSV(p1, t, d, box2d.b2EdgeShape.prototype.RayCast.s_q);\r\n\r\n\t// q = v1 + s * r\r\n\t// s = dot(q - v1, r) / dot(r, r)\r\n\tvar r = box2d.b2SubVV(v2, v1, box2d.b2EdgeShape.prototype.RayCast.s_r);\r\n\tvar rr = box2d.b2DotVV(r, r);\r\n\tif (rr === 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar s = box2d.b2DotVV(box2d.b2SubVV(q, v1, box2d.b2Vec2.s_t0), r) / rr;\r\n\tif (s < 0 || 1 < s)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\toutput.fraction = t;\r\n\tbox2d.b2MulRV(xf.q, output.normal, output.normal);\r\n\tif (numerator > 0)\r\n\t{\r\n\t\toutput.normal.SelfNeg();\r\n\t}\r\n\treturn true;\r\n}\r\nbox2d.b2EdgeShape.prototype.RayCast.s_p1 = new box2d.b2Vec2();\r\nbox2d.b2EdgeShape.prototype.RayCast.s_p2 = new box2d.b2Vec2();\r\nbox2d.b2EdgeShape.prototype.RayCast.s_d = new box2d.b2Vec2();\r\nbox2d.b2EdgeShape.prototype.RayCast.s_e = new box2d.b2Vec2();\r\nbox2d.b2EdgeShape.prototype.RayCast.s_q = new box2d.b2Vec2();\r\nbox2d.b2EdgeShape.prototype.RayCast.s_r = new box2d.b2Vec2();\r\n\r\n/** \r\n * @see box2d.b2Shape::ComputeAABB \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2AABB} aabb \r\n * @param {box2d.b2Transform} xf \r\n * @param {number} childIndex \r\n */\r\nbox2d.b2EdgeShape.prototype.ComputeAABB = function (aabb, xf, childIndex)\r\n{\r\n\tvar v1 = box2d.b2MulXV(xf, this.m_vertex1, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1);\r\n\tvar v2 = box2d.b2MulXV(xf, this.m_vertex2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2);\r\n\r\n\tbox2d.b2MinV(v1, v2, aabb.lowerBound);\r\n\tbox2d.b2MaxV(v1, v2, aabb.upperBound);\r\n\r\n\tvar r = this.m_radius;\r\n\taabb.lowerBound.SelfSubXY(r, r);\r\n\taabb.upperBound.SelfAddXY(r, r);\r\n}\r\nbox2d.b2EdgeShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2();\r\nbox2d.b2EdgeShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2();\r\n\r\n/** \r\n * @see box2d.b2Shape::ComputeMass \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2MassData} massData \r\n * @param {number} density \r\n */\r\nbox2d.b2EdgeShape.prototype.ComputeMass = function (massData, density)\r\n{\r\n\tmassData.mass = 0;\r\n\tbox2d.b2MidVV(this.m_vertex1, this.m_vertex2, massData.center);\r\n\tmassData.I = 0;\r\n}\r\n\r\n/**\r\n * @return {void} \r\n * @param {box2d.b2DistanceProxy} proxy \r\n * @param {number} index \r\n */\r\nbox2d.b2EdgeShape.prototype.SetupDistanceProxy = function (proxy, index)\r\n{\r\n\tproxy.m_vertices = new Array(2);\r\n\tproxy.m_vertices[0] = this.m_vertex1;\r\n\tproxy.m_vertices[1] = this.m_vertex2;\r\n\tproxy.m_count = 2;\r\n\tproxy.m_radius = this.m_radius;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} normal\r\n * @param {number} offset\r\n * @param {box2d.b2Transform} xf\r\n * @param {box2d.b2Vec2} c\r\n */\r\nbox2d.b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)\r\n{\r\n\tc.SetZero();\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * Dump this shape to the log file. \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2EdgeShape.prototype.Dump = function ()\r\n{\r\n\tbox2d.b2Log(\"    /*box2d.b2EdgeShape*/ var shape = new box2d.b2EdgeShape();\\n\");\r\n\tbox2d.b2Log(\"    shape.m_radius = %.15f;\\n\", this.m_radius);\r\n\tbox2d.b2Log(\"    shape.m_vertex0.SetXY(%.15f, %.15f);\\n\", this.m_vertex0.x, this.m_vertex0.y);\r\n\tbox2d.b2Log(\"    shape.m_vertex1.SetXY(%.15f, %.15f);\\n\", this.m_vertex1.x, this.m_vertex1.y);\r\n\tbox2d.b2Log(\"    shape.m_vertex2.SetXY(%.15f, %.15f);\\n\", this.m_vertex2.x, this.m_vertex2.y);\r\n\tbox2d.b2Log(\"    shape.m_vertex3.SetXY(%.15f, %.15f);\\n\", this.m_vertex3.x, this.m_vertex3.y);\r\n\tbox2d.b2Log(\"    shape.m_hasVertex0 = %s;\\n\", this.m_hasVertex0);\r\n\tbox2d.b2Log(\"    shape.m_hasVertex3 = %s;\\n\", this.m_hasVertex3);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2ChainShape');\r\n\r\ngoog.require('box2d.b2Shape');\r\ngoog.require('box2d.b2EdgeShape');\r\n\r\n/** \r\n * A chain shape is a free form sequence of line segments.\r\n * The chain has two-sided collision, so you can use inside and outside collision.\r\n * Therefore, you may use any winding order.\r\n * Since there may be many vertices, they are allocated using b2Alloc.\r\n * Connectivity information is used to create smooth collisions.\r\n * WARNING: The chain will not collide properly if there are self-intersections.\r\n * @export \r\n * @constructor\r\n * @extends {box2d.b2Shape} \r\n */\r\nbox2d.b2ChainShape = function ()\r\n{\r\n\tgoog.base(this, box2d.b2ShapeType.e_chainShape, box2d.b2_polygonRadius); // base class constructor\r\n\r\n\tthis.m_prevVertex = new box2d.b2Vec2();\r\n\tthis.m_nextVertex = new box2d.b2Vec2();\r\n}\r\n\r\ngoog.inherits(box2d.b2ChainShape, box2d.b2Shape);\r\n\r\n/** \r\n * The vertices. Owned by this class. \r\n * @export \r\n * @type {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2ChainShape.prototype.m_vertices = null;\r\n\r\n/** \r\n * The vertex count. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ChainShape.prototype.m_count = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ChainShape.prototype.m_prevVertex = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ChainShape.prototype.m_nextVertex = null;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2ChainShape.prototype.m_hasPrevVertex = false;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2ChainShape.prototype.m_hasNextVertex = false;\r\n\r\n/** \r\n * Create a loop. This automatically adjusts connectivity. \r\n * @export \r\n * @return {box2d.b2ChainShape} \r\n * @param {Array.<box2d.b2Vec2>} vertices an array of vertices, these are copied\r\n * @param {number=} count the vertex count\r\n */\r\nbox2d.b2ChainShape.prototype.CreateLoop = function (vertices, count)\r\n{\r\n\tcount = count || vertices.length;\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_vertices === null && this.m_count === 0); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(count >= 3); }\r\n\tif (box2d.ENABLE_ASSERTS)\r\n\t{\r\n\t\tfor (var i = 1; i < count; ++i)\r\n\t\t{\r\n\t\t\tvar v1 = vertices[i-1];\r\n\t\t\tvar v2 = vertices[i];\r\n\t\t\t// If the code crashes here, it means your vertices are too close together.\r\n\t\t\tbox2d.b2Assert(box2d.b2DistanceSquaredVV(v1, v2) > box2d.b2_linearSlop * box2d.b2_linearSlop);\r\n\t\t}\r\n\t}\r\n\r\n\tthis.m_count = count + 1;\r\n\tthis.m_vertices = box2d.b2Vec2.MakeArray(this.m_count);\r\n\tfor (var i = 0; i < count; ++i)\r\n\t{\r\n\t\tthis.m_vertices[i].Copy(vertices[i]);\r\n\t}\r\n\tthis.m_vertices[count].Copy(this.m_vertices[0]);\r\n\tthis.m_prevVertex.Copy(this.m_vertices[this.m_count - 2]);\r\n\tthis.m_nextVertex.Copy(this.m_vertices[1]);\r\n\tthis.m_hasPrevVertex = true;\r\n\tthis.m_hasNextVertex = true;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Create a chain with isolated end vertices. \r\n * @export \r\n * @return {box2d.b2ChainShape} \r\n * @param {Array.<box2d.b2Vec2>} vertices an array of vertices, these are copied\r\n * @param {number=} count the vertex count\r\n */\r\nbox2d.b2ChainShape.prototype.CreateChain = function (vertices, count)\r\n{\r\n\tcount = count || vertices.length;\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_vertices === null && this.m_count === 0); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(count >= 2); }\r\n\tif (box2d.ENABLE_ASSERTS)\r\n\t{\r\n\t\tfor (var i = 1; i < count; ++i)\r\n\t\t{\r\n\t\t\tvar v1 = vertices[i-1];\r\n\t\t\tvar v2 = vertices[i];\r\n\t\t\t// If the code crashes here, it means your vertices are too close together.\r\n\t\t\tbox2d.b2Assert(box2d.b2DistanceSquaredVV(v1, v2) > box2d.b2_linearSlop * box2d.b2_linearSlop);\r\n\t\t}\r\n\t}\r\n\r\n\tthis.m_count = count;\r\n\tthis.m_vertices = box2d.b2Vec2.MakeArray(count);\r\n\tfor (var i = 0; i < count; ++i)\r\n\t{\r\n\t\tthis.m_vertices[i].Copy(vertices[i]);\r\n\t}\r\n\tthis.m_hasPrevVertex = false;\r\n\tthis.m_hasNextVertex = false;\r\n\r\n\tthis.m_prevVertex.SetZero();\r\n\tthis.m_nextVertex.SetZero();\r\n\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * Establish connectivity to a vertex that precedes the first vertex.\r\n * Don't call this for loops.\r\n * @export \r\n * @return {box2d.b2ChainShape} \r\n * @param {box2d.b2Vec2} prevVertex \r\n */\r\nbox2d.b2ChainShape.prototype.SetPrevVertex = function (prevVertex)\r\n{\r\n\tthis.m_prevVertex.Copy(prevVertex);\r\n\tthis.m_hasPrevVertex = true;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * Establish connectivity to a vertex that follows the last vertex.\r\n * Don't call this for loops.\r\n * @export \r\n * @return {box2d.b2ChainShape} \r\n * @param {box2d.b2Vec2} nextVertex \r\n */\r\nbox2d.b2ChainShape.prototype.SetNextVertex = function (nextVertex)\r\n{\r\n\tthis.m_nextVertex.Copy(nextVertex);\r\n\tthis.m_hasNextVertex = true;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Implement box2d.b2Shape. Vertices are cloned using b2Alloc. \r\n * @export \r\n * @return {box2d.b2Shape} \r\n */\r\nbox2d.b2ChainShape.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2ChainShape().Copy(this);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Shape} \r\n * @param {box2d.b2Shape} other\r\n */\r\nbox2d.b2ChainShape.prototype.Copy = function (other)\r\n{\r\n\tgoog.base(this, 'Copy', other);\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(other instanceof box2d.b2ChainShape); }\r\n\r\n\tthis.CreateChain(other.m_vertices, other.m_count);\r\n\tthis.m_prevVertex.Copy(other.m_prevVertex);\r\n\tthis.m_nextVertex.Copy(other.m_nextVertex);\r\n\tthis.m_hasPrevVertex = other.m_hasPrevVertex;\r\n\tthis.m_hasNextVertex = other.m_hasNextVertex;\r\n\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * @see box2d.b2Shape::GetChildCount \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2ChainShape.prototype.GetChildCount = function ()\r\n{\r\n\t// edge count = vertex count - 1\r\n\treturn this.m_count - 1;\r\n}\r\n\r\n/** \r\n * Get a child edge. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2EdgeShape} edge \r\n * @param {number} index \r\n */\r\nbox2d.b2ChainShape.prototype.GetChildEdge = function (edge, index)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= index && index < this.m_count - 1); }\r\n\tedge.m_type = box2d.b2ShapeType.e_edgeShape;\r\n\tedge.m_radius = this.m_radius;\r\n\r\n\tedge.m_vertex1.Copy(this.m_vertices[index]);\r\n\tedge.m_vertex2.Copy(this.m_vertices[index + 1]);\r\n\r\n\tif (index > 0)\r\n\t{\r\n\t\tedge.m_vertex0.Copy(this.m_vertices[index - 1]);\r\n\t\tedge.m_hasVertex0 = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tedge.m_vertex0.Copy(this.m_prevVertex);\r\n\t\tedge.m_hasVertex0 = this.m_hasPrevVertex;\r\n\t}\r\n\r\n\tif (index < this.m_count - 2)\r\n\t{\r\n\t\tedge.m_vertex3.Copy(this.m_vertices[index + 2]);\r\n\t\tedge.m_hasVertex3 = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tedge.m_vertex3.Copy(this.m_nextVertex);\r\n\t\tedge.m_hasVertex3 = this.m_hasNextVertex;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * This always return false.\r\n * @see box2d.b2Shape::TestPoint\r\n * @export \r\n * @return {boolean}\r\n * @param {box2d.b2Transform} xf\r\n * @param {box2d.b2Vec2} p\r\n */\r\nbox2d.b2ChainShape.prototype.TestPoint = function (xf, p)\r\n{\r\n\treturn false;\r\n}\r\n\r\n/** \r\n * Implement box2d.b2Shape. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2RayCastOutput} output \r\n * @param {box2d.b2RayCastInput} input \r\n * @param {box2d.b2Transform} xf \r\n * @param {number} childIndex \r\n */\r\nbox2d.b2ChainShape.prototype.RayCast = function (output, input, xf, childIndex)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(childIndex < this.m_count); }\r\n\r\n\t/** @type {box2d.b2EdgeShape} */ var edgeShape = box2d.b2ChainShape.s_edgeShape;\r\n\r\n\tedgeShape.m_vertex1.Copy(this.m_vertices[childIndex]);\r\n\tedgeShape.m_vertex2.Copy(this.m_vertices[(childIndex + 1) % this.m_count]);\r\n\r\n\treturn edgeShape.RayCast(output, input, xf, 0);\r\n}\r\n/**\r\n * @export \r\n * @type {box2d.b2EdgeShape}\r\n */\r\nbox2d.b2ChainShape.s_edgeShape = new box2d.b2EdgeShape();\r\n\r\n/** \r\n * @see box2d.b2Shape::ComputeAABB \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2AABB} aabb \r\n * @param {box2d.b2Transform} xf \r\n * @param {number} childIndex \r\n */\r\nbox2d.b2ChainShape.prototype.ComputeAABB = function (aabb, xf, childIndex)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(childIndex < this.m_count); }\r\n\r\n\t/** @type {box2d.b2Vec2} */ var vertexi1 = this.m_vertices[childIndex];\r\n\t/** @type {box2d.b2Vec2} */ var vertexi2 = this.m_vertices[(childIndex + 1) % this.m_count];\r\n\r\n\t/** @type {box2d.b2Vec2} */ var v1 = box2d.b2MulXV(xf, vertexi1, box2d.b2ChainShape.prototype.ComputeAABB.s_v1);\r\n\t/** @type {box2d.b2Vec2} */ var v2 = box2d.b2MulXV(xf, vertexi2, box2d.b2ChainShape.prototype.ComputeAABB.s_v2);\r\n\r\n\tbox2d.b2MinV(v1, v2, aabb.lowerBound);\r\n\tbox2d.b2MaxV(v1, v2, aabb.upperBound);\r\n}\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ChainShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2();\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ChainShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2();\r\n\r\n/** \r\n * @see box2d.b2Shape::ComputeMass \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2MassData} massData \r\n * @param {number} density \r\n */\r\nbox2d.b2ChainShape.prototype.ComputeMass = function (massData, density)\r\n{\r\n\tmassData.mass = 0;\r\n\tmassData.center.SetZero();\r\n\tmassData.I = 0;\r\n}\r\n\r\n/**\r\n * @return {void} \r\n * @param {box2d.b2DistanceProxy} proxy \r\n * @param {number} index \r\n */\r\nbox2d.b2ChainShape.prototype.SetupDistanceProxy = function (proxy, index)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= index && index < this.m_count); }\r\n\r\n\tproxy.m_buffer[0].Copy(this.m_vertices[index]);\r\n\tif (index + 1 < this.m_count)\r\n\t{\r\n\t\tproxy.m_buffer[1].Copy(this.m_vertices[index + 1]);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tproxy.m_buffer[1].Copy(this.m_vertices[0]);\r\n\t}\r\n\r\n\tproxy.m_vertices = proxy.m_buffer;\r\n\tproxy.m_count = 2;\r\n\tproxy.m_radius = this.m_radius;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} normal\r\n * @param {number} offset\r\n * @param {box2d.b2Transform} xf\r\n * @param {box2d.b2Vec2} c\r\n */\r\nbox2d.b2ChainShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)\r\n{\r\n\tc.SetZero();\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * Dump this shape to the log file. \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2ChainShape.prototype.Dump = function ()\r\n{\r\n\tbox2d.b2Log(\"    /*box2d.b2ChainShape*/ var shape = new box2d.b2ChainShape();\\n\");\r\n\tbox2d.b2Log(\"    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\\n\", box2d.b2_maxPolygonVertices);\r\n\tfor (var i = 0; i < this.m_count; ++i)\r\n\t{\r\n\t\tbox2d.b2Log(\"    vs[%d].SetXY(%.15f, %.15f);\\n\", i, this.m_vertices[i].x, this.m_vertices[i].y);\r\n\t}\r\n\tbox2d.b2Log(\"    shape.CreateChain(vs, %d);\\n\", this.m_count);\r\n\tbox2d.b2Log(\"    shape.m_prevVertex.SetXY(%.15f, %.15f);\\n\", this.m_prevVertex.x, this.m_prevVertex.y);\r\n\tbox2d.b2Log(\"    shape.m_nextVertex.SetXY(%.15f, %.15f);\\n\", this.m_nextVertex.x, this.m_nextVertex.y);\r\n\tbox2d.b2Log(\"    shape.m_hasPrevVertex = %s;\\n\", (this.m_hasPrevVertex)?('true'):('false'));\r\n\tbox2d.b2Log(\"    shape.m_hasNextVertex = %s;\\n\", (this.m_hasNextVertex)?('true'):('false'));\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2ChainAndPolygonContact');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Contact');\r\ngoog.require('box2d.b2CollideEdge');\r\ngoog.require('box2d.b2ChainShape');\r\ngoog.require('box2d.b2PolygonShape');\r\n\r\n/** \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Contact} \r\n */\r\nbox2d.b2ChainAndPolygonContact = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n};\r\n\r\ngoog.inherits(box2d.b2ChainAndPolygonContact, box2d.b2Contact);\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Contact} \r\n * @param allocator \r\n */\r\nbox2d.b2ChainAndPolygonContact.Create = function (allocator)\r\n{\r\n\treturn new box2d.b2ChainAndPolygonContact();\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n * @param allocator \r\n */\r\nbox2d.b2ChainAndPolygonContact.Destroy = function (contact, allocator)\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixtureA\r\n * @param {box2d.b2Fixture} fixtureB\r\n */\r\nbox2d.b2ChainAndPolygonContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)\r\n{\r\n\tgoog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_chainShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_polygonShape); }\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2ChainAndPolygonContact.prototype.Evaluate = function (manifold, xfA, xfB)\r\n{\r\n\tvar shapeA = this.m_fixtureA.GetShape();\r\n\tvar shapeB = this.m_fixtureB.GetShape();\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2ChainShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2PolygonShape); }\r\n\t/*box2d.b2ChainShape*/ var chain = (shapeA instanceof box2d.b2ChainShape)? shapeA : null;\r\n\t/*box2d.b2EdgeShape*/ var edge = box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge;\r\n\tchain.GetChildEdge(edge, this.m_indexA);\r\n\tbox2d.b2CollideEdgeAndPolygon(\r\n\t\tmanifold, \r\n\t\tedge, xfA, \r\n\t\t(shapeB instanceof box2d.b2PolygonShape)? shapeB : null, xfB);\r\n}\r\nbox2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2CollidePolygon');\r\n\r\ngoog.require('box2d.b2Collision');\r\n\r\n/**\r\n * Find the max separation between poly1 and poly2 using edge\r\n * normals from poly1.\r\n * @export\r\n * @return {number}\r\n * @param {Array.<number>} edgeIndex\r\n * @param {box2d.b2PolygonShape} poly1\r\n * @param {box2d.b2Transform} xf1\r\n * @param {box2d.b2PolygonShape} poly2\r\n * @param {box2d.b2Transform} xf2\r\n */\r\nbox2d.b2FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2)\r\n{\r\n\tvar /*int32*/ count1 = poly1.m_count;\r\n\tvar /*int32*/ count2 = poly2.m_count;\r\n\tvar /*const b2Vec2**/ n1s = poly1.m_normals;\r\n\tvar /*const b2Vec2**/ v1s = poly1.m_vertices;\r\n\tvar /*const b2Vec2**/ v2s = poly2.m_vertices;\r\n\tvar /*b2Transform*/ xf = box2d.b2MulTXX(xf2, xf1, box2d.b2FindMaxSeparation.s_xf);\r\n\r\n\tvar /*int32*/ bestIndex = 0;\r\n\tvar /*float32*/ maxSeparation = -box2d.b2_maxFloat;\r\n\tfor (var /*int32*/ i = 0; i < count1; ++i)\r\n\t{\r\n\t\t// Get poly1 normal in frame2.\r\n\t\tvar /*b2Vec2*/ n = box2d.b2MulRV(xf.q, n1s[i], box2d.b2FindMaxSeparation.s_n);\r\n\t\tvar /*b2Vec2*/ v1 = box2d.b2MulXV(xf, v1s[i], box2d.b2FindMaxSeparation.s_v1);\r\n\r\n\t\t// Find deepest point for normal i.\r\n\t\tvar /*float32*/ si = box2d.b2_maxFloat;\r\n\t\tfor (var /*int32*/ j = 0; j < count2; ++j)\r\n\t\t{\r\n\t\t\tvar /*float32*/ sij = box2d.b2DotVV(n, box2d.b2SubVV(v2s[j], v1, box2d.b2Vec2.s_t0)); // b2Dot(n, v2s[j] - v1);\r\n\t\t\tif (sij < si)\r\n\t\t\t{\r\n\t\t\t\tsi = sij;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (si > maxSeparation)\r\n\t\t{\r\n\t\t\tmaxSeparation = si;\r\n\t\t\tbestIndex = i;\r\n\t\t}\r\n\t}\r\n\r\n\tedgeIndex[0] = bestIndex; // *edgeIndex = bestIndex;\r\n\treturn maxSeparation;\r\n}\r\nbox2d.b2FindMaxSeparation.s_xf = new box2d.b2Transform();\r\nbox2d.b2FindMaxSeparation.s_n = new box2d.b2Vec2();\r\nbox2d.b2FindMaxSeparation.s_v1 = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export\r\n * @return {void}\r\n * @param {Array.<box2d.b2ClipVertex>} c\r\n * @param {box2d.b2PolygonShape} poly1\r\n * @param {box2d.b2Transform} xf1\r\n * @param {number} edge1\r\n * @param {box2d.b2PolygonShape} poly2\r\n * @param {box2d.b2Transform} xf2\r\n */\r\nbox2d.b2FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2)\r\n{\r\n\tvar count1 = poly1.m_count;\r\n\tvar normals1 = poly1.m_normals;\r\n\r\n\tvar count2 = poly2.m_count;\r\n\tvar vertices2 = poly2.m_vertices;\r\n\tvar normals2 = poly2.m_normals;\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= edge1 && edge1 < count1); }\r\n\r\n\t// Get the normal of the reference edge in poly2's frame.\r\n\tvar normal1 = box2d.b2MulTRV(xf2.q, box2d.b2MulRV(xf1.q, normals1[edge1], box2d.b2Vec2.s_t0), box2d.b2FindIncidentEdge.s_normal1);\r\n\r\n\t// Find the incident edge on poly2.\r\n\tvar index = 0;\r\n\tvar minDot = box2d.b2_maxFloat;\r\n\tfor (var i = 0; i < count2; ++i)\r\n\t{\r\n\t\tvar dot = box2d.b2DotVV(normal1, normals2[i]);\r\n\t\tif (dot < minDot)\r\n\t\t{\r\n\t\t\tminDot = dot;\r\n\t\t\tindex = i;\r\n\t\t}\r\n\t}\r\n\r\n\t// Build the clip vertices for the incident edge.\r\n\tvar i1 = index;\r\n\tvar i2 = (i1 + 1) % count2;\r\n\r\n\tvar c0 = c[0];\r\n\tbox2d.b2MulXV(xf2, vertices2[i1], c0.v);\r\n\tvar cf0 = c0.id.cf;\r\n\tcf0.indexA = edge1;\r\n\tcf0.indexB = i1;\r\n\tcf0.typeA = box2d.b2ContactFeatureType.e_face;\r\n\tcf0.typeB = box2d.b2ContactFeatureType.e_vertex;\r\n\r\n\tvar c1 = c[1];\r\n\tbox2d.b2MulXV(xf2, vertices2[i2], c1.v);\r\n\tvar cf1 = c1.id.cf;\r\n\tcf1.indexA = edge1;\r\n\tcf1.indexB = i2;\r\n\tcf1.typeA = box2d.b2ContactFeatureType.e_face;\r\n\tcf1.typeB = box2d.b2ContactFeatureType.e_vertex;\r\n}\r\nbox2d.b2FindIncidentEdge.s_normal1 = new box2d.b2Vec2();\r\n\r\n/**\r\n * Find edge normal of max separation on A - return if separating axis is found\r\n * Find edge normal of max separation on B - return if separation axis is found\r\n * Choose reference edge as min(minA, minB)\r\n * Find incident edge\r\n * Clip\r\n * The normal points from 1 to 2\r\n * @export\r\n * @return {void}\r\n * @param {box2d.b2Manifold} manifold\r\n * @param {box2d.b2PolygonShape} polyA\r\n * @param {box2d.b2Transform} xfA\r\n * @param {box2d.b2PolygonShape} polyB\r\n * @param {box2d.b2Transform} xfB\r\n */\r\nbox2d.b2CollidePolygons = function (manifold, polyA, xfA, polyB, xfB)\r\n{\r\n\tmanifold.pointCount = 0;\r\n\tvar totalRadius = polyA.m_radius + polyB.m_radius;\r\n\r\n\tvar edgeA = box2d.b2CollidePolygons.s_edgeA; edgeA[0] = 0;\r\n\tvar separationA = box2d.b2FindMaxSeparation(edgeA, polyA, xfA, polyB, xfB);\r\n\tif (separationA > totalRadius)\r\n\t\treturn;\r\n\r\n\tvar edgeB = box2d.b2CollidePolygons.s_edgeB; edgeB[0] = 0;\r\n\tvar separationB = box2d.b2FindMaxSeparation(edgeB, polyB, xfB, polyA, xfA);\r\n\tif (separationB > totalRadius)\r\n\t\treturn;\r\n\r\n\tvar poly1; // reference polygon\r\n\tvar poly2; // incident polygon\r\n\tvar xf1, xf2;\r\n\tvar edge1 = 0; // reference edge\r\n\tvar flip = 0;\r\n\tvar k_relativeTol = 0.98;\r\n\tvar k_absoluteTol = 0.001;\r\n\r\n\tif (separationB > k_relativeTol * separationA + k_absoluteTol)\r\n\t{\r\n\t\tpoly1 = polyB;\r\n\t\tpoly2 = polyA;\r\n\t\txf1 = xfB;\r\n\t\txf2 = xfA;\r\n\t\tedge1 = edgeB[0];\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_faceB;\r\n\t\tflip = 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpoly1 = polyA;\r\n\t\tpoly2 = polyB;\r\n\t\txf1 = xfA;\r\n\t\txf2 = xfB;\r\n\t\tedge1 = edgeA[0];\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_faceA;\r\n\t\tflip = 0;\r\n\t}\r\n\r\n\tvar incidentEdge = box2d.b2CollidePolygons.s_incidentEdge;\r\n\tbox2d.b2FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\r\n\r\n\tvar count1 = poly1.m_count;\r\n\tvar vertices1 = poly1.m_vertices;\r\n\r\n\tvar iv1 = edge1;\r\n\tvar iv2 = (edge1 + 1) % count1;\r\n\r\n\tvar local_v11 = vertices1[iv1];\r\n\tvar local_v12 = vertices1[iv2];\r\n\r\n\tvar localTangent = box2d.b2SubVV(local_v12, local_v11, box2d.b2CollidePolygons.s_localTangent);\r\n\tlocalTangent.Normalize();\r\n\r\n\tvar localNormal = box2d.b2CrossVOne(localTangent, box2d.b2CollidePolygons.s_localNormal);\r\n\tvar planePoint = box2d.b2MidVV(local_v11, local_v12, box2d.b2CollidePolygons.s_planePoint);\r\n\r\n\tvar tangent = box2d.b2MulRV(xf1.q, localTangent, box2d.b2CollidePolygons.s_tangent);\r\n\tvar normal = box2d.b2CrossVOne(tangent, box2d.b2CollidePolygons.s_normal);\r\n\r\n\tvar v11 = box2d.b2MulXV(xf1, local_v11, box2d.b2CollidePolygons.s_v11);\r\n\tvar v12 = box2d.b2MulXV(xf1, local_v12, box2d.b2CollidePolygons.s_v12);\r\n\r\n\t// Face offset.\r\n\tvar frontOffset = box2d.b2DotVV(normal, v11);\r\n\r\n\t// Side offsets, extended by polytope skin thickness.\r\n\tvar sideOffset1 = -box2d.b2DotVV(tangent, v11) + totalRadius;\r\n\tvar sideOffset2 = box2d.b2DotVV(tangent, v12) + totalRadius;\r\n\r\n\t// Clip incident edge against extruded edge1 side edges.\r\n\tvar clipPoints1 = box2d.b2CollidePolygons.s_clipPoints1;\r\n\tvar clipPoints2 = box2d.b2CollidePolygons.s_clipPoints2;\r\n\tvar np;\r\n\r\n\t// Clip to box side 1\r\n\tvar ntangent = box2d.b2NegV(tangent, box2d.b2CollidePolygons.s_ntangent);\r\n\tnp = box2d.b2ClipSegmentToLine(clipPoints1, incidentEdge, ntangent, sideOffset1, iv1);\r\n\r\n\tif (np < 2)\r\n\t\treturn;\r\n\r\n\t// Clip to negative box side 1\r\n\tnp = box2d.b2ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);\r\n\r\n\tif (np < 2)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Now clipPoints2 contains the clipped points.\r\n\tmanifold.localNormal.Copy(localNormal);\r\n\tmanifold.localPoint.Copy(planePoint);\r\n\r\n\tvar pointCount = 0;\r\n\tfor (var i = 0; i < box2d.b2_maxManifoldPoints; ++i)\r\n\t{\r\n\t\tvar cv = clipPoints2[i];\r\n\t\tvar separation = box2d.b2DotVV(normal, cv.v) - frontOffset;\r\n\r\n\t\tif (separation <= totalRadius)\r\n\t\t{\r\n\t\t\tvar cp = manifold.points[pointCount];\r\n\t\t\tbox2d.b2MulTXV(xf2, cv.v, cp.localPoint);\r\n\t\t\tcp.id.Copy(cv.id);\r\n\t\t\tif (flip)\r\n\t\t\t{\r\n\t\t\t\t// Swap features\r\n\t\t\t\t/** @type {box2d.b2ContactFeature} */ var cf = cp.id.cf;\r\n\t\t\t\tcp.id.cf.indexA = cf.indexB;\r\n\t\t\t\tcp.id.cf.indexB = cf.indexA;\r\n\t\t\t\tcp.id.cf.typeA = cf.typeB;\r\n\t\t\t\tcp.id.cf.typeB = cf.typeA;\r\n\t\t\t}\r\n\t\t\t++pointCount;\r\n\t\t}\r\n\t}\r\n\r\n\tmanifold.pointCount = pointCount;\r\n}\r\nbox2d.b2CollidePolygons.s_incidentEdge = box2d.b2ClipVertex.MakeArray(2);\r\nbox2d.b2CollidePolygons.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);\r\nbox2d.b2CollidePolygons.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);\r\nbox2d.b2CollidePolygons.s_edgeA = box2d.b2MakeNumberArray(1);\r\nbox2d.b2CollidePolygons.s_edgeB = box2d.b2MakeNumberArray(1);\r\nbox2d.b2CollidePolygons.s_localTangent = new box2d.b2Vec2();\r\nbox2d.b2CollidePolygons.s_localNormal = new box2d.b2Vec2();\r\nbox2d.b2CollidePolygons.s_planePoint = new box2d.b2Vec2();\r\nbox2d.b2CollidePolygons.s_normal = new box2d.b2Vec2();\r\nbox2d.b2CollidePolygons.s_tangent = new box2d.b2Vec2();\r\nbox2d.b2CollidePolygons.s_ntangent = new box2d.b2Vec2();\r\nbox2d.b2CollidePolygons.s_v11 = new box2d.b2Vec2();\r\nbox2d.b2CollidePolygons.s_v12 = new box2d.b2Vec2();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2PolygonContact');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Contact');\r\ngoog.require('box2d.b2CollidePolygon');\r\n\r\n/**\r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Contact} \r\n */\r\nbox2d.b2PolygonContact = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n};\r\n\r\ngoog.inherits(box2d.b2PolygonContact, box2d.b2Contact);\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Contact} \r\n * @param allocator \r\n */\r\nbox2d.b2PolygonContact.Create = function (allocator)\r\n{\r\n\treturn new box2d.b2PolygonContact();\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n * @param allocator \r\n */\r\nbox2d.b2PolygonContact.Destroy = function (contact, allocator)\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixtureA\r\n * @param {box2d.b2Fixture} fixtureB\r\n */\r\nbox2d.b2PolygonContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)\r\n{\r\n\tgoog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2PolygonContact.prototype.Evaluate = function (manifold, xfA, xfB)\r\n{\r\n\tvar shapeA = this.m_fixtureA.GetShape();\r\n\tvar shapeB = this.m_fixtureB.GetShape();\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2PolygonShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2PolygonShape); }\r\n\tbox2d.b2CollidePolygons(\r\n\t\tmanifold, \r\n\t\t(shapeA instanceof box2d.b2PolygonShape)? shapeA : null, xfA, \r\n\t\t(shapeB instanceof box2d.b2PolygonShape)? shapeB : null, xfB);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2007-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2CollideCircle');\r\n\r\ngoog.require('box2d.b2Collision');\r\n\r\n/** \r\n * Compute the collision manifold between two circles. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2CircleShape} circleA \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2CircleShape} circleB \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2CollideCircles = function (manifold, circleA, xfA, circleB, xfB)\r\n{\r\n\tmanifold.pointCount = 0;\r\n\r\n\tvar pA = box2d.b2MulXV(xfA, circleA.m_p, box2d.b2CollideCircles.s_pA);\r\n\tvar pB = box2d.b2MulXV(xfB, circleB.m_p, box2d.b2CollideCircles.s_pB);\r\n\r\n\tvar distSqr = box2d.b2DistanceSquaredVV(pA, pB);\r\n\tvar radius = circleA.m_radius + circleB.m_radius;\r\n\tif (distSqr > radius * radius)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tmanifold.type = box2d.b2ManifoldType.e_circles;\r\n\tmanifold.localPoint.Copy(circleA.m_p);\r\n\tmanifold.localNormal.SetZero();\r\n\tmanifold.pointCount = 1;\r\n\r\n\tmanifold.points[0].localPoint.Copy(circleB.m_p);\r\n\tmanifold.points[0].id.key = 0;\r\n}\r\nbox2d.b2CollideCircles.s_pA = new box2d.b2Vec2();\r\nbox2d.b2CollideCircles.s_pB = new box2d.b2Vec2();\r\n\r\n/** \r\n * Compute the collision manifold between a polygon and a \r\n * circle. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold\r\n * @param {box2d.b2PolygonShape} polygonA\r\n * @param {box2d.b2Transform} xfA\r\n * @param {box2d.b2CircleShape} circleB\r\n * @param {box2d.b2Transform} xfB\r\n */\r\nbox2d.b2CollidePolygonAndCircle = function (manifold, polygonA, xfA, circleB, xfB)\r\n{\r\n\tmanifold.pointCount = 0;\r\n\r\n\t// Compute circle position in the frame of the polygon.\r\n\tvar c = box2d.b2MulXV(xfB, circleB.m_p, box2d.b2CollidePolygonAndCircle.s_c);\r\n\tvar cLocal = box2d.b2MulTXV(xfA, c, box2d.b2CollidePolygonAndCircle.s_cLocal);\r\n\r\n\t// Find the min separating edge.\r\n\tvar normalIndex = 0;\r\n\tvar separation = (-box2d.b2_maxFloat);\r\n\tvar radius = polygonA.m_radius + circleB.m_radius;\r\n\tvar vertexCount = polygonA.m_count;\r\n\tvar vertices = polygonA.m_vertices;\r\n\tvar normals = polygonA.m_normals;\r\n\r\n\tfor (var i = 0; i < vertexCount; ++i)\r\n\t{\r\n\t\tvar s = box2d.b2DotVV(normals[i], box2d.b2SubVV(cLocal, vertices[i], box2d.b2Vec2.s_t0));\r\n\r\n\t\tif (s > radius)\r\n\t\t{\r\n\t\t\t// Early out.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (s > separation)\r\n\t\t{\r\n\t\t\tseparation = s;\r\n\t\t\tnormalIndex = i;\r\n\t\t}\r\n\t}\r\n\r\n\t// Vertices that subtend the incident face.\r\n\tvar vertIndex1 = normalIndex;\r\n\tvar vertIndex2 = (vertIndex1 + 1) % vertexCount;\r\n\tvar v1 = vertices[vertIndex1];\r\n\tvar v2 = vertices[vertIndex2];\r\n\r\n\t// If the center is inside the polygon ...\r\n\tif (separation < box2d.b2_epsilon)\r\n\t{\r\n\t\tmanifold.pointCount = 1;\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_faceA;\r\n\t\tmanifold.localNormal.Copy(normals[normalIndex]);\r\n\t\tbox2d.b2MidVV(v1, v2, manifold.localPoint);\r\n\t\tmanifold.points[0].localPoint.Copy(circleB.m_p);\r\n\t\tmanifold.points[0].id.key = 0;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Compute barycentric coordinates\r\n\tvar u1 = box2d.b2DotVV(box2d.b2SubVV(cLocal, v1, box2d.b2Vec2.s_t0), box2d.b2SubVV(v2, v1, box2d.b2Vec2.s_t1));\r\n\tvar u2 = box2d.b2DotVV(box2d.b2SubVV(cLocal, v2, box2d.b2Vec2.s_t0), box2d.b2SubVV(v1, v2, box2d.b2Vec2.s_t1));\r\n\tif (u1 <= 0)\r\n\t{\r\n\t\tif (box2d.b2DistanceSquaredVV(cLocal, v1) > radius * radius)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmanifold.pointCount = 1;\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_faceA;\r\n\t\tbox2d.b2SubVV(cLocal, v1, manifold.localNormal).SelfNormalize();\r\n\t\tmanifold.localPoint.Copy(v1);\r\n\t\tmanifold.points[0].localPoint.Copy(circleB.m_p);\r\n\t\tmanifold.points[0].id.key = 0;\r\n\t}\r\n\telse if (u2 <= 0)\r\n\t{\r\n\t\tif (box2d.b2DistanceSquaredVV(cLocal, v2) > radius * radius)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmanifold.pointCount = 1;\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_faceA;\r\n\t\tbox2d.b2SubVV(cLocal, v2, manifold.localNormal).SelfNormalize();\r\n\t\tmanifold.localPoint.Copy(v2);\r\n\t\tmanifold.points[0].localPoint.Copy(circleB.m_p);\r\n\t\tmanifold.points[0].id.key = 0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvar faceCenter = box2d.b2MidVV(v1, v2, box2d.b2CollidePolygonAndCircle.s_faceCenter);\r\n\t\tseparation = box2d.b2DotVV(box2d.b2SubVV(cLocal, faceCenter, box2d.b2Vec2.s_t1), normals[vertIndex1]);\r\n\t\tif (separation > radius)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmanifold.pointCount = 1;\r\n\t\tmanifold.type = box2d.b2ManifoldType.e_faceA;\r\n\t\tmanifold.localNormal.Copy(normals[vertIndex1]).SelfNormalize();\r\n\t\tmanifold.localPoint.Copy(faceCenter);\r\n\t\tmanifold.points[0].localPoint.Copy(circleB.m_p);\r\n\t\tmanifold.points[0].id.key = 0;\r\n\t}\r\n}\r\nbox2d.b2CollidePolygonAndCircle.s_c = new box2d.b2Vec2();\r\nbox2d.b2CollidePolygonAndCircle.s_cLocal = new box2d.b2Vec2();\r\nbox2d.b2CollidePolygonAndCircle.s_faceCenter = new box2d.b2Vec2();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2CircleContact');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Contact');\r\ngoog.require('box2d.b2CollideCircle');\r\n\r\n/**\r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Contact} \r\n */\r\nbox2d.b2CircleContact = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n};\r\n\r\ngoog.inherits(box2d.b2CircleContact, box2d.b2Contact);\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Contact} \r\n * @param allocator \r\n */\r\nbox2d.b2CircleContact.Create = function (allocator)\r\n{\r\n\treturn new box2d.b2CircleContact();\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n * @param allocator \r\n */\r\nbox2d.b2CircleContact.Destroy = function (contact, allocator)\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixtureA\r\n * @param {number} indexA \r\n * @param {box2d.b2Fixture} fixtureB\r\n * @param {number} indexB \r\n */\r\nbox2d.b2CircleContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)\r\n{\r\n\tgoog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2CircleContact.prototype.Evaluate = function (manifold, xfA, xfB)\r\n{\r\n\tvar shapeA = this.m_fixtureA.GetShape();\r\n\tvar shapeB = this.m_fixtureB.GetShape();\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2CircleShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2CircleShape); }\r\n\tbox2d.b2CollideCircles(\r\n\t\tmanifold, \r\n\t\t(shapeA instanceof box2d.b2CircleShape)? shapeA : null, xfA, \r\n\t\t(shapeB instanceof box2d.b2CircleShape)? shapeB : null, xfB);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2ChainAndCircleContact');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Contact');\r\ngoog.require('box2d.b2CollideEdge');\r\n\r\n/** \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Contact} \r\n */\r\nbox2d.b2ChainAndCircleContact = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n};\r\n\r\ngoog.inherits(box2d.b2ChainAndCircleContact, box2d.b2Contact);\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Contact} \r\n * @param allocator \r\n */\r\nbox2d.b2ChainAndCircleContact.Create = function (allocator)\r\n{\r\n\treturn new box2d.b2ChainAndCircleContact();\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n * @param allocator \r\n */\r\nbox2d.b2ChainAndCircleContact.Destroy = function (contact, allocator)\r\n{\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixtureA\r\n * @param {box2d.b2Fixture} fixtureB\r\n */\r\nbox2d.b2ChainAndCircleContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)\r\n{\r\n\tgoog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_chainShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_circleShape); }\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2ChainAndCircleContact.prototype.Evaluate = function (manifold, xfA, xfB)\r\n{\r\n\tvar shapeA = this.m_fixtureA.GetShape();\r\n\tvar shapeB = this.m_fixtureB.GetShape();\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2ChainShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2CircleShape); }\r\n\t/*box2d.b2ChainShape*/ var chain = (shapeA instanceof box2d.b2ChainShape)? shapeA : null;\r\n\t/*box2d.b2EdgeShape*/ var edge = box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge;\r\n\tchain.GetChildEdge(edge, this.m_indexA);\r\n\tbox2d.b2CollideEdgeAndCircle(\r\n\t\tmanifold, \r\n\t\tedge, xfA, \r\n\t\t(shapeB instanceof box2d.b2CircleShape)? shapeB : null, xfB);\r\n}\r\nbox2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2EdgeAndCircleContact');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Contact');\r\ngoog.require('box2d.b2CollideEdge');\r\n\r\n/**\r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Contact} \r\n */\r\nbox2d.b2EdgeAndCircleContact = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n};\r\n\r\ngoog.inherits(box2d.b2EdgeAndCircleContact, box2d.b2Contact);\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Contact} \r\n * @param allocator \r\n */\r\nbox2d.b2EdgeAndCircleContact.Create = function (allocator)\r\n{\r\n\treturn new box2d.b2EdgeAndCircleContact();\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n * @param allocator \r\n */\r\nbox2d.b2EdgeAndCircleContact.Destroy = function (contact, allocator)\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixtureA\r\n * @param {box2d.b2Fixture} fixtureB\r\n */\r\nbox2d.b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB)\r\n{\r\n\tgoog.base(this, 'Reset', fixtureA, indexA, fixtureB, indexB);\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureA.GetType() === box2d.b2ShapeType.e_edgeShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixtureB.GetType() === box2d.b2ShapeType.e_circleShape); }\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Manifold} manifold \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2Transform} xfB \r\n */\r\nbox2d.b2EdgeAndCircleContact.prototype.Evaluate = function (manifold, xfA, xfB)\r\n{\r\n\tvar shapeA = this.m_fixtureA.GetShape();\r\n\tvar shapeB = this.m_fixtureB.GetShape();\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeA instanceof box2d.b2EdgeShape); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(shapeB instanceof box2d.b2CircleShape); }\r\n\tbox2d.b2CollideEdgeAndCircle(\r\n\t\tmanifold, \r\n\t\t(shapeA instanceof box2d.b2EdgeShape)? shapeA : null, xfA, \r\n\t\t(shapeB instanceof box2d.b2CircleShape)? shapeB : null, xfB);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2ContactSolver');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2Collision');\r\ngoog.require('box2d.b2CircleContact');\r\ngoog.require('box2d.b2PolygonAndCircleContact');\r\ngoog.require('box2d.b2PolygonContact');\r\ngoog.require('box2d.b2EdgeAndCircleContact');\r\ngoog.require('box2d.b2EdgeAndPolygonContact');\r\ngoog.require('box2d.b2ChainAndCircleContact');\r\ngoog.require('box2d.b2ChainAndPolygonContact');\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2VelocityConstraintPoint = function ()\r\n{\r\n\tthis.rA = new box2d.b2Vec2();\r\n\tthis.rB = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2VelocityConstraintPoint.prototype.rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2VelocityConstraintPoint.prototype.rB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2VelocityConstraintPoint.prototype.normalImpulse = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2VelocityConstraintPoint.prototype.tangentImpulse = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2VelocityConstraintPoint.prototype.normalMass = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2VelocityConstraintPoint.prototype.tangentMass = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2VelocityConstraintPoint.prototype.velocityBias = 0;\r\n\r\n/**\r\n * @export \r\n * @return {Array.<box2d.b2VelocityConstraintPoint>}\r\n * @param {number} length \r\n */\r\nbox2d.b2VelocityConstraintPoint.MakeArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return new box2d.b2VelocityConstraintPoint(); });\r\n}\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ContactVelocityConstraint = function ()\r\n{\r\n\tthis.points = box2d.b2VelocityConstraintPoint.MakeArray(box2d.b2_maxManifoldPoints);\r\n\tthis.normal = new box2d.b2Vec2();\r\n\tthis.tangent = new box2d.b2Vec2();\r\n\tthis.normalMass = new box2d.b2Mat22();\r\n\tthis.K = new box2d.b2Mat22();\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2VelocityConstraintPoint>}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.points = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.normal = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.tangent = null; // compute from normal\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.normalMass = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.K = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.indexB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.invIB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.friction = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.restitution = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.tangentSpeed = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.pointCount = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactVelocityConstraint.prototype.contactIndex = 0;\r\n\r\n/**\r\n * @export \r\n * @return {Array.<box2d.b2ContactVelocityConstraint>}\r\n * @param {number} length \r\n */\r\nbox2d.b2ContactVelocityConstraint.MakeArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return new box2d.b2ContactVelocityConstraint(); } );\r\n}\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ContactPositionConstraint = function ()\r\n{\r\n\tthis.localPoints = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints);\r\n\tthis.localNormal = new box2d.b2Vec2();\r\n\tthis.localPoint = new box2d.b2Vec2();\r\n\tthis.localCenterA = new box2d.b2Vec2();\r\n\tthis.localCenterB = new box2d.b2Vec2();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.localPoints = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.localNormal = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.localPoint = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.indexB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.invMassB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.invIB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2ManifoldType}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.type = box2d.b2ManifoldType.e_unknown;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.radiusA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.radiusB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactPositionConstraint.prototype.pointCount = 0;\r\n\r\n/**\r\n * @export \r\n * @return {Array.<box2d.b2ContactPositionConstraint>}\r\n * @param {number} length \r\n */\r\nbox2d.b2ContactPositionConstraint.MakeArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return new box2d.b2ContactPositionConstraint(); } );\r\n}\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ContactSolverDef = function ()\r\n{\r\n\tthis.step = new box2d.b2TimeStep();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2TimeStep}\r\n */\r\nbox2d.b2ContactSolverDef.prototype.step = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Contact>}\r\n */\r\nbox2d.b2ContactSolverDef.prototype.contacts = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactSolverDef.prototype.count = 0;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Position>}\r\n */\r\nbox2d.b2ContactSolverDef.prototype.positions = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Velocity>}\r\n */\r\nbox2d.b2ContactSolverDef.prototype.velocities = null;\r\n/**\r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2ContactSolverDef.prototype.allocator = null;\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ContactSolver = function ()\r\n{\r\n\tthis.m_step = new box2d.b2TimeStep();\r\n\tthis.m_positionConstraints = box2d.b2ContactPositionConstraint.MakeArray(1024); // TODO: b2Settings\r\n\tthis.m_velocityConstraints = box2d.b2ContactVelocityConstraint.MakeArray(1024); // TODO: b2Settings\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2TimeStep}\r\n */\r\nbox2d.b2ContactSolver.prototype.m_step = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Position>}\r\n */\r\nbox2d.b2ContactSolver.prototype.m_positions = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Velocity>}\r\n */\r\nbox2d.b2ContactSolver.prototype.m_velocities = null;\r\n/**\r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2ContactSolver.prototype.m_allocator = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2ContactPositionConstraint>}\r\n */\r\nbox2d.b2ContactSolver.prototype.m_positionConstraints = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2ContactVelocityConstraint>}\r\n */\r\nbox2d.b2ContactSolver.prototype.m_velocityConstraints = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Contact>}\r\n */\r\nbox2d.b2ContactSolver.prototype.m_contacts = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactSolver.prototype.m_count = 0;\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2ContactSolver} \r\n * @param {box2d.b2ContactSolverDef} def \r\n */\r\nbox2d.b2ContactSolver.prototype.Initialize = function (def)\r\n{\r\n\tthis.m_step.Copy(def.step);\r\n\tthis.m_allocator = def.allocator;\r\n\tthis.m_count = def.count;\r\n\t// TODO:\r\n\tif (this.m_positionConstraints.length < this.m_count)\r\n\t{\r\n\t\tvar new_length = box2d.b2Max(this.m_positionConstraints.length * 2, this.m_count);\r\n\r\n\t\tif (box2d.DEBUG)\r\n\t\t{\r\n\t\t\twindow.console.log(\"box2d.b2ContactSolver.m_positionConstraints: \" + new_length);\r\n\t\t}\r\n\r\n\t\twhile (this.m_positionConstraints.length < new_length)\r\n\t\t{\r\n\t\t\tthis.m_positionConstraints[this.m_positionConstraints.length] = new box2d.b2ContactPositionConstraint();\r\n\t\t}\r\n\t}\r\n\t// TODO:\r\n\tif (this.m_velocityConstraints.length < this.m_count)\r\n\t{\r\n\t\tvar new_length = box2d.b2Max(this.m_velocityConstraints.length * 2, this.m_count);\r\n\r\n\t\tif (box2d.DEBUG)\r\n\t\t{\r\n\t\t\twindow.console.log(\"box2d.b2ContactSolver.m_velocityConstraints: \" + new_length);\r\n\t\t}\r\n\r\n\t\twhile (this.m_velocityConstraints.length < new_length)\r\n\t\t{\r\n\t\t\tthis.m_velocityConstraints[this.m_velocityConstraints.length] = new box2d.b2ContactVelocityConstraint();\r\n\t\t}\r\n\t}\r\n\tthis.m_positions = def.positions;\r\n\tthis.m_velocities = def.velocities;\r\n\tthis.m_contacts = def.contacts;\r\n\r\n\t/** @type {number} */ var i;\r\n\t/** @type {number} */ var ict;\r\n\t/** @type {number} */ var j;\r\n\t/** @type {number} */ var jct;\r\n\r\n\t/** @type {box2d.b2Contact} */ var contact;\r\n\r\n\t/** @type {box2d.b2Fixture} */ var fixtureA;\r\n\t/** @type {box2d.b2Fixture} */ var fixtureB;\r\n\t/** @type {box2d.b2Shape} */ var shapeA;\r\n\t/** @type {box2d.b2Shape} */ var shapeB;\r\n\t/** @type {number} */ var radiusA;\r\n\t/** @type {number} */ var radiusB;\r\n\t/** @type {box2d.b2Body} */ var bodyA;\r\n\t/** @type {box2d.b2Body} */ var bodyB;\r\n\t/** @type {box2d.b2Manifold} */ var manifold;\r\n\r\n\t/** @type {number} */ var pointCount;\r\n\r\n\t/** @type {box2d.b2ContactVelocityConstraint} */ var vc;\r\n\t/** @type {box2d.b2ContactPositionConstraint} */ var pc;\r\n\r\n\t/** @type {box2d.b2ManifoldPoint} */ var cp;\r\n\t/** @type {box2d.b2VelocityConstraintPoint} */ var vcp;\r\n\r\n\t// Initialize position independent portions of the constraints.\r\n\tfor (i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tcontact = this.m_contacts[i];\r\n\r\n\t\tfixtureA = contact.m_fixtureA;\r\n\t\tfixtureB = contact.m_fixtureB;\r\n\t\tshapeA = fixtureA.GetShape();\r\n\t\tshapeB = fixtureB.GetShape();\r\n\t\tradiusA = shapeA.m_radius;\r\n\t\tradiusB = shapeB.m_radius;\r\n\t\tbodyA = fixtureA.GetBody();\r\n\t\tbodyB = fixtureB.GetBody();\r\n\t\tmanifold = contact.GetManifold();\r\n\r\n\t\tpointCount = manifold.pointCount;\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(pointCount > 0); }\r\n\r\n\t\tvc = this.m_velocityConstraints[i];\r\n\t\tvc.friction = contact.m_friction;\r\n\t\tvc.restitution = contact.m_restitution;\r\n\t\tvc.tangentSpeed = contact.m_tangentSpeed;\r\n\t\tvc.indexA = bodyA.m_islandIndex;\r\n\t\tvc.indexB = bodyB.m_islandIndex;\r\n\t\tvc.invMassA = bodyA.m_invMass;\r\n\t\tvc.invMassB = bodyB.m_invMass;\r\n\t\tvc.invIA = bodyA.m_invI;\r\n\t\tvc.invIB = bodyB.m_invI;\r\n\t\tvc.contactIndex = i;\r\n\t\tvc.pointCount = pointCount;\r\n\t\tvc.K.SetZero();\r\n\t\tvc.normalMass.SetZero();\r\n\r\n\t\tpc = this.m_positionConstraints[i];\r\n\t\tpc.indexA = bodyA.m_islandIndex;\r\n\t\tpc.indexB = bodyB.m_islandIndex;\r\n\t\tpc.invMassA = bodyA.m_invMass;\r\n\t\tpc.invMassB = bodyB.m_invMass;\r\n\t\tpc.localCenterA.Copy(bodyA.m_sweep.localCenter);\r\n\t\tpc.localCenterB.Copy(bodyB.m_sweep.localCenter);\r\n\t\tpc.invIA = bodyA.m_invI;\r\n\t\tpc.invIB = bodyB.m_invI;\r\n\t\tpc.localNormal.Copy(manifold.localNormal);\r\n\t\tpc.localPoint.Copy(manifold.localPoint);\r\n\t\tpc.pointCount = pointCount;\r\n\t\tpc.radiusA = radiusA;\r\n\t\tpc.radiusB = radiusB;\r\n\t\tpc.type = manifold.type;\r\n\r\n\t\tfor (j = 0, jct = pointCount; j < jct; ++j)\r\n\t\t{\r\n\t\t\tcp = manifold.points[j];\r\n\t\t\tvcp = vc.points[j];\r\n\t\r\n\t\t\tif (this.m_step.warmStarting)\r\n\t\t\t{\r\n\t\t\t\tvcp.normalImpulse = this.m_step.dtRatio * cp.normalImpulse;\r\n\t\t\t\tvcp.tangentImpulse = this.m_step.dtRatio * cp.tangentImpulse;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvcp.normalImpulse = 0;\r\n\t\t\t\tvcp.tangentImpulse = 0;\r\n\t\t\t}\r\n\r\n\t\t\tvcp.rA.SetZero();\r\n\t\t\tvcp.rB.SetZero();\r\n\t\t\tvcp.normalMass = 0;\r\n\t\t\tvcp.tangentMass = 0;\r\n\t\t\tvcp.velocityBias = 0;\r\n\r\n\t\t\tpc.localPoints[j].Copy(cp.localPoint);\r\n\t\t}\r\n\t}\r\n\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * Initialize position dependent portions of the velocity \r\n * constraints. \r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2ContactSolver.prototype.InitializeVelocityConstraints = function ()\r\n{\r\n\t/** @type {number} */ var i;\r\n\t/** @type {number} */ var ict;\r\n\t/** @type {number} */ var j;\r\n\t/** @type {number} */ var jct;\r\n\r\n\t/** @type {box2d.b2ContactVelocityConstraint} */ var vc;\r\n\t/** @type {box2d.b2ContactPositionConstraint} */ var pc;\r\n\r\n\t/** @type {number} */ var radiusA;\r\n\t/** @type {number} */ var radiusB;\r\n\t/** @type {box2d.b2Manifold} */ var manifold;\r\n\r\n\t/** @type {number} */ var indexA;\r\n\t/** @type {number} */ var indexB;\r\n\r\n\t/** @type {number} */ var mA;\r\n\t/** @type {number} */ var mB;\r\n\t/** @type {number} */ var iA;\r\n\t/** @type {number} */ var iB;\r\n\t/** @type {box2d.b2Vec2} */ var localCenterA;\r\n\t/** @type {box2d.b2Vec2} */ var localCenterB;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var cA;\r\n\t/** @type {number} */ var aA;\r\n\t/** @type {box2d.b2Vec2} */ var vA;\r\n\t/** @type {number} */ var wA;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var cB;\r\n\t/** @type {number} */ var aB;\r\n\t/** @type {box2d.b2Vec2} */ var vB;\r\n\t/** @type {number} */ var wB;\r\n\r\n\t/** @type {box2d.b2Transform} */ var xfA = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA;\r\n\t/** @type {box2d.b2Transform} */ var xfB = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB;\r\n\r\n\t/** @type {box2d.b2WorldManifold} */ var worldManifold = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold;\r\n\r\n\t/** @type {number} */ var pointCount;\r\n\r\n\t/** @type {box2d.b2VelocityConstraintPoint} */ var vcp;\r\n\r\n\t/** @type {number} */ var rnA;\r\n\t/** @type {number} */ var rnB;\r\n\r\n\t/** @type {number} */ var kNormal;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var tangent;\r\n\r\n\t/** @type {number} */ var rtA;\r\n\t/** @type {number} */ var rtB;\r\n\r\n\t/** @type {number} */ var kTangent;\r\n\r\n\t/** @type {number} */ var vRel;\r\n\r\n\t/** @type {box2d.b2VelocityConstraintPoint} */ var vcp1;\r\n\t/** @type {box2d.b2VelocityConstraintPoint} */ var vcp2;\r\n\r\n\t/** @type {number} */ var rn1A;\r\n\t/** @type {number} */ var rn1B;\r\n\t/** @type {number} */ var rn2A;\r\n\t/** @type {number} */ var rn2B;\r\n\r\n\t/** @type {number} */ var k11;\r\n\t/** @type {number} */ var k22;\r\n\t/** @type {number} */ var k12;\r\n\r\n\t/** @type {number} */ var k_maxConditionNumber = 1000;\r\n\r\n\tfor (i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tvc = this.m_velocityConstraints[i];\r\n\t\tpc = this.m_positionConstraints[i];\r\n\r\n\t\tradiusA = pc.radiusA;\r\n\t\tradiusB = pc.radiusB;\r\n\t\tmanifold = this.m_contacts[vc.contactIndex].GetManifold();\r\n\r\n\t\tindexA = vc.indexA;\r\n\t\tindexB = vc.indexB;\r\n\r\n\t\tmA = vc.invMassA;\r\n\t\tmB = vc.invMassB;\r\n\t\tiA = vc.invIA;\r\n\t\tiB = vc.invIB;\r\n\t\tlocalCenterA = pc.localCenterA;\r\n\t\tlocalCenterB = pc.localCenterB;\r\n\r\n\t\tcA = this.m_positions[indexA].c;\r\n\t\taA = this.m_positions[indexA].a;\r\n\t\tvA = this.m_velocities[indexA].v;\r\n\t\twA = this.m_velocities[indexA].w;\r\n\r\n\t\tcB = this.m_positions[indexB].c;\r\n\t\taB = this.m_positions[indexB].a;\r\n\t\tvB = this.m_velocities[indexB].v;\r\n\t\twB = this.m_velocities[indexB].w;\r\n\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(manifold.pointCount > 0); }\r\n\r\n\t\txfA.q.SetAngleRadians(aA);\r\n\t\txfB.q.SetAngleRadians(aB);\r\n\t\tbox2d.b2SubVV(cA, box2d.b2MulRV(xfA.q, localCenterA, box2d.b2Vec2.s_t0), xfA.p);\r\n\t\tbox2d.b2SubVV(cB, box2d.b2MulRV(xfB.q, localCenterB, box2d.b2Vec2.s_t0), xfB.p);\r\n\r\n\t\tworldManifold.Initialize(manifold, xfA, radiusA, xfB, radiusB);\r\n\r\n\t\tvc.normal.Copy(worldManifold.normal);\r\n\t\tbox2d.b2CrossVOne(vc.normal, vc.tangent); // compute from normal\r\n\r\n\t\tpointCount = vc.pointCount;\r\n\t\tfor (j = 0, jct = pointCount; j < jct; ++j)\r\n\t\t{\r\n\t\t\tvcp = vc.points[j];\r\n\r\n//\t\t\tvcp->rA = worldManifold.points[j] - cA;\r\n\t\t\tbox2d.b2SubVV(worldManifold.points[j], cA, vcp.rA);\r\n//\t\t\tvcp->rB = worldManifold.points[j] - cB;\r\n\t\t\tbox2d.b2SubVV(worldManifold.points[j], cB, vcp.rB);\r\n\r\n\t\t\trnA = box2d.b2CrossVV(vcp.rA, vc.normal);\r\n\t\t\trnB = box2d.b2CrossVV(vcp.rB, vc.normal);\r\n\r\n\t\t\tkNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n\r\n\t\t\tvcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;\r\n\r\n//\t\t\tb2Vec2 tangent = b2Cross(vc->normal, 1.0f);\r\n\t\t\ttangent = vc.tangent; // precomputed from normal\r\n\r\n\t\t\trtA = box2d.b2CrossVV(vcp.rA, tangent);\r\n\t\t\trtB = box2d.b2CrossVV(vcp.rB, tangent);\r\n\r\n\t\t\tkTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\r\n\r\n\t\t\tvcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;\r\n\r\n\t\t\t// Setup a velocity bias for restitution.\r\n\t\t\tvcp.velocityBias = 0;\r\n//\t\t\tfloat32 vRel = b2Dot(vc->normal, vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA));\r\n\t\t\tvRel = box2d.b2DotVV(\r\n\t\t\t\tvc.normal, \r\n\t\t\t\tbox2d.b2SubVV(\r\n\t\t\t\t\tbox2d.b2AddVCrossSV(vB, wB, vcp.rB, box2d.b2Vec2.s_t0),\r\n\t\t\t\t\tbox2d.b2AddVCrossSV(vA, wA, vcp.rA, box2d.b2Vec2.s_t1), \r\n\t\t\t\t\tbox2d.b2Vec2.s_t0));\r\n\t\t\tif (vRel < (-box2d.b2_velocityThreshold))\r\n\t\t\t{\r\n\t\t\t\tvcp.velocityBias += (-vc.restitution * vRel);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If we have two points, then prepare the block solver.\r\n\t\tif (vc.pointCount === 2)\r\n\t\t{\r\n\t\t\tvcp1 = vc.points[0];\r\n\t\t\tvcp2 = vc.points[1];\r\n\r\n\t\t\trn1A = box2d.b2CrossVV(vcp1.rA, vc.normal);\r\n\t\t\trn1B = box2d.b2CrossVV(vcp1.rB, vc.normal);\r\n\t\t\trn2A = box2d.b2CrossVV(vcp2.rA, vc.normal);\r\n\t\t\trn2B = box2d.b2CrossVV(vcp2.rB, vc.normal);\r\n\r\n\t\t\tk11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\r\n\t\t\tk22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\r\n\t\t\tk12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\r\n\r\n\t\t\t// Ensure a reasonable condition number.\r\n//\t\t\tfloat32 k_maxConditionNumber = 1000.0f;\r\n\t\t\tif (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))\r\n\t\t\t{\r\n\t\t\t\t// K is safe to invert.\r\n\t\t\t\tvc.K.ex.SetXY(k11, k12);\r\n\t\t\t\tvc.K.ey.SetXY(k12, k22);\r\n\t\t\t\tvc.K.GetInverse(vc.normalMass);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// The constraints are redundant, just use one.\r\n\t\t\t\t// TODO_ERIN use deepest?\r\n\t\t\t\tvc.pointCount = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nbox2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA = new box2d.b2Transform();\r\nbox2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB = new box2d.b2Transform();\r\nbox2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold = new box2d.b2WorldManifold();\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2ContactSolver.prototype.WarmStart = function ()\r\n{\r\n\t/** @type {number} */ var i;\r\n\t/** @type {number} */ var ict;\r\n\t/** @type {number} */ var j;\r\n\t/** @type {number} */ var jct;\r\n\r\n\t/** @type {box2d.b2ContactVelocityConstraint} */ var vc;\r\n\r\n\t/** @type {number} */ var indexA;\r\n\t/** @type {number} */ var indexB;\r\n\t/** @type {number} */ var mA;\r\n\t/** @type {number} */ var iA;\r\n\t/** @type {number} */ var mB;\r\n\t/** @type {number} */ var iB;\r\n\t/** @type {number} */ var pointCount;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var vA;\r\n\t/** @type {number} */ var wA;\r\n\t/** @type {box2d.b2Vec2} */ var vB;\r\n\t/** @type {number} */ var wB;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var normal;\r\n\t/** @type {box2d.b2Vec2} */ var tangent;\r\n\r\n\t/** @type {box2d.b2VelocityConstraintPoint} */ var vcp;\r\n\t/** @type {box2d.b2Vec2} */ var P = box2d.b2ContactSolver.prototype.WarmStart.s_P;\r\n\r\n\t// Warm start.\r\n\tfor (i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tvc = this.m_velocityConstraints[i];\r\n\r\n\t\tindexA = vc.indexA;\r\n\t\tindexB = vc.indexB;\r\n\t\tmA = vc.invMassA;\r\n\t\tiA = vc.invIA;\r\n\t\tmB = vc.invMassB;\r\n\t\tiB = vc.invIB;\r\n\t\tpointCount = vc.pointCount;\r\n\r\n\t\tvA = this.m_velocities[indexA].v;\r\n\t\twA = this.m_velocities[indexA].w;\r\n\t\tvB = this.m_velocities[indexB].v;\r\n\t\twB = this.m_velocities[indexB].w;\r\n\r\n\t\tnormal = vc.normal;\r\n//\t\tb2Vec2 tangent = b2Cross(normal, 1.0f);\r\n\t\ttangent = vc.tangent; // precomputed from normal\r\n\r\n\t\tfor (j = 0, jct = pointCount; j < jct; ++j)\r\n\t\t{\r\n\t\t\tvcp = vc.points[j];\r\n//\t\t\tb2Vec2 P = vcp->normalImpulse * normal + vcp->tangentImpulse * tangent;\r\n\t\t\tbox2d.b2AddVV(\r\n\t\t\t\tbox2d.b2MulSV(vcp.normalImpulse, normal, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2MulSV(vcp.tangentImpulse, tangent, box2d.b2Vec2.s_t1), \r\n\t\t\t\tP);\r\n//\t\t\twA -= iA * b2Cross(vcp->rA, P);\r\n\t\t\twA -= iA * box2d.b2CrossVV(vcp.rA, P);\r\n//\t\t\tvA -= mA * P;\r\n\t\t\tvA.SelfMulSub(mA, P);\r\n//\t\t\twB += iB * b2Cross(vcp->rB, P);\r\n\t\t\twB += iB * box2d.b2CrossVV(vcp.rB, P);\r\n//\t\t\tvB += mB * P;\r\n\t\t\tvB.SelfMulAdd(mB, P);\r\n\t\t}\r\n\r\n//\t\tthis.m_velocities[indexA].v = vA;\r\n\t\tthis.m_velocities[indexA].w = wA;\r\n//\t\tthis.m_velocities[indexB].v = vB;\r\n\t\tthis.m_velocities[indexB].w = wB;\r\n\t}\r\n}\r\nbox2d.b2ContactSolver.prototype.WarmStart.s_P = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints = function ()\r\n{\r\n\t/** @type {number} */ var i;\r\n\t/** @type {number} */ var ict;\r\n\t/** @type {number} */ var j;\r\n\t/** @type {number} */ var jct;\r\n\r\n\t/** @type {box2d.b2ContactVelocityConstraint} */ var vc;\r\n\t/** @type {number} */ var indexA;\r\n\t/** @type {number} */ var indexB;\r\n\t/** @type {number} */ var mA;\r\n\t/** @type {number} */ var iA;\r\n\t/** @type {number} */ var mB;\r\n\t/** @type {number} */ var iB;\r\n\t/** @type {number} */ var pointCount;\r\n\t/** @type {box2d.b2Vec2} */ var vA;\r\n\t/** @type {number} */ var wA;\r\n\t/** @type {box2d.b2Vec2} */ var vB;\r\n\t/** @type {number} */ var wB;\r\n\t/** @type {box2d.b2Vec2} */ var normal;\r\n\t/** @type {box2d.b2Vec2} */ var tangent;\r\n\t/** @type {number} */ var friction;\r\n\r\n\t/** @type {box2d.b2VelocityConstraintPoint} */ var vcp;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var dv = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv;\r\n\t/** @type {box2d.b2Vec2} */ var dv1 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1;\r\n\t/** @type {box2d.b2Vec2} */ var dv2 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2;\r\n\r\n\t/** @type {number} */ var vt;\r\n\t/** @type {number} */ var vn;\r\n\t/** @type {number} */ var lambda;\r\n\r\n\t/** @type {number} */ var maxFriction;\r\n\t/** @type {number} */ var newImpulse;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var P = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P;\r\n\r\n\t/** @type {box2d.b2VelocityConstraintPoint} */ var cp1;\r\n\t/** @type {box2d.b2VelocityConstraintPoint} */ var cp2;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var a = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a;\r\n\t/** @type {box2d.b2Vec2} */ var b = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b;\r\n\t/** @type {number} */ var vn1;\r\n\t/** @type {number} */ var vn2;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var x = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x;\r\n\t/** @type {box2d.b2Vec2} */ var d = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d;\r\n\t/** @type {box2d.b2Vec2} */ var P1 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1;\r\n\t/** @type {box2d.b2Vec2} */ var P2 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2;\r\n\t/** @type {box2d.b2Vec2} */ var P1P2 = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2;\r\n\r\n\tfor (i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tvc = this.m_velocityConstraints[i];\r\n\r\n\t\tindexA = vc.indexA;\r\n\t\tindexB = vc.indexB;\r\n\t\tmA = vc.invMassA;\r\n\t\tiA = vc.invIA;\r\n\t\tmB = vc.invMassB;\r\n\t\tiB = vc.invIB;\r\n\t\tpointCount = vc.pointCount;\r\n\r\n\t\tvA = this.m_velocities[indexA].v;\r\n\t\twA = this.m_velocities[indexA].w;\r\n\t\tvB = this.m_velocities[indexB].v;\r\n\t\twB = this.m_velocities[indexB].w;\r\n\r\n//\t\tb2Vec2 normal = vc->normal;\r\n\t\tnormal = vc.normal;\r\n//\t\tb2Vec2 tangent = b2Cross(normal, 1.0f);\r\n\t\ttangent = vc.tangent; // precomputed from normal\r\n\t\tfriction = vc.friction;\r\n\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(pointCount === 1 || pointCount === 2); }\r\n\r\n\t\t// Solve tangent constraints first because non-penetration is more important\r\n\t\t// than friction.\r\n\t\tfor (j = 0, jct = pointCount; j < jct; ++j)\r\n\t\t{\r\n\t\t\tvcp = vc.points[j];\r\n\r\n\t\t\t// Relative velocity at contact\r\n//\t\t\tb2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);\r\n\t\t\tbox2d.b2SubVV(\r\n\t\t\t\tbox2d.b2AddVCrossSV(vB, wB, vcp.rB, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2AddVCrossSV(vA, wA, vcp.rA, box2d.b2Vec2.s_t1), \r\n\t\t\t\tdv);\r\n\r\n\t\t\t// Compute tangent force\r\n//\t\t\tfloat32 vt = b2Dot(dv, tangent) - vc->tangentSpeed;\r\n\t\t\tvt = box2d.b2DotVV(dv, tangent) - vc.tangentSpeed;\r\n\t\t\tlambda = vcp.tangentMass * (-vt);\r\n\r\n\t\t\t// box2d.b2Clamp the accumulated force\r\n\t\t\tmaxFriction = friction * vcp.normalImpulse;\r\n\t\t\tnewImpulse = box2d.b2Clamp(vcp.tangentImpulse + lambda, (-maxFriction), maxFriction);\r\n\t\t\tlambda = newImpulse - vcp.tangentImpulse;\r\n\t\t\tvcp.tangentImpulse = newImpulse;\r\n\r\n\t\t\t// Apply contact impulse\r\n//\t\t\tb2Vec2 P = lambda * tangent;\r\n\t\t\tbox2d.b2MulSV(lambda, tangent, P);\r\n\r\n//\t\t\tvA -= mA * P;\r\n\t\t\tvA.SelfMulSub(mA, P);\r\n//\t\t\twA -= iA * b2Cross(vcp->rA, P);\r\n\t\t\twA -= iA * box2d.b2CrossVV(vcp.rA, P);\r\n\r\n//\t\t\tvB += mB * P;\r\n\t\t\tvB.SelfMulAdd(mB, P);\r\n//\t\t\twB += iB * b2Cross(vcp->rB, P);\r\n\t\t\twB += iB * box2d.b2CrossVV(vcp.rB, P);\r\n\t\t}\r\n\r\n\t\t// Solve normal constraints\r\n\t\tif (vc.pointCount === 1)\r\n\t\t{\r\n\t\t\tvcp = vc.points[0];\r\n\r\n\t\t\t// Relative velocity at contact\r\n//\t\t\tb2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);\r\n\t\t\tbox2d.b2SubVV(\r\n\t\t\t\tbox2d.b2AddVCrossSV(vB, wB, vcp.rB, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2AddVCrossSV(vA, wA, vcp.rA, box2d.b2Vec2.s_t1), \r\n\t\t\t\tdv);\r\n\r\n\t\t\t// Compute normal impulse\r\n//\t\t\tfloat32 vn = b2Dot(dv, normal);\r\n\t\t\tvn = box2d.b2DotVV(dv, normal);\r\n\t\t\tlambda = (-vcp.normalMass * (vn - vcp.velocityBias));\r\n\r\n\t\t\t// box2d.b2Clamp the accumulated impulse\r\n//\t\t\tfloat32 newImpulse = box2d.b2Max(vcp->normalImpulse + lambda, 0.0f);\r\n\t\t\tnewImpulse = box2d.b2Max(vcp.normalImpulse + lambda, 0);\r\n\t\t\tlambda = newImpulse - vcp.normalImpulse;\r\n\t\t\tvcp.normalImpulse = newImpulse;\r\n\r\n\t\t\t// Apply contact impulse\r\n//\t\t\tb2Vec2 P = lambda * normal;\r\n\t\t\tbox2d.b2MulSV(lambda, normal, P);\r\n//\t\t\tvA -= mA * P;\r\n\t\t\tvA.SelfMulSub(mA, P);\r\n//\t\t\twA -= iA * b2Cross(vcp->rA, P);\r\n\t\t\twA -= iA * box2d.b2CrossVV(vcp.rA, P);\r\n\r\n//\t\t\tvB += mB * P;\r\n\t\t\tvB.SelfMulAdd(mB, P);\r\n//\t\t\twB += iB * b2Cross(vcp->rB, P);\r\n\t\t\twB += iB * box2d.b2CrossVV(vcp.rB, P);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).\r\n\t\t\t// Build the mini LCP for this contact patch\r\n\t\t\t//\r\n\t\t\t// vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2\r\n\t\t\t//\r\n\t\t\t// A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\r\n\t\t\t// b = vn0 - velocityBias\r\n\t\t\t//\r\n\t\t\t// The system is solved using the \"Total enumeration method\" (s. Murty). The complementary constraint vn_i * x_i\r\n\t\t\t// implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D contact problem the cases\r\n\t\t\t// vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and vn1 = 0 need to be tested. The first valid\r\n\t\t\t// solution that satisfies the problem is chosen.\r\n\t\t\t// \r\n\t\t\t// In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires\r\n\t\t\t// that the accumulated impulse is clamped and not the incremental impulse) we change the impulse variable (x_i).\r\n\t\t\t//\r\n\t\t\t// Substitute:\r\n\t\t\t// \r\n\t\t\t// x = a + d\r\n\t\t\t// \r\n\t\t\t// a := old total impulse\r\n\t\t\t// x := new total impulse\r\n\t\t\t// d := incremental impulse \r\n\t\t\t//\r\n\t\t\t// For the current iteration we extend the formula for the incremental impulse\r\n\t\t\t// to compute the new total impulse:\r\n\t\t\t//\r\n\t\t\t// vn = A * d + b\r\n\t\t\t//    = A * (x - a) + b\r\n\t\t\t//    = A * x + b - A * a\r\n\t\t\t//    = A * x + b'\r\n\t\t\t// b' = b - A * a;\r\n\r\n\t\t\tcp1 = vc.points[0];\r\n\t\t\tcp2 = vc.points[1];\r\n\r\n//\t\t\tb2Vec2 a(cp1->normalImpulse, cp2->normalImpulse);\r\n\t\t\ta.SetXY(cp1.normalImpulse, cp2.normalImpulse);\r\n\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(a.x >= 0 && a.y >= 0); }\r\n\r\n\t\t\t// Relative velocity at contact\r\n//\t\t\tb2Vec2 dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);\r\n\t\t\tbox2d.b2SubVV(\r\n\t\t\t\tbox2d.b2AddVCrossSV(vB, wB, cp1.rB, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2AddVCrossSV(vA, wA, cp1.rA, box2d.b2Vec2.s_t1), \r\n\t\t\t\tdv1);\r\n//\t\t\tb2Vec2 dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);\r\n\t\t\tbox2d.b2SubVV(\r\n\t\t\t\tbox2d.b2AddVCrossSV(vB, wB, cp2.rB, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2AddVCrossSV(vA, wA, cp2.rA, box2d.b2Vec2.s_t1), \r\n\t\t\t\tdv2);\r\n\r\n\t\t\t// Compute normal velocity\r\n//\t\t\tfloat32 vn1 = b2Dot(dv1, normal);\r\n\t\t\tvn1 = box2d.b2DotVV(dv1, normal);\r\n//\t\t\tfloat32 vn2 = b2Dot(dv2, normal);\r\n\t\t\tvn2 = box2d.b2DotVV(dv2, normal);\r\n\r\n//\t\t\tb2Vec2 b;\r\n\t\t\tb.x = vn1 - cp1.velocityBias;\r\n\t\t\tb.y = vn2 - cp2.velocityBias;\r\n\r\n\t\t\t// Compute b'\r\n//\t\t\tb -= b2Mul(vc->K, a);\r\n\t\t\tb.SelfSub(box2d.b2MulMV(vc.K, a, box2d.b2Vec2.s_t0));\r\n\r\n/*\r\n#if B2_DEBUG_SOLVER === 1\r\n\t\t\tvar k_errorTol = 0.001;\r\n#endif\r\n*/\r\n\r\n\t\t\tfor (;;)\r\n\t\t\t{\r\n\t\t\t\t//\r\n\t\t\t\t// Case 1: vn = 0\r\n\t\t\t\t//\r\n\t\t\t\t// 0 = A * x + b'\r\n\t\t\t\t//\r\n\t\t\t\t// Solve for x:\r\n\t\t\t\t//\r\n\t\t\t\t// x = - inv(A) * b'\r\n\t\t\t\t//\r\n//\t\t\t\tb2Vec2 x = - b2Mul(vc->normalMass, b);\r\n\t\t\t\tbox2d.b2MulMV(vc.normalMass, b, x).SelfNeg();\r\n\r\n\t\t\t\tif (x.x >= 0 && x.y >= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Get the incremental impulse\r\n//\t\t\t\t\tb2Vec2 d = x - a;\r\n\t\t\t\t\tbox2d.b2SubVV(x, a, d);\r\n\r\n\t\t\t\t\t// Apply incremental impulse\r\n//\t\t\t\t\tb2Vec2 P1 = d.x * normal;\r\n\t\t\t\t\tbox2d.b2MulSV(d.x, normal, P1);\r\n//\t\t\t\t\tb2Vec2 P2 = d.y * normal;\r\n\t\t\t\t\tbox2d.b2MulSV(d.y, normal, P2);\r\n\t\t\t\t\tbox2d.b2AddVV(P1, P2, P1P2);\r\n//\t\t\t\t\tvA -= mA * (P1 + P2);\r\n\t\t\t\t\tvA.SelfMulSub(mA, P1P2);\r\n//\t\t\t\t\twA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n\t\t\t\t\twA -= iA * (box2d.b2CrossVV(cp1.rA, P1) + box2d.b2CrossVV(cp2.rA, P2));\r\n\r\n//\t\t\t\t\tvB += mB * (P1 + P2);\r\n\t\t\t\t\tvB.SelfMulAdd(mB, P1P2);\r\n//\t\t\t\t\twB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n\t\t\t\t\twB += iB * (box2d.b2CrossVV(cp1.rB, P1) + box2d.b2CrossVV(cp2.rB, P2));\r\n\r\n\t\t\t\t\t// Accumulate\r\n\t\t\t\t\tcp1.normalImpulse = x.x;\r\n\t\t\t\t\tcp2.normalImpulse = x.y;\r\n\r\n/*\r\n#if B2_DEBUG_SOLVER === 1\r\n\t\t\t\t\t// Postconditions\r\n\t\t\t\t\tdv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);\r\n\t\t\t\t\tdv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);\r\n\r\n\t\t\t\t\t// Compute normal velocity\r\n\t\t\t\t\tvn1 = b2Dot(dv1, normal);\r\n\t\t\t\t\tvn2 = b2Dot(dv2, normal);\r\n\r\n\t\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2Abs(vn1 - cp1->velocityBias) < k_errorTol); }\r\n\t\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2Abs(vn2 - cp2->velocityBias) < k_errorTol); }\r\n#endif\r\n*/\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//\r\n\t\t\t\t// Case 2: vn1 = 0 and x2 = 0\r\n\t\t\t\t//\r\n\t\t\t\t//   0 = a11 * x1 + a12 * 0 + b1' \r\n\t\t\t\t// vn2 = a21 * x1 + a22 * 0 + b2'\r\n\t\t\t\t//\r\n\t\t\t\tx.x = (-cp1.normalMass * b.x);\r\n\t\t\t\tx.y = 0;\r\n\t\t\t\tvn1 = 0;\r\n\t\t\t\tvn2 = vc.K.ex.y * x.x + b.y;\r\n\r\n\t\t\t\tif (x.x >= 0 && vn2 >= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Get the incremental impulse\r\n//\t\t\t\t\tb2Vec2 d = x - a;\r\n\t\t\t\t\tbox2d.b2SubVV(x, a, d);\r\n\r\n\t\t\t\t\t// Apply incremental impulse\r\n//\t\t\t\t\tb2Vec2 P1 = d.x * normal;\r\n\t\t\t\t\tbox2d.b2MulSV(d.x, normal, P1);\r\n//\t\t\t\t\tb2Vec2 P2 = d.y * normal;\r\n\t\t\t\t\tbox2d.b2MulSV(d.y, normal, P2);\r\n\t\t\t\t\tbox2d.b2AddVV(P1, P2, P1P2);\r\n//\t\t\t\t\tvA -= mA * (P1 + P2);\r\n\t\t\t\t\tvA.SelfMulSub(mA, P1P2);\r\n//\t\t\t\t\twA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n\t\t\t\t\twA -= iA * (box2d.b2CrossVV(cp1.rA, P1) + box2d.b2CrossVV(cp2.rA, P2));\r\n\r\n//\t\t\t\t\tvB += mB * (P1 + P2);\r\n\t\t\t\t\tvB.SelfMulAdd(mB, P1P2);\r\n//\t\t\t\t\twB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n\t\t\t\t\twB += iB * (box2d.b2CrossVV(cp1.rB, P1) + box2d.b2CrossVV(cp2.rB, P2));\r\n\r\n\t\t\t\t\t// Accumulate\r\n\t\t\t\t\tcp1.normalImpulse = x.x;\r\n\t\t\t\t\tcp2.normalImpulse = x.y;\r\n\r\n/*\r\n#if B2_DEBUG_SOLVER === 1\r\n\t\t\t\t\t// Postconditions\r\n\t\t\t\t\tdv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);\r\n\r\n\t\t\t\t\t// Compute normal velocity\r\n\t\t\t\t\tvn1 = b2Dot(dv1, normal);\r\n\r\n\t\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2Abs(vn1 - cp1->velocityBias) < k_errorTol); }\r\n#endif\r\n*/\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t//\r\n\t\t\t\t// Case 3: vn2 = 0 and x1 = 0\r\n\t\t\t\t//\r\n\t\t\t\t// vn1 = a11 * 0 + a12 * x2 + b1' \r\n\t\t\t\t//   0 = a21 * 0 + a22 * x2 + b2'\r\n\t\t\t\t//\r\n\t\t\t\tx.x = 0;\r\n\t\t\t\tx.y = (-cp2.normalMass * b.y);\r\n\t\t\t\tvn1 = vc.K.ey.x * x.y + b.x;\r\n\t\t\t\tvn2 = 0;\r\n\r\n\t\t\t\tif (x.y >= 0 && vn1 >= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Resubstitute for the incremental impulse\r\n//\t\t\t\t\tb2Vec2 d = x - a;\r\n\t\t\t\t\tbox2d.b2SubVV(x, a, d);\r\n\r\n\t\t\t\t\t// Apply incremental impulse\r\n//\t\t\t\t\tb2Vec2 P1 = d.x * normal;\r\n\t\t\t\t\tbox2d.b2MulSV(d.x, normal, P1);\r\n//\t\t\t\t\tb2Vec2 P2 = d.y * normal;\r\n\t\t\t\t\tbox2d.b2MulSV(d.y, normal, P2);\r\n\t\t\t\t\tbox2d.b2AddVV(P1, P2, P1P2);\r\n//\t\t\t\t\tvA -= mA * (P1 + P2);\r\n\t\t\t\t\tvA.SelfMulSub(mA, P1P2);\r\n//\t\t\t\t\twA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n\t\t\t\t\twA -= iA * (box2d.b2CrossVV(cp1.rA, P1) + box2d.b2CrossVV(cp2.rA, P2));\r\n\r\n//\t\t\t\t\tvB += mB * (P1 + P2);\r\n\t\t\t\t\tvB.SelfMulAdd(mB, P1P2);\r\n//\t\t\t\t\twB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n\t\t\t\t\twB += iB * (box2d.b2CrossVV(cp1.rB, P1) + box2d.b2CrossVV(cp2.rB, P2));\r\n\r\n\t\t\t\t\t// Accumulate\r\n\t\t\t\t\tcp1.normalImpulse = x.x;\r\n\t\t\t\t\tcp2.normalImpulse = x.y;\r\n\r\n/*\r\n#if B2_DEBUG_SOLVER === 1\r\n\t\t\t\t\t// Postconditions\r\n\t\t\t\t\tdv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);\r\n\r\n\t\t\t\t\t// Compute normal velocity\r\n\t\t\t\t\tvn2 = b2Dot(dv2, normal);\r\n\r\n\t\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2Abs(vn2 - cp2->velocityBias) < k_errorTol); }\r\n#endif\r\n*/\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//\r\n\t\t\t\t// Case 4: x1 = 0 and x2 = 0\r\n\t\t\t\t// \r\n\t\t\t\t// vn1 = b1\r\n\t\t\t\t// vn2 = b2;\r\n\t\t\t\tx.x = 0;\r\n\t\t\t\tx.y = 0;\r\n\t\t\t\tvn1 = b.x;\r\n\t\t\t\tvn2 = b.y;\r\n\r\n\t\t\t\tif (vn1 >= 0 && vn2 >= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Resubstitute for the incremental impulse\r\n//\t\t\t\t\tb2Vec2 d = x - a;\r\n\t\t\t\t\tbox2d.b2SubVV(x, a, d);\r\n\r\n\t\t\t\t\t// Apply incremental impulse\r\n//\t\t\t\t\tb2Vec2 P1 = d.x * normal;\r\n\t\t\t\t\tbox2d.b2MulSV(d.x, normal, P1);\r\n//\t\t\t\t\tb2Vec2 P2 = d.y * normal;\r\n\t\t\t\t\tbox2d.b2MulSV(d.y, normal, P2);\r\n\t\t\t\t\tbox2d.b2AddVV(P1, P2, P1P2);\r\n//\t\t\t\t\tvA -= mA * (P1 + P2);\r\n\t\t\t\t\tvA.SelfMulSub(mA, P1P2);\r\n//\t\t\t\t\twA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n\t\t\t\t\twA -= iA * (box2d.b2CrossVV(cp1.rA, P1) + box2d.b2CrossVV(cp2.rA, P2));\r\n\r\n//\t\t\t\t\tvB += mB * (P1 + P2);\r\n\t\t\t\t\tvB.SelfMulAdd(mB, P1P2);\r\n//\t\t\t\t\twB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n\t\t\t\t\twB += iB * (box2d.b2CrossVV(cp1.rB, P1) + box2d.b2CrossVV(cp2.rB, P2));\r\n\r\n\t\t\t\t\t// Accumulate\r\n\t\t\t\t\tcp1.normalImpulse = x.x;\r\n\t\t\t\t\tcp2.normalImpulse = x.y;\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// No solution, give up. This is hit sometimes, but it doesn't seem to matter.\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n//\t\tthis.m_velocities[indexA].v = vA;\r\n\t\tthis.m_velocities[indexA].w = wA;\r\n//\t\tthis.m_velocities[indexB].v = vB;\r\n\t\tthis.m_velocities[indexB].w = wB;\r\n\t}\r\n}\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1 = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2 = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1 = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2 = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2 = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2ContactSolver.prototype.StoreImpulses = function ()\r\n{\r\n\t/** @type {number} */ var i;\r\n\t/** @type {number} */ var ict;\r\n\t/** @type {number} */ var j;\r\n\t/** @type {number} */ var jct;\r\n\r\n\t/** @type {box2d.b2ContactVelocityConstraint} */ var vc;\r\n\t/** @type {box2d.b2Manifold} */ var manifold;\r\n\r\n\tfor (i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tvc = this.m_velocityConstraints[i];\r\n\t\tmanifold = this.m_contacts[vc.contactIndex].GetManifold();\r\n\r\n\t\tfor (j = 0, jct = vc.pointCount; j < jct; ++j)\r\n\t\t{\r\n\t\t\tmanifold.points[j].normalImpulse = vc.points[j].normalImpulse;\r\n\t\t\tmanifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2PositionSolverManifold = function ()\r\n{\r\n\tthis.normal = new box2d.b2Vec2();\r\n\tthis.point = new box2d.b2Vec2();\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PositionSolverManifold.prototype.normal = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PositionSolverManifold.prototype.point = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PositionSolverManifold.prototype.separation = 0;\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2ContactPositionConstraint} pc \r\n * @param {box2d.b2Transform} xfA \r\n * @param {box2d.b2Transform} xfB\r\n * @param {number} index \r\n */\r\nbox2d.b2PositionSolverManifold.prototype.Initialize = function (pc, xfA, xfB, index)\r\n{\r\n\t/** @type {box2d.b2Vec2} */ var pointA = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA;\r\n\t/** @type {box2d.b2Vec2} */ var pointB = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB;\r\n\t/** @type {box2d.b2Vec2} */ var planePoint = box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint;\r\n\t/** @type {box2d.b2Vec2} */ var clipPoint = box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint;\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(pc.pointCount > 0); }\r\n\r\n\tswitch (pc.type)\r\n\t{\r\n\tcase box2d.b2ManifoldType.e_circles:\r\n\t\t{\r\n//\t\t\tb2Vec2 pointA = b2Mul(xfA, pc->localPoint);\r\n\t\t\tbox2d.b2MulXV(xfA, pc.localPoint, pointA);\r\n//\t\t\tb2Vec2 pointB = b2Mul(xfB, pc->localPoints[0]);\r\n\t\t\tbox2d.b2MulXV(xfB, pc.localPoints[0], pointB);\r\n//\t\t\tnormal = pointB - pointA;\r\n//\t\t\tnormal.Normalize();\r\n\t\t\tbox2d.b2SubVV(pointB, pointA, this.normal).SelfNormalize();\r\n//\t\t\tpoint = 0.5f * (pointA + pointB);\r\n\t\t\tbox2d.b2MidVV(pointA, pointB, this.point);\r\n//\t\t\tseparation = b2Dot(pointB - pointA, normal) - pc->radius;\r\n\t\t\tthis.separation = box2d.b2DotVV(box2d.b2SubVV(pointB, pointA, box2d.b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2ManifoldType.e_faceA:\r\n\t\t{\r\n//\t\t\tnormal = b2Mul(xfA.q, pc->localNormal);\r\n\t\t\tbox2d.b2MulRV(xfA.q, pc.localNormal, this.normal);\r\n//\t\t\tb2Vec2 planePoint = b2Mul(xfA, pc->localPoint);\r\n\t\t\tbox2d.b2MulXV(xfA, pc.localPoint, planePoint);\r\n\r\n//\t\t\tb2Vec2 clipPoint = b2Mul(xfB, pc->localPoints[index]);\r\n\t\t\tbox2d.b2MulXV(xfB, pc.localPoints[index], clipPoint);\r\n//\t\t\tseparation = b2Dot(clipPoint - planePoint, normal) - pc->radius;\r\n\t\t\tthis.separation = box2d.b2DotVV(box2d.b2SubVV(clipPoint, planePoint, box2d.b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;\r\n//\t\t\tpoint = clipPoint;\r\n\t\t\tthis.point.Copy(clipPoint);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2ManifoldType.e_faceB:\r\n\t\t{\r\n//\t\t\tnormal = b2Mul(xfB.q, pc->localNormal);\r\n\t\t\tbox2d.b2MulRV(xfB.q, pc.localNormal, this.normal);\r\n//\t\t\tb2Vec2 planePoint = b2Mul(xfB, pc->localPoint);\r\n\t\t\tbox2d.b2MulXV(xfB, pc.localPoint, planePoint);\r\n\r\n//\t\t\tb2Vec2 clipPoint = b2Mul(xfA, pc->localPoints[index]);\r\n\t\t\tbox2d.b2MulXV(xfA, pc.localPoints[index], clipPoint);\r\n//\t\t\tseparation = b2Dot(clipPoint - planePoint, normal) - pc->radius;\r\n\t\t\tthis.separation = box2d.b2DotVV(box2d.b2SubVV(clipPoint, planePoint, box2d.b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;\r\n//\t\t\tpoint = clipPoint;\r\n\t\t\tthis.point.Copy(clipPoint);\r\n\r\n\t\t\t// Ensure normal points from A to B\r\n//\t\t\tnormal = -normal;\r\n\t\t\tthis.normal.SelfNeg();\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n}\r\nbox2d.b2PositionSolverManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2();\r\nbox2d.b2PositionSolverManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2();\r\nbox2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2();\r\nbox2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2();\r\n\r\n/** \r\n * Sequential solver. \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2ContactSolver.prototype.SolvePositionConstraints = function ()\r\n{\r\n\t/** @type {number} */ var i;\r\n\t/** @type {number} */ var ict;\r\n\t/** @type {number} */ var j;\r\n\t/** @type {number} */ var jct;\r\n\r\n\t/** @type {box2d.b2ContactPositionConstraint} */ var pc;\r\n\r\n\t/** @type {number} */ var indexA;\r\n\t/** @type {number} */ var indexB;\r\n\t/** @type {box2d.b2Vec2} */ var localCenterA;\r\n\t/** @type {number} */ var mA;\r\n\t/** @type {number} */ var iA;\r\n\t/** @type {box2d.b2Vec2} */ var localCenterB;\r\n\t/** @type {number} */ var mB;\r\n\t/** @type {number} */ var iB;\r\n\t/** @type {number} */ var pointCount;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var cA;\r\n\t/** @type {number} */ var aA;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var cB;\r\n\t/** @type {number} */ var aB;\r\n\r\n\t/** @type {box2d.b2Transform} */ var xfA = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA;\r\n\t/** @type {box2d.b2Transform} */ var xfB = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB;\r\n\r\n\t/** @type {box2d.b2PositionSolverManifold} */ var psm = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var normal;\r\n\t/** @type {box2d.b2Vec2} */ var point;\r\n\t/** @type {number} */ var separation;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var rA = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA;\r\n\t/** @type {box2d.b2Vec2} */ var rB = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB;\r\n\r\n\t/** @type {number} */ var C;\r\n\t/** @type {number} */ var rnA;\r\n\t/** @type {number} */ var rnB;\r\n\t/** @type {number} */ var K;\r\n\t/** @type {number} */ var impulse;\r\n\t/** @type {box2d.b2Vec2} */ var P = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P;\r\n\r\n\t/** @type {number} */ var minSeparation = 0;\r\n\r\n\tfor (i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tpc = this.m_positionConstraints[i];\r\n\r\n\t\tindexA = pc.indexA;\r\n\t\tindexB = pc.indexB;\r\n\t\tlocalCenterA = pc.localCenterA;\r\n\t\tmA = pc.invMassA;\r\n\t\tiA = pc.invIA;\r\n\t\tlocalCenterB = pc.localCenterB;\r\n\t\tmB = pc.invMassB;\r\n\t\tiB = pc.invIB;\r\n\t\tpointCount = pc.pointCount;\r\n\r\n\t\tcA = this.m_positions[indexA].c;\r\n\t\taA = this.m_positions[indexA].a;\r\n\r\n\t\tcB = this.m_positions[indexB].c;\r\n\t\taB = this.m_positions[indexB].a;\r\n\r\n\t\t// Solve normal constraints\r\n\t\tfor (j = 0, jct = pointCount; j < jct; ++j)\r\n\t\t{\r\n\t\t\txfA.q.SetAngleRadians(aA);\r\n\t\t\txfB.q.SetAngleRadians(aB);\r\n\t\t\tbox2d.b2SubVV(cA, box2d.b2MulRV(xfA.q, localCenterA, box2d.b2Vec2.s_t0), xfA.p);\r\n\t\t\tbox2d.b2SubVV(cB, box2d.b2MulRV(xfB.q, localCenterB, box2d.b2Vec2.s_t0), xfB.p);\r\n\r\n\t\t\tpsm.Initialize(pc, xfA, xfB, j);\r\n\t\t\tnormal = psm.normal;\r\n\r\n\t\t\tpoint = psm.point;\r\n\t\t\tseparation = psm.separation;\r\n\r\n//\t\t\tb2Vec2 rA = point - cA;\r\n\t\t\tbox2d.b2SubVV(point, cA, rA);\r\n//\t\t\tb2Vec2 rB = point - cB;\r\n\t\t\tbox2d.b2SubVV(point, cB, rB);\r\n\r\n\t\t\t// Track max constraint error.\r\n\t\t\tminSeparation = box2d.b2Min(minSeparation, separation);\r\n\r\n\t\t\t// Prevent large corrections and allow slop.\r\n\t\t\tC = box2d.b2Clamp(box2d.b2_baumgarte * (separation + box2d.b2_linearSlop), (-box2d.b2_maxLinearCorrection), 0);\r\n\r\n\t\t\t// Compute the effective mass.\r\n//\t\t\tfloat32 rnA = b2Cross(rA, normal);\r\n\t\t\trnA = box2d.b2CrossVV(rA, normal);\r\n//\t\t\tfloat32 rnB = b2Cross(rB, normal);\r\n\t\t\trnB = box2d.b2CrossVV(rB, normal);\r\n//\t\t\tfloat32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n\t\t\tK = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n\r\n\t\t\t// Compute normal impulse\r\n\t\t\timpulse = K > 0 ? - C / K : 0;\r\n\r\n//\t\t\tb2Vec2 P = impulse * normal;\r\n\t\t\tbox2d.b2MulSV(impulse, normal, P);\r\n\r\n//\t\t\tcA -= mA * P;\r\n\t\t\tcA.SelfMulSub(mA, P);\r\n//\t\t\taA -= iA * b2Cross(rA, P);\r\n\t\t\taA -= iA * box2d.b2CrossVV(rA, P);\r\n\r\n//\t\t\tcB += mB * P;\r\n\t\t\tcB.SelfMulAdd(mB, P);\r\n//\t\t\taB += iB * b2Cross(rB, P);\r\n\t\t\taB += iB * box2d.b2CrossVV(rB, P);\r\n\t\t}\r\n\r\n//\t\tthis.m_positions[indexA].c = cA;\r\n\t\tthis.m_positions[indexA].a = aA;\r\n\r\n//\t\tthis.m_positions[indexB].c = cB;\r\n\t\tthis.m_positions[indexB].a = aB;\r\n\t}\r\n\r\n\t// We can't expect minSpeparation >= -box2d.b2_linearSlop because we don't\r\n\t// push the separation above -box2d.b2_linearSlop.\r\n\treturn minSeparation > (-3 * box2d.b2_linearSlop);\r\n}\r\nbox2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA = new box2d.b2Transform();\r\nbox2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB = new box2d.b2Transform();\r\nbox2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm = new box2d.b2PositionSolverManifold();\r\nbox2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/** \r\n * Sequential position solver for position constraints. \r\n * @export \r\n * @return {boolean} \r\n * @param {number} toiIndexA \r\n * @param {number} toiIndexB \r\n */\r\nbox2d.b2ContactSolver.prototype.SolveTOIPositionConstraints = function (toiIndexA, toiIndexB)\r\n{\r\n\t/** @type {number} */ var i;\r\n\t/** @type {number} */ var ict;\r\n\t/** @type {number} */ var j;\r\n\t/** @type {number} */ var jct;\r\n\r\n\t/** @type {box2d.b2ContactPositionConstraint} */ var pc;\r\n\r\n\t/** @type {number} */ var indexA;\r\n\t/** @type {number} */ var indexB;\r\n\t/** @type {box2d.b2Vec2} */ var localCenterA;\r\n\t/** @type {box2d.b2Vec2} */ var localCenterB;\r\n\t/** @type {number} */ var pointCount;\r\n\r\n\t/** @type {number} */ var mA;\r\n\t/** @type {number} */ var iA;\r\n\r\n\t/** @type {number} */ var mB;\r\n\t/** @type {number} */ var iB;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var cA;\r\n\t/** @type {number} */ var aA;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var cB;\r\n\t/** @type {number} */ var aB;\r\n\r\n\t/** @type {box2d.b2Transform} */ var xfA = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA;\r\n\t/** @type {box2d.b2Transform} */ var xfB = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB;\r\n\r\n\t/** @type {box2d.b2PositionSolverManifold} */ var psm = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm;\r\n\t/** @type {box2d.b2Vec2} */ var normal;\r\n\t/** @type {box2d.b2Vec2} */ var point;\r\n\t/** @type {number} */ var separation;\r\n\t/** @type {box2d.b2Vec2} */ var rA = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA;\r\n\t/** @type {box2d.b2Vec2} */ var rB = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB;\r\n\t/** @type {number} */ var C;\r\n\t/** @type {number} */ var rnA;\r\n\t/** @type {number} */ var rnB;\r\n\t/** @type {number} */ var K;\r\n\t/** @type {number} */ var impulse;\r\n\t/** @type {box2d.b2Vec2} */ var P = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P;\r\n\r\n\t/** @type {number} */ var minSeparation = 0;\r\n\r\n\tfor (i = 0, ict = this.m_count; i < ict; ++i)\r\n\t{\r\n\t\tpc = this.m_positionConstraints[i];\r\n\r\n\t\tindexA = pc.indexA;\r\n\t\tindexB = pc.indexB;\r\n\t\tlocalCenterA = pc.localCenterA;\r\n\t\tlocalCenterB = pc.localCenterB;\r\n\t\tpointCount = pc.pointCount;\r\n\r\n\t\tmA = 0;\r\n\t\tiA = 0;\r\n\t\tif (indexA === toiIndexA || indexA === toiIndexB)\r\n\t\t{\r\n\t\t\tmA = pc.invMassA;\r\n\t\t\tiA = pc.invIA;\r\n\t\t}\r\n\r\n\t\tmB = 0;\r\n\t\tiB = 0;\r\n\t\tif (indexB === toiIndexA || indexB === toiIndexB)\r\n\t\t{\r\n\t\t\tmB = pc.invMassB;\r\n\t\t\tiB = pc.invIB;\r\n\t\t}\r\n\r\n\t\tcA = this.m_positions[indexA].c;\r\n\t\taA = this.m_positions[indexA].a;\r\n\r\n\t\tcB = this.m_positions[indexB].c;\r\n\t\taB = this.m_positions[indexB].a;\r\n\r\n\t\t// Solve normal constraints\r\n\t\tfor (j = 0, jct = pointCount; j < jct; ++j)\r\n\t\t{\r\n\t\t\txfA.q.SetAngleRadians(aA);\r\n\t\t\txfB.q.SetAngleRadians(aB);\r\n\t\t\tbox2d.b2SubVV(cA, box2d.b2MulRV(xfA.q, localCenterA, box2d.b2Vec2.s_t0), xfA.p);\r\n\t\t\tbox2d.b2SubVV(cB, box2d.b2MulRV(xfB.q, localCenterB, box2d.b2Vec2.s_t0), xfB.p);\r\n\r\n\t\t\tpsm.Initialize(pc, xfA, xfB, j);\r\n\t\t\tnormal = psm.normal;\r\n\r\n\t\t\tpoint = psm.point;\r\n\t\t\tseparation = psm.separation;\r\n\r\n//\t\t\tb2Vec2 rA = point - cA;\r\n\t\t\tbox2d.b2SubVV(point, cA, rA);\r\n//\t\t\tb2Vec2 rB = point - cB;\r\n\t\t\tbox2d.b2SubVV(point, cB, rB);\r\n\r\n\t\t\t// Track max constraint error.\r\n\t\t\tminSeparation = box2d.b2Min(minSeparation, separation);\r\n\r\n\t\t\t// Prevent large corrections and allow slop.\r\n\t\t\tC = box2d.b2Clamp(box2d.b2_toiBaumgarte * (separation + box2d.b2_linearSlop), (-box2d.b2_maxLinearCorrection), 0);\r\n\r\n\t\t\t// Compute the effective mass.\r\n//\t\t\tfloat32 rnA = b2Cross(rA, normal);\r\n\t\t\trnA = box2d.b2CrossVV(rA, normal);\r\n//\t\t\tfloat32 rnB = b2Cross(rB, normal);\r\n\t\t\trnB = box2d.b2CrossVV(rB, normal);\r\n//\t\t\tfloat32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n\t\t\tK = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n\r\n\t\t\t// Compute normal impulse\r\n\t\t\timpulse = K > 0 ? - C / K : 0;\r\n\r\n//\t\t\tb2Vec2 P = impulse * normal;\r\n\t\t\tbox2d.b2MulSV(impulse, normal, P);\r\n\r\n//\t\t\tcA -= mA * P;\r\n\t\t\tcA.SelfMulSub(mA, P);\r\n//\t\t\taA -= iA * b2Cross(rA, P);\r\n\t\t\taA -= iA * box2d.b2CrossVV(rA, P);\r\n\r\n//\t\t\tcB += mB * P;\r\n\t\t\tcB.SelfMulAdd(mB, P);\r\n//\t\t\taB += iB * b2Cross(rB, P);\r\n\t\t\taB += iB * box2d.b2CrossVV(rB, P);\r\n\t\t}\r\n\r\n//\t\tthis.m_positions[indexA].c = cA;\r\n\t\tthis.m_positions[indexA].a = aA;\r\n\r\n//\t\tthis.m_positions[indexB].c = cB;\r\n\t\tthis.m_positions[indexB].a = aB;\r\n\t}\r\n\r\n\t// We can't expect minSpeparation >= -box2d.b2_linearSlop because we don't\r\n\t// push the separation above -box2d.b2_linearSlop.\r\n\treturn minSeparation >= -1.5 * box2d.b2_linearSlop;\r\n}\r\nbox2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA = new box2d.b2Transform();\r\nbox2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB = new box2d.b2Transform();\r\nbox2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm = new box2d.b2PositionSolverManifold();\r\nbox2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB = new box2d.b2Vec2();\r\nbox2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2WorldCallbacks');\r\n\r\ngoog.require('box2d.b2Settings');\r\n\r\n/** \r\n * Joints and fixtures are destroyed when their associated body \r\n * is destroyed. Implement this listener so that you may nullify \r\n * references to these joints and shapes. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2DestructionListener = function ()\r\n{\r\n};\r\n\r\n/** \r\n * Called when any joint is about to be destroyed due to the \r\n * destruction of one of its attached bodies. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Joint} joint \r\n */\r\nbox2d.b2DestructionListener.prototype.SayGoodbyeJoint = function (joint)\r\n{\r\n}\r\n\r\n/** \r\n * Called when any fixture is about to be destroyed due to the \r\n * destruction of its parent body. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixture \r\n */\r\nbox2d.b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture)\r\n{\r\n}\r\n\r\n/** \r\n * Implement this class to provide collision filtering. In other \r\n * words, you can implement this class if you want finer control \r\n * over contact creation. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ContactFilter = function ()\r\n{\r\n};\r\n\r\n/** \r\n * Return true if contact calculations should be performed \r\n * between these two shapes. \r\n * warning for performance reasons this is only called when the \r\n * AABBs begin to overlap. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2Fixture} fixtureA \r\n * @param {box2d.b2Fixture} fixtureB \r\n */\r\nbox2d.b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB)\r\n{\r\n\tvar filter1 = fixtureA.GetFilterData();\r\n\tvar filter2 = fixtureB.GetFilterData();\r\n\r\n\tif (filter1.groupIndex === filter2.groupIndex && filter1.groupIndex !== 0)\r\n\t{\r\n\t\treturn (filter1.groupIndex > 0);\r\n\t}\r\n\r\n\tvar collide = (((filter1.maskBits & filter2.categoryBits) !== 0) && ((filter1.categoryBits & filter2.maskBits) !== 0));\r\n\treturn collide;\r\n}\r\n\r\nbox2d.b2ContactFilter.b2_defaultFilter = new box2d.b2ContactFilter();\r\n\r\n/** \r\n * Contact impulses for reporting. Impulses are used instead of \r\n * forces because sub-step forces may approach infinity for \r\n * rigid body collisions. These match up one-to-one with the \r\n * contact points in b2Manifold. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ContactImpulse = function ()\r\n{\r\n\tthis.normalImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints);\r\n\tthis.tangentImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints);\r\n};\r\n\r\nbox2d.b2ContactImpulse.prototype.normalImpulses = null;\r\nbox2d.b2ContactImpulse.prototype.tangentImpulses = null;\r\nbox2d.b2ContactImpulse.prototype.count = 0;\r\n\r\n/** \r\n * Implement this class to get contact information. You can use \r\n * these results for things like sounds and game logic. You can \r\n * also get contact results by traversing the contact lists \r\n * after the time step. However, you might miss some contacts \r\n * because continuous physics leads to sub-stepping. \r\n * Additionally you may receive multiple callbacks for the same \r\n * contact in a single time step. \r\n * You should strive to make your callbacks efficient because \r\n * there may be many callbacks per time step. \r\n * warning You cannot create/destroy Box2D entities inside these \r\n * callbacks. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2ContactListener = function ()\r\n{\r\n};\r\n\r\n/** \r\n * Called when two fixtures begin to touch. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n */\r\nbox2d.b2ContactListener.prototype.BeginContact = function (contact)\r\n{\r\n}\r\n\r\n/** \r\n * Called when two fixtures cease to touch. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n */\r\nbox2d.b2ContactListener.prototype.EndContact = function (contact)\r\n{\r\n}\r\n\r\n/** \r\n * This is called after a contact is updated. This allows you to \r\n * inspect a contact before it goes to the solver. If you are \r\n * careful, you can modify the contact manifold (e.g. disable \r\n * contact). \r\n * A copy of the old manifold is provided so that you can detect \r\n * changes. \r\n * Note: this is called only for awake bodies. \r\n * Note: this is called even when the number of contact points \r\n * is zero. \r\n * Note: this is not called for sensors. \r\n * Note: if you set the number of contact points to zero, you \r\n * will not get an EndContact callback. However, you may get a \r\n * BeginContact callback the next step. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n * @param {box2d.b2Manifold} oldManifold \r\n */\r\nbox2d.b2ContactListener.prototype.PreSolve = function (contact, oldManifold)\r\n{\r\n}\r\n\r\n/** \r\n * This lets you inspect a contact after the solver is finished. \r\n * This is useful for inspecting impulses. \r\n * Note: the contact manifold does not include time of impact \r\n * impulses, which can be arbitrarily large if the sub-step is \r\n * small. Hence the impulse is provided explicitly in a separate \r\n * data structure. \r\n * Note: this is only called for contacts that are touching, \r\n * solid, and awake. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact\r\n * @param {box2d.b2ContactImpulse} impulse\r\n */\r\nbox2d.b2ContactListener.prototype.PostSolve = function (contact, impulse)\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactListener} \r\n */\r\nbox2d.b2ContactListener.b2_defaultListener = new box2d.b2ContactListener();\r\n\r\n/** \r\n * Callback class for AABB queries. \r\n * See b2World::Query \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2QueryCallback = function ()\r\n{\r\n}\r\n\r\n/** \r\n * Called for each fixture found in the query AABB. \r\n * @export \r\n * @return {boolean} false to terminate the query.\r\n */\r\nbox2d.b2QueryCallback.prototype.ReportFixture = function (fixture)\r\n{\r\n\treturn true;\r\n}\r\n\r\n/** \r\n * Callback class for ray casts. \r\n * See b2World::RayCast \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2RayCastCallback = function ()\r\n{\r\n}\r\n\r\n/** \r\n * Called for each fixture found in the query. You control how \r\n * the ray cast proceeds by returning a float: \r\n * return -1: ignore this fixture and continue \r\n * return 0: terminate the ray cast \r\n * return fraction: clip the ray to this point \r\n * return 1: don't clip the ray and continue\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Fixture} fixture the fixture hit by the ray\r\n * @param {box2d.b2Vec2} point the point of initial intersection\r\n * @param {box2d.b2Vec2} normal the normal vector at the point \r\n *  \t  of intersection\r\n * @param {number} fraction \r\n */\r\nbox2d.b2RayCastCallback.prototype.ReportFixture = function (fixture, point, normal, fraction)\r\n{\r\n\treturn fraction;\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Island');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Timer');\r\ngoog.require('box2d.b2TimeStep');\r\ngoog.require('box2d.b2WorldCallbacks');\r\ngoog.require('box2d.b2ContactSolver');\r\n\r\n/*\r\nPosition Correction Notes\r\n=========================\r\nI tried the several algorithms for position correction of the 2D revolute joint.\r\nI looked at these systems:\r\n- simple pendulum (1m diameter sphere on massless 5m stick) with initial angular velocity of 100 rad/s.\r\n- suspension bridge with 30 1m long planks of length 1m.\r\n- multi-link chain with 30 1m long links.\r\n\r\nHere are the algorithms:\r\n\r\nBaumgarte - A fraction of the position error is added to the velocity error. There is no\r\nseparate position solver.\r\n\r\nPseudo Velocities - After the velocity solver and position integration,\r\nthe position error, Jacobian, and effective mass are recomputed. Then\r\nthe velocity constraints are solved with pseudo velocities and a fraction\r\nof the position error is added to the pseudo velocity error. The pseudo\r\nvelocities are initialized to zero and there is no warm-starting. After\r\nthe position solver, the pseudo velocities are added to the positions.\r\nThis is also called the First Order World method or the Position LCP method.\r\n\r\nModified Nonlinear Gauss-Seidel (NGS) - Like Pseudo Velocities except the\r\nposition error is re-computed for each constraint and the positions are updated\r\nafter the constraint is solved. The radius vectors (aka Jacobians) are\r\nre-computed too (otherwise the algorithm has horrible instability). The pseudo\r\nvelocity states are not needed because they are effectively zero at the beginning\r\nof each iteration. Since we have the current position error, we allow the\r\niterations to terminate early if the error becomes smaller than box2d.b2_linearSlop.\r\n\r\nFull NGS or just NGS - Like Modified NGS except the effective mass are re-computed\r\neach time a constraint is solved.\r\n\r\nHere are the results:\r\nBaumgarte - this is the cheapest algorithm but it has some stability problems,\r\nespecially with the bridge. The chain links separate easily close to the root\r\nand they jitter as they struggle to pull together. This is one of the most common\r\nmethods in the field. The big drawback is that the position correction artificially\r\naffects the momentum, thus leading to instabilities and false bounce. I used a\r\nbias factor of 0.2. A larger bias factor makes the bridge less stable, a smaller\r\nfactor makes joints and contacts more spongy.\r\n\r\nPseudo Velocities - the is more stable than the Baumgarte method. The bridge is\r\nstable. However, joints still separate with large angular velocities. Drag the\r\nsimple pendulum in a circle quickly and the joint will separate. The chain separates\r\neasily and does not recover. I used a bias factor of 0.2. A larger value lead to\r\nthe bridge collapsing when a heavy cube drops on it.\r\n\r\nModified NGS - this algorithm is better in some ways than Baumgarte and Pseudo\r\nVelocities, but in other ways it is worse. The bridge and chain are much more\r\nstable, but the simple pendulum goes unstable at high angular velocities.\r\n\r\nFull NGS - stable in all tests. The joints display good stiffness. The bridge\r\nstill sags, but this is better than infinite forces.\r\n\r\nRecommendations\r\nPseudo Velocities are not really worthwhile because the bridge and chain cannot\r\nrecover from joint separation. In other cases the benefit over Baumgarte is small.\r\n\r\nModified NGS is not a robust method for the revolute joint due to the violent\r\ninstability seen in the simple pendulum. Perhaps it is viable with other constraint\r\ntypes, especially scalar constraints where the effective mass is a scalar.\r\n\r\nThis leaves Baumgarte and Full NGS. Baumgarte has small, but manageable instabilities\r\nand is very fast. I don't think we can escape Baumgarte, especially in highly\r\ndemanding cases where high constraint fidelity is not needed.\r\n\r\nFull NGS is robust and easy on the eyes. I recommend this as an option for\r\nhigher fidelity simulation and certainly for suspension bridges and long chains.\r\nFull NGS might be a good choice for ragdolls, especially motorized ragdolls where\r\njoint separation can be problematic. The number of NGS iterations can be reduced\r\nfor better performance without harming robustness much.\r\n\r\nEach joint in a can be handled differently in the position solver. So I recommend\r\na system where the user can select the algorithm on a per joint basis. I would\r\nprobably default to the slower Full NGS and let the user select the faster\r\nBaumgarte method in performance critical scenarios.\r\n*/\r\n\r\n/*\r\nCache Performance\r\n\r\nThe Box2D solvers are dominated by cache misses. Data structures are designed\r\nto increase the number of cache hits. Much of misses are due to random access\r\nto body data. The constraint structures are iterated over linearly, which leads\r\nto few cache misses.\r\n\r\nThe bodies are not accessed during iteration. Instead read only data, such as\r\nthe mass values are stored with the constraints. The mutable data are the constraint\r\nimpulses and the bodies velocities/positions. The impulses are held inside the\r\nconstraint structures. The body velocities/positions are held in compact, temporary\r\narrays to increase the number of cache hits. Linear and angular velocity are\r\nstored in a single array since multiple arrays lead to multiple misses.\r\n*/\r\n\r\n/*\r\n2D Rotation\r\n\r\nR = [cos(theta) -sin(theta)]\r\n    [sin(theta) cos(theta) ]\r\n\r\nthetaDot = omega\r\n\r\nLet q1 = cos(theta), q2 = sin(theta).\r\nR = [q1 -q2]\r\n    [q2  q1]\r\n\r\nq1Dot = -thetaDot * q2\r\nq2Dot = thetaDot * q1\r\n\r\nq1_new = q1_old - dt * w * q2\r\nq2_new = q2_old + dt * w * q1\r\nthen normalize.\r\n\r\nThis might be faster than computing sin+cos.\r\nHowever, we can compute sin+cos of the same angle fast.\r\n*/\r\n\r\n/** \r\n * This is an internal class. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Island = function ()\r\n{\r\n\tthis.m_bodies = new Array(1024); // TODO: b2Settings\r\n\tthis.m_contacts = new Array(1024); // TODO: b2Settings\r\n\tthis.m_joints = new Array(1024); // TODO: b2Settings\r\n\r\n\tthis.m_positions = box2d.b2Position.MakeArray(1024); // TODO: b2Settings\r\n\tthis.m_velocities = box2d.b2Velocity.MakeArray(1024); // TODO: b2Settings\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2Island.prototype.m_allocator = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactListener}\r\n */\r\nbox2d.b2Island.prototype.m_listener = null;\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Body>}\r\n */\r\nbox2d.b2Island.prototype.m_bodies = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Contact>}\r\n */\r\nbox2d.b2Island.prototype.m_contacts = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Joint>}\r\n */\r\nbox2d.b2Island.prototype.m_joints = null;\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Position>}\r\n */\r\nbox2d.b2Island.prototype.m_positions = null;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Velocity>}\r\n */\r\nbox2d.b2Island.prototype.m_velocities = null;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Island.prototype.m_bodyCount = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Island.prototype.m_jointCount = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Island.prototype.m_contactCount = 0;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Island.prototype.m_bodyCapacity = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Island.prototype.m_contactCapacity = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Island.prototype.m_jointCapacity = 0;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {number} bodyCapacity\r\n * @param {number} contactCapacity\r\n * @param {number} jointCapacity \r\n * @param allocator \r\n * @param {box2d.b2ContactListener} listener \r\n */\r\nbox2d.b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener)\r\n{\r\n\tthis.m_bodyCapacity = bodyCapacity;\r\n\tthis.m_contactCapacity = contactCapacity;\r\n\tthis.m_jointCapacity = jointCapacity;\r\n\tthis.m_bodyCount = 0;\r\n\tthis.m_contactCount = 0;\r\n\tthis.m_jointCount = 0;\r\n\r\n\tthis.m_allocator = allocator;\r\n\tthis.m_listener = listener;\r\n\r\n\t// TODO:\r\n\twhile (this.m_bodies.length < bodyCapacity)\r\n\t{\r\n\t\tthis.m_bodies[this.m_bodies.length] = null;\r\n\t}\r\n\t// TODO:\r\n\twhile (this.m_contacts.length < contactCapacity)\r\n\t{\r\n\t\tthis.m_contacts[this.m_contacts.length] = null;\r\n\t}\r\n\t// TODO:\r\n\twhile (this.m_joints.length < jointCapacity)\r\n\t{\r\n\t\tthis.m_joints[this.m_joints.length] = null;\r\n\t}\r\n\r\n\t// TODO:\r\n\tif (this.m_positions.length < bodyCapacity)\r\n\t{\r\n\t\tvar new_length = box2d.b2Max(this.m_positions.length * 2, bodyCapacity);\r\n\r\n\t\tif (box2d.DEBUG)\r\n\t\t{\r\n\t\t\twindow.console.log(\"box2d.b2Island.m_positions: \" + new_length);\r\n\t\t}\r\n\r\n\t\twhile (this.m_positions.length < new_length)\r\n\t\t{\r\n\t\t\tthis.m_positions[this.m_positions.length] = new box2d.b2Position();\r\n\t\t}\r\n\t}\r\n\t// TODO:\r\n\tif (this.m_velocities.length < bodyCapacity)\r\n\t{\r\n\t\tvar new_length = box2d.b2Max(this.m_velocities.length * 2, bodyCapacity);\r\n\r\n\t\tif (box2d.DEBUG)\r\n\t\t{\r\n\t\t\twindow.console.log(\"box2d.b2Island.m_velocities: \" + new_length);\r\n\t\t}\r\n\r\n\t\twhile (this.m_velocities.length < new_length)\r\n\t\t{\r\n\t\t\tthis.m_velocities[this.m_velocities.length] = new box2d.b2Velocity();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Island.prototype.Clear = function ()\r\n{\r\n\tthis.m_bodyCount = 0;\r\n\tthis.m_contactCount = 0;\r\n\tthis.m_jointCount = 0;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} body\r\n */\r\nbox2d.b2Island.prototype.AddBody = function (body)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_bodyCount < this.m_bodyCapacity); }\r\n\tbody.m_islandIndex = this.m_bodyCount;\r\n\tthis.m_bodies[this.m_bodyCount++] = body;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact\r\n */\r\nbox2d.b2Island.prototype.AddContact = function (contact)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_contactCount < this.m_contactCapacity); }\r\n\tthis.m_contacts[this.m_contactCount++] = contact;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Joint} joint\r\n */\r\nbox2d.b2Island.prototype.AddJoint = function (joint)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_jointCount < this.m_jointCapacity); }\r\n\tthis.m_joints[this.m_jointCount++] = joint;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Profile} profile \r\n * @param {box2d.b2TimeStep} step \r\n * @param {box2d.b2Vec2} gravity \r\n * @param {boolean} allowSleep \r\n */\r\nbox2d.b2Island.prototype.Solve = function (profile, step, gravity, allowSleep)\r\n{\r\n\t/*box2d.b2Timer*/ var timer = box2d.b2Island.s_timer.Reset();\r\n\r\n\t/*float32*/ var h = step.dt;\r\n\r\n\t// Integrate velocities and apply damping. Initialize the body state.\r\n\tfor (var i = 0; i < this.m_bodyCount; ++i)\r\n\t{\r\n\t\t/*box2d.b2Body*/ var b = this.m_bodies[i];\r\n\r\n\t\t/*box2d.b2Vec2&*/ var c = this.m_positions[i].c.Copy(b.m_sweep.c);\r\n\t\t/*float32*/ var a = b.m_sweep.a;\r\n\t\t/*box2d.b2Vec2&*/ var v = this.m_velocities[i].v.Copy(b.m_linearVelocity);\r\n\t\t/*float32*/ var w = b.m_angularVelocity;\r\n\r\n\t\t// Store positions for continuous collision.\r\n\t\tb.m_sweep.c0.Copy(b.m_sweep.c);\r\n\t\tb.m_sweep.a0 = b.m_sweep.a;\r\n\r\n\t\tif (b.m_type === box2d.b2BodyType.b2_dynamicBody)\r\n\t\t{\r\n\t\t\t// Integrate velocities.\r\n\t\t\tv.x += h * (b.m_gravityScale * gravity.x + b.m_invMass * b.m_force.x);\r\n\t\t\tv.y += h * (b.m_gravityScale * gravity.y + b.m_invMass * b.m_force.y);\r\n\t\t\tw += h * b.m_invI * b.m_torque;\r\n\t\r\n\t\t\t// Apply damping.\r\n\t\t\t// ODE: dv/dt + c * v = 0\r\n\t\t\t// Solution: v(t) = v0 * exp(-c * t)\r\n\t\t\t// Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\r\n\t\t\t// v2 = exp(-c * dt) * v1\r\n\t\t\t// Pade approximation:\r\n\t\t\t// v2 = v1 * 1 / (1 + c * dt)\r\n\t\t\tv.SelfMul(1.0 / (1.0 + h * b.m_linearDamping));\r\n\t\t\tw *= 1.0 / (1.0 + h * b.m_angularDamping);\r\n\t\t}\r\n\r\n//\t\tthis.m_positions[i].c = c;\r\n\t\tthis.m_positions[i].a = a;\r\n//\t\tthis.m_velocities[i].v = v;\r\n\t\tthis.m_velocities[i].w = w;\r\n\t}\r\n\r\n\ttimer.Reset();\r\n\r\n\t// Solver data\r\n\t/*box2d.b2SolverData*/ var solverData = box2d.b2Island.s_solverData;\r\n\tsolverData.step.Copy(step);\r\n\tsolverData.positions = this.m_positions;\r\n\tsolverData.velocities = this.m_velocities;\r\n\r\n\t// Initialize velocity constraints.\r\n\t/*box2d.b2ContactSolverDef*/ var contactSolverDef = box2d.b2Island.s_contactSolverDef;\r\n\tcontactSolverDef.step.Copy(step);\r\n\tcontactSolverDef.contacts = this.m_contacts;\r\n\tcontactSolverDef.count = this.m_contactCount;\r\n\tcontactSolverDef.positions = this.m_positions;\r\n\tcontactSolverDef.velocities = this.m_velocities;\r\n\tcontactSolverDef.allocator = this.m_allocator;\r\n\r\n\t/*box2d.b2ContactSolver*/ var contactSolver = box2d.b2Island.s_contactSolver.Initialize(contactSolverDef);\r\n\tcontactSolver.InitializeVelocityConstraints();\r\n\r\n\tif (step.warmStarting)\r\n\t{\r\n\t\tcontactSolver.WarmStart();\r\n\t}\r\n\r\n\tfor (var i = 0; i < this.m_jointCount; ++i)\r\n\t{\r\n\t\tthis.m_joints[i].InitVelocityConstraints(solverData);\r\n\t}\r\n\r\n\tprofile.solveInit = timer.GetMilliseconds();\r\n\r\n\t// Solve velocity constraints.\r\n\ttimer.Reset();\r\n\tfor (var i = 0; i < step.velocityIterations; ++i)\r\n\t{\r\n\t\tfor (var j = 0; j < this.m_jointCount; ++j)\r\n\t\t{\r\n\t\t\tthis.m_joints[j].SolveVelocityConstraints(solverData);\r\n\t\t}\r\n\r\n\t\tcontactSolver.SolveVelocityConstraints();\r\n\t}\r\n\r\n\t// Store impulses for warm starting\r\n\tcontactSolver.StoreImpulses();\r\n\tprofile.solveVelocity = timer.GetMilliseconds();\r\n\r\n\t// Integrate positions.\r\n\tfor (var i = 0; i < this.m_bodyCount; ++i)\r\n\t{\r\n\t\t/*box2d.b2Vec2&*/ var c = this.m_positions[i].c;\r\n\t\t/*float32*/ var a = this.m_positions[i].a;\r\n\t\t/*box2d.b2Vec2&*/ var v = this.m_velocities[i].v;\r\n\t\t/*float32*/ var w = this.m_velocities[i].w;\r\n\r\n\t\t// Check for large velocities\r\n\t\t/*box2d.b2Vec2*/ var translation = box2d.b2MulSV(h, v, box2d.b2Island.s_translation);\r\n\t\tif (box2d.b2DotVV(translation, translation) > box2d.b2_maxTranslationSquared)\r\n\t\t{\r\n\t\t\t/*float32*/ var ratio = box2d.b2_maxTranslation / translation.GetLength();\r\n\t\t\tv.SelfMul(ratio);\r\n\t\t}\r\n\r\n\t\t/*float32*/ var rotation = h * w;\r\n\t\tif (rotation * rotation > box2d.b2_maxRotationSquared)\r\n\t\t{\r\n\t\t\t/*float32*/ var ratio = box2d.b2_maxRotation / box2d.b2Abs(rotation);\r\n\t\t\tw *= ratio;\r\n\t\t}\r\n\r\n\t\t// Integrate\r\n\t\tc.x += h * v.x;\r\n\t\tc.y += h * v.y;\r\n\t\ta += h * w;\r\n\r\n//\t\tthis.m_positions[i].c = c;\r\n\t\tthis.m_positions[i].a = a;\r\n//\t\tthis.m_velocities[i].v = v;\r\n\t\tthis.m_velocities[i].w = w;\r\n\t}\r\n\r\n\t// Solve position constraints\r\n\ttimer.Reset();\r\n\t/*bool*/ var positionSolved = false;\r\n\tfor (var i = 0; i < step.positionIterations; ++i)\r\n\t{\r\n\t\t/*bool*/ var contactsOkay = contactSolver.SolvePositionConstraints();\r\n\r\n\t\t/*bool*/ var jointsOkay = true;\r\n\t\tfor (var j = 0; j < this.m_jointCount; ++j)\r\n\t\t{\r\n\t\t\t/*bool*/ var jointOkay = this.m_joints[j].SolvePositionConstraints(solverData);\r\n\t\t\tjointsOkay = jointsOkay && jointOkay;\r\n\t\t}\r\n\r\n\t\tif (contactsOkay && jointsOkay)\r\n\t\t{\r\n\t\t\t// Exit early if the position errors are small.\r\n\t\t\tpositionSolved = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// Copy state buffers back to the bodies\r\n\tfor (var i = 0; i < this.m_bodyCount; ++i)\r\n\t{\r\n\t\t/** @type {box2d.b2Body} */ var body = this.m_bodies[i];\r\n\t\tbody.m_sweep.c.Copy(this.m_positions[i].c);\r\n\t\tbody.m_sweep.a = this.m_positions[i].a;\r\n\t\tbody.m_linearVelocity.Copy(this.m_velocities[i].v);\r\n\t\tbody.m_angularVelocity = this.m_velocities[i].w;\r\n\t\tbody.SynchronizeTransform();\r\n\t}\r\n\r\n\tprofile.solvePosition = timer.GetMilliseconds();\r\n\r\n\tthis.Report(contactSolver.m_velocityConstraints);\r\n\r\n\tif (allowSleep)\r\n\t{\r\n\t\t/*float32*/ var minSleepTime = box2d.b2_maxFloat;\r\n\r\n\t\t/*float32*/ var linTolSqr = box2d.b2_linearSleepTolerance * box2d.b2_linearSleepTolerance;\r\n\t\t/*float32*/ var angTolSqr = box2d.b2_angularSleepTolerance * box2d.b2_angularSleepTolerance;\r\n\r\n\t\tfor (var i = 0; i < this.m_bodyCount; ++i)\r\n\t\t{\r\n\t\t\t/*box2d.b2Body*/ var b = this.m_bodies[i];\r\n\t\t\tif (b.GetType() === box2d.b2BodyType.b2_staticBody)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif ((b.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === 0 || \r\n\t\t\t\tb.m_angularVelocity * b.m_angularVelocity > angTolSqr || \r\n\t\t\t\tbox2d.b2DotVV(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr)\r\n\t\t\t{\r\n\t\t\t\tb.m_sleepTime = 0;\r\n\t\t\t\tminSleepTime = 0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tb.m_sleepTime += h;\r\n\t\t\t\tminSleepTime = box2d.b2Min(minSleepTime, b.m_sleepTime);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (minSleepTime >= box2d.b2_timeToSleep && positionSolved)\r\n\t\t{\r\n\t\t\tfor (var i = 0; i < this.m_bodyCount; ++i)\r\n\t\t\t{\r\n\t\t\t\t/*box2d.b2Body*/ var b = this.m_bodies[i];\r\n\t\t\t\tb.SetAwake(false);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TimeStep} subStep \r\n * @param {number} toiIndexA \r\n * @param {number} toiIndexB \r\n */\r\nbox2d.b2Island.prototype.SolveTOI = function (subStep, toiIndexA, toiIndexB)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(toiIndexA < this.m_bodyCount); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(toiIndexB < this.m_bodyCount); }\r\n\r\n\t// Initialize the body state.\r\n\tfor (var i = 0; i < this.m_bodyCount; ++i)\r\n\t{\r\n\t\t/*box2d.b2Body*/ var b = this.m_bodies[i];\r\n\t\tthis.m_positions[i].c.Copy(b.m_sweep.c);\r\n\t\tthis.m_positions[i].a = b.m_sweep.a;\r\n\t\tthis.m_velocities[i].v.Copy(b.m_linearVelocity);\r\n\t\tthis.m_velocities[i].w = b.m_angularVelocity;\r\n\t}\r\n\r\n\t/*box2d.b2ContactSolverDef*/ var contactSolverDef = box2d.b2Island.s_contactSolverDef;\r\n\tcontactSolverDef.contacts = this.m_contacts;\r\n\tcontactSolverDef.count = this.m_contactCount;\r\n\tcontactSolverDef.allocator = this.m_allocator;\r\n\tcontactSolverDef.step.Copy(subStep);\r\n\tcontactSolverDef.positions = this.m_positions;\r\n\tcontactSolverDef.velocities = this.m_velocities;\r\n\t/*box2d.b2ContactSolver*/ var contactSolver = box2d.b2Island.s_contactSolver.Initialize(contactSolverDef);\r\n\r\n\t// Solve position constraints.\r\n\tfor (var i = 0; i < subStep.positionIterations; ++i)\r\n\t{\r\n\t\t/*bool*/ var contactsOkay = contactSolver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);\r\n\t\tif (contactsOkay)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n/*\r\n#if 0\r\n\t// Is the new position really safe?\r\n\tfor (int32 i = 0; i < this.m_contactCount; ++i)\r\n\t{\r\n\t\tbox2d.b2Contact* c = this.m_contacts[i];\r\n\t\tbox2d.b2Fixture* fA = c.GetFixtureA();\r\n\t\tbox2d.b2Fixture* fB = c.GetFixtureB();\r\n\r\n\t\tbox2d.b2Body* bA = fA.GetBody();\r\n\t\tbox2d.b2Body* bB = fB.GetBody();\r\n\r\n\t\tint32 indexA = c.GetChildIndexA();\r\n\t\tint32 indexB = c.GetChildIndexB();\r\n\r\n\t\tbox2d.b2DistanceInput input;\r\n\t\tinput.proxyA.Set(fA.GetShape(), indexA);\r\n\t\tinput.proxyB.Set(fB.GetShape(), indexB);\r\n\t\tinput.transformA = bA.GetTransform();\r\n\t\tinput.transformB = bB.GetTransform();\r\n\t\tinput.useRadii = false;\r\n\r\n\t\tbox2d.b2DistanceOutput output;\r\n\t\tbox2d.b2SimplexCache cache;\r\n\t\tcache.count = 0;\r\n\t\tbox2d.b2Distance(&output, &cache, &input);\r\n\r\n\t\tif (output.distance === 0 || cache.count === 3)\r\n\t\t{\r\n\t\t\tcache.count += 0;\r\n\t\t}\r\n\t}\r\n#endif\r\n*/\r\n\r\n\t// Leap of faith to new safe state.\r\n\tthis.m_bodies[toiIndexA].m_sweep.c0.Copy(this.m_positions[toiIndexA].c);\r\n\tthis.m_bodies[toiIndexA].m_sweep.a0 = this.m_positions[toiIndexA].a;\r\n\tthis.m_bodies[toiIndexB].m_sweep.c0.Copy(this.m_positions[toiIndexB].c);\r\n\tthis.m_bodies[toiIndexB].m_sweep.a0 = this.m_positions[toiIndexB].a;\r\n\r\n\t// No warm starting is needed for TOI events because warm\r\n\t// starting impulses were applied in the discrete solver.\r\n\tcontactSolver.InitializeVelocityConstraints();\r\n\r\n\t// Solve velocity constraints.\r\n\tfor (var i = 0; i < subStep.velocityIterations; ++i)\r\n\t{\r\n\t\tcontactSolver.SolveVelocityConstraints();\r\n\t}\r\n\r\n\t// Don't store the TOI contact forces for warm starting\r\n\t// because they can be quite large.\r\n\r\n\t/*float32*/ var h = subStep.dt;\r\n\r\n\t// Integrate positions\r\n\tfor (var i = 0; i < this.m_bodyCount; ++i)\r\n\t{\r\n\t\t/*box2d.b2Vec2&*/ var c = this.m_positions[i].c;\r\n\t\t/*float32*/ var a = this.m_positions[i].a;\r\n\t\t/*box2d.b2Vec2&*/ var v = this.m_velocities[i].v;\r\n\t\t/*float32*/ var w = this.m_velocities[i].w;\r\n\r\n\t\t// Check for large velocities\r\n\t\t/*box2d.b2Vec2*/ var translation = box2d.b2MulSV(h, v, box2d.b2Island.s_translation);\r\n\t\tif (box2d.b2DotVV(translation, translation) > box2d.b2_maxTranslationSquared)\r\n\t\t{\r\n\t\t\t/*float32*/ var ratio = box2d.b2_maxTranslation / translation.GetLength();\r\n\t\t\tv.SelfMul(ratio);\r\n\t\t}\r\n\r\n\t\t/*float32*/ var rotation = h * w;\r\n\t\tif (rotation * rotation > box2d.b2_maxRotationSquared)\r\n\t\t{\r\n\t\t\t/*float32*/ var ratio = box2d.b2_maxRotation / box2d.b2Abs(rotation);\r\n\t\t\tw *= ratio;\r\n\t\t}\r\n\r\n\t\t// Integrate\r\n\t\tc.SelfMulAdd(h, v);\r\n\t\ta += h * w;\r\n\r\n//\t\tthis.m_positions[i].c = c;\r\n\t\tthis.m_positions[i].a = a;\r\n//\t\tthis.m_velocities[i].v = v;\r\n\t\tthis.m_velocities[i].w = w;\r\n\r\n\t\t// Sync bodies\r\n\t\t/*box2d.b2Body*/ var body = this.m_bodies[i];\r\n\t\tbody.m_sweep.c.Copy(c);\r\n\t\tbody.m_sweep.a = a;\r\n\t\tbody.m_linearVelocity.Copy(v);\r\n\t\tbody.m_angularVelocity = w;\r\n\t\tbody.SynchronizeTransform();\r\n\t}\r\n\r\n\tthis.Report(contactSolver.m_velocityConstraints);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {Array.<box2d.b2ContactVelocityConstraint>} constraints\r\n */\r\nbox2d.b2Island.prototype.Report = function (constraints)\r\n{\r\n\tif (this.m_listener === null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor (var i = 0; i < this.m_contactCount; ++i)\r\n\t{\r\n\t\t/** @type {box2d.b2Contact} */ var c = this.m_contacts[i];\r\n\r\n\t\tif (!c) { continue; }\r\n\r\n\t\t/** @type {box2d.b2ContactVelocityConstraint} */ var vc = constraints[i];\r\n\r\n\t\t/*box2d.b2ContactImpulse*/ var impulse = box2d.b2Island.s_impulse;\r\n\t\timpulse.count = vc.pointCount;\r\n\t\tfor (var j = 0; j < vc.pointCount; ++j)\r\n\t\t{\r\n\t\t\timpulse.normalImpulses[j] = vc.points[j].normalImpulse;\r\n\t\t\timpulse.tangentImpulses[j] = vc.points[j].tangentImpulse;\r\n\t\t}\r\n\r\n\t\tthis.m_listener.PostSolve(c, impulse);\r\n\t}\r\n}\r\n\r\nbox2d.b2Island.s_timer = new box2d.b2Timer();\r\nbox2d.b2Island.s_solverData = new box2d.b2SolverData();\r\nbox2d.b2Island.s_contactSolverDef = new box2d.b2ContactSolverDef();\r\nbox2d.b2Island.s_contactSolver = new box2d.b2ContactSolver();\r\nbox2d.b2Island.s_translation = new box2d.b2Vec2();\r\nbox2d.b2Island.s_impulse = new box2d.b2ContactImpulse();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2ContactFactory');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Contact');\r\n\r\n/**\r\n * @export\r\n * @constructor\r\n */\r\nbox2d.b2ContactRegister = function ()\r\n{\r\n};\r\n\r\nbox2d.b2ContactRegister.prototype.createFcn = null;\r\nbox2d.b2ContactRegister.prototype.destroyFcn = null;\r\nbox2d.b2ContactRegister.prototype.primary = false;\r\n\r\n/**\r\n * @export\r\n * @constructor\r\n * @param allocator\r\n */\r\nbox2d.b2ContactFactory = function (allocator)\r\n{\r\n\tthis.m_allocator = allocator;\r\n\tthis.InitializeRegisters();\r\n}\r\n\r\nbox2d.b2ContactFactory.prototype.m_allocator = null;\r\n\r\n/**\r\n * @export\r\n * @return {void}\r\n * @param createFcn\r\n * @param destroyFcn\r\n * @param {box2d.b2ShapeType} type1\r\n * @param {box2d.b2ShapeType} type2\r\n */\r\nbox2d.b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2)\r\n{\r\n\tif (true)\r\n\t{\r\n\t\tvar pool = box2d.b2MakeArray(256, function (i) { return createFcn(); } ); // TODO: b2Settings\r\n\r\n\t\tvar poolCreateFcn = function (allocator)\r\n\t\t{\r\n\t\t\tif (pool.length > 0)\r\n\t\t\t{\r\n\t\t\t\treturn pool.pop();\r\n\t\t\t}\r\n\r\n\t\t\treturn createFcn(allocator);\r\n\t\t}\r\n\r\n\t\tvar poolDestroyFcn = function (contact, allocator)\r\n\t\t{\r\n\t\t\tpool.push(contact);\r\n\t\t}\r\n\r\n\t\tthis.m_registers[type1][type2].pool = pool;\r\n\t\tthis.m_registers[type1][type2].createFcn = poolCreateFcn;\r\n\t\tthis.m_registers[type1][type2].destroyFcn = poolDestroyFcn;\r\n\t\tthis.m_registers[type1][type2].primary = true;\r\n\r\n\t\tif (type1 !== type2)\r\n\t\t{\r\n\t\t\tthis.m_registers[type2][type1].pool = pool;\r\n\t\t\tthis.m_registers[type2][type1].createFcn = poolCreateFcn;\r\n\t\t\tthis.m_registers[type2][type1].destroyFcn = poolDestroyFcn;\r\n\t\t\tthis.m_registers[type2][type1].primary = false;\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\tthis.m_registers[type1][type2].createFcn = createFcn;\r\n\tthis.m_registers[type1][type2].destroyFcn = destroyFcn;\r\n\tthis.m_registers[type1][type2].primary = true;\r\n\r\n\tif (type1 !== type2)\r\n\t{\r\n\t\tthis.m_registers[type2][type1].createFcn = createFcn;\r\n\t\tthis.m_registers[type2][type1].destroyFcn = destroyFcn;\r\n\t\tthis.m_registers[type2][type1].primary = false;\r\n\t}\r\n\t*/\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {void}\r\n */\r\nbox2d.b2ContactFactory.prototype.InitializeRegisters = function ()\r\n{\r\n\tthis.m_registers = new Array(box2d.b2ShapeType.e_shapeTypeCount);\r\n\r\n\tfor (var i = 0; i < box2d.b2ShapeType.e_shapeTypeCount; i++)\r\n\t{\r\n\t\tthis.m_registers[i] = new Array(box2d.b2ShapeType.e_shapeTypeCount);\r\n\r\n\t\tfor (var j = 0; j < box2d.b2ShapeType.e_shapeTypeCount; j++)\r\n\t\t{\r\n\t\t\tthis.m_registers[i][j] = new box2d.b2ContactRegister();\r\n\t\t}\r\n\t}\r\n\r\n\tthis.AddType(box2d.b2CircleContact.Create, box2d.b2CircleContact.Destroy, box2d.b2ShapeType.e_circleShape, box2d.b2ShapeType.e_circleShape);\r\n\tthis.AddType(box2d.b2PolygonAndCircleContact.Create, box2d.b2PolygonAndCircleContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_circleShape);\r\n\tthis.AddType(box2d.b2PolygonContact.Create, box2d.b2PolygonContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_polygonShape);\r\n\tthis.AddType(box2d.b2EdgeAndCircleContact.Create, box2d.b2EdgeAndCircleContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_circleShape);\r\n\tthis.AddType(box2d.b2EdgeAndPolygonContact.Create, box2d.b2EdgeAndPolygonContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_polygonShape);\r\n\tthis.AddType(box2d.b2ChainAndCircleContact.Create, box2d.b2ChainAndCircleContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_circleShape);\r\n\tthis.AddType(box2d.b2ChainAndPolygonContact.Create, box2d.b2ChainAndPolygonContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_polygonShape);\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {box2d.b2Contact}\r\n * @param {box2d.b2Fixture} fixtureA\r\n * @param {number} indexA\r\n * @param {box2d.b2Fixture} fixtureB\r\n * @param {number} indexB\r\n */\r\nbox2d.b2ContactFactory.prototype.Create = function (fixtureA, indexA, fixtureB, indexB)\r\n{\r\n\tvar type1 = fixtureA.GetType();\r\n\tvar type2 = fixtureB.GetType();\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= type1 && type1 < box2d.b2ShapeType.e_shapeTypeCount); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= type2 && type2 < box2d.b2ShapeType.e_shapeTypeCount); }\r\n\r\n\tvar reg = this.m_registers[type1][type2];\r\n\r\n\tvar createFcn = reg.createFcn;\r\n\tif (createFcn !== null)\r\n\t{\r\n\t\tif (reg.primary)\r\n\t\t{\r\n\t\t\tvar c = createFcn(this.m_allocator);\r\n\t\t\tc.Reset(fixtureA, indexA, fixtureB, indexB);\r\n\t\t\treturn c;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar c = createFcn(this.m_allocator);\r\n\t\t\tc.Reset(fixtureB, indexB, fixtureA, indexA);\r\n\t\t\treturn c;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {void}\r\n * @param {box2d.b2Contact} contact\r\n */\r\nbox2d.b2ContactFactory.prototype.Destroy = function (contact)\r\n{\r\n\tvar fixtureA = contact.m_fixtureA;\r\n\tvar fixtureB = contact.m_fixtureB;\r\n\r\n\tif (contact.m_manifold.pointCount > 0 &&\r\n\t\tfixtureA.IsSensor() === false &&\r\n\t\tfixtureB.IsSensor() === false)\r\n\t{\r\n\t\tfixtureA.GetBody().SetAwake(true);\r\n\t\tfixtureB.GetBody().SetAwake(true);\r\n\t}\r\n\r\n\tvar typeA = fixtureA.GetType();\r\n\tvar typeB = fixtureB.GetType();\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= typeA && typeB < box2d.b2ShapeType.e_shapeTypeCount); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= typeA && typeB < box2d.b2ShapeType.e_shapeTypeCount); }\r\n\r\n\tvar reg = this.m_registers[typeA][typeB];\r\n\r\n\tvar destroyFcn = reg.destroyFcn;\r\n\tdestroyFcn(contact, this.m_allocator);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2010 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2GrowableStack');\r\n\r\ngoog.require('box2d.b2Settings');\r\n\r\n/** \r\n * This is a growable LIFO stack with an initial capacity of N. \r\n * If the stack size exceeds the initial capacity, the heap is \r\n * used to increase the size of the stack. \r\n * @export \r\n * @constructor \r\n * @param {number} N \r\n */\r\nbox2d.b2GrowableStack = function (N)\r\n{\r\n\tthis.m_stack = new Array(N);\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {Array.<*>}\r\n */\r\nbox2d.b2GrowableStack.prototype.m_stack = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2GrowableStack.prototype.m_count = 0;\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2GrowableStack}\r\n */\r\nbox2d.b2GrowableStack.prototype.Reset = function ()\r\n{\r\n\tthis.m_count = 0;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {*} element \r\n */\r\nbox2d.b2GrowableStack.prototype.Push = function (element)\r\n{\r\n\tthis.m_stack[this.m_count] = element;\r\n\t++this.m_count;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {*}\r\n */\r\nbox2d.b2GrowableStack.prototype.Pop = function ()\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_count > 0); }\r\n\t--this.m_count;\r\n\tvar element = this.m_stack[this.m_count];\r\n\tthis.m_stack[this.m_count] = null;\r\n\treturn element;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2GrowableStack.prototype.GetCount = function ()\r\n{\r\n\treturn this.m_count;\r\n}\r\n\r\n/*\r\n* Copyright (c) 2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2DynamicTree')\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Collision');\r\ngoog.require('box2d.b2GrowableStack');\r\n\r\n/** \r\n * A node in the dynamic tree. The client does not interact with \r\n * this directly. \r\n * @export \r\n * @constructor \r\n * @param {number=} id \r\n */\r\nbox2d.b2TreeNode = function (id)\r\n{\r\n\tthis.m_id = id || 0;\r\n\r\n\tthis.aabb = new box2d.b2AABB();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2TreeNode.prototype.m_id = 0;\r\n\r\n/** \r\n * Enlarged AABB \r\n * @export \r\n * @type {box2d.b2AABB}\r\n */\r\nbox2d.b2TreeNode.prototype.aabb = null;\r\n\r\n/**\r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2TreeNode.prototype.userData = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2TreeNode}\r\n */\r\nbox2d.b2TreeNode.prototype.parent = null; // or box2d.b2TreeNode.prototype.next\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2TreeNode}\r\n */\r\nbox2d.b2TreeNode.prototype.child1 = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2TreeNode}\r\n */\r\nbox2d.b2TreeNode.prototype.child2 = null;\r\n\r\n/** \r\n * leaf = 0, free node = -1 \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2TreeNode.prototype.height = 0;\r\n\r\n/**\r\n * @export \r\n * @return {boolean} \r\n */\r\nbox2d.b2TreeNode.prototype.IsLeaf = function ()\r\n{\r\n\treturn this.child1 === null;\r\n}\r\n\r\n/** \r\n * A dynamic tree arranges data in a binary tree to accelerate\r\n * queries such as volume queries and ray casts. Leafs are proxies\r\n * with an AABB. In the tree we expand the proxy AABB by b2_fatAABBFactor\r\n * so that the proxy AABB is bigger than the client object. This allows the client\r\n * object to move by small amounts without triggering a tree update.\r\n *\r\n * Nodes are pooled and relocatable, so we use node indices rather than pointers.\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2DynamicTree = function ()\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2TreeNode}\r\n */\r\nbox2d.b2DynamicTree.prototype.m_root = null;\r\n\r\n//b2TreeNode* box2d.b2DynamicTree.prototype.m_nodes;\r\n//int32 box2d.b2DynamicTree.prototype.m_nodeCount;\r\n//int32 box2d.b2DynamicTree.prototype.m_nodeCapacity;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2TreeNode}\r\n */\r\nbox2d.b2DynamicTree.prototype.m_freeList = null;\r\n\r\n/** \r\n * This is used to incrementally traverse the tree for \r\n * re-balancing. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DynamicTree.prototype.m_path = 0;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DynamicTree.prototype.m_insertionCount = 0;\r\n\r\nbox2d.b2DynamicTree.s_stack = new box2d.b2GrowableStack(256);\r\nbox2d.b2DynamicTree.s_r = new box2d.b2Vec2();\r\nbox2d.b2DynamicTree.s_v = new box2d.b2Vec2();\r\nbox2d.b2DynamicTree.s_abs_v = new box2d.b2Vec2();\r\nbox2d.b2DynamicTree.s_segmentAABB = new box2d.b2AABB();\r\nbox2d.b2DynamicTree.s_subInput = new box2d.b2RayCastInput();\r\nbox2d.b2DynamicTree.s_combinedAABB = new box2d.b2AABB();\r\nbox2d.b2DynamicTree.s_aabb = new box2d.b2AABB();\r\n\r\n/** \r\n * Get proxy user data. \r\n * @export \r\n * @return {*} the proxy user data or 0 if the id is invalid.\r\n * @param {box2d.b2TreeNode} proxy\r\n */\r\nbox2d.b2DynamicTree.prototype.GetUserData = function (proxy)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxy !== null); }\r\n\treturn proxy.userData;\r\n}\r\n\r\n/** \r\n * Get the fat AABB for a proxy. \r\n * @export \r\n * @return {box2d.b2AABB} \r\n * @param {box2d.b2TreeNode} proxy \r\n */\r\nbox2d.b2DynamicTree.prototype.GetFatAABB = function (proxy)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxy !== null); }\r\n\treturn proxy.aabb;\r\n}\r\n\r\n/** \r\n * Query an AABB for overlapping proxies. The callback class is \r\n * called for each proxy that overlaps the supplied AABB. \r\n * @export \r\n * @return {void} \r\n * @param {function(!box2d.b2TreeNode): boolean} callback\r\n * @param {box2d.b2AABB} aabb \r\n */\r\nbox2d.b2DynamicTree.prototype.Query = function (callback, aabb)\r\n{\r\n\tif (this.m_root === null) return;\r\n\r\n\t/** @type {box2d.b2GrowableStack} */ var stack = box2d.b2DynamicTree.s_stack.Reset();\r\n\tstack.Push(this.m_root);\r\n\r\n\twhile (stack.GetCount() > 0)\r\n\t{\r\n\t\t/** @type {box2d.b2TreeNode} */ var node = /** @type {box2d.b2TreeNode} */ (stack.Pop());\r\n\t\tif (node === null)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (node.aabb.TestOverlap(aabb))\r\n\t\t{\r\n\t\t\tif (node.IsLeaf())\r\n\t\t\t{\r\n\t\t\t\t/** @type {boolean} */ var proceed = callback(node);\r\n\t\t\t\tif (proceed === false)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstack.Push(node.child1);\r\n\t\t\t\tstack.Push(node.child2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Ray-cast against the proxies in the tree. This relies on the callback\r\n * to perform a exact ray-cast in the case were the proxy contains a shape.\r\n * The callback also performs the any collision filtering. This has performance\r\n * roughly equal to k * log(n), where k is the number of collisions and n is the\r\n * number of proxies in the tree.\r\n * @export \r\n * @return {void} \r\n * @param {function(!box2d.b2RayCastInput, !box2d.b2TreeNode): number} callback a callback class that is called for each proxy that is hit by the ray.\r\n * @param {box2d.b2RayCastInput} input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).\r\n */\r\nbox2d.b2DynamicTree.prototype.RayCast = function (callback, input)\r\n{\r\n\tif (this.m_root === null) return;\r\n\r\n\t/** @type {box2d.b2Vec2} */ var p1 = input.p1;\r\n\t/** @type {box2d.b2Vec2} */ var p2 = input.p2;\r\n\t/** @type {box2d.b2Vec2} */ var r = box2d.b2SubVV(p2, p1, box2d.b2DynamicTree.s_r);\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(r.GetLengthSquared() > 0); }\r\n\tr.Normalize();\r\n\r\n\t// v is perpendicular to the segment.\r\n\t/** @type {box2d.b2Vec2} */ var v = box2d.b2CrossOneV(r, box2d.b2DynamicTree.s_v);\r\n\t/** @type {box2d.b2Vec2} */ var abs_v = box2d.b2AbsV(v, box2d.b2DynamicTree.s_abs_v);\r\n\r\n\t// Separating axis for segment (Gino, p80).\r\n\t// |dot(v, p1 - c)| > dot(|v|, h)\r\n\r\n\t/** @type {number} */ var maxFraction = input.maxFraction;\r\n\r\n\t// Build a bounding box for the segment.\r\n\t/** @type {box2d.b2AABB} */ var segmentAABB = box2d.b2DynamicTree.s_segmentAABB;\r\n\t/** @type {number} */ var t_x = p1.x + maxFraction * (p2.x - p1.x);\r\n\t/** @type {number} */ var t_y = p1.y + maxFraction * (p2.y - p1.y);\r\n\tsegmentAABB.lowerBound.x = box2d.b2Min(p1.x, t_x);\r\n\tsegmentAABB.lowerBound.y = box2d.b2Min(p1.y, t_y);\r\n\tsegmentAABB.upperBound.x = box2d.b2Max(p1.x, t_x);\r\n\tsegmentAABB.upperBound.y = box2d.b2Max(p1.y, t_y);\r\n\r\n\t/** @type {box2d.b2GrowableStack} */ var stack = box2d.b2DynamicTree.s_stack.Reset();\r\n\tstack.Push(this.m_root);\r\n\r\n\twhile (stack.GetCount() > 0)\r\n\t{\r\n\t\t/** @type {box2d.b2TreeNode} */ var node = /** @type {box2d.b2TreeNode} */ (stack.Pop());\r\n\t\tif (node === null)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (box2d.b2TestOverlapAABB(node.aabb, segmentAABB) === false)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// Separating axis for segment (Gino, p80).\r\n\t\t// |dot(v, p1 - c)| > dot(|v|, h)\r\n\t\t/** @type {box2d.b2Vec2} */ var c = node.aabb.GetCenter();\r\n\t\t/** @type {box2d.b2Vec2} */ var h = node.aabb.GetExtents();\r\n\t\t/** @type {number} */ var separation = box2d.b2Abs(box2d.b2DotVV(v, box2d.b2SubVV(p1, c, box2d.b2Vec2.s_t0))) - box2d.b2DotVV(abs_v, h);\r\n\t\tif (separation > 0)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (node.IsLeaf())\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2RayCastInput} */ var subInput = box2d.b2DynamicTree.s_subInput;\r\n\t\t\tsubInput.p1.Copy(input.p1);\r\n\t\t\tsubInput.p2.Copy(input.p2);\r\n\t\t\tsubInput.maxFraction = maxFraction;\r\n\r\n\t\t\t/** @type {number} */ var value = callback(subInput, node);\r\n\r\n\t\t\tif (value === 0)\r\n\t\t\t{\r\n\t\t\t\t// The client has terminated the ray cast.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (value > 0)\r\n\t\t\t{\r\n\t\t\t\t// Update segment bounding box.\r\n\t\t\t\tmaxFraction = value;\r\n\t\t\t\tt_x = p1.x + maxFraction * (p2.x - p1.x);\r\n\t\t\t\tt_y = p1.y + maxFraction * (p2.y - p1.y);\r\n\t\t\t\tsegmentAABB.lowerBound.x = box2d.b2Min(p1.x, t_x);\r\n\t\t\t\tsegmentAABB.lowerBound.y = box2d.b2Min(p1.y, t_y);\r\n\t\t\t\tsegmentAABB.upperBound.x = box2d.b2Max(p1.x, t_x);\r\n\t\t\t\tsegmentAABB.upperBound.y = box2d.b2Max(p1.y, t_y);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstack.Push(node.child1);\r\n\t\t\tstack.Push(node.child2);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2TreeNode}\r\n */\r\nbox2d.b2DynamicTree.prototype.AllocateNode = function ()\r\n{\r\n\t// Expand the node pool as needed.\r\n\tif (this.m_freeList)\r\n\t{\r\n\t\t/** @type {box2d.b2TreeNode} */ var node = this.m_freeList;\r\n\t\tthis.m_freeList = node.parent; // this.m_freeList = node.next;\r\n\t\tnode.parent = null;\r\n\t\tnode.child1 = null;\r\n\t\tnode.child2 = null;\r\n\t\tnode.height = 0;\r\n\t\tnode.userData = null;\r\n\t\treturn node;\r\n\t}\r\n\r\n\treturn new box2d.b2TreeNode(box2d.b2DynamicTree.prototype.s_node_id++);\r\n}\r\nbox2d.b2DynamicTree.prototype.s_node_id = 0;\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} node\r\n */\r\nbox2d.b2DynamicTree.prototype.FreeNode = function (node)\r\n{\r\n\tnode.parent = this.m_freeList; // node.next = this.m_freeList;\r\n\tnode.height = -1;\r\n\tthis.m_freeList = node;\r\n}\r\n\r\n/** \r\n * Create a proxy. Provide a tight fitting AABB and a userData \r\n * pointer. \r\n * @export \r\n * @return {box2d.b2TreeNode}\r\n * @param {box2d.b2AABB} aabb \r\n * @param {*} userData \r\n */\r\nbox2d.b2DynamicTree.prototype.CreateProxy = function (aabb, userData)\r\n{\r\n\t/** @type {box2d.b2TreeNode} */ var node = this.AllocateNode();\r\n\r\n\t// Fatten the aabb.\r\n\t/** @type {number} */ var r_x = box2d.b2_aabbExtension;\r\n\t/** @type {number} */ var r_y = box2d.b2_aabbExtension;\r\n\tnode.aabb.lowerBound.x = aabb.lowerBound.x - r_x;\r\n\tnode.aabb.lowerBound.y = aabb.lowerBound.y - r_y;\r\n\tnode.aabb.upperBound.x = aabb.upperBound.x + r_x;\r\n\tnode.aabb.upperBound.y = aabb.upperBound.y + r_y;\r\n\tnode.userData = userData;\r\n\tnode.height = 0;\r\n\r\n\tthis.InsertLeaf(node);\r\n\r\n\treturn node;\r\n}\r\n\r\n/** \r\n * Destroy a proxy. This asserts if the id is invalid. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} proxy\r\n */\r\nbox2d.b2DynamicTree.prototype.DestroyProxy = function (proxy)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxy.IsLeaf()); }\r\n\r\n\tthis.RemoveLeaf(proxy);\r\n\tthis.FreeNode(proxy);\r\n}\r\n\r\n/** \r\n * Move a proxy with a swepted AABB. If the proxy has moved \r\n * outside of its fattened AABB, then the proxy is removed from \r\n * the tree and re-inserted. Otherwise the function returns \r\n * immediately. \r\n * @export \r\n * @return {boolean} true if the proxy was re-inserted.\r\n * @param {box2d.b2TreeNode} proxy\r\n * @param {box2d.b2AABB} aabb \r\n * @param {box2d.b2Vec2} displacement \r\n */\r\nbox2d.b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxy.IsLeaf()); }\r\n\r\n\tif (proxy.aabb.Contains(aabb))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tthis.RemoveLeaf(proxy);\r\n\r\n\t// Extend AABB.\r\n\t// Predict AABB displacement.\r\n\t/** @type {number} */ var r_x = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));\r\n\t/** @type {number} */ var r_y = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));\r\n\tproxy.aabb.lowerBound.x = aabb.lowerBound.x - r_x;\r\n\tproxy.aabb.lowerBound.y = aabb.lowerBound.y - r_y;\r\n\tproxy.aabb.upperBound.x = aabb.upperBound.x + r_x;\r\n\tproxy.aabb.upperBound.y = aabb.upperBound.y + r_y;\r\n\r\n\tthis.InsertLeaf(proxy);\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} leaf\r\n */\r\nbox2d.b2DynamicTree.prototype.InsertLeaf = function (leaf)\r\n{\r\n\t++this.m_insertionCount;\r\n\r\n\tif (this.m_root === null)\r\n\t{\r\n\t\tthis.m_root = leaf;\r\n\t\tthis.m_root.parent = null;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Find the best sibling for this node\r\n\t/** @type {box2d.b2AABB} */ var leafAABB = leaf.aabb;\r\n\t/** @type {box2d.b2Vec2} */ var center = leafAABB.GetCenter();\r\n\t/** @type {box2d.b2TreeNode} */ var index = this.m_root;\r\n\t/** @type {box2d.b2TreeNode} */ var child1;\r\n\t/** @type {box2d.b2TreeNode} */ var child2;\r\n\twhile (index.IsLeaf() === false)\r\n\t{\r\n\t\tchild1 = index.child1;\r\n\t\tchild2 = index.child2;\r\n\r\n\t\t/** @type {number} */ var area = index.aabb.GetPerimeter();\r\n\r\n\t\t/** @type {box2d.b2AABB} */ var combinedAABB = box2d.b2DynamicTree.s_combinedAABB;\r\n\t\tcombinedAABB.Combine2(index.aabb, leafAABB);\r\n\t\t/** @type {number} */ var combinedArea = combinedAABB.GetPerimeter();\r\n\r\n\t\t// Cost of creating a new parent for this node and the new leaf\r\n\t\t/** @type {number} */ var cost = 2 * combinedArea;\r\n\r\n\t\t// Minimum cost of pushing the leaf further down the tree\r\n\t\t/** @type {number} */ var inheritanceCost = 2 * (combinedArea - area);\r\n\r\n\t\t// Cost of descending into child1\r\n\t\t/** @type {number} */ var cost1;\r\n\t\t/** @type {box2d.b2AABB} */ var aabb = box2d.b2DynamicTree.s_aabb;\r\n\t\t/** @type {number} */ var oldArea;\r\n\t\t/** @type {number} */ var newArea;\r\n\t\tif (child1.IsLeaf())\r\n\t\t{\r\n\t\t\taabb.Combine2(leafAABB, child1.aabb);\r\n\t\t\tcost1 = aabb.GetPerimeter() + inheritanceCost;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\taabb.Combine2(leafAABB, child1.aabb);\r\n\t\t\toldArea = child1.aabb.GetPerimeter();\r\n\t\t\tnewArea = aabb.GetPerimeter();\r\n\t\t\tcost1 = (newArea - oldArea) + inheritanceCost;\r\n\t\t}\r\n\r\n\t\t// Cost of descending into child2\r\n\t\t/** @type {number} */ var cost2;\r\n\t\tif (child2.IsLeaf())\r\n\t\t{\r\n\t\t\taabb.Combine2(leafAABB, child2.aabb);\r\n\t\t\tcost2 = aabb.GetPerimeter() + inheritanceCost;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\taabb.Combine2(leafAABB, child2.aabb);\r\n\t\t\toldArea = child2.aabb.GetPerimeter();\r\n\t\t\tnewArea = aabb.GetPerimeter();\r\n\t\t\tcost2 = newArea - oldArea + inheritanceCost;\r\n\t\t}\r\n\r\n\t\t// Descend according to the minimum cost.\r\n\t\tif (cost < cost1 && cost < cost2)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Descend\r\n\t\tif (cost1 < cost2)\r\n\t\t{\r\n\t\t\tindex = child1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tindex = child2;\r\n\t\t}\r\n\t}\r\n\r\n\t/** @type {box2d.b2TreeNode} */ var sibling = index;\r\n\r\n\t// Create a parent for the siblings.\r\n\t/** @type {box2d.b2TreeNode} */ var oldParent = sibling.parent;\r\n\t/** @type {box2d.b2TreeNode} */ var newParent = this.AllocateNode();\r\n\tnewParent.parent = oldParent;\r\n\tnewParent.userData = null;\r\n\tnewParent.aabb.Combine2(leafAABB, sibling.aabb);\r\n\tnewParent.height = sibling.height + 1;\r\n\r\n\tif (oldParent)\r\n\t{\r\n\t\t// The sibling was not the root.\r\n\t\tif (oldParent.child1 === sibling)\r\n\t\t{\r\n\t\t\toldParent.child1 = newParent;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toldParent.child2 = newParent;\r\n\t\t}\r\n\r\n\t\tnewParent.child1 = sibling;\r\n\t\tnewParent.child2 = leaf;\r\n\t\tsibling.parent = newParent;\r\n\t\tleaf.parent = newParent;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// The sibling was the root.\r\n\t\tnewParent.child1 = sibling;\r\n\t\tnewParent.child2 = leaf;\r\n\t\tsibling.parent = newParent;\r\n\t\tleaf.parent = newParent;\r\n\t\tthis.m_root = newParent;\r\n\t}\r\n\r\n\t// Walk back up the tree fixing heights and AABBs\r\n\tindex = leaf.parent;\r\n\twhile (index !== null)\r\n\t{\r\n\t\tindex = this.Balance(index);\r\n\r\n\t\tchild1 = index.child1;\r\n\t\tchild2 = index.child2;\r\n\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child1 !== null); }\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child2 !== null); }\r\n\r\n\t\tindex.height = 1 + box2d.b2Max(child1.height, child2.height);\r\n\t\tindex.aabb.Combine2(child1.aabb, child2.aabb);\r\n\r\n\t\tindex = index.parent;\r\n\t}\r\n\r\n\t//this.Validate();\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} leaf\r\n */\r\nbox2d.b2DynamicTree.prototype.RemoveLeaf = function (leaf)\r\n{\r\n\tif (leaf === this.m_root)\r\n\t{\r\n\t\tthis.m_root = null;\r\n\t\treturn;\r\n\t}\r\n\r\n\t/** @type {box2d.b2TreeNode} */ var parent = leaf.parent;\r\n\t/** @type {box2d.b2TreeNode} */ var grandParent = parent.parent;\r\n\t/** @type {box2d.b2TreeNode} */ var sibling;\r\n\tif (parent.child1 === leaf)\r\n\t{\r\n\t\tsibling = parent.child2;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsibling = parent.child1;\r\n\t}\r\n\r\n\tif (grandParent)\r\n\t{\r\n\t\t// Destroy parent and connect sibling to grandParent.\r\n\t\tif (grandParent.child1 === parent)\r\n\t\t{\r\n\t\t\tgrandParent.child1 = sibling;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tgrandParent.child2 = sibling;\r\n\t\t}\r\n\t\tsibling.parent = grandParent;\r\n\t\tthis.FreeNode(parent);\r\n\r\n\t\t// Adjust ancestor bounds.\r\n\t\t/** @type {box2d.b2TreeNode} */ var index = grandParent;\r\n\t\twhile (index)\r\n\t\t{\r\n\t\t\tindex = this.Balance(index);\r\n\r\n\t\t\t/** @type {box2d.b2TreeNode} */ var child1 = index.child1;\r\n\t\t\t/** @type {box2d.b2TreeNode} */ var child2 = index.child2;\r\n\r\n\t\t\tindex.aabb.Combine2(child1.aabb, child2.aabb);\r\n\t\t\tindex.height = 1 + box2d.b2Max(child1.height, child2.height);\r\n\r\n\t\t\tindex = index.parent;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_root = sibling;\r\n\t\tsibling.parent = null;\r\n\t\tthis.FreeNode(parent);\r\n\t}\r\n\r\n\t//this.Validate();\r\n}\r\n\r\n/**\r\n * Perform a left or right rotation if node A is imbalanced.\r\n * Returns the new root index.\r\n * @export \r\n * @param {box2d.b2TreeNode} A \r\n * @return {box2d.b2TreeNode} \r\n */\r\nbox2d.b2DynamicTree.prototype.Balance = function (A)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(A !== null); }\r\n\r\n\tif (A.IsLeaf() || A.height < 2)\r\n\t{\r\n\t\treturn A;\r\n\t}\r\n\r\n\t/** @type {box2d.b2TreeNode} */ var B = A.child1;\r\n\t/** @type {box2d.b2TreeNode} */ var C = A.child2;\r\n\r\n\t/** @type {number} */ var balance = C.height - B.height;\r\n\r\n\t// Rotate C up\r\n\tif (balance > 1)\r\n\t{\r\n\t\t/** @type {box2d.b2TreeNode} */ var F = C.child1;\r\n\t\t/** @type {box2d.b2TreeNode} */ var G = C.child2;\r\n\r\n\t\t// Swap A and C\r\n\t\tC.child1 = A;\r\n\t\tC.parent = A.parent;\r\n\t\tA.parent = C;\r\n\r\n\t\t// A's old parent should point to C\r\n\t\tif (C.parent !== null)\r\n\t\t{\r\n\t\t\tif (C.parent.child1 === A)\r\n\t\t\t{\r\n\t\t\t\tC.parent.child1 = C;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(C.parent.child2 === A); }\r\n\t\t\t\tC.parent.child2 = C;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_root = C;\r\n\t\t}\r\n\r\n\t\t// Rotate\r\n\t\tif (F.height > G.height)\r\n\t\t{\r\n\t\t\tC.child2 = F;\r\n\t\t\tA.child2 = G;\r\n\t\t\tG.parent = A;\r\n\t\t\tA.aabb.Combine2(B.aabb, G.aabb);\r\n\t\t\tC.aabb.Combine2(A.aabb, F.aabb);\r\n\r\n\t\t\tA.height = 1 + box2d.b2Max(B.height, G.height);\r\n\t\t\tC.height = 1 + box2d.b2Max(A.height, F.height);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tC.child2 = G;\r\n\t\t\tA.child2 = F;\r\n\t\t\tF.parent = A;\r\n\t\t\tA.aabb.Combine2(B.aabb, F.aabb);\r\n\t\t\tC.aabb.Combine2(A.aabb, G.aabb);\r\n\r\n\t\t\tA.height = 1 + box2d.b2Max(B.height, F.height);\r\n\t\t\tC.height = 1 + box2d.b2Max(A.height, G.height);\r\n\t\t}\r\n\r\n\t\treturn C;\r\n\t}\r\n\t\r\n\t// Rotate B up\r\n\tif (balance < -1)\r\n\t{\r\n\t\t/** @type {box2d.b2TreeNode} */ var D = B.child1;\r\n\t\t/** @type {box2d.b2TreeNode} */ var E = B.child2;\r\n\r\n\t\t// Swap A and B\r\n\t\tB.child1 = A;\r\n\t\tB.parent = A.parent;\r\n\t\tA.parent = B;\r\n\r\n\t\t// A's old parent should point to B\r\n\t\tif (B.parent !== null)\r\n\t\t{\r\n\t\t\tif (B.parent.child1 === A)\r\n\t\t\t{\r\n\t\t\t\tB.parent.child1 = B;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(B.parent.child2 === A); }\r\n\t\t\t\tB.parent.child2 = B;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_root = B;\r\n\t\t}\r\n\r\n\t\t// Rotate\r\n\t\tif (D.height > E.height)\r\n\t\t{\r\n\t\t\tB.child2 = D;\r\n\t\t\tA.child1 = E;\r\n\t\t\tE.parent = A;\r\n\t\t\tA.aabb.Combine2(C.aabb, E.aabb);\r\n\t\t\tB.aabb.Combine2(A.aabb, D.aabb);\r\n\r\n\t\t\tA.height = 1 + box2d.b2Max(C.height, E.height);\r\n\t\t\tB.height = 1 + box2d.b2Max(A.height, D.height);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tB.child2 = E;\r\n\t\t\tA.child1 = D;\r\n\t\t\tD.parent = A;\r\n\t\t\tA.aabb.Combine2(C.aabb, D.aabb);\r\n\t\t\tB.aabb.Combine2(A.aabb, E.aabb);\r\n\r\n\t\t\tA.height = 1 + box2d.b2Max(C.height, D.height);\r\n\t\t\tB.height = 1 + box2d.b2Max(A.height, E.height);\r\n\t\t}\r\n\r\n\t\treturn B;\r\n\t}\r\n\r\n\treturn A;\r\n}\r\n\r\n/** \r\n * Compute the height of the binary tree in O(N) time. Should \r\n * not be called often. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2DynamicTree.prototype.GetHeight = function ()\r\n{\r\n\tif (this.m_root === null)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\r\n\treturn this.m_root.height;\r\n}\r\n\r\n/** \r\n * Get the ratio of the sum of the node areas to the root area. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2DynamicTree.prototype.GetAreaRatio = function ()\r\n{\r\n\tif (this.m_root === null)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/** @type {box2d.b2TreeNode} */ var root = this.m_root;\r\n\t/** @type {number} */ var rootArea = root.aabb.GetPerimeter();\r\n\r\n\tvar GetAreaNode = function (node)\r\n\t{\r\n\t\tif (node === null)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tif (node.IsLeaf())\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t/** @type {number} */ var area = node.aabb.GetPerimeter();\r\n\t\tarea += GetAreaNode(node.child1);\r\n\t\tarea += GetAreaNode(node.child2);\r\n\t\treturn area;\r\n\t}\r\n\t/** @type {number} */ var totalArea = GetAreaNode(this.m_root);\r\n\r\n\t/*\r\n\tfloat32 totalArea = 0.0;\r\n\tfor (int32 i = 0; i < m_nodeCapacity; ++i)\r\n\t{\r\n\t\tconst b2TreeNode* node = m_nodes + i;\r\n\t\tif (node.height < 0)\r\n\t\t{\r\n\t\t\t// Free node in pool\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\ttotalArea += node.aabb.GetPerimeter();\r\n\t}\r\n\t*/\r\n\r\n\treturn totalArea / rootArea;\r\n}\r\n\r\n/** \r\n * Compute the height of a sub-tree. \r\n * @export \r\n * @return {number} \r\n * @param {box2d.b2TreeNode} node \r\n */\r\nbox2d.b2DynamicTree.prototype.ComputeHeightNode = function (node)\r\n{\r\n\tif (node.IsLeaf())\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/** @type {number} */ var height1 = this.ComputeHeightNode(node.child1);\r\n\t/** @type {number} */ var height2 = this.ComputeHeightNode(node.child2);\r\n\treturn 1 + box2d.b2Max(height1, height2);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2DynamicTree.prototype.ComputeHeight = function ()\r\n{\r\n\t/** @type {number} */ var height = this.ComputeHeightNode(this.m_root);\r\n\treturn height;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} index \r\n */\r\nbox2d.b2DynamicTree.prototype.ValidateStructure = function (index)\r\n{\r\n\tif (index === null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (index === this.m_root)\r\n\t{\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(index.parent === null); }\r\n\t}\r\n\r\n\t/** @type {box2d.b2TreeNode} */ var node = index;\r\n\r\n\t/** @type {box2d.b2TreeNode} */ var child1 = node.child1;\r\n\t/** @type {box2d.b2TreeNode} */ var child2 = node.child2;\r\n\r\n\tif (node.IsLeaf())\r\n\t{\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child1 === null); }\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child2 === null); }\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.height === 0); }\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child1.parent === index); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child2.parent === index); }\r\n\r\n\tthis.ValidateStructure(child1);\r\n\tthis.ValidateStructure(child2);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} index\r\n */\r\nbox2d.b2DynamicTree.prototype.ValidateMetrics = function (index)\r\n{\r\n\tif (index === null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t/** @type {box2d.b2TreeNode} */ var node = index;\r\n\r\n\t/** @type {box2d.b2TreeNode} */ var child1 = node.child1;\r\n\t/** @type {box2d.b2TreeNode} */ var child2 = node.child2;\r\n\r\n\tif (node.IsLeaf())\r\n\t{\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child1 === null); }\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(child2 === null); }\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.height === 0); }\r\n\t\treturn;\r\n\t}\r\n\r\n\t/** @type {number} */ var height1 = child1.height;\r\n\t/** @type {number} */ var height2 = child2.height;\r\n\t/** @type {number} */ var height;\r\n\theight = 1 + box2d.b2Max(height1, height2);\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.height === height); }\r\n\r\n\t/** @type {box2d.b2AABB} */ var aabb = box2d.b2DynamicTree.s_aabb;\r\n\taabb.Combine2(child1.aabb, child2.aabb);\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(aabb.lowerBound === node.aabb.lowerBound); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(aabb.upperBound === node.aabb.upperBound); }\r\n\r\n\tthis.ValidateMetrics(child1);\r\n\tthis.ValidateMetrics(child2);\r\n}\r\n\r\n/** \r\n * Validate this tree. For testing. \r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2DynamicTree.prototype.Validate = function ()\r\n{\r\n\tthis.ValidateStructure(this.m_root);\r\n\tthis.ValidateMetrics(this.m_root);\r\n\r\n\t/** @type {number} */ var freeCount = 0;\r\n\t/** @type {box2d.b2TreeNode} */ var freeIndex = this.m_freeList;\r\n\twhile (freeIndex !== null)\r\n\t{\r\n\t\tfreeIndex = freeIndex.parent; //freeIndex = freeIndex.next;\r\n\t\t++freeCount;\r\n\t}\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.GetHeight() === this.ComputeHeight()); }\r\n}\r\n\r\n/** \r\n * Get the maximum balance of an node in the tree. The balance \r\n * is the difference in height of the two children of a node. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2DynamicTree.prototype.GetMaxBalance = function ()\r\n{\r\n\tvar GetMaxBalanceNode = function (node, maxBalance)\r\n\t{\r\n\t\tif (node === null)\r\n\t\t{\r\n\t\t\treturn maxBalance;\r\n\t\t}\r\n\r\n\t\tif (node.height <= 1)\r\n\t\t{\r\n\t\t\treturn maxBalance;\r\n\t\t}\r\n\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.IsLeaf() === false); }\r\n\r\n\t\t/** @type {box2d.b2TreeNode} */ var child1 = node.child1;\r\n\t\t/** @type {box2d.b2TreeNode} */ var child2 = node.child2;\r\n\t\t/** @type {number} */ var balance = box2d.b2Abs(child2.height - child1.height);\r\n\t\treturn box2d.b2Max(maxBalance, balance);\r\n\t}\r\n\r\n\t/** @type {number} */ var maxBalance = GetMaxBalanceNode(this.m_root, 0);\r\n\r\n\t/*\r\n\tint32 maxBalance = 0;\r\n\tfor (int32 i = 0; i < m_nodeCapacity; ++i)\r\n\t{\r\n\t\tconst b2TreeNode* node = m_nodes + i;\r\n\t\tif (node.height <= 1)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tb2Assert(node.IsLeaf() === false);\r\n\r\n\t\tint32 child1 = node.child1;\r\n\t\tint32 child2 = node.child2;\r\n\t\tint32 balance = b2Abs(m_nodes[child2].height - m_nodes[child1].height);\r\n\t\tmaxBalance = b2Max(maxBalance, balance);\r\n\t}\r\n\t*/\r\n\r\n\treturn maxBalance;\r\n}\r\n\r\n/** \r\n * Build an optimal tree. Very expensive. For testing. \r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2DynamicTree.prototype.RebuildBottomUp = function ()\r\n{\r\n\t/* \r\n\tint32* nodes = (int32*)b2Alloc(m_nodeCount * sizeof(int32));\r\n\tint32 count = 0;\r\n\r\n\t// Build array of leaves. Free the rest.\r\n\tfor (int32 i = 0; i < m_nodeCapacity; ++i)\r\n\t{\r\n\t\tif (m_nodes[i].height < 0)\r\n\t\t{\r\n\t\t\t// free node in pool\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (m_nodes[i].IsLeaf())\r\n\t\t{\r\n\t\t\tm_nodes[i].parent = b2_nullNode;\r\n\t\t\tnodes[count] = i;\r\n\t\t\t++count;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tFreeNode(i);\r\n\t\t}\r\n\t}\r\n\r\n\twhile (count > 1)\r\n\t{\r\n\t\tfloat32 minCost = b2_maxFloat;\r\n\t\tint32 iMin = -1, jMin = -1;\r\n\t\tfor (int32 i = 0; i < count; ++i)\r\n\t\t{\r\n\t\t\tb2AABB aabbi = m_nodes[nodes[i]].aabb;\r\n\r\n\t\t\tfor (int32 j = i + 1; j < count; ++j)\r\n\t\t\t{\r\n\t\t\t\tb2AABB aabbj = m_nodes[nodes[j]].aabb;\r\n\t\t\t\tb2AABB b;\r\n\t\t\t\tb.Combine(aabbi, aabbj);\r\n\t\t\t\tfloat32 cost = b.GetPerimeter();\r\n\t\t\t\tif (cost < minCost)\r\n\t\t\t\t{\r\n\t\t\t\t\tiMin = i;\r\n\t\t\t\t\tjMin = j;\r\n\t\t\t\t\tminCost = cost;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint32 index1 = nodes[iMin];\r\n\t\tint32 index2 = nodes[jMin];\r\n\t\tb2TreeNode* child1 = m_nodes + index1;\r\n\t\tb2TreeNode* child2 = m_nodes + index2;\r\n\r\n\t\tint32 parentIndex = AllocateNode();\r\n\t\tb2TreeNode* parent = m_nodes + parentIndex;\r\n\t\tparent.child1 = index1;\r\n\t\tparent.child2 = index2;\r\n\t\tparent.height = 1 + b2Max(child1.height, child2.height);\r\n\t\tparent.aabb.Combine(child1.aabb, child2.aabb);\r\n\t\tparent.parent = b2_nullNode;\r\n\r\n\t\tchild1.parent = parentIndex;\r\n\t\tchild2.parent = parentIndex;\r\n\r\n\t\tnodes[jMin] = nodes[count-1];\r\n\t\tnodes[iMin] = parentIndex;\r\n\t\t--count;\r\n\t}\r\n\r\n\tm_root = nodes[0];\r\n\tb2Free(nodes);\r\n\t*/\r\n\r\n\tthis.Validate();\r\n}\r\n\r\n/**\r\n * Shift the world origin. Useful for large worlds.\r\n * The shift formula is: position -= newOrigin\r\n * @export \r\n * @param {box2d.b2Vec2} newOrigin the new origin with respect to the old origin\r\n * @return {void} \r\n */\r\nbox2d.b2DynamicTree.prototype.ShiftOrigin = function (newOrigin)\r\n{\r\n\tvar ShiftOriginNode = function (node, newOrigin)\r\n\t{\r\n\t\tif (node === null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (node.height <= 1)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(node.IsLeaf() === false); }\r\n\r\n\t\t/** @type {box2d.b2TreeNode} */ var child1 = node.child1;\r\n\t\t/** @type {box2d.b2TreeNode} */ var child2 = node.child2;\r\n\t\tShiftOriginNode(child1, newOrigin);\r\n\t\tShiftOriginNode(child2, newOrigin);\r\n\r\n\t\tnode.aabb.lowerBound.SelfSub(newOrigin);\r\n\t\tnode.aabb.upperBound.SelfSub(newOrigin);\r\n\t}\r\n\r\n\tShiftOriginNode(this.m_root, newOrigin);\r\n\r\n\t/*\r\n\t// Build array of leaves. Free the rest.\r\n\tfor (int32 i = 0; i < m_nodeCapacity; ++i)\r\n\t{\r\n\t\tm_nodes[i].aabb.lowerBound -= newOrigin;\r\n\t\tm_nodes[i].aabb.upperBound -= newOrigin;\r\n\t}\r\n\t*/\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2BroadPhase')\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2DynamicTree')\r\n\r\n/** \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Pair = function ()\r\n{\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2TreeNode}\r\n */\r\nbox2d.b2Pair.prototype.proxyA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2TreeNode}\r\n */\r\nbox2d.b2Pair.prototype.proxyB = null;\r\n\r\n/** \r\n * The broad-phase is used for computing pairs and performing \r\n * volume queries and ray casts. This broad-phase does not \r\n * persist pairs. Instead, this reports potentially new pairs. \r\n * It is up to the client to consume the new pairs and to track \r\n * subsequent overlap. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2BroadPhase = function ()\r\n{\r\n\tthis.m_tree = new box2d.b2DynamicTree();\r\n\tthis.m_moveBuffer = new Array();\r\n\tthis.m_pairBuffer = new Array();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2DynamicTree}\r\n */\r\nbox2d.b2BroadPhase.prototype.m_tree = null;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2BroadPhase.prototype.m_proxyCount = 0;\r\n\r\n//box2d.b2BroadPhase.prototype.m_moveCapacity = 16;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2BroadPhase.prototype.m_moveCount = 0;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2TreeNode>}\r\n */\r\nbox2d.b2BroadPhase.prototype.m_moveBuffer = null;\r\n\r\n//box2d.b2BroadPhase.prototype.m_pairCapacity = 16;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2BroadPhase.prototype.m_pairCount = 0;\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Pair>}\r\n */\r\nbox2d.b2BroadPhase.prototype.m_pairBuffer = null;\r\n\r\n//box2d.b2BroadPhase.prototype.m_queryProxyId = 0;\r\n\r\n/** \r\n * Create a proxy with an initial AABB. Pairs are not reported \r\n * until UpdatePairs is called. \r\n * @export \r\n * @return {box2d.b2TreeNode} \r\n * @param {box2d.b2AABB} aabb \r\n * @param {*} userData \r\n */\r\nbox2d.b2BroadPhase.prototype.CreateProxy = function (aabb, userData)\r\n{\r\n\tvar proxy = this.m_tree.CreateProxy(aabb, userData);\r\n\t++this.m_proxyCount;\r\n\tthis.BufferMove(proxy);\r\n\treturn proxy;\r\n}\r\n\r\n/** \r\n * Destroy a proxy. It is up to the client to remove any pairs. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} proxy \r\n */\r\nbox2d.b2BroadPhase.prototype.DestroyProxy = function (proxy)\r\n{\r\n\tthis.UnBufferMove(proxy);\r\n\t--this.m_proxyCount;\r\n\tthis.m_tree.DestroyProxy(proxy);\r\n}\r\n\r\n/** \r\n * Call MoveProxy as many times as you like, then when you are \r\n * done call UpdatePairs to finalized the proxy pairs (for your \r\n * time step). \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} proxy \r\n * @param {box2d.b2AABB} aabb \r\n * @param {box2d.b2Vec2} displacement \r\n */\r\nbox2d.b2BroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement)\r\n{\r\n\tvar buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);\r\n\tif (buffer)\r\n\t{\r\n\t\tthis.BufferMove(proxy);\r\n\t}\r\n}\r\n\r\n/** \r\n * Call to trigger a re-processing of it's pairs on the next \r\n * call to UpdatePairs. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} proxy \r\n */\r\nbox2d.b2BroadPhase.prototype.TouchProxy = function (proxy)\r\n{\r\n\tthis.BufferMove(proxy);\r\n}\r\n\r\n/** \r\n * Get the fat AABB for a proxy. \r\n * @export \r\n * @return {box2d.b2AABB}\r\n * @param {box2d.b2TreeNode} proxy \r\n */\r\nbox2d.b2BroadPhase.prototype.GetFatAABB = function (proxy)\r\n{\r\n\treturn this.m_tree.GetFatAABB(proxy);\r\n}\r\n\r\n/** \r\n * Get user data from a proxy. Returns NULL if the id is \r\n * invalid. \r\n * @export \r\n * @return {*} \r\n * @param {box2d.b2TreeNode} proxy \r\n */\r\nbox2d.b2BroadPhase.prototype.GetUserData = function (proxy)\r\n{\r\n\treturn this.m_tree.GetUserData(proxy);\r\n}\r\n\r\n/** \r\n * Test overlap of fat AABBs. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2TreeNode} proxyA\r\n * @param {box2d.b2TreeNode} proxyB \r\n */\r\nbox2d.b2BroadPhase.prototype.TestOverlap = function (proxyA, proxyB)\r\n{\r\n\tvar aabbA = this.m_tree.GetFatAABB(proxyA);\r\n\tvar aabbB = this.m_tree.GetFatAABB(proxyB);\r\n\treturn box2d.b2TestOverlapAABB(aabbA, aabbB);\r\n}\r\n\r\n/** \r\n * Get the number of proxies. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2BroadPhase.prototype.GetProxyCount = function ()\r\n{\r\n\treturn this.m_proxyCount;\r\n}\r\n\r\n/** \r\n * Get the height of the embedded tree. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2BroadPhase.prototype.GetTreeHeight = function ()\r\n{\r\n\treturn this.m_tree.GetHeight();\r\n}\r\n\r\n/** \r\n * Get the balance of the embedded tree. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2BroadPhase.prototype.GetTreeBalance = function ()\r\n{\r\n\treturn this.m_tree.GetMaxBalance();\r\n}\r\n\r\n/** \r\n * Get the quality metric of the embedded tree. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2BroadPhase.prototype.GetTreeQuality = function ()\r\n{\r\n\treturn this.m_tree.GetAreaRatio();\r\n}\r\n\r\n/** \r\n * Shift the world origin. Useful for large worlds. The shift \r\n * formula is: position -= newOrigin \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} newOrigin the new origin with respect to the old origin\r\n */\r\nbox2d.b2BroadPhase.prototype.ShiftOrigin = function (newOrigin)\r\n{\r\n\tthis.m_tree.ShiftOrigin(newOrigin);\r\n}\r\n\r\n/** \r\n * Update the pairs. This results in pair callbacks. This can \r\n * only add pairs. \r\n * @export \r\n * @return {void} \r\n * @param contactManager \r\n */\r\nbox2d.b2BroadPhase.prototype.UpdatePairs = function (contactManager)\r\n{\r\n\t// Reset pair buffer\r\n\tthis.m_pairCount = 0;\r\n\r\n\t// Perform tree queries for all moving proxies.\r\n\tfor (var i = 0; i < this.m_moveCount; ++i)\r\n\t{\r\n\t\tvar queryProxy = this.m_moveBuffer[i];\r\n\t\tif (queryProxy === null)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvar that = this;\r\n\r\n\t\t// This is called from box2d.b2DynamicTree::Query when we are gathering pairs.\r\n\t\t// bool b2BroadPhase::QueryCallback(int32 proxyId);\r\n\t\tvar QueryCallback = function (proxy)\r\n\t\t{\r\n\t\t\t// A proxy cannot form a pair with itself.\r\n\t\t\tif (proxy.m_id === queryProxy.m_id)\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Grow the pair buffer as needed.\r\n\t\t\tif (that.m_pairCount === that.m_pairBuffer.length)\r\n\t\t\t{\r\n\t\t\t\tthat.m_pairBuffer[that.m_pairCount] = new box2d.b2Pair();\r\n\t\t\t}\r\n\r\n\t\t\tvar pair = that.m_pairBuffer[that.m_pairCount];\r\n\t\t\t//pair.proxyA = proxy < queryProxy ? proxy : queryProxy;\r\n\t\t\t//pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;\r\n\t\t\tif (proxy.m_id < queryProxy.m_id)\r\n\t\t\t{\r\n\t\t\t\tpair.proxyA = proxy;\r\n\t\t\t\tpair.proxyB = queryProxy;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tpair.proxyA = queryProxy;\r\n\t\t\t\tpair.proxyB = proxy;\r\n\t\t\t}\r\n\t\t\t++that.m_pairCount;\r\n\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t\t// We have to query the tree with the fat AABB so that\r\n\t\t// we don't fail to create a pair that may touch later.\r\n\t\tvar fatAABB = this.m_tree.GetFatAABB(queryProxy);\r\n\r\n\t\t// Query tree, create pairs and add them pair buffer.\r\n\t\tthis.m_tree.Query(QueryCallback, fatAABB);\r\n\t}\r\n\r\n\t// Reset move buffer\r\n\tthis.m_moveCount = 0;\r\n\r\n\t// Sort the pair buffer to expose duplicates.\r\n\tthis.m_pairBuffer.length = this.m_pairCount;\r\n\tthis.m_pairBuffer.sort(box2d.b2PairLessThan);\r\n\r\n\t// Send the pairs back to the client.\r\n\tvar i = 0;\r\n\twhile (i < this.m_pairCount)\r\n\t{\r\n\t\tvar primaryPair = this.m_pairBuffer[i];\r\n\t\tvar userDataA = this.m_tree.GetUserData(primaryPair.proxyA);\r\n\t\tvar userDataB = this.m_tree.GetUserData(primaryPair.proxyB);\r\n\r\n\t\tcontactManager.AddPair(userDataA, userDataB);\r\n\t\t++i;\r\n\r\n\t\t// Skip any duplicate pairs.\r\n\t\twhile (i < this.m_pairCount)\r\n\t\t{\r\n\t\t\tvar pair = this.m_pairBuffer[i];\r\n\t\t\tif (pair.proxyA.m_id !== primaryPair.proxyA.m_id || pair.proxyB.m_id !== primaryPair.proxyB.m_id)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t++i;\r\n\t\t}\r\n\t}\r\n\r\n\t// Try to keep the tree balanced.\r\n\t//this.m_tree.Rebalance(4);\r\n}\r\n\r\n/** \r\n * Query an AABB for overlapping proxies. The callback class is \r\n * called for each proxy that overlaps the supplied AABB. \r\n * @export \r\n * @return {void} \r\n * @param callback \r\n * @param {box2d.b2AABB} aabb \r\n */\r\nbox2d.b2BroadPhase.prototype.Query = function (callback, aabb)\r\n{\r\n\tthis.m_tree.Query(callback, aabb);\r\n}\r\n\r\n/** \r\n * Ray-cast against the proxies in the tree. This relies on the \r\n * callback to perform a exact ray-cast in the case were the \r\n * proxy contains a shape. The callback also performs the any \r\n * collision filtering. This has performance roughly equal to k \r\n * * log(n), where k is the number of collisions and n is the \r\n * number of proxies in the tree.\r\n * @export \r\n * @return {void} \r\n * @param callback a callback class that is called for each proxy that is hit by the ray.\r\n * @param {box2d.b2RayCastInput} input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).\r\n */\r\nbox2d.b2BroadPhase.prototype.RayCast = function (callback, input)\r\n{\r\n\tthis.m_tree.RayCast(callback, input);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} proxy \r\n */\r\nbox2d.b2BroadPhase.prototype.BufferMove = function (proxy)\r\n{\r\n\tthis.m_moveBuffer[this.m_moveCount] = proxy;\r\n\t++this.m_moveCount;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TreeNode} proxy \r\n */\r\nbox2d.b2BroadPhase.prototype.UnBufferMove = function (proxy)\r\n{\r\n\tvar i = this.m_moveBuffer.indexOf(proxy);\r\n\tthis.m_moveBuffer[i] = null;\r\n}\r\n\r\n/** \r\n * This is used to sort pairs. \r\n * @return {number} \r\n * @param {box2d.b2Pair} pair1 \r\n * @param {box2d.b2Pair} pair2 \r\n */\r\nbox2d.b2PairLessThan = function (pair1, pair2)\r\n{\r\n\tif (pair1.proxyA.m_id === pair2.proxyA.m_id)\r\n\t{\r\n\t\treturn pair1.proxyB.m_id - pair2.proxyB.m_id;\r\n\t}\r\n\r\n\treturn pair1.proxyA.m_id - pair2.proxyA.m_id;\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2ContactManager');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2Collision');\r\ngoog.require('box2d.b2BroadPhase');\r\ngoog.require('box2d.b2ContactFactory');\r\n\r\n/** \r\n * Delegate of box2d.b2World. \r\n * @constructor\r\n */\r\nbox2d.b2ContactManager = function ()\r\n{\r\n\tthis.m_broadPhase = new box2d.b2BroadPhase();\r\n\r\n\tthis.m_contactFactory = new box2d.b2ContactFactory(this.m_allocator);\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2BroadPhase}\r\n */\r\nbox2d.b2ContactManager.prototype.m_broadPhase = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Contact} \r\n */\r\nbox2d.b2ContactManager.prototype.m_contactList = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2ContactManager.prototype.m_contactCount = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactFilter}\r\n */\r\nbox2d.b2ContactManager.prototype.m_contactFilter = box2d.b2ContactFilter.b2_defaultFilter;\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactListener}\r\n */\r\nbox2d.b2ContactManager.prototype.m_contactListener = box2d.b2ContactListener.b2_defaultListener;\r\n/**\r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2ContactManager.prototype.m_allocator = null; \r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactFactory}\r\n */\r\nbox2d.b2ContactManager.prototype.m_contactFactory = null;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} c\r\n */\r\nbox2d.b2ContactManager.prototype.Destroy = function (c)\r\n{\r\n\tvar fixtureA = c.GetFixtureA();\r\n\tvar fixtureB = c.GetFixtureB();\r\n\tvar bodyA = fixtureA.GetBody();\r\n\tvar bodyB = fixtureB.GetBody();\r\n\r\n\tif (this.m_contactListener && c.IsTouching())\r\n\t{\r\n\t\tthis.m_contactListener.EndContact(c);\r\n\t}\r\n\r\n\t// Remove from the world.\r\n\tif (c.m_prev)\r\n\t{\r\n\t\tc.m_prev.m_next = c.m_next;\r\n\t}\r\n\r\n\tif (c.m_next)\r\n\t{\r\n\t\tc.m_next.m_prev = c.m_prev;\r\n\t}\r\n\r\n\tif (c === this.m_contactList)\r\n\t{\r\n\t\tthis.m_contactList = c.m_next;\r\n\t}\r\n\r\n\t// Remove from body 1\r\n\tif (c.m_nodeA.prev)\r\n\t{\r\n\t\tc.m_nodeA.prev.next = c.m_nodeA.next;\r\n\t}\r\n\r\n\tif (c.m_nodeA.next)\r\n\t{\r\n\t\tc.m_nodeA.next.prev = c.m_nodeA.prev;\r\n\t}\r\n\r\n\tif (c.m_nodeA === bodyA.m_contactList)\r\n\t{\r\n\t\tbodyA.m_contactList = c.m_nodeA.next;\r\n\t}\r\n\r\n\t// Remove from body 2\r\n\tif (c.m_nodeB.prev)\r\n\t{\r\n\t\tc.m_nodeB.prev.next = c.m_nodeB.next;\r\n\t}\r\n\r\n\tif (c.m_nodeB.next)\r\n\t{\r\n\t\tc.m_nodeB.next.prev = c.m_nodeB.prev;\r\n\t}\r\n\r\n\tif (c.m_nodeB === bodyB.m_contactList)\r\n\t{\r\n\t\tbodyB.m_contactList = c.m_nodeB.next;\r\n\t}\r\n\r\n\t// Call the factory.\r\n\tthis.m_contactFactory.Destroy(c);\r\n\t--this.m_contactCount;\r\n}\r\n\r\n/** \r\n * This is the top level collision call for the time step. Here \r\n * all the narrow phase collision is processed for the world \r\n * contact list. \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2ContactManager.prototype.Collide = function ()\r\n{\r\n\t// Update awake contacts.\r\n\tvar c = this.m_contactList;\r\n\twhile (c)\r\n\t{\r\n\t\tvar fixtureA = c.GetFixtureA();\r\n\t\tvar fixtureB = c.GetFixtureB();\r\n\t\tvar indexA = c.GetChildIndexA();\r\n\t\tvar indexB = c.GetChildIndexB();\r\n\t\tvar bodyA = fixtureA.GetBody();\r\n\t\tvar bodyB = fixtureB.GetBody();\r\n\r\n\t\t// Is this contact flagged for filtering?\r\n\t\tif (c.m_flags & box2d.b2ContactFlag.e_filterFlag)\r\n\t\t{\r\n\t\t\t// Should these bodies collide?\r\n\t\t\tif (bodyB.ShouldCollide(bodyA) === false)\r\n\t\t\t{\r\n\t\t\t\tvar cNuke = c;\r\n\t\t\t\tc = cNuke.m_next;\r\n\t\t\t\tthis.Destroy(cNuke);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Check user filtering.\r\n\t\t\tif (this.m_contactFilter && this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) === false)\r\n\t\t\t{\r\n\t\t\t\tcNuke = c;\r\n\t\t\t\tc = cNuke.m_next;\r\n\t\t\t\tthis.Destroy(cNuke);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Clear the filtering flag.\r\n\t\t\tc.m_flags &= ~box2d.b2ContactFlag.e_filterFlag;\r\n\t\t}\r\n\r\n\t\tvar activeA = bodyA.IsAwake() && bodyA.m_type !== box2d.b2BodyType.b2_staticBody;\r\n\t\tvar activeB = bodyB.IsAwake() && bodyB.m_type !== box2d.b2BodyType.b2_staticBody;\r\n\r\n\t\t// At least one body must be awake and it must be dynamic or kinematic.\r\n\t\tif (activeA === false && activeB === false)\r\n\t\t{\r\n\t\t\tc = c.m_next;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvar proxyA = fixtureA.m_proxies[indexA].proxy;\r\n\t\tvar proxyB = fixtureB.m_proxies[indexB].proxy;\r\n\t\tvar overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);\r\n\r\n\t\t// Here we destroy contacts that cease to overlap in the broad-phase.\r\n\t\tif (overlap === false)\r\n\t\t{\r\n\t\t\tcNuke = c;\r\n\t\t\tc = cNuke.m_next;\r\n\t\t\tthis.Destroy(cNuke);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// The contact persists.\r\n\t\tc.Update(this.m_contactListener);\r\n\t\tc = c.m_next;\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2ContactManager.prototype.FindNewContacts = function ()\r\n{\r\n\tthis.m_broadPhase.UpdatePairs(this);\r\n}\r\n\r\n/** \r\n * Broad-phase callback. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2FixtureProxy} proxyUserDataA\r\n * @param {box2d.b2FixtureProxy} proxyUserDataB\r\n */\r\nbox2d.b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxyUserDataA instanceof box2d.b2FixtureProxy); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(proxyUserDataB instanceof box2d.b2FixtureProxy); }\r\n\tvar proxyA = proxyUserDataA;//(proxyUserDataA instanceof box2d.b2FixtureProxy ? proxyUserDataA : null);\r\n\tvar proxyB = proxyUserDataB;//(proxyUserDataB instanceof box2d.b2FixtureProxy ? proxyUserDataB : null);\r\n\r\n\tvar fixtureA = proxyA.fixture;\r\n\tvar fixtureB = proxyB.fixture;\r\n\r\n\tvar indexA = proxyA.childIndex;\r\n\tvar indexB = proxyB.childIndex;\r\n\r\n\tvar bodyA = fixtureA.GetBody();\r\n\tvar bodyB = fixtureB.GetBody();\r\n\r\n\t// Are the fixtures on the same body?\r\n\tif (bodyA === bodyB)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// TODO_ERIN use a hash table to remove a potential bottleneck when both\r\n\t// bodies have a lot of contacts.\r\n\t// Does a contact already exist?\r\n\tvar edge = bodyB.GetContactList();\r\n\twhile (edge)\r\n\t{\r\n\t\tif (edge.other === bodyA)\r\n\t\t{\r\n\t\t\tvar fA = edge.contact.GetFixtureA();\r\n\t\t\tvar fB = edge.contact.GetFixtureB();\r\n\t\t\tvar iA = edge.contact.GetChildIndexA();\r\n\t\t\tvar iB = edge.contact.GetChildIndexB();\r\n\r\n\t\t\tif (fA === fixtureA && fB === fixtureB && iA === indexA && iB === indexB)\r\n\t\t\t{\r\n\t\t\t\t// A contact already exists.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (fA === fixtureB && fB === fixtureA && iA === indexB && iB === indexA)\r\n\t\t\t{\r\n\t\t\t\t// A contact already exists.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tedge = edge.next;\r\n\t}\r\n\r\n\t// Does a joint override collision? Is at least one body dynamic?\r\n\tif (bodyB.ShouldCollide(bodyA) === false)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Check user filtering.\r\n\tif (this.m_contactFilter && this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) === false)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Call the factory.\r\n\tvar c = this.m_contactFactory.Create(fixtureA, indexA, fixtureB, indexB);\r\n\tif (c === null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Contact creation may swap fixtures.\r\n\tfixtureA = c.GetFixtureA();\r\n\tfixtureB = c.GetFixtureB();\r\n\tindexA = c.GetChildIndexA();\r\n\tindexB = c.GetChildIndexB();\r\n\tbodyA = fixtureA.m_body;\r\n\tbodyB = fixtureB.m_body;\r\n\r\n\t// Insert into the world.\r\n\tc.m_prev = null;\r\n\tc.m_next = this.m_contactList;\r\n\tif (this.m_contactList !== null)\r\n\t{\r\n\t\tthis.m_contactList.m_prev = c;\r\n\t}\r\n\tthis.m_contactList = c;\r\n\r\n\t// Connect to island graph.\r\n\r\n\t// Connect to body A\r\n\tc.m_nodeA.contact = c;\r\n\tc.m_nodeA.other = bodyB;\r\n\r\n\tc.m_nodeA.prev = null;\r\n\tc.m_nodeA.next = bodyA.m_contactList;\r\n\tif (bodyA.m_contactList !== null)\r\n\t{\r\n\t\tbodyA.m_contactList.prev = c.m_nodeA;\r\n\t}\r\n\tbodyA.m_contactList = c.m_nodeA;\r\n\r\n\t// Connect to body B\r\n\tc.m_nodeB.contact = c;\r\n\tc.m_nodeB.other = bodyA;\r\n\r\n\tc.m_nodeB.prev = null;\r\n\tc.m_nodeB.next = bodyB.m_contactList;\r\n\tif (bodyB.m_contactList !== null)\r\n\t{\r\n\t\tbodyB.m_contactList.prev = c.m_nodeB;\r\n\t}\r\n\tbodyB.m_contactList = c.m_nodeB;\r\n\r\n\t// Wake up the bodies\r\n\tif (fixtureA.IsSensor() === false && fixtureB.IsSensor() === false)\r\n\t{\r\n\t\tbodyA.SetAwake(true);\r\n\t\tbodyB.SetAwake(true);\r\n\t}\r\n\r\n\t++this.m_contactCount;\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2JointFactory');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2Joint');\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Joint}\r\n * @param {box2d.b2JointDef} def \r\n * @param allocator \r\n */\r\nbox2d.b2JointFactory.Create = function (def, allocator)\r\n{\r\n\tvar joint = null;\r\n\r\n\tswitch (def.type)\r\n\t{\r\n\tcase box2d.b2JointType.e_distanceJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2DistanceJoint((def instanceof box2d.b2DistanceJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_mouseJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2MouseJoint((def instanceof box2d.b2MouseJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_prismaticJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2PrismaticJoint((def instanceof box2d.b2PrismaticJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_revoluteJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2RevoluteJoint((def instanceof box2d.b2RevoluteJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_pulleyJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2PulleyJoint((def instanceof box2d.b2PulleyJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_gearJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2GearJoint((def instanceof box2d.b2GearJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_wheelJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2WheelJoint((def instanceof box2d.b2WheelJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_weldJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2WeldJoint((def instanceof box2d.b2WeldJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_frictionJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2FrictionJoint((def instanceof box2d.b2FrictionJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_ropeJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2RopeJoint((def instanceof box2d.b2RopeJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_motorJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2MotorJoint((def instanceof box2d.b2MotorJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_areaJoint:\r\n\t\t{\r\n\t\t\tjoint = new box2d.b2AreaJoint((def instanceof box2d.b2AreaJointDef ? def : null));\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn joint;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Joint} joint \r\n * @param allocator \r\n */\r\nbox2d.b2JointFactory.Destroy = function (joint, allocator)\r\n{\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Draw');\r\n\r\ngoog.require('box2d.b2Settings');\r\n\r\n/** \r\n * Color for debug drawing. Each value has the range [0,1]. \r\n * @export\r\n * @constructor\r\n * @param {number} rr\r\n * @param {number} gg\r\n * @param {number} bb\r\n */\r\nbox2d.b2Color = function (rr, gg, bb)\r\n{\r\n\tthis.r = rr;\r\n\tthis.g = gg;\r\n\tthis.b = bb;\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Color.prototype.r = 0.5;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Color.prototype.g = 0.5;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Color.prototype.b = 0.5;\r\n\r\n/**\r\n * @export\r\n * @return {box2d.b2Color}\r\n * @param {number} rr\r\n * @param {number} gg\r\n * @param {number} bb\r\n */\r\nbox2d.b2Color.prototype.SetRGB = function (rr, gg, bb)\r\n{\r\n\tthis.r = rr;\r\n\tthis.g = gg;\r\n\tthis.b = bb;\r\n\treturn this;\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {string}\r\n * @param {number=} alpha\r\n */\r\nbox2d.b2Color.prototype.MakeStyleString = function (alpha)\r\n{\r\n\tvar r = Math.round(Math.max(0, Math.min(255, this.r * 255)));\r\n\tvar g = Math.round(Math.max(0, Math.min(255, this.g * 255)));\r\n\tvar b = Math.round(Math.max(0, Math.min(255, this.b * 255)));\r\n\tvar a = (typeof(alpha) === 'undefined')?(1.0):(Math.max(0, Math.min(1, alpha)));\r\n\treturn box2d.b2Color.MakeStyleString(r, g, b, a);\r\n}\r\n\r\n/**\r\n * @export\r\n * @return {string}\r\n */\r\nbox2d.b2Color.MakeStyleString = function (r, g, b, a)\r\n{\r\n\tif (a < 1)\r\n\t{\r\n\t\treturn 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn 'rgb(' + r + ',' + g + ',' + b + ')';\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @const \r\n * @type {box2d.b2Color}\r\n */\r\nbox2d.b2Color.RED = new box2d.b2Color(1,0,0);\r\n/**\r\n * @export \r\n * @const \r\n * @type {box2d.b2Color}\r\n */\r\nbox2d.b2Color.GREEN\t= new box2d.b2Color(0,1,0);\r\n/**\r\n * @export \r\n * @const \r\n * @type {box2d.b2Color}\r\n */\r\nbox2d.b2Color.BLUE = new box2d.b2Color(0,0,1);\r\n\r\n/** \r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2DrawFlags = \r\n{\r\n\te_none\t\t\t\t: 0,\r\n\te_shapeBit\t\t\t: 0x0001, ///< draw shapes\r\n\te_jointBit\t\t\t: 0x0002, ///< draw joint connections\r\n\te_aabbBit\t\t\t: 0x0004, ///< draw axis aligned bounding boxes\r\n\te_pairBit\t\t\t: 0x0008, ///< draw broad-phase pairs\r\n\te_centerOfMassBit\t: 0x0010, ///< draw center of mass frame\r\n\te_controllerBit\t\t: 0x0020, /// @see box2d.b2Controller list\r\n\te_all\t\t\t\t: 0x003f\r\n};\r\ngoog.exportProperty(box2d.b2DrawFlags, 'e_none'           , box2d.b2DrawFlags.e_none           );\r\ngoog.exportProperty(box2d.b2DrawFlags, 'e_shapeBit'       , box2d.b2DrawFlags.e_shapeBit       );\r\ngoog.exportProperty(box2d.b2DrawFlags, 'e_jointBit'       , box2d.b2DrawFlags.e_jointBit       );\r\ngoog.exportProperty(box2d.b2DrawFlags, 'e_aabbBit'        , box2d.b2DrawFlags.e_aabbBit        );\r\ngoog.exportProperty(box2d.b2DrawFlags, 'e_pairBit'        , box2d.b2DrawFlags.e_pairBit        );\r\ngoog.exportProperty(box2d.b2DrawFlags, 'e_centerOfMassBit', box2d.b2DrawFlags.e_centerOfMassBit);\r\ngoog.exportProperty(box2d.b2DrawFlags, 'e_controllerBit'  , box2d.b2DrawFlags.e_controllerBit  );\r\ngoog.exportProperty(box2d.b2DrawFlags, 'e_all'            , box2d.b2DrawFlags.e_all            );\r\n\r\n/** \r\n * Implement and register this class with a b2World to provide \r\n * debug drawing of physics entities in your game. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Draw = function ()\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2DrawFlags} \r\n */\r\nbox2d.b2Draw.prototype.m_drawFlags = box2d.b2DrawFlags.e_none;\r\n\r\n/** \r\n * Set the drawing flags. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2DrawFlags} flags \r\n */\r\nbox2d.b2Draw.prototype.SetFlags = function (flags)\r\n{\r\n\tthis.m_drawFlags = flags;\r\n}\r\n\r\n/** \r\n * Get the drawing flags. \r\n * @export \r\n * @return {box2d.b2DrawFlags}\r\n */\r\nbox2d.b2Draw.prototype.GetFlags = function ()\r\n{\r\n\treturn this.m_drawFlags;\r\n}\r\n\r\n/** \r\n * Append flags to the current flags. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2DrawFlags} flags \r\n */\r\nbox2d.b2Draw.prototype.AppendFlags = function (flags)\r\n{\r\n\tthis.m_drawFlags |= flags;\r\n}\r\n\r\n/** \r\n * Clear flags from the current flags. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2DrawFlags} flags \r\n */\r\nbox2d.b2Draw.prototype.ClearFlags = function (flags)\r\n{\r\n\tthis.m_drawFlags &= ~flags;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Transform} xf \r\n */\r\nbox2d.b2Draw.prototype.PushTransform = function (xf)\r\n{\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Transform} xf \r\n */\r\nbox2d.b2Draw.prototype.PopTransform = function (xf)\r\n{\r\n}\r\n\r\n/** \r\n * Draw a closed polygon provided in CCW order. \r\n * @export \r\n * @return {void} \r\n * @param {Array.<box2d.b2Vec2>} vertices\r\n * @param {number} vertexCount\r\n * @param {box2d.b2Color} color \r\n */\r\nbox2d.b2Draw.prototype.DrawPolygon = function (vertices, vertexCount, color)\r\n{\r\n}\r\n\r\n/** \r\n * Draw a solid closed polygon provided in CCW order. \r\n * @export \r\n * @return {void} \r\n * @param {Array.<box2d.b2Vec2>} vertices\r\n * @param {number} vertexCount\r\n * @param {box2d.b2Color} color \r\n */\r\nbox2d.b2Draw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color)\r\n{\r\n}\r\n\r\n/** \r\n * Draw a circle. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} center\r\n * @param {number} radius\r\n * @param {box2d.b2Color} color \r\n */\r\nbox2d.b2Draw.prototype.DrawCircle = function (center, radius, color)\r\n{\r\n}\r\n\r\n/** \r\n * Draw a solid circle. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} center\r\n * @param {number} radius\r\n * @param {box2d.b2Vec2} axis\r\n * @param {box2d.b2Color} color \r\n */\r\nbox2d.b2Draw.prototype.DrawSolidCircle = function (center, radius, axis, color)\r\n{\r\n}\r\n\r\n/** \r\n * Draw a line segment. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} p1\r\n * @param {box2d.b2Vec2} p2\r\n * @param {box2d.b2Color} color \r\n */\r\nbox2d.b2Draw.prototype.DrawSegment = function (p1, p2, color)\r\n{\r\n}\r\n\r\n/** \r\n * Draw a transform. Choose your own length scale. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Transform} xf a transform.\r\n */\r\nbox2d.b2Draw.prototype.DrawTransform = function (xf)\r\n{\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Fixture');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Collision');\r\ngoog.require('box2d.b2Shape');\r\n\r\n/** \r\n * This holds contact filtering data. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Filter = function ()\r\n{\r\n};\r\n\r\n/** \r\n * The collision category bits. Normally you would just set one \r\n * bit. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Filter.prototype.categoryBits = 0x0001;\r\n\r\n/** \r\n * The collision mask bits. This states the categories that this \r\n * shape would accept for collision. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Filter.prototype.maskBits = 0xFFFF;\r\n\r\n/** \r\n * Collision groups allow a certain group of objects to never \r\n * collide (negative) or always collide (positive). Zero means \r\n * no collision group. Non-zero group filtering always wins \r\n * against the mask bits. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Filter.prototype.groupIndex = 0;\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Filter}\r\n */\r\nbox2d.b2Filter.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2Filter().Copy(this);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Filter} \r\n * @param {box2d.b2Filter} other \r\n */\r\nbox2d.b2Filter.prototype.Copy = function (other)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this !== other); }\r\n\tthis.categoryBits = other.categoryBits;\r\n\tthis.maskBits = other.maskBits;\r\n\tthis.groupIndex = other.groupIndex;\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * A fixture definition is used to create a fixture. This class \r\n * defines an abstract fixture definition. You can reuse fixture \r\n * definitions safely. \r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2FixtureDef = function ()\r\n{\r\n\tthis.filter = new box2d.b2Filter();\r\n}\r\n\r\n/** \r\n * The shape, this must be set. The shape will be cloned, so you \r\n * can create the shape on the stack. \r\n * @export \r\n * @type {box2d.b2Shape}\r\n */\r\nbox2d.b2FixtureDef.prototype.shape = null;\r\n\r\n/** \r\n * Use this to store application specific fixture data. \r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2FixtureDef.prototype.userData = null;\r\n\r\n/** \r\n * The friction coefficient, usually in the range [0,1]. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FixtureDef.prototype.friction = 0.2;\r\n\r\n/** \r\n * The restitution (elasticity) usually in the range [0,1]. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FixtureDef.prototype.restitution = 0;\r\n\r\n/** \r\n * The density, usually in kg/m^2. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FixtureDef.prototype.density = 0;\r\n\r\n/** \r\n * A sensor shape collects contact information but never \r\n * generates a collision response. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2FixtureDef.prototype.isSensor = false;\r\n\r\n/** \r\n * Contact filtering data. \r\n * @export \r\n * @type {box2d.b2Filter}\r\n */\r\nbox2d.b2FixtureDef.prototype.filter = null;\r\n\r\n/** \r\n * This proxy is used internally to connect fixtures to the \r\n * broad-phase. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2FixtureProxy = function ()\r\n{\r\n\tthis.aabb = new box2d.b2AABB();\r\n};\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2AABB}\r\n */\r\nbox2d.b2FixtureProxy.prototype.aabb = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Fixture}\r\n */\r\nbox2d.b2FixtureProxy.prototype.fixture = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FixtureProxy.prototype.childIndex = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2TreeNode}\r\n */\r\nbox2d.b2FixtureProxy.prototype.proxy = null;\r\n\r\n/** \r\n * @export \r\n * @return {Array.<box2d.b2FixtureProxy>} \r\n * @param {number} length \r\n */\r\nbox2d.b2FixtureProxy.MakeArray = function (length)\r\n{\r\n\treturn box2d.b2MakeArray(length, function (i) { return new box2d.b2FixtureProxy(); });\r\n}\r\n\r\n/** \r\n * A fixture is used to attach a shape to a body for collision \r\n * detection. A fixture inherits its transform from its parent. \r\n * Fixtures hold additional non-geometric data such as friction, \r\n * collision filters, etc. \r\n * Fixtures are created via box2d.b2Body::CreateFixture. \r\n * warning you cannot reuse fixtures.\r\n * @export \r\n * @constructor \r\n */\r\nbox2d.b2Fixture = function ()\r\n{\r\n//\tthis.m_proxies = new Array();\r\n\tthis.m_proxyCount = 0;\r\n\r\n\tthis.m_filter = new box2d.b2Filter();\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Fixture.prototype.m_density = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Fixture}\r\n */\r\nbox2d.b2Fixture.prototype.m_next = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2Fixture.prototype.m_body = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Shape}\r\n */\r\nbox2d.b2Fixture.prototype.m_shape = null;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Fixture.prototype.m_friction = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Fixture.prototype.m_restitution = 0;\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2FixtureProxy>}\r\n */\r\nbox2d.b2Fixture.prototype.m_proxies = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Fixture.prototype.m_proxyCount = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Filter}\r\n */\r\nbox2d.b2Fixture.prototype.m_filter = null;\r\n\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2Fixture.prototype.m_isSensor = false;\r\n\r\n/**\r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2Fixture.prototype.m_userData = null;\r\n\r\n/** \r\n * Get the type of the child shape. You can use this to down \r\n * cast to the concrete shape. \r\n * @export \r\n * @return {box2d.b2ShapeType} the shape type.\r\n */\r\nbox2d.b2Fixture.prototype.GetType = function ()\r\n{\r\n\treturn this.m_shape.GetType();\r\n}\r\n\r\n/** \r\n * Get the child shape. You can modify the child shape, however \r\n * you should not change the number of vertices because this \r\n * will crash some collision caching mechanisms. \r\n * Manipulating the shape may lead to non-physical behavior.\r\n * @export \r\n * @return {box2d.b2Shape}\r\n */\r\nbox2d.b2Fixture.prototype.GetShape = function ()\r\n{\r\n\treturn this.m_shape;\r\n}\r\n\r\n/** \r\n * Is this fixture a sensor (non-solid)? \r\n * @export \r\n * @return {boolean} true if the shape is a sensor.\r\n */\r\nbox2d.b2Fixture.prototype.IsSensor = function ()\r\n{\r\n\treturn this.m_isSensor;\r\n}\r\n\r\n/** \r\n * Get the contact filtering data. \r\n * @export \r\n * @return {box2d.b2Filter} \r\n */\r\nbox2d.b2Fixture.prototype.GetFilterData = function ()\r\n{\r\n\treturn this.m_filter;\r\n}\r\n\r\n/** \r\n * Get the user data that was assigned in the fixture \r\n * definition. Use this to store your application specific data.\r\n * @export \r\n * @return {*} \r\n */\r\nbox2d.b2Fixture.prototype.GetUserData = function ()\r\n{\r\n\treturn this.m_userData;\r\n}\r\n\r\n/** \r\n * Set the user data. Use this to store your application \r\n * specific data. \r\n * @export \r\n * @param {*} data \r\n */\r\nbox2d.b2Fixture.prototype.SetUserData = function (data)\r\n{\r\n\tthis.m_userData = data;\r\n}\r\n\r\n/** \r\n * Get the parent body of this fixture. This is NULL if the \r\n * fixture is not attached. \r\n * @export \r\n * @return {box2d.b2Body} the parent body.\r\n */\r\nbox2d.b2Fixture.prototype.GetBody = function ()\r\n{\r\n\treturn this.m_body;\r\n}\r\n\r\n/** \r\n * Get the next fixture in the parent body's fixture list. \r\n * @export \r\n * @return {box2d.b2Fixture} the next shape.\r\n */\r\nbox2d.b2Fixture.prototype.GetNext = function ()\r\n{\r\n\treturn this.m_next;\r\n}\r\n\r\n/** \r\n * Set the density of this fixture. This will _not_ \r\n * automatically adjust the mass of the body. You must call \r\n * box2d.b2Body::ResetMassData to update the body's mass. \r\n * @export \r\n * @return {void} \r\n * @param {number} density \r\n */\r\nbox2d.b2Fixture.prototype.SetDensity = function (density)\r\n{\r\n\tthis.m_density = density;\r\n}\r\n\r\n/** \r\n * Get the density of this fixture. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2Fixture.prototype.GetDensity = function ()\r\n{\r\n\treturn this.m_density;\r\n}\r\n\r\n/** \r\n * Get the coefficient of friction. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2Fixture.prototype.GetFriction = function ()\r\n{\r\n\treturn this.m_friction;\r\n}\r\n\r\n/** \r\n * Set the coefficient of friction. This will _not_ change the \r\n * friction of existing contacts. \r\n * @export \r\n * @return {void} \r\n * @param {number} friction \r\n */\r\nbox2d.b2Fixture.prototype.SetFriction = function (friction)\r\n{\r\n\tthis.m_friction = friction;\r\n}\r\n\r\n/** \r\n * Get the coefficient of restitution. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2Fixture.prototype.GetRestitution = function ()\r\n{\r\n\treturn this.m_restitution;\r\n}\r\n\r\n/** \r\n * Set the coefficient of restitution. This will _not_ change \r\n * the restitution of existing contacts. \r\n * @export \r\n * @return {void} \r\n * @param {number} restitution \r\n */\r\nbox2d.b2Fixture.prototype.SetRestitution = function (restitution)\r\n{\r\n\tthis.m_restitution = restitution;\r\n}\r\n\r\n/** \r\n * Test a point for containment in this fixture. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2Vec2} p a point in world coordinates.\r\n */\r\nbox2d.b2Fixture.prototype.TestPoint = function (p)\r\n{\r\n\treturn this.m_shape.TestPoint(this.m_body.GetTransform(), p);\r\n}\r\n\r\n/** \r\n * Cast a ray against this shape. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2RayCastOutput} output ray-cast results.\r\n * @param {box2d.b2RayCastInput} input the ray-cast input parameters.\r\n * @param {number} childIndex \r\n */\r\nbox2d.b2Fixture.prototype.RayCast = function (output, input, childIndex)\r\n{\r\n\treturn this.m_shape.RayCast(output, input, this.m_body.GetTransform(), childIndex);\r\n}\r\n\r\n/** \r\n * Get the mass data for this fixture. The mass data is based on \r\n * the density and the shape. The rotational inertia is about \r\n * the shape's origin. This operation may be expensive. \r\n * @export \r\n * @return {box2d.b2MassData} \r\n * @param {box2d.b2MassData=} massData \r\n */\r\nbox2d.b2Fixture.prototype.GetMassData = function (massData)\r\n{\r\n\tmassData = massData || new box2d.b2MassData();\r\n\r\n\tthis.m_shape.ComputeMass(massData, this.m_density);\r\n\r\n\treturn massData;\r\n}\r\n\r\n/** \r\n * Get the fixture's AABB. This AABB may be enlarge and/or \r\n * stale. If you need a more accurate AABB, compute it using the \r\n * shape and the body transform. \r\n * @export \r\n * @return {box2d.b2AABB} \r\n * @param {number} childIndex \r\n */\r\nbox2d.b2Fixture.prototype.GetAABB = function (childIndex)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(0 <= childIndex && childIndex < this.m_proxyCount); }\r\n\treturn this.m_proxies[childIndex].aabb;\r\n}\r\n\r\n/** \r\n * We need separation create/destroy functions from the \r\n * constructor/destructor because the destructor cannot access \r\n * the allocator (no destructor arguments allowed by C++). \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} body \r\n * @param {box2d.b2FixtureDef} def\r\n */\r\nbox2d.b2Fixture.prototype.Create = function (body, def)\r\n{\r\n\tthis.m_userData = def.userData;\r\n\tthis.m_friction = def.friction;\r\n\tthis.m_restitution = def.restitution;\r\n\r\n\tthis.m_body = body;\r\n\tthis.m_next = null;\r\n\r\n\tthis.m_filter.Copy(def.filter);\r\n\r\n\tthis.m_isSensor = def.isSensor;\r\n\r\n\tthis.m_shape = def.shape.Clone();\r\n\r\n\t// Reserve proxy space\r\n//\tvar childCount = m_shape->GetChildCount();\r\n//\tm_proxies = (box2d.b2FixtureProxy*)allocator->Allocate(childCount * sizeof(box2d.b2FixtureProxy));\r\n//\tfor (int32 i = 0; i < childCount; ++i)\r\n//\t{\r\n//\t\tm_proxies[i].fixture = NULL;\r\n//\t\tm_proxies[i].proxyId = box2d.b2BroadPhase::e_nullProxy;\r\n//\t}\r\n\tthis.m_proxies = box2d.b2FixtureProxy.MakeArray(this.m_shape.GetChildCount());\r\n\tthis.m_proxyCount = 0;\r\n\r\n\tthis.m_density = def.density;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Fixture.prototype.Destroy = function ()\r\n{\r\n\t// The proxies must be destroyed before calling this.\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_proxyCount === 0); }\r\n\r\n\t// Free the proxy array.\r\n//\tint32 childCount = m_shape->GetChildCount();\r\n//\tallocator->Free(m_proxies, childCount * sizeof(box2d.b2FixtureProxy));\r\n//\tm_proxies = NULL;\r\n\r\n\tthis.m_shape = null;\r\n}\r\n\r\n/** \r\n * These support body activation/deactivation. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2BroadPhase} broadPhase \r\n * @param {box2d.b2Transform} xf \r\n */\r\nbox2d.b2Fixture.prototype.CreateProxies = function (broadPhase, xf)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_proxyCount === 0); }\r\n\r\n\t// Create proxies in the broad-phase.\r\n\tthis.m_proxyCount = this.m_shape.GetChildCount();\r\n\r\n\tfor (var i = 0; i < this.m_proxyCount; ++i)\r\n\t{\r\n\t\tvar proxy = this.m_proxies[i];\r\n\t\tthis.m_shape.ComputeAABB(proxy.aabb, xf, i);\r\n\t\tproxy.proxy = broadPhase.CreateProxy(proxy.aabb, proxy);\r\n\t\tproxy.fixture = this;\r\n\t\tproxy.childIndex = i;\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2BroadPhase} broadPhase \r\n */\r\nbox2d.b2Fixture.prototype.DestroyProxies = function (broadPhase)\r\n{\r\n\t// Destroy proxies in the broad-phase.\r\n\tfor (var i = 0; i < this.m_proxyCount; ++i)\r\n\t{\r\n\t\tvar proxy = this.m_proxies[i];\r\n\t\tbroadPhase.DestroyProxy(proxy.proxy);\r\n\t\tproxy.proxy = null;\r\n\t}\r\n\t\r\n\tthis.m_proxyCount = 0;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2BroadPhase} broadPhase \r\n * @param {box2d.b2Transform} transform1\r\n * @param {box2d.b2Transform} transform2\r\n */\r\nbox2d.b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2)\r\n{\r\n\tif (this.m_proxyCount === 0)\r\n\t{\t\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor (var i = 0; i < this.m_proxyCount; ++i)\r\n\t{\r\n\t\tvar proxy = this.m_proxies[i];\r\n\r\n\t\t// Compute an AABB that covers the swept shape (may miss some rotation effect).\r\n\t\tvar aabb1 = box2d.b2Fixture.prototype.Synchronize.s_aabb1;\r\n\t\tvar aabb2 = box2d.b2Fixture.prototype.Synchronize.s_aabb2;\r\n\t\tthis.m_shape.ComputeAABB(aabb1, transform1, i);\r\n\t\tthis.m_shape.ComputeAABB(aabb2, transform2, i);\r\n\t\r\n\t\tproxy.aabb.Combine2(aabb1, aabb2);\r\n\t\r\n\t\tvar displacement = box2d.b2SubVV(transform2.p, transform1.p, box2d.b2Fixture.prototype.Synchronize.s_displacement);\r\n\t\r\n\t\tbroadPhase.MoveProxy(proxy.proxy, proxy.aabb, displacement);\r\n\t}\r\n}\r\nbox2d.b2Fixture.prototype.Synchronize.s_aabb1 = new box2d.b2AABB();\r\nbox2d.b2Fixture.prototype.Synchronize.s_aabb2 = new box2d.b2AABB();\r\nbox2d.b2Fixture.prototype.Synchronize.s_displacement = new box2d.b2Vec2();\r\n\r\n/** \r\n * Set the contact filtering data. This will not update contacts \r\n * until the next time step when either parent body is active \r\n * and awake. \r\n * This automatically calls Refilter. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Filter} filter \r\n */\r\nbox2d.b2Fixture.prototype.SetFilterData = function (filter)\r\n{\r\n\tthis.m_filter.Copy(filter);\r\n\r\n\tthis.Refilter();\r\n}\r\n\r\n/**\r\n * Call this if you want to establish collision that was \r\n * previously disabled by box2d.b2ContactFilter::ShouldCollide. \r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Fixture.prototype.Refilter = function ()\r\n{\r\n\tif (this.m_body)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Flag associated contacts for filtering.\r\n\tvar edge = this.m_body.GetContactList();\r\n\r\n\twhile (edge)\r\n\t{\r\n\t\tvar contact = edge.contact;\r\n\t\tvar fixtureA = contact.GetFixtureA();\r\n\t\tvar fixtureB = contact.GetFixtureB();\r\n\t\tif (fixtureA === this || fixtureB === this)\r\n\t\t{\r\n\t\t\tcontact.FlagForFiltering();\r\n\t\t}\r\n\r\n\t\tedge = edge.next;\r\n\t}\r\n\r\n\tvar world = this.m_body.GetWorld();\r\n\r\n\tif (world === null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Touch each proxy so that new pairs may be created\r\n\tvar broadPhase = world.m_contactManager.m_broadPhase;\r\n\tfor (var i = 0; i < this.m_proxyCount; ++i)\r\n\t{\r\n\t\tbroadPhase.TouchProxy(this.m_proxies[i].proxy);\r\n\t}\r\n}\r\n\r\n/** \r\n * Set if this fixture is a sensor. \r\n * @export \r\n * @return {void} \r\n * @param {boolean} sensor\r\n */\r\nbox2d.b2Fixture.prototype.SetSensor = function (sensor)\r\n{\r\n\tif (sensor !== this.m_isSensor)\r\n\t{\r\n\t\tthis.m_body.SetAwake(true);\r\n\t\tthis.m_isSensor = sensor;\r\n\t}\r\n}\r\n\r\n/** \r\n * Dump this fixture to the log file. \r\n * @export \r\n * @return {void}\r\n * @param {number} bodyIndex \r\n */\r\nbox2d.b2Fixture.prototype.Dump = function (bodyIndex)\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tbox2d.b2Log(\"    /*box2d.b2FixtureDef*/ var fd = new box2d.b2FixtureDef();\\n\");\r\n\t\tbox2d.b2Log(\"    fd.friction = %.15f;\\n\", this.m_friction);\r\n\t\tbox2d.b2Log(\"    fd.restitution = %.15f;\\n\", this.m_restitution);\r\n\t\tbox2d.b2Log(\"    fd.density = %.15f;\\n\", this.m_density);\r\n\t\tbox2d.b2Log(\"    fd.isSensor = %s;\\n\", (this.m_isSensor)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"    fd.filter.categoryBits = %d;\\n\", this.m_filter.categoryBits);\r\n\t\tbox2d.b2Log(\"    fd.filter.maskBits = %d;\\n\", this.m_filter.maskBits);\r\n\t\tbox2d.b2Log(\"    fd.filter.groupIndex = %d;\\n\", this.m_filter.groupIndex);\r\n\t\r\n\t\tthis.m_shape.Dump();\r\n\t\r\n\t\tbox2d.b2Log(\"\\n\");\r\n\t\tbox2d.b2Log(\"    fd.shape = shape;\\n\");\r\n\t\tbox2d.b2Log(\"\\n\");\r\n\t\tbox2d.b2Log(\"    bodies[%d].CreateFixture(fd);\\n\", bodyIndex);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Body');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2Fixture');\r\n\r\n/**\r\n * The body type.\r\n * static: zero mass, zero velocity, may be manually moved\r\n * kinematic: zero mass, non-zero velocity set by user, moved by solver\r\n * dynamic: positive mass, non-zero velocity determined by forces, moved by solver\r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2BodyType = \r\n{\r\n\tb2_unknown\t\t\t: -1,\r\n\tb2_staticBody\t\t: 0,\r\n\tb2_kinematicBody\t: 1,\r\n\tb2_dynamicBody\t\t: 2,\r\n\tb2_bulletBody\t\t: 3 // TODO_ERIN\r\n};\r\ngoog.exportProperty(box2d.b2BodyType, 'b2_unknown'      , box2d.b2BodyType.b2_unknown      );\r\ngoog.exportProperty(box2d.b2BodyType, 'b2_staticBody'   , box2d.b2BodyType.b2_staticBody   );\r\ngoog.exportProperty(box2d.b2BodyType, 'b2_kinematicBody', box2d.b2BodyType.b2_kinematicBody);\r\ngoog.exportProperty(box2d.b2BodyType, 'b2_dynamicBody'  , box2d.b2BodyType.b2_dynamicBody  );\r\ngoog.exportProperty(box2d.b2BodyType, 'b2_bulletBody'   , box2d.b2BodyType.b2_bulletBody   );\r\n\r\n/** \r\n * A body definition holds all the data needed to construct a \r\n * rigid body. \r\n * You can safely re-use body definitions. Shapes are added to a \r\n * body after construction. \r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2BodyDef = function ()\r\n{\r\n\tthis.position = new box2d.b2Vec2(0, 0);\r\n\tthis.linearVelocity = new box2d.b2Vec2(0, 0);\r\n}\r\n\r\n/** \r\n * The body type: static, kinematic, or dynamic. \r\n * Note: if a dynamic body would have zero mass, the mass is set \r\n * to one. \r\n * @export\r\n * @type {box2d.b2BodyType} \r\n */ \r\nbox2d.b2BodyDef.prototype.type = box2d.b2BodyType.b2_staticBody;\r\n\r\n/** \r\n * The world position of the body. Avoid creating bodies at the \r\n * origin since this can lead to many overlapping shapes. \r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2BodyDef.prototype.position = null;\r\n\r\n/** \r\n * The world angle of the body in radians. \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2BodyDef.prototype.angle = 0;\r\n\r\n/** \r\n * The linear velocity of the body's origin in world \r\n * co-ordinates. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2BodyDef.prototype.linearVelocity = null;\r\n\r\n/** \r\n * The angular velocity of the body. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2BodyDef.prototype.angularVelocity = 0;\r\n\r\n/** \r\n * Linear damping is use to reduce the linear velocity. The \r\n * damping parameter can be larger than 1.0f but the damping \r\n * effect becomes sensitive to the time step when the damping \r\n * parameter is large. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2BodyDef.prototype.linearDamping = 0;\r\n\r\n/** \r\n * Angular damping is use to reduce the angular velocity. The \r\n * damping parameter can be larger than 1.0f but the damping \r\n * effect becomes sensitive to the time step when the damping \r\n * parameter is large. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2BodyDef.prototype.angularDamping = 0;\r\n\r\n/** \r\n * Set this flag to false if this body should never fall asleep. \r\n * Note that this increases CPU usage. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2BodyDef.prototype.allowSleep = true;\r\n\r\n/** \r\n * Is this body initially awake or sleeping? \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2BodyDef.prototype.awake = true;\r\n\r\n/** \r\n * Should this body be prevented from rotating? Useful for \r\n * characters. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2BodyDef.prototype.fixedRotation = false;\r\n\r\n/** \r\n * Is this a fast moving body that should be prevented from \r\n * tunneling through other moving bodies? Note that all bodies \r\n * are prevented from tunneling through kinematic and static \r\n * bodies. This setting is only considered on dynamic bodies. \r\n * warning You should use this flag sparingly since it increases \r\n * processing time. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2BodyDef.prototype.bullet = false;\r\n\r\n/** \r\n * Does this body start out active? \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2BodyDef.prototype.active = true;\r\n\r\n/** \r\n * Use this to store application specific body data. \r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2BodyDef.prototype.userData = null;\r\n\r\n/** \r\n * Scale the gravity applied to this body. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2BodyDef.prototype.gravityScale = 1;\r\n\r\n/** \r\n * @enum\r\n */\r\nbox2d.b2BodyFlag = \r\n{\r\n\te_none\t\t\t\t: 0,\r\n\te_islandFlag\t\t: 0x0001,\r\n\te_awakeFlag\t\t\t: 0x0002,\r\n\te_autoSleepFlag\t\t: 0x0004,\r\n\te_bulletFlag\t\t: 0x0008,\r\n\te_fixedRotationFlag\t: 0x0010,\r\n\te_activeFlag\t\t: 0x0020,\r\n\te_toiFlag\t\t\t: 0x0040\r\n};\r\ngoog.exportProperty(box2d.b2BodyFlag, 'e_none'             , box2d.b2BodyFlag.e_none             );\r\ngoog.exportProperty(box2d.b2BodyFlag, 'e_islandFlag'       , box2d.b2BodyFlag.e_islandFlag       );\r\ngoog.exportProperty(box2d.b2BodyFlag, 'e_awakeFlag'        , box2d.b2BodyFlag.e_awakeFlag        );\r\ngoog.exportProperty(box2d.b2BodyFlag, 'e_autoSleepFlag'    , box2d.b2BodyFlag.e_autoSleepFlag    );\r\ngoog.exportProperty(box2d.b2BodyFlag, 'e_bulletFlag'       , box2d.b2BodyFlag.e_bulletFlag       );\r\ngoog.exportProperty(box2d.b2BodyFlag, 'e_fixedRotationFlag', box2d.b2BodyFlag.e_fixedRotationFlag);\r\ngoog.exportProperty(box2d.b2BodyFlag, 'e_activeFlag'       , box2d.b2BodyFlag.e_activeFlag       );\r\ngoog.exportProperty(box2d.b2BodyFlag, 'e_toiFlag'          , box2d.b2BodyFlag.e_toiFlag          );\r\n\r\n/** \r\n * A rigid body. These are created via \r\n * box2d.b2World::CreateBody. \r\n * @export \r\n * @constructor\r\n * @param {box2d.b2BodyDef} bd\r\n * @param {box2d.b2World} world\r\n */\r\nbox2d.b2Body = function (bd, world)\r\n{\r\n\tthis.m_xf = new box2d.b2Transform();\r\n\tthis.m_out_xf = new box2d.b2Transform();\r\n\tthis.m_sweep = new box2d.b2Sweep();\r\n\tthis.m_out_sweep = new box2d.b2Sweep();\r\n\tthis.m_linearVelocity = new box2d.b2Vec2();\r\n\tthis.m_out_linearVelocity = new box2d.b2Vec2();\r\n\tthis.m_force = new box2d.b2Vec2();\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(bd.position.IsValid()); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(bd.linearVelocity.IsValid()); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.angle)); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.angularVelocity)); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.gravityScale) && bd.gravityScale >= 0); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.angularDamping) && bd.angularDamping >= 0); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(bd.linearDamping) && bd.linearDamping >= 0); }\r\n\r\n\tthis.m_flags = box2d.b2BodyFlag.e_none;\r\n\r\n\tif (bd.bullet)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2BodyFlag.e_bulletFlag;\r\n\t}\r\n\tif (bd.fixedRotation)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag;\r\n\t}\r\n\tif (bd.allowSleep)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag;\r\n\t}\r\n\tif (bd.awake)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2BodyFlag.e_awakeFlag;\r\n\t}\r\n\tif (bd.active)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2BodyFlag.e_activeFlag;\r\n\t}\r\n\r\n\tthis.m_world = world;\r\n\r\n\tthis.m_xf.p.Copy(bd.position);\r\n\tthis.m_xf.q.SetAngleRadians(bd.angle);\r\n\r\n\tthis.m_sweep.localCenter.SetZero();\r\n\tthis.m_sweep.c0.Copy(this.m_xf.p);\r\n\tthis.m_sweep.c.Copy(this.m_xf.p);\r\n\tthis.m_sweep.a0 = bd.angle;\r\n\tthis.m_sweep.a = bd.angle;\r\n\tthis.m_sweep.alpha0 = 0;\r\n\r\n\tthis.m_linearVelocity.Copy(bd.linearVelocity);\r\n\tthis.m_angularVelocity = bd.angularVelocity;\r\n\r\n\tthis.m_linearDamping = bd.linearDamping;\r\n\tthis.m_angularDamping = bd.angularDamping;\r\n\tthis.m_gravityScale = bd.gravityScale;\r\n\r\n\tthis.m_force.SetZero();\r\n\tthis.m_torque = 0;\r\n\r\n\tthis.m_sleepTime = 0;\r\n\r\n\tthis.m_type = bd.type;\r\n\r\n\tif (bd.type === box2d.b2BodyType.b2_dynamicBody)\r\n\t{\r\n\t\tthis.m_mass = 1;\r\n\t\tthis.m_invMass = 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_mass = 0;\r\n\t\tthis.m_invMass = 0;\r\n\t}\r\n\r\n\tthis.m_I = 0;\r\n\tthis.m_invI = 0;\r\n\r\n\tthis.m_userData = bd.userData;\r\n\r\n\tthis.m_fixtureList = null;\r\n\tthis.m_fixtureCount = 0;\r\n\r\n\tthis.m_controllerList = null;\r\n\tthis.m_controllerCount = 0;\r\n}\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2BodyFlag}\r\n */\r\nbox2d.b2Body.prototype.m_flags = box2d.b2BodyFlag.e_none;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_islandIndex = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2World}\r\n */\r\nbox2d.b2Body.prototype.m_world = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Transform}\r\n */\r\nbox2d.b2Body.prototype.m_xf = null; // the body origin transform\r\n/**\r\n * @export \r\n * @type {box2d.b2Transform}\r\n */\r\nbox2d.b2Body.prototype.m_out_xf = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Sweep}\r\n */\r\nbox2d.b2Body.prototype.m_sweep = null; // the swept motion for CCD\r\n/**\r\n * @export \r\n * @type {box2d.b2Sweep}\r\n */\r\nbox2d.b2Body.prototype.m_out_sweep = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2JointEdge}\r\n */\r\nbox2d.b2Body.prototype.m_jointList = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactEdge}\r\n */\r\nbox2d.b2Body.prototype.m_contactList = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2Body.prototype.m_prev = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2Body.prototype.m_next = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2Body.prototype.m_linearVelocity = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2Body.prototype.m_out_linearVelocity = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_angularVelocity = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_linearDamping = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_angularDamping = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_gravityScale = 1;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2Body.prototype.m_force = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_torque = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_sleepTime = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2BodyType} \r\n */\r\nbox2d.b2Body.prototype.m_type = box2d.b2BodyType.b2_staticBody;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_mass = 1;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_invMass = 1;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_I = 0; // Rotational inertia about the center of mass.\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_invI = 0;\r\n/**\r\n * @export \r\n * @type {*}\r\n */\r\nbox2d.b2Body.prototype.m_userData = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Fixture}\r\n */\r\nbox2d.b2Body.prototype.m_fixtureList = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_fixtureCount = 0;\r\n/** \r\n * @see box2d.b2Controller list \r\n * @export \r\n * @type {box2d.b2ControllerEdge}\r\n */\r\nbox2d.b2Body.prototype.m_controllerList = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2Body.prototype.m_controllerCount = 0;\r\n\r\n/** \r\n * Creates a fixture and attach it to this body. Use this \r\n * function if you need to set some fixture parameters, like \r\n * friction. Otherwise you can create the fixture directly from \r\n * a shape. \r\n * If the density is non-zero, this function automatically \r\n * updates the mass of the body. Contacts are not created until \r\n * the next time step. \r\n * warning This function is locked during callbacks.\r\n * @export \r\n * @return {box2d.b2Fixture}\r\n * @param {box2d.b2FixtureDef} def the fixture definition.\r\n */\r\nbox2d.b2Body.prototype.CreateFixture = function (def)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }\r\n\tif (this.m_world.IsLocked() === true)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\r\n\tvar fixture = new box2d.b2Fixture();\r\n\tfixture.Create(this, def);\r\n\r\n\tif (this.m_flags & box2d.b2BodyFlag.e_activeFlag)\r\n\t{\r\n\t\tvar broadPhase = this.m_world.m_contactManager.m_broadPhase;\r\n\t\tfixture.CreateProxies(broadPhase, this.m_xf);\r\n\t}\r\n\r\n\tfixture.m_next = this.m_fixtureList;\r\n\tthis.m_fixtureList = fixture;\r\n\t++this.m_fixtureCount;\r\n\r\n\tfixture.m_body = this;\r\n\r\n\t// Adjust mass properties if needed.\r\n\tif (fixture.m_density > 0)\r\n\t{\r\n\t\tthis.ResetMassData();\r\n\t}\r\n\r\n\t// Let the world know we have a new fixture. This will cause new contacts\r\n\t// to be created at the beginning of the next time step.\r\n\tthis.m_world.m_flags |= box2d.b2WorldFlag.e_newFixture;\r\n\r\n\treturn fixture;\r\n}\r\n\r\n/** \r\n * Creates a fixture from a shape and attach it to this body. \r\n * This is a convenience function. Use b2FixtureDef if you need \r\n * to set parameters like friction, restitution, user data, or \r\n * filtering. \r\n * If the density is non-zero, this function automatically \r\n * updates the mass of the body. \r\n * warning This function is locked during callbacks.\r\n * @export \r\n * @return {box2d.b2Fixture}\r\n * @param {box2d.b2Shape} shape the shape to be cloned.\r\n * @param {number} density the shape density (set to zero for static bodies).\r\n */\r\nbox2d.b2Body.prototype.CreateFixture2 = function (shape, density)\r\n{\r\n\tif (density === undefined) density = 0;\r\n\r\n\tvar def = box2d.b2Body.prototype.CreateFixture2.s_def;\r\n\tdef.shape = shape;\r\n\tdef.density = density;\r\n\treturn this.CreateFixture(def);\r\n}\r\nbox2d.b2Body.prototype.CreateFixture2.s_def = new box2d.b2FixtureDef();\r\n\r\n/** \r\n * Destroy a fixture. This removes the fixture from the \r\n * broad-phase and destroys all contacts associated with this \r\n * fixture. This will automatically adjust the mass of the body \r\n * if the body is dynamic and the fixture has positive density. \r\n * All fixtures attached to a body are implicitly destroyed when \r\n * the body is destroyed. \r\n * warning This function is locked during callbacks.\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixture the fixture to be removed.\r\n */\r\nbox2d.b2Body.prototype.DestroyFixture = function (fixture)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }\r\n\tif (this.m_world.IsLocked() === true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture.m_body === this); }\r\n\r\n\t// Remove the fixture from this body's singly linked list.\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_fixtureCount > 0); }\r\n\tvar node = this.m_fixtureList;\r\n\tvar ppF = null;\r\n\tvar found = false;\r\n\twhile (node !== null)\r\n\t{\r\n\t\tif (node === fixture)\r\n\t\t{\r\n\t\t\tif (ppF)\r\n\t\t\t\tppF.m_next = fixture.m_next;\r\n\t\t\telse\r\n\t\t\t\tthis.m_fixtureList = fixture.m_next;\r\n\t\t\tfound = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tppF = node;\r\n\t\tnode = node.m_next;\r\n\t}\r\n\r\n\t// You tried to remove a shape that is not attached to this body.\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(found); }\r\n\r\n\t// Destroy any contacts associated with the fixture.\r\n\tvar edge = this.m_contactList;\r\n\twhile (edge)\r\n\t{\r\n\t\tvar c = edge.contact;\r\n\t\tedge = edge.next;\r\n\r\n\t\tvar fixtureA = c.GetFixtureA();\r\n\t\tvar fixtureB = c.GetFixtureB();\r\n\r\n\t\tif (fixture === fixtureA || fixture === fixtureB)\r\n\t\t{\r\n\t\t\t// This destroys the contact and removes it from\r\n\t\t\t// this body's contact list.\r\n\t\t\tthis.m_world.m_contactManager.Destroy(c);\r\n\t\t}\r\n\t}\r\n\r\n\tif (this.m_flags & box2d.b2BodyFlag.e_activeFlag)\r\n\t{\r\n\t\tvar broadPhase = this.m_world.m_contactManager.m_broadPhase;\r\n\t\tfixture.DestroyProxies(broadPhase);\r\n\t}\r\n\r\n\tfixture.Destroy();\r\n\tfixture.m_body = null;\r\n\tfixture.m_next = null;\r\n\r\n\t--this.m_fixtureCount;\r\n\r\n\t// Reset the mass data.\r\n\tthis.ResetMassData();\r\n}\r\n\r\n/** \r\n * Set the position of the body's origin and rotation. \r\n * Manipulating a body's transform may cause non-physical \r\n * behavior. \r\n * Note: contacts are updated on the next call to b2World::Step.\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} position the world position of the body's local origin.\r\n * @param {number} angle the world rotation in radians.\r\n */\r\nbox2d.b2Body.prototype.SetTransformVecRadians = function (position, angle)\r\n{\r\n\tthis.SetTransformXYRadians(position.x, position.y, angle);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} angle \r\n */\r\nbox2d.b2Body.prototype.SetTransformXYRadians = function (x, y, angle)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }\r\n\tif (this.m_world.IsLocked() === true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif ((this.m_xf.p.x === x) && \r\n\t\t(this.m_xf.p.y === y) && \r\n\t\t(this.m_xf.q.GetAngleRadians()) === angle)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tthis.m_xf.q.SetAngleRadians(angle);\r\n\tthis.m_xf.p.SetXY(x, y);\r\n\r\n\tbox2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);\r\n\tthis.m_sweep.a = angle;\r\n\r\n\tthis.m_sweep.c0.Copy(this.m_sweep.c);\r\n\tthis.m_sweep.a0 = angle;\r\n\r\n\tvar broadPhase = this.m_world.m_contactManager.m_broadPhase;\r\n\tfor (var f = this.m_fixtureList; f; f = f.m_next)\r\n\t{\r\n\t\tf.Synchronize(broadPhase, this.m_xf, this.m_xf);\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Transform} xf \r\n */\r\nbox2d.b2Body.prototype.SetTransform = function (xf)\r\n{\r\n\tthis.SetTransformVecRadians(xf.p, xf.GetAngleRadians());\r\n}\r\n\r\n/** \r\n * Get the body transform for the body's origin. \r\n * @export \r\n * @return {box2d.b2Transform} the world transform of the body's origin.\r\n * @param {box2d.b2Transform=} out \r\n */\r\nbox2d.b2Body.prototype.GetTransform = function (out)\r\n{\r\n\tout = out || this.m_out_xf;\r\n\treturn out.Copy(this.m_xf);\r\n}\r\n\r\n/** \r\n * Get the world body origin position. \r\n * @export \r\n * @return {box2d.b2Vec2} the world position of the body's origin.\r\n * @param {box2d.b2Vec2=} out \r\n */\r\nbox2d.b2Body.prototype.GetPosition = function (out)\r\n{\r\n\tout = out || this.m_out_xf.p;\r\n\treturn out.Copy(this.m_xf.p);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} position \r\n */\r\nbox2d.b2Body.prototype.SetPosition = function (position)\r\n{\r\n\tthis.SetTransformVecRadians(position, this.GetAngleRadians());\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} x\r\n * @param {number} y \r\n */\r\nbox2d.b2Body.prototype.SetPositionXY = function (x, y)\r\n{\r\n\tthis.SetTransformXYRadians(x, y, this.GetAngleRadians());\r\n}\r\n\r\n/** \r\n * Get the angle in radians. \r\n * @export \r\n * @return {number} the current world rotation angle in radians.\r\n */\r\nbox2d.b2Body.prototype.GetAngle = function ()\r\n{\r\n\treturn this.m_sweep.a;\r\n}\r\n\r\nbox2d.b2Body.prototype.GetAngleRadians = box2d.b2Body.prototype.GetAngle;\r\n\r\nbox2d.b2Body.prototype.GetAngleDegrees = function () { return box2d.b2RadToDeg(this.GetAngle()); }\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} angle \r\n */\r\nbox2d.b2Body.prototype.SetAngle = function (angle)\r\n{\r\n\tthis.SetTransformVecRadians(this.GetPosition(), angle);\r\n}\r\n\r\nbox2d.b2Body.prototype.SetAngleRadians = box2d.b2Body.prototype.SetAngle;\r\n\r\nbox2d.b2Body.prototype.SetAngleDegrees = function (angle) { this.SetAngle(box2d.b2DegToRad(angle)); }\r\n\r\n/** \r\n * Get the world position of the center of mass. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2=} out \r\n */\r\nbox2d.b2Body.prototype.GetWorldCenter = function (out)\r\n{\r\n\tout = out || this.m_out_sweep.c;\r\n\treturn out.Copy(this.m_sweep.c);\r\n}\r\n\r\n/** \r\n * Get the local position of the center of mass. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2=} out \r\n */\r\nbox2d.b2Body.prototype.GetLocalCenter = function (out)\r\n{\r\n\tout = out || this.m_out_sweep.localCenter;\r\n\treturn out.Copy(this.m_sweep.localCenter);\r\n}\r\n\r\n/** \r\n * Set the linear velocity of the center of mass. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} v the new linear velocity of the center of mass.\r\n */\r\nbox2d.b2Body.prototype.SetLinearVelocity = function (v)\r\n{\r\n\tif (this.m_type === box2d.b2BodyType.b2_staticBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (box2d.b2DotVV(v,v) > 0)\r\n\t{\r\n\t\tthis.SetAwake(true);\r\n\t}\r\n\r\n\tthis.m_linearVelocity.Copy(v);\r\n}\r\n\r\n/** \r\n * Get the linear velocity of the center of mass. \r\n * @export \r\n * @return {box2d.b2Vec2} the linear velocity of the center of mass.\r\n * @param {box2d.b2Vec2=} out \r\n */\r\nbox2d.b2Body.prototype.GetLinearVelocity = function (out)\r\n{\r\n\tout = out || this.m_out_linearVelocity;\r\n\treturn out.Copy(this.m_linearVelocity);\r\n}\r\n\r\n/** \r\n * Set the angular velocity. \r\n * @export \r\n * @return {void} \r\n * @param {number} w the new angular velocity in radians/second.\r\n */\r\nbox2d.b2Body.prototype.SetAngularVelocity = function (w)\r\n{\r\n\tif (this.m_type === box2d.b2BodyType.b2_staticBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (w * w > 0)\r\n\t{\r\n\t\tthis.SetAwake(true);\r\n\t}\r\n\r\n\tthis.m_angularVelocity = w;\r\n}\r\n\r\n/** \r\n * Get the angular velocity. \r\n * @export \r\n * @return {number} the angular velocity in radians/second.\r\n */\r\nbox2d.b2Body.prototype.GetAngularVelocity = function ()\r\n{\r\n\treturn this.m_angularVelocity;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2BodyDef} \r\n * @param {box2d.b2BodyDef} bd\r\n */\r\nbox2d.b2Body.prototype.GetDefinition = function (bd)\r\n{\r\n\tbd.type = this.GetType();\r\n\tbd.allowSleep = (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag;\r\n\tbd.angle = this.GetAngleRadians();\r\n\tbd.angularDamping = this.m_angularDamping;\r\n\tbd.gravityScale = this.m_gravityScale;\r\n\tbd.angularVelocity = this.m_angularVelocity;\r\n\tbd.fixedRotation = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag;\r\n\tbd.bullet = (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag;\r\n\tbd.awake = (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag;\r\n\tbd.linearDamping = this.m_linearDamping;\r\n\tbd.linearVelocity.Copy(this.GetLinearVelocity());\r\n\tbd.position.Copy(this.GetPosition());\r\n\tbd.userData = this.GetUserData();\r\n\treturn bd;\r\n}\r\n\r\n/** \r\n * Apply a force at a world point. If the force is not applied \r\n * at the center of mass, it will generate a torque and affect \r\n * the angular velocity. This wakes up the body. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} force the world force vector, usually in Newtons (N).\r\n * @param {box2d.b2Vec2} point the world position of the point of application. \r\n * @param {boolean=} wake also wake up the body \r\n */\r\nbox2d.b2Body.prototype.ApplyForce = function (force, point, wake)\r\n{\r\n\twake = wake || true;\r\n\r\n\tif (this.m_type !== box2d.b2BodyType.b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)\r\n\t{\r\n\t\tthis.SetAwake(true);\r\n\t}\r\n\r\n\t// Don't accumulate a force if the body is sleeping.\r\n\tif (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)\r\n\t{\r\n\t\tthis.m_force.x += force.x;\r\n\t\tthis.m_force.y += force.y;\r\n\t\tthis.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);\r\n\t}\r\n}\r\n\r\n/** \r\n * Apply a force to the center of mass. This wakes up the body. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} force the world force vector, usually in Newtons (N).\r\n * @param {boolean=} wake also wake up the body \r\n */\r\nbox2d.b2Body.prototype.ApplyForceToCenter = function (force, wake)\r\n{\r\n\twake = wake || true;\r\n\r\n\tif (this.m_type !== box2d.b2BodyType.b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)\r\n\t{\r\n\t\tthis.SetAwake(true);\r\n\t}\r\n\r\n\t// Don't accumulate a force if the body is sleeping.\r\n\tif (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)\r\n\t{\r\n\t\tthis.m_force.x += force.x;\r\n\t\tthis.m_force.y += force.y;\r\n\t}\r\n}\r\n\r\n/** \r\n * Apply a torque. This affects the angular velocity without \r\n * affecting the linear velocity of the center of mass. This \r\n * wakes up the body. \r\n * @export \r\n * @return {void} \r\n * @param {number} torque about the z-axis (out of the screen), usually in N-m.\r\n * @param {boolean=} wake also wake up the body \r\n */\r\nbox2d.b2Body.prototype.ApplyTorque = function (torque, wake)\r\n{\r\n\twake = wake || true;\r\n\r\n\tif (this.m_type !== box2d.b2BodyType.b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)\r\n\t{\r\n\t\tthis.SetAwake(true);\r\n\t}\r\n\r\n\t// Don't accumulate a force if the body is sleeping.\r\n\tif (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)\r\n\t{\r\n\t\tthis.m_torque += torque;\r\n\t}\r\n}\r\n\r\n/** \r\n * Apply an impulse at a point. This immediately modifies the \r\n * velocity. It also modifies the angular velocity if the point \r\n * of application is not at the center of mass. This wakes up \r\n * the body. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n * @param {box2d.b2Vec2} point the world position of the point of application.\r\n * @param {boolean=} wake also wake up the body \r\n */\r\nbox2d.b2Body.prototype.ApplyLinearImpulse = function (impulse, point, wake)\r\n{\r\n\twake = wake || true;\r\n\r\n\tif (this.m_type !== box2d.b2BodyType.b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)\r\n\t{\r\n\t\tthis.SetAwake(true);\r\n\t}\r\n\r\n\t// Don't accumulate a force if the body is sleeping.\r\n\tif (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)\r\n\t{\r\n\t\tthis.m_linearVelocity.x += this.m_invMass * impulse.x;\r\n\t\tthis.m_linearVelocity.y += this.m_invMass * impulse.y;\r\n\t\tthis.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);\r\n\t}\r\n}\r\n\r\n/** \r\n * Apply an angular impulse. \r\n * @export \r\n * @return {void} \r\n * @param {number} impulse the angular impulse in units of kg*m*m/s\r\n * @param {boolean=} wake also wake up the body \r\n */\r\nbox2d.b2Body.prototype.ApplyAngularImpulse = function (impulse, wake)\r\n{\r\n\twake = wake || true;\r\n\r\n\tif (this.m_type !== box2d.b2BodyType.b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (wake && (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)\r\n\t{\r\n\t\tthis.SetAwake(true);\r\n\t}\r\n\r\n\t// Don't accumulate a force if the body is sleeping.\r\n\tif (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)\r\n\t{\r\n\t\tthis.m_angularVelocity += this.m_invI * impulse;\r\n\t}\r\n}\r\n\r\n/** \r\n * Get the total mass of the body. \r\n * @export \r\n * @return {number} the mass, usually in kilograms (kg).\r\n */\r\nbox2d.b2Body.prototype.GetMass = function ()\r\n{\r\n\treturn this.m_mass;\r\n}\r\n\r\n/** \r\n * Get the rotational inertia of the body about the local \r\n * origin. \r\n * @export \r\n * @return {number} the rotational inertia, usually in kg-m^2.\r\n */\r\nbox2d.b2Body.prototype.GetInertia = function ()\r\n{\r\n\treturn this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);\r\n}\r\n\r\n/** \r\n * Get the mass data of the body. \r\n * @export \r\n * @return {box2d.b2MassData} a struct containing the mass, inertia and center of the body.\r\n * @param {box2d.b2MassData} data\r\n */\r\nbox2d.b2Body.prototype.GetMassData = function (data)\r\n{\r\n\tdata.mass = this.m_mass;\r\n\tdata.I = this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);\r\n\tdata.center.Copy(this.m_sweep.localCenter);\r\n\treturn data;\r\n}\r\n\r\n/** \r\n * Set the mass properties to override the mass properties of \r\n * the fixtures. \r\n * Note that this changes the center of mass position. \r\n * Note that creating or destroying fixtures can also alter the \r\n * mass. \r\n * This function has no effect if the body isn't dynamic. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2MassData} massData the mass properties.\r\n */\r\nbox2d.b2Body.prototype.SetMassData = function (massData)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }\r\n\tif (this.m_world.IsLocked() === true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (this.m_type !== box2d.b2BodyType.b2_dynamicBody)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tthis.m_invMass = 0;\r\n\tthis.m_I = 0;\r\n\tthis.m_invI = 0;\r\n\r\n\tthis.m_mass = massData.mass;\r\n\tif (this.m_mass <= 0)\r\n\t{\r\n\t\tthis.m_mass = 1;\r\n\t}\r\n\r\n\tthis.m_invMass = 1 / this.m_mass;\r\n\r\n\tif (massData.I > 0 && (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === 0)\r\n\t{\r\n\t\tthis.m_I = massData.I - this.m_mass * box2d.b2DotVV(massData.center, massData.center);\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_I > 0); }\r\n\t\tthis.m_invI = 1 / this.m_I;\r\n\t}\r\n\r\n\t// Move center of mass.\r\n\tvar oldCenter = box2d.b2Body.prototype.SetMassData.s_oldCenter.Copy(this.m_sweep.c);\r\n\tthis.m_sweep.localCenter.Copy(massData.center);\r\n\tbox2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);\r\n\tthis.m_sweep.c0.Copy(this.m_sweep.c);\r\n\r\n\t// Update center of mass velocity.\r\n\tbox2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, oldCenter, box2d.b2Vec2.s_t0), this.m_linearVelocity);\r\n}\r\nbox2d.b2Body.prototype.SetMassData.s_oldCenter = new box2d.b2Vec2();\r\n\r\n/** \r\n * This resets the mass properties to the sum of the mass \r\n * properties of the fixtures. This normally does not need to be \r\n * called unless you called SetMassData to override the mass and \r\n * you later want to reset the mass. \r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Body.prototype.ResetMassData = function ()\r\n{\r\n\t// Compute mass data from shapes. Each shape has its own density.\r\n\tthis.m_mass = 0;\r\n\tthis.m_invMass = 0;\r\n\tthis.m_I = 0;\r\n\tthis.m_invI = 0;\r\n\tthis.m_sweep.localCenter.SetZero();\r\n\r\n\t// Static and kinematic bodies have zero mass.\r\n\tif (this.m_type === box2d.b2BodyType.b2_staticBody || this.m_type === box2d.b2BodyType.b2_kinematicBody)\r\n\t{\r\n\t\tthis.m_sweep.c0.Copy(this.m_xf.p);\r\n\t\tthis.m_sweep.c.Copy(this.m_xf.p);\r\n\t\tthis.m_sweep.a0 = this.m_sweep.a;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_type === box2d.b2BodyType.b2_dynamicBody); }\r\n\r\n\t// Accumulate mass over all fixtures.\r\n\tvar localCenter = box2d.b2Body.prototype.ResetMassData.s_localCenter.SetZero();\r\n\tfor (var f = this.m_fixtureList; f; f = f.m_next)\r\n\t{\r\n\t\tif (f.m_density === 0)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvar massData = f.GetMassData(box2d.b2Body.prototype.ResetMassData.s_massData);\r\n\t\tthis.m_mass += massData.mass;\r\n\t\tlocalCenter.x += massData.center.x * massData.mass;\r\n\t\tlocalCenter.y += massData.center.y * massData.mass;\r\n\t\tthis.m_I += massData.I;\r\n\t}\r\n\r\n\t// Compute center of mass.\r\n\tif (this.m_mass > 0)\r\n\t{\r\n\t\tthis.m_invMass = 1 / this.m_mass;\r\n\t\tlocalCenter.x *= this.m_invMass;\r\n\t\tlocalCenter.y *= this.m_invMass;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Force all dynamic bodies to have a positive mass.\r\n\t\tthis.m_mass = 1;\r\n\t\tthis.m_invMass = 1;\r\n\t}\r\n\r\n\tif (this.m_I > 0 && (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === 0)\r\n\t{\r\n\t\t// Center the inertia about the center of mass.\r\n\t\tthis.m_I -= this.m_mass * box2d.b2DotVV(localCenter, localCenter);\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_I > 0); }\r\n\t\tthis.m_invI = 1 / this.m_I;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_I = 0;\r\n\t\tthis.m_invI = 0;\r\n\t}\r\n\r\n\t// Move center of mass.\r\n\tvar oldCenter = box2d.b2Body.prototype.ResetMassData.s_oldCenter.Copy(this.m_sweep.c);\r\n\tthis.m_sweep.localCenter.Copy(localCenter);\r\n\tbox2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);\r\n\tthis.m_sweep.c0.Copy(this.m_sweep.c);\r\n\r\n\t// Update center of mass velocity.\r\n\tbox2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, oldCenter, box2d.b2Vec2.s_t0), this.m_linearVelocity);\r\n}\r\nbox2d.b2Body.prototype.ResetMassData.s_localCenter = new box2d.b2Vec2();\r\nbox2d.b2Body.prototype.ResetMassData.s_oldCenter = new box2d.b2Vec2();\r\nbox2d.b2Body.prototype.ResetMassData.s_massData = new box2d.b2MassData();\r\n\r\n/** \r\n * Get the world coordinates of a point given the local \r\n * coordinates. \r\n * @export \r\n * @return {box2d.b2Vec2} the same point expressed in world coordinates.\r\n * @param {box2d.b2Vec2} localPoint a point on the body measured relative the the body's origin.\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Body.prototype.GetWorldPoint = function (localPoint, out)\r\n{\r\n\treturn box2d.b2MulXV(this.m_xf, localPoint, out);\r\n}\r\n\r\n/** \r\n * Get the world coordinates of a vector given the local \r\n * coordinates. \r\n * @export \r\n * @return {box2d.b2Vec2} the same vector expressed in world coordinates.\r\n * @param {box2d.b2Vec2} localVector a vector fixed in the body.\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Body.prototype.GetWorldVector = function (localVector, out)\r\n{\r\n\treturn box2d.b2MulRV(this.m_xf.q, localVector, out);\r\n}\r\n\r\n/** \r\n * Gets a local point relative to the body's origin given a \r\n * world point. \r\n * @export \r\n * @return {box2d.b2Vec2} the corresponding local point relative to the body's origin.\r\n * @param {box2d.b2Vec2} worldPoint a point in world coordinates.\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Body.prototype.GetLocalPoint = function (worldPoint, out)\r\n{\r\n\treturn box2d.b2MulTXV(this.m_xf, worldPoint, out);\r\n}\r\n\r\n/** \r\n * Gets a local vector given a world vector. \r\n * @export \r\n * @return {box2d.b2Vec2} the corresponding local vector.\r\n * @param {box2d.b2Vec2} worldVector a vector in world coordinates.\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Body.prototype.GetLocalVector = function (worldVector, out)\r\n{\r\n\treturn box2d.b2MulTRV(this.m_xf.q, worldVector, out);\r\n}\r\n\r\n/** \r\n * Get the world linear velocity of a world point attached to \r\n * this body. \r\n * @export \r\n * @return {box2d.b2Vec2} the world velocity of a point.\r\n * @param {box2d.b2Vec2} worldPoint a point in world coordinates.\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint, out)\r\n{\r\n\treturn box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(worldPoint, this.m_sweep.c, box2d.b2Vec2.s_t0), out);\r\n}\r\n\r\n/** \r\n * Get the world velocity of a local point. \r\n * @export \r\n * @return {box2d.b2Vec2} the world velocity of a point.\r\n * @param {box2d.b2Vec2} localPoint a point in local coordinates.\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint, out)\r\n{\r\n\treturn this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(localPoint, out), out);\r\n}\r\n\r\n/** \r\n * Get the linear damping of the body. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Body.prototype.GetLinearDamping = function ()\r\n{\r\n\treturn this.m_linearDamping;\r\n}\r\n\r\n/** \r\n * Set the linear damping of the body. \r\n * @export \r\n * @param {number} linearDamping\r\n */\r\nbox2d.b2Body.prototype.SetLinearDamping = function (linearDamping)\r\n{\r\n\tthis.m_linearDamping = linearDamping;\r\n}\r\n\r\n/** \r\n * Get the angular damping of the body. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Body.prototype.GetAngularDamping = function ()\r\n{\r\n\treturn this.m_angularDamping;\r\n}\r\n\r\n/** \r\n * Set the angular damping of the body. \r\n * @export \r\n * @return {void} \r\n * @param {number} angularDamping \r\n */\r\nbox2d.b2Body.prototype.SetAngularDamping = function (angularDamping)\r\n{\r\n\tthis.m_angularDamping = angularDamping;\r\n}\r\n\r\n/** \r\n * Get the gravity scale of the body. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Body.prototype.GetGravityScale = function ()\r\n{\r\n\treturn this.m_gravityScale;\r\n}\r\n\r\n/** \r\n * Set the gravity scale of the body. \r\n * @export \r\n * @return {void} \r\n * @param {number} scale \r\n */\r\nbox2d.b2Body.prototype.SetGravityScale = function (scale)\r\n{\r\n\tthis.m_gravityScale = scale;\r\n}\r\n\r\n/** \r\n * Set the type of this body. This may alter the mass and \r\n * velocity. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2BodyType} type \r\n */\r\nbox2d.b2Body.prototype.SetType = function (type)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }\r\n\tif (this.m_world.IsLocked() === true)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (this.m_type === type)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tthis.m_type = type;\r\n\r\n\tthis.ResetMassData();\r\n\r\n\tif (this.m_type === box2d.b2BodyType.b2_staticBody)\r\n\t{\r\n\t\tthis.m_linearVelocity.SetZero();\r\n\t\tthis.m_angularVelocity = 0;\r\n\t\tthis.m_sweep.a0 = this.m_sweep.a;\r\n\t\tthis.m_sweep.c0.Copy(this.m_sweep.c);\r\n\t\tthis.SynchronizeFixtures();\r\n\t}\r\n\r\n\tthis.SetAwake(true);\r\n\r\n\tthis.m_force.SetZero();\r\n\tthis.m_torque = 0;\r\n\r\n\t// Delete the attached contacts.\r\n\t/** @type {box2d.b2ContactEdge} */ var ce = this.m_contactList;\r\n\twhile (ce)\r\n\t{\r\n\t\t/** @type {box2d.b2ContactEdge} */ var ce0 = ce;\r\n\t\tce = ce.next;\r\n\t\tthis.m_world.m_contactManager.Destroy(ce0.contact);\r\n\t}\r\n\tthis.m_contactList = null;\r\n\r\n\t// Touch the proxies so that new contacts will be created (when appropriate)\r\n\t/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_world.m_contactManager.m_broadPhase;\r\n\tfor (/** @type {box2d.b2Fixture} */ var f = this.m_fixtureList; f; f = f.m_next)\r\n\t{\r\n\t\tvar proxyCount = f.m_proxyCount;\r\n\t\tfor (var i = 0; i < proxyCount; ++i)\r\n\t\t{\r\n\t\t\tbroadPhase.TouchProxy(f.m_proxies[i].proxy);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** \r\n * Get the type of this body. \r\n * @export \r\n * @return {box2d.b2BodyType}\r\n */\r\nbox2d.b2Body.prototype.GetType = function ()\r\n{\r\n\treturn this.m_type;\r\n}\r\n\r\n/** \r\n * Should this body be treated like a bullet for continuous \r\n * collision detection? \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag \r\n */\r\nbox2d.b2Body.prototype.SetBullet = function (flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2BodyFlag.e_bulletFlag;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_flags &= ~box2d.b2BodyFlag.e_bulletFlag;\r\n\t}\r\n}\r\n\r\n/** \r\n * Is this body treated like a bullet for continuous collision \r\n * detection? \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2Body.prototype.IsBullet = function ()\r\n{\r\n\treturn (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag;\r\n}\r\n\r\n/** \r\n * You can disable sleeping on this body. If you disable \r\n * sleeping, the body will be woken. \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag \r\n */\r\nbox2d.b2Body.prototype.SetSleepingAllowed = function (flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_flags &= ~box2d.b2BodyFlag.e_autoSleepFlag;\r\n\t\tthis.SetAwake(true);\r\n\t}\r\n}\r\n\r\n/** \r\n * Is this body allowed to sleep \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2Body.prototype.IsSleepingAllowed = function ()\r\n{\r\n\treturn (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag;\r\n}\r\n\r\n/** \r\n * Set the sleep state of the body. A sleeping body has very low CPU cost. \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag set to true to wake the body, false to \r\n *  \t  put it to sleep.\r\n */\r\nbox2d.b2Body.prototype.SetAwake = function (flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tif ((this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === 0)\r\n\t\t{\r\n\t\t\tthis.m_flags |= box2d.b2BodyFlag.e_awakeFlag;\r\n\t\t\tthis.m_sleepTime = 0;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_flags &= ~box2d.b2BodyFlag.e_awakeFlag;\r\n\t\tthis.m_sleepTime = 0;\r\n\t\tthis.m_linearVelocity.SetZero();\r\n\t\tthis.m_angularVelocity = 0;\r\n\t\tthis.m_force.SetZero();\r\n\t\tthis.m_torque = 0;\r\n\t}\r\n}\r\n\r\n/** \r\n * Get the sleeping state of this body. \r\n * @export \r\n * @return {boolean} true if the body is awake.\r\n */\r\nbox2d.b2Body.prototype.IsAwake = function ()\r\n{\r\n\treturn (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag;\r\n}\r\n\r\n/**\r\n * Set the active state of the body. An inactive body is not\r\n * simulated and cannot be collided with or woken up.\r\n * If you pass a flag of true, all fixtures will be added to the\r\n * broad-phase.\r\n * If you pass a flag of false, all fixtures will be removed from\r\n * the broad-phase and all contacts will be destroyed.\r\n * Fixtures and joints are otherwise unaffected. You may continue\r\n * to create/destroy fixtures and joints on inactive bodies.\r\n * Fixtures on an inactive body are implicitly inactive and will\r\n * not participate in collisions, ray-casts, or queries.\r\n * Joints connected to an inactive body are implicitly inactive.\r\n * An inactive body is still owned by a b2World object and remains\r\n * in the body list.\r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag \r\n */\r\nbox2d.b2Body.prototype.SetActive = function (flag)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_world.IsLocked() === false); }\r\n\r\n\tif (flag === this.IsActive())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (flag)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2BodyFlag.e_activeFlag;\r\n\r\n\t\t// Create all proxies.\r\n\t\tvar broadPhase = this.m_world.m_contactManager.m_broadPhase;\r\n\t\tfor (var f = this.m_fixtureList; f; f = f.m_next)\r\n\t\t{\r\n\t\t\tf.CreateProxies(broadPhase, this.m_xf);\r\n\t\t}\r\n\r\n\t\t// Contacts are created the next time step.\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_flags &= ~box2d.b2BodyFlag.e_activeFlag;\r\n\r\n\t\t// Destroy all proxies.\r\n\t\tvar broadPhase = this.m_world.m_contactManager.m_broadPhase;\r\n\t\tfor (var f = this.m_fixtureList; f; f = f.m_next)\r\n\t\t{\r\n\t\t\tf.DestroyProxies(broadPhase);\r\n\t\t}\r\n\r\n\t\t// Destroy the attached contacts.\r\n\t\tvar ce = this.m_contactList;\r\n\t\twhile (ce)\r\n\t\t{\r\n\t\t\tvar ce0 = ce;\r\n\t\t\tce = ce.next;\r\n\t\t\tthis.m_world.m_contactManager.Destroy(ce0.contact);\r\n\t\t}\r\n\t\tthis.m_contactList = null;\r\n\t}\r\n}\r\n\r\n/** \r\n * Get the active state of the body. \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2Body.prototype.IsActive = function ()\r\n{\r\n\treturn (this.m_flags & box2d.b2BodyFlag.e_activeFlag) === box2d.b2BodyFlag.e_activeFlag;\r\n}\r\n\r\n/** \r\n * Set this body to have fixed rotation. This causes the mass to \r\n * be reset. \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag \r\n */\r\nbox2d.b2Body.prototype.SetFixedRotation = function (flag)\r\n{\r\n\tvar status = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag;\r\n\tif (status === flag)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (flag)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_flags &= ~box2d.b2BodyFlag.e_fixedRotationFlag;\r\n\t}\r\n\r\n\tthis.m_angularVelocity = 0;\r\n\r\n\tthis.ResetMassData();\r\n}\r\n\r\n/** \r\n * Does this body have fixed rotation? \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2Body.prototype.IsFixedRotation = function ()\r\n{\r\n\treturn (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag;\r\n}\r\n\r\n/** \r\n * Get the list of all fixtures attached to this body. \r\n * @export \r\n * @return {box2d.b2Fixture}\r\n */\r\nbox2d.b2Body.prototype.GetFixtureList = function ()\r\n{\r\n\treturn this.m_fixtureList;\r\n}\r\n\r\n/** \r\n * Get the list of all joints attached to this body. \r\n * @export \r\n * @return {box2d.b2JointEdge}\r\n */\r\nbox2d.b2Body.prototype.GetJointList = function ()\r\n{\r\n\treturn this.m_jointList;\r\n}\r\n\r\n/** \r\n * Get the list of all contacts attached to this body. \r\n * warning this list changes during the time step and you may \r\n * miss some collisions if you don't use b2ContactListener. \r\n * @export \r\n * @return {box2d.b2ContactEdge}\r\n */\r\nbox2d.b2Body.prototype.GetContactList = function ()\r\n{\r\n\treturn this.m_contactList;\r\n}\r\n\r\n/** \r\n * Get the next body in the world's body list. \r\n * @export \r\n * @return {box2d.b2Body}\r\n */\r\nbox2d.b2Body.prototype.GetNext = function ()\r\n{\r\n\treturn this.m_next;\r\n}\r\n\r\n/** \r\n * Get the user data pointer that was provided in the body \r\n * definition. \r\n * @export \r\n * @return {*} \r\n */\r\nbox2d.b2Body.prototype.GetUserData = function ()\r\n{\r\n\treturn this.m_userData;\r\n}\r\n\r\n/** \r\n * Set the user data. Use this to store your application \r\n * specific data. \r\n * @export \r\n * @return {void} \r\n * @param {*} data \r\n */\r\nbox2d.b2Body.prototype.SetUserData = function (data)\r\n{\r\n\tthis.m_userData = data;\r\n}\r\n\r\n/** \r\n * Get the parent world of this body. \r\n * @export \r\n * @return {box2d.b2World}\r\n */\r\nbox2d.b2Body.prototype.GetWorld = function ()\r\n{\r\n\treturn this.m_world;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Body.prototype.SynchronizeFixtures = function ()\r\n{\r\n\tvar xf1 = box2d.b2Body.prototype.SynchronizeFixtures.s_xf1;\r\n\txf1.q.SetAngleRadians(this.m_sweep.a0);\r\n\tbox2d.b2MulRV(xf1.q, this.m_sweep.localCenter, xf1.p);\r\n\tbox2d.b2SubVV(this.m_sweep.c0, xf1.p, xf1.p);\r\n\r\n\tvar broadPhase = this.m_world.m_contactManager.m_broadPhase;\r\n\tfor (var f = this.m_fixtureList; f; f = f.m_next)\r\n\t{\r\n\t\tf.Synchronize(broadPhase, xf1, this.m_xf);\r\n\t}\r\n}\r\nbox2d.b2Body.prototype.SynchronizeFixtures.s_xf1 = new box2d.b2Transform();\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2Body.prototype.SynchronizeTransform = function ()\r\n{\r\n\tthis.m_xf.q.SetAngleRadians(this.m_sweep.a);\r\n\tbox2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);\r\n\tbox2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);\r\n}\r\n\r\n/** \r\n * This is used to prevent connected bodies from colliding. \r\n * It may lie, depending on the collideConnected flag.\r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2Body} other \r\n */\r\nbox2d.b2Body.prototype.ShouldCollide = function (other)\r\n{\r\n\t// At least one body should be dynamic.\r\n\tif (this.m_type !== box2d.b2BodyType.b2_dynamicBody && other.m_type !== box2d.b2BodyType.b2_dynamicBody)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Does a joint prevent collision?\r\n\tfor (var jn = this.m_jointList; jn; jn = jn.next)\r\n\t{\r\n\t\tif (jn.other === other)\r\n\t\t{\r\n\t\t\tif (jn.joint.m_collideConnected === false)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} alpha \r\n */\r\nbox2d.b2Body.prototype.Advance = function (alpha)\r\n{\r\n\t// Advance to the new safe time. This doesn't sync the broad-phase.\r\n\tthis.m_sweep.Advance(alpha);\r\n\tthis.m_sweep.c.Copy(this.m_sweep.c0);\r\n\tthis.m_sweep.a = this.m_sweep.a0;\r\n\tthis.m_xf.q.SetAngleRadians(this.m_sweep.a);\r\n\tbox2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);\r\n\tbox2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);\r\n}\r\n\r\n/** \r\n * Dump this body to a log file \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2Body.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar bodyIndex = this.m_islandIndex;\r\n\t\r\n\t\tbox2d.b2Log(\"if (true)\\n\");\r\n\t\tbox2d.b2Log(\"{\\n\");\r\n\t\tbox2d.b2Log(\"  /*box2d.b2BodyDef*/ var bd = new box2d.b2BodyDef();\\n\");\r\n\t\tvar type_str = '';\r\n\t\tswitch (this.m_type)\r\n\t\t{\r\n\t\tcase box2d.b2BodyType.b2_staticBody:\r\n\t\t\ttype_str = 'box2d.b2BodyType.b2_staticBody';\r\n\t\t\tbreak;\r\n\t\tcase box2d.b2BodyType.b2_kinematicBody:\r\n\t\t\ttype_str = 'box2d.b2BodyType.b2_kinematicBody';\r\n\t\t\tbreak;\r\n\t\tcase box2d.b2BodyType.b2_dynamicBody:\r\n\t\t\ttype_str = 'box2d.b2BodyType.b2_dynamicBody';\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); }\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tbox2d.b2Log(\"  bd.type = %s;\\n\", type_str);\r\n\t\tbox2d.b2Log(\"  bd.position.SetXY(%.15f, %.15f);\\n\", this.m_xf.p.x, this.m_xf.p.y);\r\n\t\tbox2d.b2Log(\"  bd.angle = %.15f;\\n\", this.m_sweep.a);\r\n\t\tbox2d.b2Log(\"  bd.linearVelocity.SetXY(%.15f, %.15f);\\n\", this.m_linearVelocity.x, this.m_linearVelocity.y);\r\n\t\tbox2d.b2Log(\"  bd.angularVelocity = %.15f;\\n\", this.m_angularVelocity);\r\n\t\tbox2d.b2Log(\"  bd.linearDamping = %.15f;\\n\", this.m_linearDamping);\r\n\t\tbox2d.b2Log(\"  bd.angularDamping = %.15f;\\n\", this.m_angularDamping);\r\n\t\tbox2d.b2Log(\"  bd.allowSleep = %s;\\n\", (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  bd.awake = %s;\\n\", (this.m_flags & box2d.b2BodyFlag.e_awakeFlag)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  bd.fixedRotation = %s;\\n\", (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  bd.bullet = %s;\\n\", (this.m_flags & box2d.b2BodyFlag.e_bulletFlag)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  bd.active = %s;\\n\", (this.m_flags & box2d.b2BodyFlag.e_activeFlag)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  bd.gravityScale = %.15f;\\n\", this.m_gravityScale);\r\n\t\tbox2d.b2Log(\"\\n\");\r\n\t\tbox2d.b2Log(\"  bodies[%d] = this.m_world.CreateBody(bd);\\n\", this.m_islandIndex);\r\n\t\tbox2d.b2Log(\"\\n\");\r\n\t\tfor (/** @type {box2d.b2Fixture} */ var f = this.m_fixtureList; f; f = f.m_next)\r\n\t\t{\r\n\t\t\tbox2d.b2Log(\"  if (true)\\n\");\r\n\t\t\tbox2d.b2Log(\"  {\\n\");\r\n\t\t\tf.Dump(bodyIndex);\r\n\t\t\tbox2d.b2Log(\"  }\\n\");\r\n\t\t}\r\n\t\tbox2d.b2Log(\"}\\n\");\r\n\t}\r\n}\r\n\r\n/** \r\n * @see box2d.b2Controller list \r\n * @export \r\n * @return {box2d.b2ControllerEdge}\r\n */\r\nbox2d.b2Body.prototype.GetControllerList = function ()\r\n{\r\n\treturn this.m_controllerList;\r\n}\r\n\r\n/** \r\n * @see box2d.b2Controller list \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Body.prototype.GetControllerCount = function ()\r\n{\r\n\treturn this.m_controllerCount;\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2World');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Draw');\r\ngoog.require('box2d.b2ContactManager');\r\ngoog.require('box2d.b2ContactSolver');\r\ngoog.require('box2d.b2Island');\r\ngoog.require('box2d.b2Body');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2Collision');\r\ngoog.require('box2d.b2TimeStep');\r\ngoog.require('box2d.b2WorldCallbacks');\r\ngoog.require('box2d.b2JointFactory');\r\n\r\n/**\r\n * The world class manages all physics entities, dynamic \r\n * simulation, and asynchronous queries. The world also contains \r\n * efficient memory management facilities. \r\n */\r\n\r\n/**\r\n * @export \r\n * @enum\r\n */\r\nbox2d.b2WorldFlag = \r\n{\r\n\te_none\t\t\t: 0,\r\n\te_newFixture\t: 0x1,\r\n\te_locked\t\t: 0x2,\r\n\te_clearForces\t: 0x4\r\n};\r\ngoog.exportProperty(box2d.b2WorldFlag, 'e_none'       , box2d.b2WorldFlag.e_none       );\r\ngoog.exportProperty(box2d.b2WorldFlag, 'e_newFixture' , box2d.b2WorldFlag.e_newFixture );\r\ngoog.exportProperty(box2d.b2WorldFlag, 'e_locked'     , box2d.b2WorldFlag.e_locked     );\r\ngoog.exportProperty(box2d.b2WorldFlag, 'e_clearForces', box2d.b2WorldFlag.e_clearForces);\r\n\r\n/** \r\n * Construct a world object. \r\n * @export \r\n * @constructor\r\n * @param {box2d.b2Vec2} gravity the world gravity vector.\r\n */\r\nbox2d.b2World = function (gravity)\r\n{\r\n\tthis.m_flags = box2d.b2WorldFlag.e_clearForces;\r\n\r\n\tthis.m_contactManager = new box2d.b2ContactManager();\r\n\r\n\tthis.m_gravity = gravity.Clone();\r\n\tthis.m_out_gravity = new box2d.b2Vec2();\r\n\tthis.m_allowSleep = true;\r\n\r\n\tthis.m_destructionListener = null;\r\n\tthis.m_debugDraw = null;\r\n\r\n\tthis.m_warmStarting = true;\r\n\tthis.m_continuousPhysics = true;\r\n\tthis.m_subStepping = false;\r\n\r\n\tthis.m_stepComplete = true;\r\n\r\n\tthis.m_profile = new box2d.b2Profile();\r\n\r\n\tthis.m_island = new box2d.b2Island();\r\n\r\n\tthis.s_stack = new Array();\r\n}\r\n\r\n//b2BlockAllocator m_blockAllocator;\r\n//b2StackAllocator m_stackAllocator;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2WorldFlag}\r\n */\r\nbox2d.b2World.prototype.m_flags = box2d.b2WorldFlag.e_none;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2ContactManager}\r\n */\r\nbox2d.b2World.prototype.m_contactManager = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Body}\r\n */\r\nbox2d.b2World.prototype.m_bodyList = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Joint}\r\n */\r\nbox2d.b2World.prototype.m_jointList = null;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2World.prototype.m_bodyCount = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2World.prototype.m_jointCount = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2World.prototype.m_gravity = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2World.prototype.m_out_gravity = null;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2World.prototype.m_allowSleep = true;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2DestructionListener}\r\n */\r\nbox2d.b2World.prototype.m_destructionListener = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Draw}\r\n */\r\nbox2d.b2World.prototype.m_debugDraw = null;\r\n\r\n/** \r\n * This is used to compute the time step ratio to support a \r\n * variable time step. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2World.prototype.m_inv_dt0 = 0;\r\n\r\n/** \r\n * These are for debugging the solver. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2World.prototype.m_warmStarting = true;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2World.prototype.m_continuousPhysics = true;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2World.prototype.m_subStepping = false;\r\n\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2World.prototype.m_stepComplete = true;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Profile}\r\n */\r\nbox2d.b2World.prototype.m_profile = null;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Island}\r\n */\r\nbox2d.b2World.prototype.m_island = null;\r\n\r\n/**\r\n * @export \r\n * @type {Array.<?box2d.b2Body>}\r\n */\r\nbox2d.b2World.prototype.s_stack = null;\r\n\r\n/** \r\n * @see box2d.b2Controller list \r\n * @export \r\n * @type {box2d.b2Controller}\r\n */\r\nbox2d.b2World.prototype.m_controllerList = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2World.prototype.m_controllerCount = 0;\r\n\r\n/** \r\n * Enable/disable sleep. \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag \r\n */\r\nbox2d.b2World.prototype.SetAllowSleeping = function (flag)\r\n{\r\n\tif (flag === this.m_allowSleep)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tthis.m_allowSleep = flag;\r\n\tif (this.m_allowSleep === false)\r\n\t{\r\n\t\tfor (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t\t{\r\n\t\t\tb.SetAwake(true);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2World.prototype.GetAllowSleeping = function ()\r\n{\r\n\treturn this.m_allowSleep;\r\n}\r\n\r\n/** \r\n * Enable/disable warm starting. For testing. \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag\r\n */\r\nbox2d.b2World.prototype.SetWarmStarting = function (flag)\r\n{\r\n\tthis.m_warmStarting = flag;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2World.prototype.GetWarmStarting = function ()\r\n{\r\n\treturn this.m_warmStarting;\r\n}\r\n\r\n/** \r\n * Enable/disable continuous physics. For testing. \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag\r\n */\r\nbox2d.b2World.prototype.SetContinuousPhysics = function (flag)\r\n{\r\n\tthis.m_continuousPhysics = flag;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2World.prototype.GetContinuousPhysics = function ()\r\n{\r\n\treturn this.m_continuousPhysics;\r\n}\r\n\r\n/** \r\n * Enable/disable single stepped continuous physics. For \r\n * testing. \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag\r\n */\r\nbox2d.b2World.prototype.SetSubStepping = function (flag)\r\n{\r\n\tthis.m_subStepping = flag;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2World.prototype.GetSubStepping = function ()\r\n{\r\n\treturn this.m_subStepping;\r\n}\r\n\r\n/** \r\n * Get the world body list. With the returned body, use \r\n * b2Body::GetNext to get the next body in the world list. A \r\n * NULL body indicates the end of the list. \r\n * @export \r\n * @return {box2d.b2Body} the head of the world body list.\r\n */\r\nbox2d.b2World.prototype.GetBodyList = function ()\r\n{\r\n\treturn this.m_bodyList;\r\n}\r\n\r\n/** \r\n * Get the world joint list. With the returned joint, use \r\n * b2Joint::GetNext to get the next joint in the world list. A \r\n * NULL joint indicates the end of the list. \r\n * @export \r\n * @return {box2d.b2Joint} the head of the world joint list.\r\n */\r\nbox2d.b2World.prototype.GetJointList = function ()\r\n{\r\n\treturn this.m_jointList;\r\n}\r\n\r\n/** \r\n * Get the world contact list. With the returned contact, use \r\n * box2d.b2Contact::GetNext to get the next contact in the world \r\n * list. A NULL contact indicates the end of the list. \r\n * warning contacts are created and destroyed in the middle of a \r\n * time step. \r\n * Use box2d.b2ContactListener to avoid missing contacts.\r\n * @export \r\n * @return {box2d.b2Contact} the head of the world contact list.\r\n */\r\nbox2d.b2World.prototype.GetContactList = function ()\r\n{\r\n\treturn this.m_contactManager.m_contactList;\r\n}\r\n\r\n/** \r\n * Get the number of bodies. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2World.prototype.GetBodyCount = function ()\r\n{\r\n\treturn this.m_bodyCount;\r\n}\r\n\r\n/** \r\n * Get the number of joints. \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2World.prototype.GetJointCount = function ()\r\n{\r\n\treturn this.m_jointCount;\r\n}\r\n\r\n/** \r\n * Get the number of contacts (each may have 0 or more contact \r\n * points). \r\n * @export \r\n * @return {number} \r\n */\r\nbox2d.b2World.prototype.GetContactCount = function ()\r\n{\r\n\treturn this.m_contactManager.m_contactCount;\r\n}\r\n\r\n/** \r\n * Change the global gravity vector. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} gravity\r\n * @param {boolean=} wake also wake up the bodies \r\n */\r\nbox2d.b2World.prototype.SetGravity = function (gravity, wake)\r\n{\r\n\twake = wake || true;\r\n\r\n\tif ((this.m_gravity.x !== gravity.x) || (this.m_gravity.y !== gravity.y))\r\n\t{\r\n\t\tthis.m_gravity.Copy(gravity);\r\n\r\n\t\tif (wake)\r\n\t\t{\r\n\t\t\tfor (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t\t\t{\r\n\t\t\t\tb.SetAwake(true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** \r\n * Get the global gravity vector. \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2=} out \r\n */\r\nbox2d.b2World.prototype.GetGravity = function (out)\r\n{\r\n\tout = out || this.m_out_gravity;\r\n\treturn out.Copy(this.m_gravity);\r\n}\r\n\r\n/** \r\n * Is the world locked (in the middle of a time step). \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2World.prototype.IsLocked = function ()\r\n{\r\n\treturn (this.m_flags & box2d.b2WorldFlag.e_locked) > 0;\r\n}\r\n\r\n/** \r\n * Set flag to control automatic clearing of forces after each \r\n * time step. \r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag\r\n */\r\nbox2d.b2World.prototype.SetAutoClearForces = function (flag)\r\n{\r\n\tif (flag)\r\n\t{\r\n\t\tthis.m_flags |= box2d.b2WorldFlag.e_clearForces;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_flags &= ~box2d.b2WorldFlag.e_clearForces;\r\n\t}\r\n}\r\n\r\n/** \r\n * Get the flag that controls automatic clearing of forces after \r\n * each time step. \r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2World.prototype.GetAutoClearForces = function ()\r\n{\r\n\treturn (this.m_flags & box2d.b2WorldFlag.e_clearForces) === box2d.b2WorldFlag.e_clearForces;\r\n}\r\n\r\n/** \r\n * Get the contact manager for testing. \r\n * @export \r\n * @return {box2d.b2ContactManager}\r\n */\r\nbox2d.b2World.prototype.GetContactManager = function ()\r\n{\r\n\treturn this.m_contactManager;\r\n}\r\n\r\n/** \r\n * Get the current profile. \r\n * @export \r\n * @return {box2d.b2Profile} \r\n */\r\nbox2d.b2World.prototype.GetProfile = function ()\r\n{\r\n\treturn this.m_profile;\r\n}\r\n\r\n/** \r\n * Register a destruction listener. The listener is owned by you \r\n * and must remain in scope. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2DestructionListener} listener\r\n */\r\nbox2d.b2World.prototype.SetDestructionListener = function (listener)\r\n{\r\n\tthis.m_destructionListener = listener;\r\n}\r\n\r\n/** \r\n * Register a contact filter to provide specific control over \r\n * collision. Otherwise the default filter is used \r\n * (b2_defaultFilter). The listener is owned by you and must \r\n * remain in scope. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2ContactFilter} filter\r\n */\r\nbox2d.b2World.prototype.SetContactFilter = function (filter)\r\n{\r\n\tthis.m_contactManager.m_contactFilter = filter;\r\n}\r\n\r\n/** \r\n * Register a contact event listener. The listener is owned by \r\n * you and must remain in scope. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2ContactListener} listener\r\n */\r\nbox2d.b2World.prototype.SetContactListener = function (listener)\r\n{\r\n\tthis.m_contactManager.m_contactListener = listener;\r\n}\r\n\r\n/** \r\n * Register a routine for debug drawing. The debug draw \r\n * functions are called inside with b2World::DrawDebugData \r\n * method. The debug draw object is owned by you and must remain \r\n * in scope. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Draw} debugDraw\r\n */\r\nbox2d.b2World.prototype.SetDebugDraw = function (debugDraw)\r\n{\r\n\tthis.m_debugDraw = debugDraw;\r\n}\r\n\r\n/** \r\n * Create a rigid body given a definition. No reference to the \r\n * definition is retained. \r\n * warning This function is locked during callbacks.\r\n * @export \r\n * @return {box2d.b2Body}\r\n * @param {box2d.b2BodyDef} def\r\n */\r\nbox2d.b2World.prototype.CreateBody = function (def)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }\r\n\tif (this.IsLocked())\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** @type {box2d.b2Body} */ var b = new box2d.b2Body(def, this);\r\n\r\n\t// Add to world doubly linked list.\r\n\tb.m_prev = null;\r\n\tb.m_next = this.m_bodyList;\r\n\tif (this.m_bodyList)\r\n\t{\r\n\t\tthis.m_bodyList.m_prev = b;\r\n\t}\r\n\tthis.m_bodyList = b;\r\n\t++this.m_bodyCount;\r\n\r\n\treturn b;\r\n}\r\n\r\n/** \r\n * Destroy a rigid body given a definition. No reference to the \r\n * definition is retained. This function is locked during \r\n * callbacks. \r\n * warning This automatically deletes all associated shapes and \r\n * joints. \r\n * warning This function is locked during callbacks. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} b\r\n */\r\nbox2d.b2World.prototype.DestroyBody = function (b)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_bodyCount > 0); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }\r\n\tif (this.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Delete the attached joints.\r\n\t/** @type {box2d.b2JointEdge} */ var je = b.m_jointList;\r\n\twhile (je)\r\n\t{\r\n\t\t/** @type {box2d.b2JointEdge} */ var je0 = je;\r\n\t\tje = je.next;\r\n\r\n\t\tif (this.m_destructionListener)\r\n\t\t{\r\n\t\t\tthis.m_destructionListener.SayGoodbyeJoint(je0.joint);\r\n\t\t}\r\n\r\n\t\tthis.DestroyJoint(je0.joint);\r\n\r\n\t\tb.m_jointList = je;\r\n\t}\r\n\tb.m_jointList = null;\r\n\r\n\t/// @see box2d.b2Controller list\r\n\t/** @type {box2d.b2ControllerEdge} */ var coe = b.m_controllerList;\r\n\twhile (coe)\r\n\t{\r\n\t\t/** @type {box2d.b2ControllerEdge} */ var coe0 = coe;\r\n\t\tcoe = coe.nextController;\r\n\t\tcoe0.controller.RemoveBody(b);\r\n\t}\r\n\r\n\t// Delete the attached contacts.\r\n\t/** @type {box2d.b2ContactEdge} */ var ce = b.m_contactList;\r\n\twhile (ce)\r\n\t{\r\n\t\t/** @type {box2d.b2ContactEdge} */ var ce0 = ce;\r\n\t\tce = ce.next;\r\n\t\tthis.m_contactManager.Destroy(ce0.contact);\r\n\t}\r\n\tb.m_contactList = null;\r\n\r\n\t// Delete the attached fixtures. This destroys broad-phase proxies.\r\n\t/** @type {box2d.b2Fixture} */ var f = b.m_fixtureList;\r\n\twhile (f)\r\n\t{\r\n\t\t/** @type {box2d.b2Fixture} */ var f0 = f;\r\n\t\tf = f.m_next;\r\n\r\n\t\tif (this.m_destructionListener)\r\n\t\t{\r\n\t\t\tthis.m_destructionListener.SayGoodbyeFixture(f0);\r\n\t\t}\r\n\r\n\t\tf0.DestroyProxies(this.m_contactManager.m_broadPhase);\r\n\t\tf0.Destroy();\r\n\r\n\r\n\t\tb.m_fixtureList = f;\r\n\t\tb.m_fixtureCount -= 1;\r\n\t}\r\n\tb.m_fixtureList = null;\r\n\tb.m_fixtureCount = 0;\r\n\r\n\t// Remove world body list.\r\n\tif (b.m_prev)\r\n\t{\r\n\t\tb.m_prev.m_next = b.m_next;\r\n\t}\r\n\r\n\tif (b.m_next)\r\n\t{\r\n\t\tb.m_next.m_prev = b.m_prev;\r\n\t}\r\n\r\n\tif (b === this.m_bodyList)\r\n\t{\r\n\t\tthis.m_bodyList = b.m_next;\r\n\t}\r\n\r\n\t--this.m_bodyCount;\r\n}\r\n\r\n/** \r\n * Create a joint to constrain bodies together. No reference to \r\n * the definition is retained. This may cause the connected \r\n * bodies to cease colliding. \r\n * warning This function is locked during callbacks.\r\n * @export \r\n * @return {box2d.b2Joint}\r\n * @param {box2d.b2JointDef} def \r\n */\r\nbox2d.b2World.prototype.CreateJoint = function (def)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }\r\n\tif (this.IsLocked())\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** @type {box2d.b2Joint} */ var j = box2d.b2JointFactory.Create(def, null);\r\n\r\n\t// Connect to the world list.\r\n\tj.m_prev = null;\r\n\tj.m_next = this.m_jointList;\r\n\tif (this.m_jointList)\r\n\t{\r\n\t\tthis.m_jointList.m_prev = j;\r\n\t}\r\n\tthis.m_jointList = j;\r\n\t++this.m_jointCount;\r\n\r\n\t// Connect to the bodies' doubly linked lists.\r\n\tj.m_edgeA.joint = j;\r\n\tj.m_edgeA.other = j.m_bodyB;\r\n\tj.m_edgeA.prev = null;\r\n\tj.m_edgeA.next = j.m_bodyA.m_jointList;\r\n\tif (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;\r\n\tj.m_bodyA.m_jointList = j.m_edgeA;\r\n\r\n\tj.m_edgeB.joint = j;\r\n\tj.m_edgeB.other = j.m_bodyA;\r\n\tj.m_edgeB.prev = null;\r\n\tj.m_edgeB.next = j.m_bodyB.m_jointList;\r\n\tif (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;\r\n\tj.m_bodyB.m_jointList = j.m_edgeB;\r\n\r\n\t/** @type {box2d.b2Body} */ var bodyA = def.bodyA;\r\n\t/** @type {box2d.b2Body} */ var bodyB = def.bodyB;\r\n\r\n\t// If the joint prevents collisions, then flag any contacts for filtering.\r\n\tif (def.collideConnected === false)\r\n\t{\r\n\t\t/** @type {box2d.b2ContactEdge} */ var edge = bodyB.GetContactList();\r\n\t\twhile (edge)\r\n\t\t{\r\n\t\t\tif (edge.other === bodyA)\r\n\t\t\t{\r\n\t\t\t\t// Flag the contact for filtering at the next time step (where either\r\n\t\t\t\t// body is awake).\r\n\t\t\t\tedge.contact.FlagForFiltering();\r\n\t\t\t}\r\n\r\n\t\t\tedge = edge.next;\r\n\t\t}\r\n\t}\r\n\r\n\t// Note: creating a joint doesn't wake the bodies.\r\n\r\n\treturn j;\r\n}\r\n\r\n/** \r\n * Destroy a joint. This may cause the connected bodies to begin \r\n * colliding. \r\n * warning This function is locked during callbacks.\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Joint} j\r\n */\r\nbox2d.b2World.prototype.DestroyJoint = function (j)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }\r\n\tif (this.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t/** @type {boolean} */ var collideConnected = j.m_collideConnected;\r\n\r\n\t// Remove from the doubly linked list.\r\n\tif (j.m_prev)\r\n\t{\r\n\t\tj.m_prev.m_next = j.m_next;\r\n\t}\r\n\r\n\tif (j.m_next)\r\n\t{\r\n\t\tj.m_next.m_prev = j.m_prev;\r\n\t}\r\n\r\n\tif (j === this.m_jointList)\r\n\t{\r\n\t\tthis.m_jointList = j.m_next;\r\n\t}\r\n\r\n\t// Disconnect from island graph.\r\n\t/** @type {box2d.b2Body} */ var bodyA = j.m_bodyA;\r\n\t/** @type {box2d.b2Body} */ var bodyB = j.m_bodyB;\r\n\r\n\t// Wake up connected bodies.\r\n\tbodyA.SetAwake(true);\r\n\tbodyB.SetAwake(true);\r\n\r\n\t// Remove from body 1.\r\n\tif (j.m_edgeA.prev)\r\n\t{\r\n\t\tj.m_edgeA.prev.next = j.m_edgeA.next;\r\n\t}\r\n\r\n\tif (j.m_edgeA.next)\r\n\t{\r\n\t\tj.m_edgeA.next.prev = j.m_edgeA.prev;\r\n\t}\r\n\r\n\tif (j.m_edgeA === bodyA.m_jointList)\r\n\t{\r\n\t\tbodyA.m_jointList = j.m_edgeA.next;\r\n\t}\r\n\r\n\tj.m_edgeA.prev = null;\r\n\tj.m_edgeA.next = null;\r\n\r\n\t// Remove from body 2\r\n\tif (j.m_edgeB.prev)\r\n\t{\r\n\t\tj.m_edgeB.prev.next = j.m_edgeB.next;\r\n\t}\r\n\r\n\tif (j.m_edgeB.next)\r\n\t{\r\n\t\tj.m_edgeB.next.prev = j.m_edgeB.prev;\r\n\t}\r\n\r\n\tif (j.m_edgeB === bodyB.m_jointList)\r\n\t{\r\n\t\tbodyB.m_jointList = j.m_edgeB.next;\r\n\t}\r\n\r\n\tj.m_edgeB.prev = null;\r\n\tj.m_edgeB.next = null;\r\n\r\n\tbox2d.b2JointFactory.Destroy(j, null);\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.m_jointCount > 0); }\r\n\t--this.m_jointCount;\r\n\r\n\t// If the joint prevents collisions, then flag any contacts for filtering.\r\n\tif (collideConnected === false)\r\n\t{\r\n\t\t/** @type {box2d.b2ContactEdge} */ var edge = bodyB.GetContactList();\r\n\t\twhile (edge)\r\n\t\t{\r\n\t\t\tif (edge.other === bodyA)\r\n\t\t\t{\r\n\t\t\t\t// Flag the contact for filtering at the next time step (where either\r\n\t\t\t\t// body is awake).\r\n\t\t\t\tedge.contact.FlagForFiltering();\r\n\t\t\t}\r\n\r\n\t\t\tedge = edge.next;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** \r\n * Find islands, integrate and solve constraints, solve position \r\n * constraints \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TimeStep} step\r\n */\r\nbox2d.b2World.prototype.Solve = function (step)\r\n{\r\n\t/// @see box2d.b2Controller list\r\n\tfor (/** @type {box2d.b2Controller} */ var controller = this.m_controllerList; controller; controller = controller.m_next)\r\n\t{\r\n\t\tcontroller.Step(step);\r\n\t}\r\n\r\n\tthis.m_profile.solveInit = 0;\r\n\tthis.m_profile.solveVelocity = 0;\r\n\tthis.m_profile.solvePosition = 0;\r\n\r\n\t// Size the island for the worst case.\r\n\t/** @type {box2d.b2Island} */ var island = this.m_island;\r\n\tisland.Initialize(this.m_bodyCount,\r\n\t\t\t\t\t  this.m_contactManager.m_contactCount,\r\n\t\t\t\t\t  this.m_jointCount,\r\n\t\t\t\t\t  null, // this.m_stackAllocator, \r\n\t\t\t\t\t  this.m_contactManager.m_contactListener);\r\n\r\n\t// Clear all the island flags.\r\n\tfor (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t{\r\n\t\tb.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;\r\n\t}\r\n\tfor (/** @type {box2d.b2Contact} */ var c = this.m_contactManager.m_contactList; c; c = c.m_next)\r\n\t{\r\n\t\tc.m_flags &= ~box2d.b2ContactFlag.e_islandFlag;\r\n\t}\r\n\tfor (/** @type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)\r\n\t{\r\n\t\tj.m_islandFlag = false;\r\n\t}\r\n\r\n\t// Build and simulate all awake islands.\r\n\t/** @type {number} */ var stackSize = this.m_bodyCount;\r\n\t/** @type {Array.<?box2d.b2Body>} */ var stack = this.s_stack;\r\n\tfor (/** @type {box2d.b2Body} */ var seed = this.m_bodyList; seed; seed = seed.m_next)\r\n\t{\r\n\t\tif (seed.m_flags & box2d.b2BodyFlag.e_islandFlag)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (seed.IsAwake() === false || seed.IsActive() === false)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// The seed can be dynamic or kinematic.\r\n\t\tif (seed.GetType() === box2d.b2BodyType.b2_staticBody)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// Reset island and stack.\r\n\t\tisland.Clear();\r\n\t\t/** @type {number} */ var stackCount = 0;\r\n\t\tstack[stackCount++] = seed;\r\n\t\tseed.m_flags |= box2d.b2BodyFlag.e_islandFlag;\r\n\r\n\t\t// Perform a depth first search (DFS) on the constraint graph.\r\n\t\twhile (stackCount > 0)\r\n\t\t{\r\n\t\t\t// Grab the next body off the stack and add it to the island.\r\n\t\t\t/* type {box2d.b2Body} */ var b = stack[--stackCount];\r\n\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(b.IsActive() === true); }\r\n\t\t\tisland.AddBody(b);\r\n\r\n\t\t\t// Make sure the body is awake.\r\n\t\t\tb.SetAwake(true);\r\n\r\n\t\t\t// To keep islands as small as possible, we don't\r\n\t\t\t// propagate islands across static bodies.\r\n\t\t\tif (b.GetType() === box2d.b2BodyType.b2_staticBody)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Search all contacts connected to this body.\r\n\t\t\tfor (/** @type {box2d.b2ContactEdge} */ var ce = b.m_contactList; ce; ce = ce.next)\r\n\t\t\t{\r\n\t\t\t\t/** @type {box2d.b2Contact} */ var contact = ce.contact;\r\n\r\n\t\t\t\t// Has this contact already been added to an island?\r\n\t\t\t\tif (contact.m_flags & box2d.b2ContactFlag.e_islandFlag)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Is this contact solid and touching?\r\n\t\t\t\tif (contact.IsEnabled() === false ||\r\n\t\t\t\t\tcontact.IsTouching() === false)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Skip sensors.\r\n\t\t\t\t/** @type {boolean} */ var sensorA = contact.m_fixtureA.m_isSensor;\r\n\t\t\t\t/** @type {boolean} */ var sensorB = contact.m_fixtureB.m_isSensor;\r\n\t\t\t\tif (sensorA || sensorB)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tisland.AddContact(contact);\r\n\t\t\t\tcontact.m_flags |= box2d.b2ContactFlag.e_islandFlag;\r\n\r\n\t\t\t\t/** @type {box2d.b2Body} */ var other = ce.other;\r\n\r\n\t\t\t\t// Was the other body already added to this island?\r\n\t\t\t\tif (other.m_flags & box2d.b2BodyFlag.e_islandFlag)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(stackCount < stackSize); }\r\n\t\t\t\tstack[stackCount++] = other;\r\n\t\t\t\tother.m_flags |= box2d.b2BodyFlag.e_islandFlag;\r\n\t\t\t}\r\n\r\n\t\t\t// Search all joints connect to this body.\r\n\t\t\tfor (/** @type {box2d.b2JointEdge} */ var je = b.m_jointList; je; je = je.next)\r\n\t\t\t{\r\n\t\t\t\tif (je.joint.m_islandFlag === true)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* type {box2d.b2Body} */ var other = je.other;\r\n\r\n\t\t\t\t// Don't simulate joints connected to inactive bodies.\r\n\t\t\t\tif (other.IsActive() === false)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tisland.AddJoint(je.joint);\r\n\t\t\t\tje.joint.m_islandFlag = true;\r\n\r\n\t\t\t\tif (other.m_flags & box2d.b2BodyFlag.e_islandFlag)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(stackCount < stackSize); }\r\n\t\t\t\tstack[stackCount++] = other;\r\n\t\t\t\tother.m_flags |= box2d.b2BodyFlag.e_islandFlag;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/** @type {box2d.b2Profile} */ var profile = new box2d.b2Profile();\r\n\t\tisland.Solve(profile, step, this.m_gravity, this.m_allowSleep);\r\n\t\tthis.m_profile.solveInit += profile.solveInit;\r\n\t\tthis.m_profile.solveVelocity += profile.solveVelocity;\r\n\t\tthis.m_profile.solvePosition += profile.solvePosition;\r\n\r\n\t\t// Post solve cleanup.\r\n\t\tfor (/** @type {number} */ var i = 0; i < island.m_bodyCount; ++i)\r\n\t\t{\r\n\t\t\t// Allow static bodies to participate in other islands.\r\n\t\t\t/* type {box2d.b2Body} */ var b = island.m_bodies[i];\r\n\t\t\tif (b.GetType() === box2d.b2BodyType.b2_staticBody)\r\n\t\t\t{\r\n\t\t\t\tb.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (/* type {number} */ var i = 0; i < stack.length; ++i)\r\n\t{\r\n\t\tif (!stack[i]) break;\r\n\t\tstack[i] = null;\r\n\t}\r\n\r\n\t{\r\n\t\t/** @type {box2d.b2Timer} */ var timer = new box2d.b2Timer();\r\n\r\n\t\t// Synchronize fixtures, check for out of range bodies.\r\n\t\tfor (/* type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t\t{\r\n\t\t\t// If a body was not in an island then it did not move.\r\n\t\t\tif ((b.m_flags & box2d.b2BodyFlag.e_islandFlag) === 0)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\r\n\t\t\tif (b.GetType() === box2d.b2BodyType.b2_staticBody)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\r\n\t\t\t// Update fixtures (for broad-phase).\r\n\t\t\tb.SynchronizeFixtures();\r\n\t\t}\r\n\t\r\n\t\t// Look for new contacts.\r\n\t\tthis.m_contactManager.FindNewContacts();\r\n\t\tthis.m_profile.broadphase = timer.GetMilliseconds();\r\n\t}\r\n}\r\n\r\n/** \r\n * Find TOI contacts and solve them. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TimeStep} step\r\n */\r\nbox2d.b2World.prototype.SolveTOI = function (step)\r\n{\r\n//\tbox2d.b2Island island(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, &m_stackAllocator, m_contactManager.m_contactListener);\r\n\t/** @type {box2d.b2Island} */ var island = this.m_island;\r\n\tisland.Initialize(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, null, this.m_contactManager.m_contactListener);\r\n\r\n\tif (this.m_stepComplete)\r\n\t{\r\n\t\tfor (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t\t{\r\n\t\t\tb.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;\r\n\t\t\tb.m_sweep.alpha0 = 0;\r\n\t\t}\r\n\r\n\t\tfor (/** @type {box2d.b2Contact} */ var c = this.m_contactManager.m_contactList; c; c = c.m_next)\r\n\t\t{\r\n\t\t\t// Invalidate TOI\r\n\t\t\tc.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag);\r\n\t\t\tc.m_toiCount = 0;\r\n\t\t\tc.m_toi = 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// Find TOI events and solve them.\r\n\tfor (;;)\r\n\t{\r\n\t\t// Find the first TOI.\r\n\t\t/** @type {box2d.b2Contact} */ var minContact = null;\r\n\t\t/** @type {number} */ var minAlpha = 1;\r\n\r\n\t\tfor (/* type {box2d.b2Contact} */ var c = this.m_contactManager.m_contactList; c; c = c.m_next)\r\n\t\t{\r\n\t\t\t// Is this contact disabled?\r\n\t\t\tif (c.IsEnabled() === false)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Prevent excessive sub-stepping.\r\n\t\t\tif (c.m_toiCount > box2d.b2_maxSubSteps)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t/** @type {number} */ var alpha = 1;\r\n\t\t\tif (c.m_flags & box2d.b2ContactFlag.e_toiFlag)\r\n\t\t\t{\r\n\t\t\t\t// This contact has a valid cached TOI.\r\n\t\t\t\talpha = c.m_toi;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t/** @type {box2d.b2Fixture} */ var fA = c.GetFixtureA();\r\n\t\t\t\t/** @type {box2d.b2Fixture} */ var fB = c.GetFixtureB();\r\n\r\n\t\t\t\t// Is there a sensor?\r\n\t\t\t\tif (fA.IsSensor() || fB.IsSensor())\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/** @type {box2d.b2Body} */ var bA = fA.GetBody();\r\n\t\t\t\t/** @type {box2d.b2Body} */ var bB = fB.GetBody();\r\n\r\n\t\t\t\t/** @type {box2d.b2BodyType} */ var typeA = bA.m_type;\r\n\t\t\t\t/** @type {box2d.b2BodyType} */ var typeB = bB.m_type;\r\n\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(typeA === box2d.b2BodyType.b2_dynamicBody || typeB === box2d.b2BodyType.b2_dynamicBody); }\r\n\r\n\t\t\t\t/** @type {boolean} */ var activeA = bA.IsAwake() && typeA !== box2d.b2BodyType.b2_staticBody;\r\n\t\t\t\t/** @type {boolean} */ var activeB = bB.IsAwake() && typeB !== box2d.b2BodyType.b2_staticBody;\r\n\r\n\t\t\t\t// Is at least one body active (awake and dynamic or kinematic)?\r\n\t\t\t\tif (activeA === false && activeB === false)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/** @type {boolean} */ var collideA = bA.IsBullet() || typeA !== box2d.b2BodyType.b2_dynamicBody;\r\n\t\t\t\t/** @type {boolean} */ var collideB = bB.IsBullet() || typeB !== box2d.b2BodyType.b2_dynamicBody;\r\n\r\n\t\t\t\t// Are these two non-bullet dynamic bodies?\r\n\t\t\t\tif (collideA === false && collideB === false)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Compute the TOI for this contact.\r\n\t\t\t\t// Put the sweeps onto the same time interval.\r\n\t\t\t\t/** @type {number} */ var alpha0 = bA.m_sweep.alpha0;\r\n\r\n\t\t\t\tif (bA.m_sweep.alpha0 < bB.m_sweep.alpha0)\r\n\t\t\t\t{\r\n\t\t\t\t\talpha0 = bB.m_sweep.alpha0;\r\n\t\t\t\t\tbA.m_sweep.Advance(alpha0);\r\n\t\t\t\t}\r\n\t\t\t\telse if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0)\r\n\t\t\t\t{\r\n\t\t\t\t\talpha0 = bA.m_sweep.alpha0;\r\n\t\t\t\t\tbB.m_sweep.Advance(alpha0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(alpha0 < 1); }\r\n\r\n\t\t\t\t/** @type {number} */ var indexA = c.GetChildIndexA();\r\n\t\t\t\t/** @type {number} */ var indexB = c.GetChildIndexB();\r\n\r\n\t\t\t\t// Compute the time of impact in interval [0, minTOI]\r\n\t\t\t\t/** @type {box2d.b2TOIInput} */ var input = box2d.b2World.prototype.SolveTOI.s_toi_input;\r\n\t\t\t\tinput.proxyA.SetShape(fA.GetShape(), indexA);\r\n\t\t\t\tinput.proxyB.SetShape(fB.GetShape(), indexB);\r\n\t\t\t\tinput.sweepA.Copy(bA.m_sweep);\r\n\t\t\t\tinput.sweepB.Copy(bB.m_sweep);\r\n\t\t\t\tinput.tMax = 1;\r\n\r\n\t\t\t\t/** @type {box2d.b2TOIOutput} */ var output = box2d.b2World.prototype.SolveTOI.s_toi_output;\r\n\t\t\t\tbox2d.b2TimeOfImpact(output, input);\r\n\r\n\t\t\t\t// Beta is the fraction of the remaining portion of the .\r\n\t\t\t\t/** @type {number} */ var beta = output.t;\r\n\t\t\t\tif (output.state === box2d.b2TOIOutputState.e_touching)\r\n\t\t\t\t{\r\n\t\t\t\t\talpha = box2d.b2Min(alpha0 + (1 - alpha0) * beta, 1);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\talpha = 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tc.m_toi = alpha;\r\n\t\t\t\tc.m_flags |= box2d.b2ContactFlag.e_toiFlag;\r\n\t\t\t}\r\n\r\n\t\t\tif (alpha < minAlpha)\r\n\t\t\t{\r\n\t\t\t\t// This is the minimum TOI found so far.\r\n\t\t\t\tminContact = c;\r\n\t\t\t\tminAlpha = alpha;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (minContact === null || 1 - 10 * box2d.b2_epsilon < minAlpha)\r\n\t\t{\r\n\t\t\t// No more TOI events. Done!\r\n\t\t\tthis.m_stepComplete = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Advance the bodies to the TOI.\r\n\t\t/* type {box2d.b2Fixture} */ var fA = minContact.GetFixtureA();\r\n\t\t/* type {box2d.b2Fixture} */ var fB = minContact.GetFixtureB();\r\n\t\t/* type {box2d.b2Body} */ var bA = fA.GetBody();\r\n\t\t/* type {box2d.b2Body} */ var bB = fB.GetBody();\r\n\r\n\t\t/** @type {box2d.b2Sweep} */ var backup1 = box2d.b2World.prototype.SolveTOI.s_backup1.Copy(bA.m_sweep);\r\n\t\t/** @type {box2d.b2Sweep} */ var backup2 = box2d.b2World.prototype.SolveTOI.s_backup2.Copy(bB.m_sweep);\r\n\r\n\t\tbA.Advance(minAlpha);\r\n\t\tbB.Advance(minAlpha);\r\n\r\n\t\t// The TOI contact likely has some new contact points.\r\n\t\tminContact.Update(this.m_contactManager.m_contactListener);\r\n\t\tminContact.m_flags &= ~box2d.b2ContactFlag.e_toiFlag;\r\n\t\t++minContact.m_toiCount;\r\n\r\n\t\t// Is the contact solid?\r\n\t\tif (minContact.IsEnabled() === false || minContact.IsTouching() === false)\r\n\t\t{\r\n\t\t\t// Restore the sweeps.\r\n\t\t\tminContact.SetEnabled(false);\r\n\t\t\tbA.m_sweep.Copy(backup1);\r\n\t\t\tbB.m_sweep.Copy(backup2);\r\n\t\t\tbA.SynchronizeTransform();\r\n\t\t\tbB.SynchronizeTransform();\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tbA.SetAwake(true);\r\n\t\tbB.SetAwake(true);\r\n\r\n\t\t// Build the island\r\n\t\tisland.Clear();\r\n\t\tisland.AddBody(bA);\r\n\t\tisland.AddBody(bB);\r\n\t\tisland.AddContact(minContact);\r\n\r\n\t\tbA.m_flags |= box2d.b2BodyFlag.e_islandFlag;\r\n\t\tbB.m_flags |= box2d.b2BodyFlag.e_islandFlag;\r\n\t\tminContact.m_flags |= box2d.b2ContactFlag.e_islandFlag;\r\n\r\n\t\t// Get contacts on bodyA and bodyB.\r\n\t\t//** @type {box2d.b2Body} */ var bodies = [bA, bB];\r\n\t\tfor (/** @type {number} */ var i = 0; i < 2; ++i)\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2Body} */ var body = (i === 0)?(bA):(bB);//bodies[i];\r\n\t\t\tif (body.m_type === box2d.b2BodyType.b2_dynamicBody)\r\n\t\t\t{\r\n\t\t\t\tfor (/** @type {box2d.b2ContactEdge} */ var ce = body.m_contactList; ce; ce = ce.next)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (island.m_bodyCount === island.m_bodyCapacity)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (island.m_contactCount === island.m_contactCapacity)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/** @type {box2d.b2Contact} */ var contact = ce.contact;\r\n\r\n\t\t\t\t\t// Has this contact already been added to the island?\r\n\t\t\t\t\tif (contact.m_flags & box2d.b2ContactFlag.e_islandFlag)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Only add static, kinematic, or bullet bodies.\r\n\t\t\t\t\t/** @type {box2d.b2Body} */ var other = ce.other;\r\n\t\t\t\t\tif (other.m_type === box2d.b2BodyType.b2_dynamicBody &&\r\n\t\t\t\t\t\tbody.IsBullet() === false && other.IsBullet() === false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Skip sensors.\r\n\t\t\t\t\t/** @type {boolean} */ var sensorA = contact.m_fixtureA.m_isSensor;\r\n\t\t\t\t\t/** @type {boolean} */ var sensorB = contact.m_fixtureB.m_isSensor;\r\n\t\t\t\t\tif (sensorA || sensorB)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Tentatively advance the body to the TOI.\r\n\t\t\t\t\t/** @type {box2d.b2Sweep} */ var backup = box2d.b2World.prototype.SolveTOI.s_backup.Copy(other.m_sweep);\r\n\t\t\t\t\tif ((other.m_flags & box2d.b2BodyFlag.e_islandFlag) === 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tother.Advance(minAlpha);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Update the contact points\r\n\t\t\t\t\tcontact.Update(this.m_contactManager.m_contactListener);\r\n\r\n\t\t\t\t\t// Was the contact disabled by the user?\r\n\t\t\t\t\tif (contact.IsEnabled() === false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tother.m_sweep.Copy(backup);\r\n\t\t\t\t\t\tother.SynchronizeTransform();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Are there contact points?\r\n\t\t\t\t\tif (contact.IsTouching() === false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tother.m_sweep.Copy(backup);\r\n\t\t\t\t\t\tother.SynchronizeTransform();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Add the contact to the island\r\n\t\t\t\t\tcontact.m_flags |= box2d.b2ContactFlag.e_islandFlag;\r\n\t\t\t\t\tisland.AddContact(contact);\r\n\r\n\t\t\t\t\t// Has the other body already been added to the island?\r\n\t\t\t\t\tif (other.m_flags & box2d.b2BodyFlag.e_islandFlag)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Add the other body to the island.\r\n\t\t\t\t\tother.m_flags |= box2d.b2BodyFlag.e_islandFlag;\r\n\r\n\t\t\t\t\tif (other.m_type !== box2d.b2BodyType.b2_staticBody)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tother.SetAwake(true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tisland.AddBody(other);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/** @type {box2d.b2TimeStep} */ var subStep = box2d.b2World.prototype.SolveTOI.s_subStep;\r\n\t\tsubStep.dt = (1 - minAlpha) * step.dt;\r\n\t\tsubStep.inv_dt = 1 / subStep.dt;\r\n\t\tsubStep.dtRatio = 1;\r\n\t\tsubStep.positionIterations = 20;\r\n\t\tsubStep.velocityIterations = step.velocityIterations;\r\n\t\tsubStep.warmStarting = false;\r\n\t\tisland.SolveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);\r\n\r\n\t\t// Reset island flags and synchronize broad-phase proxies.\r\n\t\tfor (/* type {number} */ var i = 0; i < island.m_bodyCount; ++i)\r\n\t\t{\r\n\t\t\t/* type {box2d.b2Body} */ var body = island.m_bodies[i];\r\n\t\t\tbody.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;\r\n\r\n\t\t\tif (body.m_type !== box2d.b2BodyType.b2_dynamicBody)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tbody.SynchronizeFixtures();\r\n\r\n\t\t\t// Invalidate all contact TOIs on this displaced body.\r\n\t\t\tfor (/* type {box2d.b2ContactEdge} */ var ce = body.m_contactList; ce; ce = ce.next)\r\n\t\t\t{\r\n\t\t\t\tce.contact.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Commit fixture proxy movements to the broad-phase so that new contacts are created.\r\n\t\t// Also, some contacts can be destroyed.\r\n\t\tthis.m_contactManager.FindNewContacts();\r\n\r\n\t\tif (this.m_subStepping)\r\n\t\t{\r\n\t\t\tthis.m_stepComplete = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\nbox2d.b2World.prototype.SolveTOI.s_subStep = new box2d.b2TimeStep();\r\nbox2d.b2World.prototype.SolveTOI.s_backup = new box2d.b2Sweep();\r\nbox2d.b2World.prototype.SolveTOI.s_backup1 = new box2d.b2Sweep();\r\nbox2d.b2World.prototype.SolveTOI.s_backup2 = new box2d.b2Sweep();\r\nbox2d.b2World.prototype.SolveTOI.s_toi_input = new box2d.b2TOIInput();\r\nbox2d.b2World.prototype.SolveTOI.s_toi_output = new box2d.b2TOIOutput();\r\n\r\n/** \r\n * Take a time step. This performs collision detection, \r\n * integration, and constraint solution. \r\n * @export \r\n * @return {void} \r\n * @param {number} dt the amount of time to simulate, this should not vary.\r\n * @param {number} velocityIterations for the velocity constraint solver.\r\n * @param {number} positionIterations for the position constraint solver.\r\n */\r\nbox2d.b2World.prototype.Step = function (dt, velocityIterations, positionIterations)\r\n{\r\n\t/** @type {box2d.b2Timer} */ var stepTimer = new box2d.b2Timer();\r\n\r\n\t// If new fixtures were added, we need to find the new contacts.\r\n\tif (this.m_flags & box2d.b2WorldFlag.e_newFixture)\r\n\t{\r\n\t\tthis.m_contactManager.FindNewContacts();\r\n\t\tthis.m_flags &= ~box2d.b2WorldFlag.e_newFixture;\r\n\t}\r\n\r\n\tthis.m_flags |= box2d.b2WorldFlag.e_locked;\r\n\r\n\t/** @type {box2d.b2TimeStep} */ var step = box2d.b2World.prototype.Step.s_step;\r\n\tstep.dt = dt;\r\n\tstep.velocityIterations = velocityIterations;\r\n\tstep.positionIterations = positionIterations;\r\n\tif (dt > 0)\r\n\t{\r\n\t\tstep.inv_dt = 1 / dt;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstep.inv_dt = 0;\r\n\t}\r\n\r\n\tstep.dtRatio = this.m_inv_dt0 * dt;\r\n\r\n\tstep.warmStarting = this.m_warmStarting;\r\n\r\n\t// Update contacts. This is where some contacts are destroyed.\r\n\tif (true)\r\n\t{\r\n\t\t/** @type {box2d.b2Timer} */ var timer = new box2d.b2Timer();\r\n\t\tthis.m_contactManager.Collide();\r\n\t\tthis.m_profile.collide = timer.GetMilliseconds();\r\n\t}\r\n\r\n\t// Integrate velocities, solve velocity constraints, and integrate positions.\r\n\tif (this.m_stepComplete && step.dt > 0)\r\n\t{\r\n\t\t/* type {box2d.b2Timer} */ var timer = new box2d.b2Timer();\r\n\t\tthis.Solve(step);\r\n\t\tthis.m_profile.solve = timer.GetMilliseconds();\r\n\t}\r\n\r\n\t// Handle TOI events.\r\n\tif (this.m_continuousPhysics && step.dt > 0)\r\n\t{\r\n\t\t/* type {box2d.b2Timer} */ var timer = new box2d.b2Timer();\r\n\t\tthis.SolveTOI(step);\r\n\t\tthis.m_profile.solveTOI = timer.GetMilliseconds();\r\n\t}\r\n\r\n\tif (step.dt > 0)\r\n\t{\r\n\t\tthis.m_inv_dt0 = step.inv_dt;\r\n\t}\r\n\r\n\tif (this.m_flags & box2d.b2WorldFlag.e_clearForces)\r\n\t{\r\n\t\tthis.ClearForces();\r\n\t}\r\n\r\n\tthis.m_flags &= ~box2d.b2WorldFlag.e_locked;\r\n\r\n\tthis.m_profile.step = stepTimer.GetMilliseconds();\r\n}\r\nbox2d.b2World.prototype.Step.s_step = new box2d.b2TimeStep();\r\n\r\n/**\r\n * Manually clear the force buffer on all bodies. By default, \r\n * forces are cleared automatically after each call to Step. The \r\n * default behavior is modified by calling SetAutoClearForces. \r\n * The purpose of this function is to support sub-stepping. \r\n * Sub-stepping is often used to maintain a fixed sized time \r\n * step under a variable frame-rate. \r\n * When you perform sub-stepping you will disable auto clearing \r\n * of forces and instead call ClearForces after all sub-steps \r\n * are complete in one pass of your game loop. \r\n * @see SetAutoClearForces\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2World.prototype.ClearForces = function ()\r\n{\r\n\tfor (/** @type {box2d.b2Body} */ var body = this.m_bodyList; body; body = body.m_next)\r\n\t{\r\n\t\tbody.m_force.SetZero();\r\n\t\tbody.m_torque = 0;\r\n\t}\r\n}\r\n\r\n/** \r\n * Query the world for all fixtures that potentially overlap the \r\n * provided AABB. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2QueryCallback | function(box2d.b2Fixture): \r\n *  \t  boolean} callback a user implemented callback class.\r\n * @param {box2d.b2AABB} aabb the query box.\r\n */\r\nbox2d.b2World.prototype.QueryAABB = function (callback, aabb)\r\n{\r\n\t/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_contactManager.m_broadPhase;\r\n\r\n\t/**\r\n\t * @return {boolean} \r\n\t * @param {box2d.b2TreeNode} proxy \r\n\t */\r\n\tvar WorldQueryWrapper = function (proxy)\r\n\t{\r\n\t\t/* type {box2d.b2FixtureProxy} */ var fixture_proxy = broadPhase.GetUserData(proxy);\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture_proxy instanceof box2d.b2FixtureProxy); }\r\n\t\t/* type {box2d.b2Fixture} */ var fixture = fixture_proxy.fixture;\r\n\t\t/** @type {number} */ var index = fixture_proxy.childIndex;\r\n\t\tif (callback instanceof box2d.b2QueryCallback)\r\n\t\t{\r\n\t\t\treturn callback.ReportFixture(fixture);\r\n\t\t}\r\n\t\telse //if (typeof(callback) === 'function')\r\n\t\t{\r\n\t\t\treturn callback(fixture);\r\n\t\t}\r\n\t};\r\n\r\n\tbroadPhase.Query(WorldQueryWrapper, aabb);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2QueryCallback | function(box2d.b2Fixture): \r\n *  \t  boolean} callback\r\n * @param {box2d.b2Shape} shape\r\n * @param {box2d.b2Transform} transform\r\n */\r\nbox2d.b2World.prototype.QueryShape = function (callback, shape, transform)\r\n{\r\n\t/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_contactManager.m_broadPhase;\r\n\r\n\t/**\r\n\t * @return {boolean} \r\n\t * @param {box2d.b2TreeNode} proxy \r\n\t */\r\n\tvar WorldQueryWrapper = function (proxy)\r\n\t{\r\n\t\t/* type {box2d.b2FixtureProxy} */ var fixture_proxy = broadPhase.GetUserData(proxy);\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture_proxy instanceof box2d.b2FixtureProxy); }\r\n\t\t/** @type {box2d.b2Fixture} */ var fixture = fixture_proxy.fixture;\r\n\t\t/** @type {number} */ var index = fixture_proxy.childIndex;\r\n\t\tif (box2d.b2TestOverlapShape(shape, 0, fixture.GetShape(), 0, transform, fixture.GetBody().GetTransform()))\r\n\t\t{\r\n\t\t\tif (callback instanceof box2d.b2QueryCallback)\r\n\t\t\t{\r\n\t\t\t\treturn callback.ReportFixture(fixture);\r\n\t\t\t}\r\n\t\t\telse //if (typeof(callback) === 'function')\r\n\t\t\t{\r\n\t\t\t\treturn callback(fixture);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/** @type {box2d.b2AABB} */ var aabb = box2d.b2World.prototype.QueryShape.s_aabb;\r\n\tshape.ComputeAABB(aabb, transform, 0); // TODO\r\n\tbroadPhase.Query(WorldQueryWrapper, aabb);\r\n}\r\nbox2d.b2World.prototype.QueryShape.s_aabb = new box2d.b2AABB();\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2QueryCallback | function(box2d.b2Fixture): \r\n *  \t  boolean} callback\r\n * @param {box2d.b2Vec2} point\r\n */\r\nbox2d.b2World.prototype.QueryPoint = function (callback, point)\r\n{\r\n\t/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_contactManager.m_broadPhase;\r\n\r\n\t/**\r\n\t * @return {boolean} \r\n\t * @param {box2d.b2TreeNode} proxy \r\n\t */\r\n\tvar WorldQueryWrapper = function (proxy)\r\n\t{\r\n\t\t/* type {box2d.b2FixtureProxy} */ var fixture_proxy = broadPhase.GetUserData(proxy);\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture_proxy instanceof box2d.b2FixtureProxy); }\r\n\t\t/** @type {box2d.b2Fixture} */ var fixture = fixture_proxy.fixture;\r\n\t\t/** @type {number} */ var index = fixture_proxy.childIndex;\r\n\t\tif (fixture.TestPoint(point))\r\n\t\t{\r\n\t\t\tif (callback instanceof box2d.b2QueryCallback)\r\n\t\t\t{\r\n\t\t\t\treturn callback.ReportFixture(fixture);\r\n\t\t\t}\r\n\t\t\telse //if (typeof(callback) === 'function')\r\n\t\t\t{\r\n\t\t\t\treturn callback(fixture);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/** @type {box2d.b2AABB} */ var aabb = box2d.b2World.prototype.QueryPoint.s_aabb;\r\n\taabb.lowerBound.SetXY(point.x - box2d.b2_linearSlop, point.y - box2d.b2_linearSlop);\r\n\taabb.upperBound.SetXY(point.x + box2d.b2_linearSlop, point.y + box2d.b2_linearSlop);\r\n\tbroadPhase.Query(WorldQueryWrapper, aabb);\r\n}\r\nbox2d.b2World.prototype.QueryPoint.s_aabb = new box2d.b2AABB();\r\n\r\n/** \r\n * Ray-cast the world for all fixtures in the path of the ray. \r\n * Your callback controls whether you get the closest point, any \r\n * point, or n-points. The ray-cast ignores shapes that contain \r\n * the starting point. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2RayCastCallback | function(box2d.b2Fixture, \r\n *  \t  box2d.b2Vec2, box2d.b2Vec2, number)} callback a user\r\n *  \t  implemented callback class.\r\n * @param {box2d.b2Vec2} point1 the ray starting point\r\n * @param {box2d.b2Vec2} point2 the ray ending point\r\n */\r\nbox2d.b2World.prototype.RayCast = function (callback, point1, point2)\r\n{\r\n\t/** @type {box2d.b2BroadPhase} */ var broadPhase = this.m_contactManager.m_broadPhase;\r\n\r\n\t/**\r\n\t * @return {number} \r\n\t * @param {box2d.b2RayCastInput} input \r\n\t * @param {box2d.b2TreeNode} proxy \r\n\t */\r\n\tvar WorldRayCastWrapper = function (input, proxy)\r\n\t{\r\n\t\t/* type {box2d.b2FixtureProxy} */ var fixture_proxy = broadPhase.GetUserData(proxy);\r\n\t\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(fixture_proxy instanceof box2d.b2FixtureProxy); }\r\n\t\t/** @type {box2d.b2Fixture} */ var fixture = fixture_proxy.fixture;\r\n\t\t/** @type {number} */ var index = fixture_proxy.childIndex;\r\n\t\t/** @type {box2d.b2RayCastOutput} */ var output = box2d.b2World.prototype.RayCast.s_output;\r\n\t\t/** @type {boolean} */ var hit = fixture.RayCast(output, input, index);\r\n\r\n\t\tif (hit)\r\n\t\t{\r\n\t\t\t/** @type {number} */ var fraction = output.fraction;\r\n\t\t\t/** @type {box2d.b2Vec2} */ var point = box2d.b2World.prototype.RayCast.s_point;\r\n\t\t\tpoint.SetXY((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);\r\n\r\n\t\t\tif (callback instanceof box2d.b2RayCastCallback)\r\n\t\t\t{\r\n\t\t\t\treturn callback.ReportFixture(fixture, point, output.normal, fraction);\r\n\t\t\t}\r\n\t\t\telse //if (typeof(callback) === 'function')\r\n\t\t\t{\r\n\t\t\t\treturn callback(fixture, point, output.normal, fraction);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn input.maxFraction;\r\n\t};\r\n\r\n\t/** @type {box2d.b2RayCastInput} */ var input = box2d.b2World.prototype.RayCast.s_input;\r\n\tinput.maxFraction = 1;\r\n\tinput.p1.Copy(point1);\r\n\tinput.p2.Copy(point2);\r\n\tbroadPhase.RayCast(WorldRayCastWrapper, input);\r\n}\r\nbox2d.b2World.prototype.RayCast.s_input = new box2d.b2RayCastInput();\r\nbox2d.b2World.prototype.RayCast.s_output = new box2d.b2RayCastOutput();\r\nbox2d.b2World.prototype.RayCast.s_point = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Fixture} \r\n * @param {box2d.b2Vec2} point1\r\n * @param {box2d.b2Vec2} point2 \r\n */\r\nbox2d.b2World.prototype.RayCastOne = function (point1, point2)\r\n{\r\n\t/** @type {box2d.b2Fixture} */ var result = null;\r\n\t/** @type {number} */ var min_fraction = 1;\r\n\r\n\t/**\r\n\t * @return {number} \r\n\t * @param {box2d.b2Fixture} fixture \r\n\t * @param {box2d.b2Vec2} point \r\n\t * @param {box2d.b2Vec2} normal \r\n\t * @param {number} fraction\r\n\t */\r\n\tfunction WorldRayCastOneWrapper(fixture, point, normal, fraction)\r\n\t{\r\n\t\tif (fraction < min_fraction)\r\n\t\t{\r\n\t\t\tmin_fraction = fraction;\r\n\t\t\tresult = fixture;\r\n\t\t}\r\n\r\n\t\treturn min_fraction;\r\n\t};\r\n\r\n\tthis.RayCast(WorldRayCastOneWrapper, point1, point2);\r\n\r\n\treturn result;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {Array.<box2d.b2Fixture>} \r\n * @param {box2d.b2Vec2} point1\r\n * @param {box2d.b2Vec2} point2 \r\n * @param {Array.<box2d.b2Fixture>} out\r\n */\r\nbox2d.b2World.prototype.RayCastAll = function (point1, point2, out)\r\n{\r\n\tout.length = 0;\r\n\r\n\t/**\r\n\t * @return {number} \r\n\t * @param {box2d.b2Fixture} fixture \r\n\t * @param {box2d.b2Vec2} point \r\n\t * @param {box2d.b2Vec2} normal \r\n\t * @param {number} fraction\r\n\t */\r\n\tfunction WorldRayCastAllWrapper(fixture, point, normal, fraction)\r\n\t{\r\n\t\tout.push(fixture);\r\n\t\treturn 1;\r\n\t};\r\n\r\n\tthis.RayCast(WorldRayCastAllWrapper, point1, point2);\r\n\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Fixture} fixture \r\n * @param {box2d.b2Color} color \r\n */\r\nbox2d.b2World.prototype.DrawShape = function (fixture, color)\r\n{\r\n\t/** @type {box2d.b2Shape} */ var shape = fixture.GetShape();\r\n\r\n\tswitch (shape.m_type)\r\n\t{\r\n\tcase box2d.b2ShapeType.e_circleShape:\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2CircleShape} */ var circle = ((shape instanceof box2d.b2CircleShape ? shape : null));\r\n\r\n\t\t\t/** @type {box2d.b2Vec2} */ var center = circle.m_p;\r\n\t\t\t/** @type {number} */ var radius = circle.m_radius;\r\n\t\t\t/** @type {box2d.b2Vec2} */ var axis = box2d.b2Vec2.UNITX;\r\n\r\n\t\t\tthis.m_debugDraw.DrawSolidCircle(center, radius, axis, color);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2ShapeType.e_edgeShape:\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2EdgeShape} */ var edge = ((shape instanceof box2d.b2EdgeShape ? shape : null));\r\n\t\t\t/** @type {box2d.b2Vec2} */ var v1 = edge.m_vertex1;\r\n\t\t\t/** @type {box2d.b2Vec2} */ var v2 = edge.m_vertex2;\r\n\t\t\tthis.m_debugDraw.DrawSegment(v1, v2, color);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2ShapeType.e_chainShape:\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2ChainShape} */ var chain = ((shape instanceof box2d.b2ChainShape ? shape : null));\r\n\t\t\t/** @type {number} */ var count = chain.m_count;\r\n\t\t\t/* type {Array.<box2d.b2Vec2>} */ var vertices = chain.m_vertices;\r\n\r\n\t\t\t/* type {box2d.b2Vec2} */ var v1 = vertices[0];\r\n\t\t\t// this.m_debugDraw.DrawCircle(v1, 0.05, color);\r\n\t\t\tfor (/** @type {number} */ var i = 0; i < count; ++i)\r\n\t\t\t{\r\n\t\t\t\t/* type {box2d.b2Vec2} */ var v2 = vertices[i];\r\n\t\t\t\tthis.m_debugDraw.DrawSegment(v1, v2, color);\r\n\t\t\t\tthis.m_debugDraw.DrawCircle(v2, 0.05, color);\r\n\t\t\t\tv1 = v2;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2ShapeType.e_polygonShape:\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2PolygonShape} */ var poly = ((shape instanceof box2d.b2PolygonShape ? shape : null));\r\n\t\t\t/** @type {number} */ var vertexCount = poly.m_count;\r\n\t\t\t/* type {Array.<box2d.b2Vec2>} */ var vertices = poly.m_vertices;\r\n\r\n\t\t\tthis.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Joint} joint\r\n */\r\nbox2d.b2World.prototype.DrawJoint = function (joint)\r\n{\r\n\t/** @type {box2d.b2Body} */ var bodyA = joint.GetBodyA();\r\n\t/** @type {box2d.b2Body} */ var bodyB = joint.GetBodyB();\r\n\t/** @type {box2d.b2Transform} */ var xf1 = bodyA.m_xf;\r\n\t/** @type {box2d.b2Transform} */ var xf2 = bodyB.m_xf;\r\n\t/** @type {box2d.b2Vec2} */ var x1 = xf1.p;\r\n\t/** @type {box2d.b2Vec2} */ var x2 = xf2.p;\r\n\t/** @type {box2d.b2Vec2} */ var p1 = joint.GetAnchorA(box2d.b2World.prototype.DrawJoint.s_p1);\r\n\t/** @type {box2d.b2Vec2} */ var p2 = joint.GetAnchorB(box2d.b2World.prototype.DrawJoint.s_p2);\r\n\r\n\t/** @type {box2d.b2Color} */ var color = box2d.b2World.prototype.DrawJoint.s_color.SetRGB(0.5, 0.8, 0.8);\r\n\r\n\tswitch (joint.m_type)\r\n\t{\r\n\tcase box2d.b2JointType.e_distanceJoint:\r\n\t\tthis.m_debugDraw.DrawSegment(p1, p2, color);\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_pulleyJoint:\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2PulleyJoint} */ var pulley = ((joint instanceof box2d.b2PulleyJoint ? joint : null));\r\n\t\t\t/** @type {box2d.b2Vec2} */ var s1 = pulley.GetGroundAnchorA(box2d.b2World.prototype.DrawJoint.s_s1);\r\n\t\t\t/** @type {box2d.b2Vec2} */ var s2 = pulley.GetGroundAnchorB(box2d.b2World.prototype.DrawJoint.s_s2);\r\n\t\t\tthis.m_debugDraw.DrawSegment(s1, p1, color);\r\n\t\t\tthis.m_debugDraw.DrawSegment(s2, p2, color);\r\n\t\t\tthis.m_debugDraw.DrawSegment(s1, s2, color);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase box2d.b2JointType.e_mouseJoint:\r\n\t\t// don't draw this\r\n\t\tthis.m_debugDraw.DrawSegment(p1, p2, color);\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tthis.m_debugDraw.DrawSegment(x1, p1, color);\r\n\t\tthis.m_debugDraw.DrawSegment(p1, p2, color);\r\n\t\tthis.m_debugDraw.DrawSegment(x2, p2, color);\r\n\t}\r\n}\r\nbox2d.b2World.prototype.DrawJoint.s_p1 = new box2d.b2Vec2();\r\nbox2d.b2World.prototype.DrawJoint.s_p2 = new box2d.b2Vec2();\r\nbox2d.b2World.prototype.DrawJoint.s_color = new box2d.b2Color(0.5, 0.8, 0.8);\r\nbox2d.b2World.prototype.DrawJoint.s_s1 = new box2d.b2Vec2();\r\nbox2d.b2World.prototype.DrawJoint.s_s2 = new box2d.b2Vec2();\r\n\r\n/**\r\n * Call this to draw shapes and other debug draw data.\r\n * @export \r\n * @return {void} \r\n */\r\nbox2d.b2World.prototype.DrawDebugData = function ()\r\n{\r\n\tif (this.m_debugDraw === null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t/** @type {number} */ var flags = this.m_debugDraw.GetFlags();\r\n\t/** @type {box2d.b2Color} */ var color = box2d.b2World.prototype.DrawDebugData.s_color.SetRGB(0, 0, 0);\r\n\r\n\tif (flags & box2d.b2DrawFlags.e_shapeBit)\r\n\t{\r\n\t\tfor (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t\t{\r\n\t\t\t/** @type {box2d.b2Transform} */ var xf = b.m_xf;\r\n\r\n\t\t\tthis.m_debugDraw.PushTransform(xf);\r\n\r\n\t\t\tfor (/** @type {box2d.b2Fixture} */ var f = b.GetFixtureList(); f; f = f.m_next)\r\n\t\t\t{\r\n\t\t\t\tif (b.IsActive() === false)\r\n\t\t\t\t{\r\n\t\t\t\t\tcolor.SetRGB(0.5, 0.5, 0.3);\r\n\t\t\t\t\tthis.DrawShape(f, color);\r\n\t\t\t\t}\r\n\t\t\t\telse if (b.GetType() === box2d.b2BodyType.b2_staticBody)\r\n\t\t\t\t{\r\n\t\t\t\t\tcolor.SetRGB(0.5, 0.9, 0.5);\r\n\t\t\t\t\tthis.DrawShape(f, color);\r\n\t\t\t\t}\r\n\t\t\t\telse if (b.GetType() === box2d.b2BodyType.b2_kinematicBody)\r\n\t\t\t\t{\r\n\t\t\t\t\tcolor.SetRGB(0.5, 0.5, 0.9);\r\n\t\t\t\t\tthis.DrawShape(f, color);\r\n\t\t\t\t}\r\n\t\t\t\telse if (b.IsAwake() === false)\r\n\t\t\t\t{\r\n\t\t\t\t\tcolor.SetRGB(0.6, 0.6, 0.6);\r\n\t\t\t\t\tthis.DrawShape(f, color);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tcolor.SetRGB(0.9, 0.7, 0.7);\r\n\t\t\t\t\tthis.DrawShape(f, color);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.m_debugDraw.PopTransform(xf);\r\n\t\t}\r\n\t}\r\n\r\n\tif (flags & box2d.b2DrawFlags.e_jointBit)\r\n\t{\r\n\t\tfor (/** @type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)\r\n\t\t{\r\n\t\t\tthis.DrawJoint(j);\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\tif (flags & box2d.b2DrawFlags.e_pairBit)\r\n\t{\r\n\t\tcolor.SetRGB(0.3, 0.9, 0.9);\r\n\t\tfor (var contact = this.m_contactManager.m_contactList; contact; contact = contact.m_next)\r\n\t\t{\r\n\t\t\tvar fixtureA = contact.GetFixtureA();\r\n\t\t\tvar fixtureB = contact.GetFixtureB();\r\n\r\n\t\t\tvar cA = fixtureA.GetAABB().GetCenter();\r\n\t\t\tvar cB = fixtureB.GetAABB().GetCenter();\r\n\r\n\t\t\tthis.m_debugDraw.DrawSegment(cA, cB, color);\r\n\t\t}\r\n\t}\r\n\t*/\r\n\r\n\tif (flags & box2d.b2DrawFlags.e_aabbBit)\r\n\t{\r\n\t\tcolor.SetRGB(0.9, 0.3, 0.9);\r\n\t\t/** @type {box2d.b2BroadPhase} */ var bp = this.m_contactManager.m_broadPhase;\r\n\t\t/** @type {Array.<box2d.b2Vec2>} */ var vs = box2d.b2World.prototype.DrawDebugData.s_vs;\r\n\r\n\t\tfor (/* type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t\t{\r\n\t\t\tif (b.IsActive() === false)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tfor (/* type {box2d.b2Fixture} */ var f = b.GetFixtureList(); f; f = f.m_next)\r\n\t\t\t{\r\n\t\t\t\tfor (/** @type {number} */ var i = 0; i < f.m_proxyCount; ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\t/** @type {box2d.b2FixtureProxy} */ var proxy = f.m_proxies[i];\r\n\r\n\t\t\t\t\t/** @type {box2d.b2AABB} */ var aabb = bp.GetFatAABB(proxy.proxy);\r\n\t\t\t\t\tvs[0].SetXY(aabb.lowerBound.x, aabb.lowerBound.y);\r\n\t\t\t\t\tvs[1].SetXY(aabb.upperBound.x, aabb.lowerBound.y);\r\n\t\t\t\t\tvs[2].SetXY(aabb.upperBound.x, aabb.upperBound.y);\r\n\t\t\t\t\tvs[3].SetXY(aabb.lowerBound.x, aabb.upperBound.y);\r\n\t\r\n\t\t\t\t\tthis.m_debugDraw.DrawPolygon(vs, 4, color);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (flags & box2d.b2DrawFlags.e_centerOfMassBit)\r\n\t{\r\n\t\tfor (/* type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t\t{\r\n\t\t\t/* type {box2d.b2Transform} */ var xf = box2d.b2World.prototype.DrawDebugData.s_xf;\r\n\t\t\txf.q.Copy(b.m_xf.q);\r\n\t\t\txf.p.Copy(b.GetWorldCenter());\r\n\t\t\tthis.m_debugDraw.DrawTransform(xf);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @see box2d.b2Controller list\r\n\tif (flags & box2d.b2DrawFlags.e_controllerBit)\r\n\t{\r\n\t\tfor (/** @type {box2d.b2Controller} */ var c = this.m_controllerList; c; c = c.m_next)\r\n\t\t{\r\n\t\t\tc.Draw(this.m_debugDraw);\r\n\t\t}\r\n\t}\r\n}\r\nbox2d.b2World.prototype.DrawDebugData.s_color = new box2d.b2Color(0, 0, 0);\r\nbox2d.b2World.prototype.DrawDebugData.s_vs = box2d.b2Vec2.MakeArray(4);\r\nbox2d.b2World.prototype.DrawDebugData.s_xf = new box2d.b2Transform();\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2BroadPhase} broadPhase\r\n */\r\nbox2d.b2World.prototype.SetBroadPhase = function (broadPhase)\r\n{\r\n\tvar oldBroadPhase = this.m_contactManager.m_broadPhase;\r\n\r\n\tthis.m_contactManager.m_broadPhase = broadPhase;\r\n\r\n\tfor (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t{\r\n\t\tfor (/** @type {box2d.b2Fixture} */ var f = b.m_fixtureList; f; f = f.m_next)\r\n\t\t{\r\n\t\t\tf.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** \r\n * Get the number of broad-phase proxies. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2World.prototype.GetProxyCount = function ()\r\n{\r\n\treturn this.m_contactManager.m_broadPhase.GetProxyCount();\r\n}\r\n\r\n/** \r\n * Get the height of the dynamic tree. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2World.prototype.GetTreeHeight = function ()\r\n{\r\n\treturn this.m_contactManager.m_broadPhase.GetTreeHeight();\r\n}\r\n\r\n/** \r\n * Get the balance of the dynamic tree. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2World.prototype.GetTreeBalance = function ()\r\n{\r\n\treturn this.m_contactManager.m_broadPhase.GetTreeBalance();\r\n}\r\n\r\n/** \r\n * Get the quality metric of the dynamic tree. The smaller the \r\n * better. The minimum is 1. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2World.prototype.GetTreeQuality = function ()\r\n{\r\n\treturn this.m_contactManager.m_broadPhase.GetTreeQuality();\r\n}\r\n\r\n/** \r\n * Shift the world origin. Useful for large worlds. \r\n * The body shift formula is: position -= newOrigin\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} newOrigin the new origin with respect to the old origin\r\n */\r\nbox2d.b2World.prototype.ShiftOrigin = function (newOrigin)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.IsLocked() === false); }\r\n\tif (this.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t{\r\n\t\tb.m_xf.p.SelfSub(newOrigin);\r\n\t\tb.m_sweep.c0.SelfSub(newOrigin);\r\n\t\tb.m_sweep.c.SelfSub(newOrigin);\r\n\t}\r\n\r\n\tfor (/** @type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)\r\n\t{\r\n\t\tj.ShiftOrigin(newOrigin);\r\n\t}\r\n\r\n\tthis.m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);\r\n}\r\n\r\n/** \r\n * Dump the world into the log file. \r\n * warning this should be called outside of a time step.\r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2World.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tif ((this.m_flags & box2d.b2WorldFlag.e_locked) === box2d.b2WorldFlag.e_locked)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\r\n\t\tbox2d.b2Log(\"/** @type {box2d.b2Vec2} */ var g = new box2d.b2Vec2(%.15f, %.15f);\\n\", this.m_gravity.x, this.m_gravity.y);\r\n\t\tbox2d.b2Log(\"this.m_world.SetGravity(g);\\n\");\r\n\t\r\n\t\tbox2d.b2Log(\"/** @type {Array.<box2d.b2Body>} */ var bodies = new Array(%d);\\n\", this.m_bodyCount);\r\n\t\tbox2d.b2Log(\"/** @type {Array.<box2d.b2Joint>} */ var joints = new Array(%d);\\n\", this.m_jointCount);\r\n\t\tvar i = 0;\r\n\t\tfor (/** @type {box2d.b2Body} */ var b = this.m_bodyList; b; b = b.m_next)\r\n\t\t{\r\n\t\t\tb.m_islandIndex = i;\r\n\t\t\tb.Dump();\r\n\t\t\t++i;\r\n\t\t}\r\n\t\r\n\t\ti = 0;\r\n\t\tfor (/** @type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)\r\n\t\t{\r\n\t\t\tj.m_index = i;\r\n\t\t\t++i;\r\n\t\t}\r\n\t\r\n\t\t// First pass on joints, skip gear joints.\r\n\t\tfor (/* type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)\r\n\t\t{\r\n\t\t\tif (j.m_type === box2d.b2JointType.e_gearJoint)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\r\n\t\t\tbox2d.b2Log(\"if (true)\\n\");\r\n\t\t\tbox2d.b2Log(\"{\\n\");\r\n\t\t\tj.Dump();\r\n\t\t\tbox2d.b2Log(\"}\\n\");\r\n\t\t}\r\n\t\r\n\t\t// Second pass on joints, only gear joints.\r\n\t\tfor (/* type {box2d.b2Joint} */ var j = this.m_jointList; j; j = j.m_next)\r\n\t\t{\r\n\t\t\tif (j.m_type !== box2d.b2JointType.e_gearJoint)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\r\n\t\t\tbox2d.b2Log(\"if (true)\\n\");\r\n\t\t\tbox2d.b2Log(\"{\\n\");\r\n\t\t\tj.Dump();\r\n\t\t\tbox2d.b2Log(\"}\\n\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @see box2d.b2Controller list \r\n * @export \r\n * @return {box2d.b2Controller} \r\n * @param {box2d.b2Controller} controller\r\n */\r\nbox2d.b2World.prototype.AddController = function (controller)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(controller.m_world === null, \"Controller can only be a member of one world\"); }\r\n\tcontroller.m_world = this;\r\n\tcontroller.m_next = this.m_controllerList;\r\n\tcontroller.m_prev = null;\r\n\tif (this.m_controllerList)\r\n\t\tthis.m_controllerList.m_prev = controller;\r\n\tthis.m_controllerList = controller;\r\n\t++this.m_controllerCount;\r\n\treturn controller;\r\n}\r\n\r\n/**\r\n * @see box2d.b2Controller list\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Controller} controller\r\n */\r\nbox2d.b2World.prototype.RemoveController = function (controller)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(controller.m_world === this, \"Controller is not a member of this world\"); }\r\n\tif (controller.m_prev)\r\n\t\tcontroller.m_prev.m_next = controller.m_next;\r\n\tif (controller.m_next)\r\n\t\tcontroller.m_next.m_prev = controller.m_prev;\r\n\tif (this.m_controllerList === controller)\r\n\t\tthis.m_controllerList = controller.m_next;\r\n\t--this.m_controllerCount;\r\n\tcontroller.m_prev = null;\r\n\tcontroller.m_next = null;\r\n\tcontroller.m_world = null;\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2AreaJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Definition for a {@link box2d.b2AreaJoint}, which connects a \r\n * group a bodies together so they maintain a constant area \r\n * within them. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2AreaJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_areaJoint); // base class constructor\r\n\r\n\tthis.bodies = new Array();\r\n}\r\n\r\ngoog.inherits(box2d.b2AreaJointDef, box2d.b2JointDef);\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2World}\r\n */\r\nbox2d.b2AreaJointDef.prototype.world = null;\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Body>}\r\n */\r\nbox2d.b2AreaJointDef.prototype.bodies = null;\r\n\r\n/** \r\n * The mass-spring-damper frequency in Hertz. A value of 0 \r\n * disables softness. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2AreaJointDef.prototype.frequencyHz = 0;\r\n\r\n/** \r\n * The damping ratio. 0 = no damping, 1 = critical damping. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2AreaJointDef.prototype.dampingRatio = 0;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} body\r\n */\r\nbox2d.b2AreaJointDef.prototype.AddBody = function (body)\r\n{\r\n\tthis.bodies.push(body);\r\n\r\n\tif (this.bodies.length === 1)\r\n\t{\r\n\t\tthis.bodyA = body;\r\n\t}\r\n\telse if (this.bodies.length === 2)\r\n\t{\r\n\t\tthis.bodyB = body;\r\n\t}\r\n}\r\n\r\n/** \r\n * A distance joint constrains two points on two bodies to \r\n * remain at a fixed distance from each other. You can view this \r\n * as a massless, rigid rod. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2AreaJointDef} def \r\n */\r\nbox2d.b2AreaJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.bodies.length >= 3, \"You cannot create an area joint with less than three bodies.\"); }\r\n\r\n\tthis.m_bodies = def.bodies;\r\n\tthis.m_frequencyHz = def.frequencyHz;\r\n\tthis.m_dampingRatio = def.dampingRatio;\r\n\r\n\tthis.m_targetLengths = box2d.b2MakeNumberArray(def.bodies.length);\r\n\tthis.m_normals = box2d.b2Vec2.MakeArray(def.bodies.length);\r\n\tthis.m_joints = new Array(def.bodies.length);\r\n\tthis.m_deltas = box2d.b2Vec2.MakeArray(def.bodies.length);\r\n\tthis.m_delta = new box2d.b2Vec2();\r\n\r\n\tvar djd = new box2d.b2DistanceJointDef();\r\n\tdjd.frequencyHz = def.frequencyHz;\r\n\tdjd.dampingRatio = def.dampingRatio;\r\n\r\n\tthis.m_targetArea = 0;\r\n\r\n\tfor (var i = 0, ict = this.m_bodies.length; i < ict; ++i)\r\n\t{\r\n\t\tvar body = this.m_bodies[i];\r\n\t\tvar next = this.m_bodies[(i+1)%ict];\r\n\r\n\t\tvar body_c = body.GetWorldCenter();\r\n\t\tvar next_c = next.GetWorldCenter();\r\n\r\n\t\tthis.m_targetLengths[i] = box2d.b2DistanceVV(body_c, next_c);\r\n\r\n\t\tthis.m_targetArea += box2d.b2CrossVV(body_c, next_c);\r\n\r\n\t\tdjd.Initialize(body, next, body_c, next_c);\r\n\t\tthis.m_joints[i] = def.world.CreateJoint(djd);\r\n\t}\r\n\r\n\tthis.m_targetArea *= 0.5;\r\n}\r\n\r\ngoog.inherits(box2d.b2AreaJoint, box2d.b2Joint);\r\n\r\n/**\r\n * @export \r\n * @type {Array.<box2d.b2Body>}\r\n */\r\nbox2d.b2AreaJoint.prototype.m_bodies = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2AreaJoint.prototype.m_frequencyHz = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2AreaJoint.prototype.m_dampingRatio = 0;\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2AreaJoint.prototype.m_impulse = 0;\r\n\r\n// Solver temp\r\nbox2d.b2AreaJoint.prototype.m_targetLengths = null;\r\nbox2d.b2AreaJoint.prototype.m_targetArea = 0;\r\nbox2d.b2AreaJoint.prototype.m_normals = null;\r\nbox2d.b2AreaJoint.prototype.m_joints = null;\r\nbox2d.b2AreaJoint.prototype.m_deltas = null;\r\nbox2d.b2AreaJoint.prototype.m_delta = null;\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2AreaJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn out.SetZero();\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2AreaJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn out.SetZero();\r\n}\r\n\r\n/** \r\n * Get the reaction force given the inverse time step. \r\n * Unit is N.\r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2AreaJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n\treturn out.SetZero();\r\n}\r\n\r\n/** \r\n * Get the reaction torque given the inverse time step. \r\n * Unit is N*m. This is always zero for a distance joint.\r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2AreaJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * Set/get frequency in Hz. \r\n * @export \r\n * @return {void} \r\n * @param {number} hz\r\n */\r\nbox2d.b2AreaJoint.prototype.SetFrequency = function (hz)\r\n{\r\n\tthis.m_frequencyHz = hz;\r\n\r\n\tfor (var i = 0, ict = this.m_joints.length; i < ict; ++i)\r\n\t{\r\n\t\tthis.m_joints[i].SetFrequency(hz);\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2AreaJoint.prototype.GetFrequency = function ()\r\n{\r\n\treturn this.m_frequencyHz;\r\n}\r\n\r\n/** \r\n * Set/get damping ratio. \r\n * @export \r\n * @return {void} \r\n * @param {number} ratio\r\n */\r\nbox2d.b2AreaJoint.prototype.SetDampingRatio = function (ratio)\r\n{\r\n\tthis.m_dampingRatio = ratio;\r\n\r\n\tfor (var i = 0, ict = this.m_joints.length; i < ict; ++i)\r\n\t{\r\n\t\tthis.m_joints[i].SetDampingRatio(ratio);\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2AreaJoint.prototype.GetDampingRatio = function ()\r\n{\r\n\treturn this.m_dampingRatio;\r\n}\r\n\r\n/** \r\n * Dump joint to dmLog \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2AreaJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tbox2d.b2Log(\"Area joint dumping is not supported.\\n\");\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2AreaJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tfor (var i = 0, ict = this.m_bodies.length; i < ict; ++i)\r\n\t{\r\n\t\tvar prev = this.m_bodies[(i+ict-1)%ict];\r\n\t\tvar next = this.m_bodies[(i+1)%ict];\r\n\t\tvar prev_c = data.positions[prev.m_islandIndex].c;\r\n\t\tvar next_c = data.positions[next.m_islandIndex].c;\r\n\t\tvar delta = this.m_deltas[i];\r\n\r\n\t\tbox2d.b2SubVV(next_c, prev_c, delta);\r\n\t}\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\tthis.m_impulse *= data.step.dtRatio;\r\n\r\n\t\tfor (var i = 0, ict = this.m_bodies.length; i < ict; ++i)\r\n\t\t{\r\n\t\t\tvar body = this.m_bodies[i];\r\n\t\t\tvar body_v = data.velocities[body.m_islandIndex].v;\r\n\t\t\tvar delta = this.m_deltas[i];\r\n\r\n\t\t\tbody_v.x += body.m_invMass *  delta.y * 0.5 * this.m_impulse;\r\n\t\t\tbody_v.y += body.m_invMass * -delta.x * 0.5 * this.m_impulse;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse = 0;\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2AreaJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\tvar dotMassSum = 0;\r\n\tvar crossMassSum = 0;\r\n\r\n\tfor (var i = 0, ict = this.m_bodies.length; i < ict; ++i)\r\n\t{\r\n\t\tvar body = this.m_bodies[i];\r\n\t\tvar body_v = data.velocities[body.m_islandIndex].v;\r\n\t\tvar delta = this.m_deltas[i];\r\n\r\n\t\tdotMassSum += delta.GetLengthSquared() / body.GetMass();\r\n\t\tcrossMassSum += box2d.b2CrossVV(body_v, delta);\r\n\t}\r\n\r\n\tvar lambda = -2 * crossMassSum / dotMassSum;\r\n\t//lambda = box2d.b2Clamp(lambda, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection);\r\n\r\n\tthis.m_impulse += lambda;\r\n\r\n\tfor (var i = 0, ict = this.m_bodies.length; i < ict; ++i)\r\n\t{\r\n\t\tvar body = this.m_bodies[i];\r\n\t\tvar body_v = data.velocities[body.m_islandIndex].v;\r\n\t\tvar delta = this.m_deltas[i];\r\n\r\n\t\tbody_v.x += body.m_invMass *  delta.y * 0.5 * lambda;\r\n\t\tbody_v.y += body.m_invMass * -delta.x * 0.5 * lambda;\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2AreaJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\tvar perimeter = 0;\r\n\tvar area = 0;\r\n\r\n\tfor (var i = 0, ict = this.m_bodies.length; i < ict; ++i)\r\n\t{\r\n\t\tvar body = this.m_bodies[i];\r\n\t\tvar next = this.m_bodies[(i+1)%ict];\r\n\t\tvar body_c = data.positions[body.m_islandIndex].c;\r\n\t\tvar next_c = data.positions[next.m_islandIndex].c;\r\n\r\n\t\tvar delta = box2d.b2SubVV(next_c, body_c, this.m_delta);\r\n\r\n\t\tvar dist = delta.GetLength();\r\n\t\tif (dist < box2d.b2_epsilon)\r\n\t\t{\r\n\t\t\tdist = 1;\r\n\t\t}\r\n\r\n\t\tthis.m_normals[i].x =  delta.y / dist;\r\n\t\tthis.m_normals[i].y = -delta.x / dist;\r\n\r\n\t\tperimeter += dist;\r\n\r\n\t\tarea += box2d.b2CrossVV(body_c, next_c);\r\n\t}\r\n\r\n\tarea *= 0.5;\r\n\r\n\tvar deltaArea = this.m_targetArea - area;\r\n\tvar toExtrude = 0.5 * deltaArea / perimeter;\r\n\tvar done = true;\r\n\r\n\tfor (var i = 0, ict = this.m_bodies.length; i < ict; ++i)\r\n\t{\r\n\t\tvar body = this.m_bodies[i];\r\n\t\tvar body_c = data.positions[body.m_islandIndex].c;\r\n\t\tvar next_i = (i+1)%ict;\r\n\r\n\t\tvar delta = box2d.b2AddVV(this.m_normals[i], this.m_normals[next_i], this.m_delta);\r\n\t\tdelta.SelfMul(toExtrude);\r\n\r\n\t\tvar norm_sq = delta.GetLengthSquared();\r\n\t\tif (norm_sq > box2d.b2Sq(box2d.b2_maxLinearCorrection))\r\n\t\t{\r\n\t\t\tdelta.SelfMul(box2d.b2_maxLinearCorrection / box2d.b2Sqrt(norm_sq));\r\n\t\t}\r\n\t\tif (norm_sq > box2d.b2Sq(box2d.b2_linearSlop))\r\n\t\t{\r\n\t\t\tdone = false;\r\n\t\t}\r\n\r\n\t\tbody_c.x += delta.x;\r\n\t\tbody_c.y += delta.y;\r\n\t}\r\n\r\n\treturn done;\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2BuoyancyController');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Controller');\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2WorldCallbacks');\r\n\r\n/** \r\n * Calculates buoyancy forces for fluids in the form of a half \r\n * plane. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Controller} \r\n */\r\nbox2d.b2BuoyancyController = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n\r\n\tthis.normal = new box2d.b2Vec2(0, 1);\r\n\tthis.velocity = new box2d.b2Vec2(0, 0);\r\n\tthis.gravity = new box2d.b2Vec2(0, 0);\r\n};\r\n\r\ngoog.inherits(box2d.b2BuoyancyController, box2d.b2Controller);\r\n\r\n/** \r\n * The outer surface normal \r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2BuoyancyController.prototype.normal = null;\r\n/** \r\n * The height of the fluid surface along the normal \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2BuoyancyController.prototype.offset = 0;\r\n/** \r\n * The fluid density \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2BuoyancyController.prototype.density = 0;\r\n/** \r\n * Fluid velocity, for drag calculations \r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2BuoyancyController.prototype.velocity = null;\r\n/** \r\n * Linear drag co-efficient \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2BuoyancyController.prototype.linearDrag = 0;\r\n/** \r\n * Linear drag co-efficient \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2BuoyancyController.prototype.angularDrag = 0;\r\n/** \r\n * If false, bodies are assumed to be uniformly dense, otherwise \r\n * use the shapes densities \r\n * @export \r\n * @type {boolean} \r\n */\r\nbox2d.b2BuoyancyController.prototype.useDensity = false; //False by default to prevent a gotcha\r\n/** \r\n * If true, gravity is taken from the world instead of the\r\n * @export \r\n * @type {boolean} \r\n */\r\nbox2d.b2BuoyancyController.prototype.useWorldGravity = true;\r\n/** \r\n * Gravity vector, if the world's gravity is not used \r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2BuoyancyController.prototype.gravity = null;\r\n\r\n/** \r\n * @see box2d.b2Controller::Step \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TimeStep} step \r\n */\r\nbox2d.b2BuoyancyController.prototype.Step = function (step)\r\n{\r\n\tif (!this.m_bodyList) \r\n\t\treturn;\r\n\tif (this.useWorldGravity)\r\n\t{\r\n\t\tthis.gravity.Copy(this.GetWorld().GetGravity());\r\n\t}\r\n\tfor (var i = this.m_bodyList; i; i = i.nextBody)\r\n\t{\r\n\t\tvar body = i.body;\r\n\t\tif (body.IsAwake() === false)\r\n\t\t{\r\n\t\t\t//Buoyancy force is just a function of position,\r\n\t\t\t//so unlike most forces, it is safe to ignore sleeping bodes\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tvar areac = new box2d.b2Vec2();\r\n\t\tvar massc = new box2d.b2Vec2();\r\n\t\tvar area = 0;\r\n\t\tvar mass = 0;\r\n\t\tfor (var fixture = body.GetFixtureList(); fixture; fixture = fixture.m_next)\r\n\t\t{\r\n\t\t\tvar sc = new box2d.b2Vec2();\r\n\t\t\tvar sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);\r\n\t\t\tarea += sarea;\r\n\t\t\tareac.x += sarea * sc.x;\r\n\t\t\tareac.y += sarea * sc.y;\r\n\t\t\tvar shapeDensity = 0;\r\n\t\t\tif (this.useDensity)\r\n\t\t\t{\r\n\t\t\t\t//TODO: Expose density publicly\r\n\t\t\t\tshapeDensity = fixture.GetDensity();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tshapeDensity = 1;\r\n\t\t\t}\r\n\t\t\tmass += sarea * shapeDensity;\r\n\t\t\tmassc.x += sarea * sc.x * shapeDensity;\r\n\t\t\tmassc.y += sarea * sc.y * shapeDensity;\r\n\t\t}\r\n\t\tareac.x /= area;\r\n\t\tareac.y /= area;\r\n//\t\tb2Vec2 localCentroid = b2MulT(body->GetXForm(),areac);\r\n\t\tmassc.x /= mass;\r\n\t\tmassc.y /= mass;\r\n\t\tif (area < box2d.b2_epsilon)\r\n\t\t\tcontinue;\r\n\t\t//Buoyancy\r\n\t\tvar buoyancyForce = box2d.b2NegV(this.gravity, new box2d.b2Vec2());\r\n\t\tbuoyancyForce.SelfMul(this.density * area);\r\n\t\tbody.ApplyForce(buoyancyForce, massc);\r\n\t\t//Linear drag\r\n\t\tvar dragForce = body.GetLinearVelocityFromWorldPoint(areac, new box2d.b2Vec2());\r\n\t\tdragForce.SelfSub(this.velocity);\r\n\t\tdragForce.SelfMul((-this.linearDrag * area));\r\n\t\tbody.ApplyForce(dragForce, areac);\r\n\t\t//Angular drag\r\n\t\t//TODO: Something that makes more physical sense?\r\n\t\tbody.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));\r\n\t}\r\n}\r\n\r\n/** \r\n * @see b2Controller::Draw \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Draw} debugDraw\r\n */\r\nbox2d.b2BuoyancyController.prototype.Draw = function (debugDraw)\r\n{\r\n\tvar r = 100;\r\n\tvar p1 = new box2d.b2Vec2();\r\n\tvar p2 = new box2d.b2Vec2();\r\n\tp1.x = this.normal.x * this.offset + this.normal.y * r;\r\n\tp1.y = this.normal.y * this.offset - this.normal.x * r;\r\n\tp2.x = this.normal.x * this.offset - this.normal.y * r;\r\n\tp2.y = this.normal.y * this.offset + this.normal.x * r;\r\n\r\n\tvar color = new box2d.b2Color(0, 0, 0.8);\r\n\r\n\tdebugDraw.DrawSegment(p1, p2, color);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2TensorDampingController');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Controller');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Applies top down linear damping to the controlled bodies \r\n * The damping is calculated by multiplying velocity by a matrix \r\n * in local co-ordinates. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Controller} \r\n */\r\nbox2d.b2TensorDampingController = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n\r\n\t/// Tensor to use in damping model\r\n\t/** @type {box2d.b2Mat22} */ this.T = new box2d.b2Mat22();\r\n\t/*Some examples (matrixes in format (row1; row2))\r\n\t(-a 0; 0 -a)\t\tStandard isotropic damping with strength a\r\n\t( 0 a; -a 0)\t\tElectron in fixed field - a force at right angles to velocity with proportional magnitude\r\n\t(-a 0; 0 -b)\t\tDiffering x and y damping. Useful e.g. for top-down wheels.\r\n\t*/\r\n\t//By the way, tensor in this case just means matrix, don't let the terminology get you down.\r\n\r\n\t/// Set this to a positive number to clamp the maximum amount of damping done.\r\n\t/** @type {number} */ this.maxTimestep = 0;\r\n\t// Typically one wants maxTimestep to be 1/(max eigenvalue of T), so that damping will never cause something to reverse direction\r\n};\r\n\r\ngoog.inherits(box2d.b2TensorDampingController, box2d.b2Controller);\r\n\r\n/** \r\n * Tensor to use in damping model \r\n * @export \r\n * @type {box2d.b2Mat22} \r\n */\r\nbox2d.b2TensorDampingController.prototype.T = new box2d.b2Mat22();\r\n/*Some examples (matrixes in format (row1; row2))\r\n(-a 0; 0 -a)\t\tStandard isotropic damping with strength a\r\n( 0 a; -a 0)\t\tElectron in fixed field - a force at right angles to velocity with proportional magnitude\r\n(-a 0; 0 -b)\t\tDiffering x and y damping. Useful e.g. for top-down wheels.\r\n*/\r\n//By the way, tensor in this case just means matrix, don't let the terminology get you down.\r\n\r\n/** \r\n * Set this to a positive number to clamp the maximum amount of \r\n * damping done. \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2TensorDampingController.prototype.maxTimestep = 0;\r\n// Typically one wants maxTimestep to be 1/(max eigenvalue of T), so that damping will never cause something to reverse direction\r\n\r\n/** \r\n * @see b2Controller::Step \r\n * @return {void} \r\n * @param {box2d.b2TimeStep} step \r\n */\r\nbox2d.b2TensorDampingController.prototype.Step = function (step)\r\n{\r\n\tvar timestep = step.dt;\r\n\tif (timestep <= box2d.b2_epsilon)\r\n\t\treturn;\r\n\tif (timestep > this.maxTimestep && this.maxTimestep > 0)\r\n\t\ttimestep = this.maxTimestep;\r\n\tfor (var i = this.m_bodyList; i; i = i.nextBody)\r\n\t{\r\n\t\tvar body = i.body;\r\n\t\tif (!body.IsAwake())\r\n\t\t\tcontinue;\r\n\t\tvar damping = body.GetWorldVector(\r\n\t\t\tbox2d.b2MulMV(\r\n\t\t\t\tthis.T, \r\n\t\t\t\tbody.GetLocalVector(\r\n\t\t\t\t\tbody.GetLinearVelocity(), \r\n\t\t\t\t\tbox2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2Vec2.s_t1),\r\n\t\t\tbox2d.b2TensorDampingController.prototype.Step.s_damping);\r\n//\t\tbody->SetLinearVelocity(body->GetLinearVelocity() + timestep * damping);\r\n\t\tbody.SetLinearVelocity(box2d.b2AddVV(body.GetLinearVelocity(), box2d.b2MulSV(timestep, damping, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1));\r\n\t}\r\n}\r\nbox2d.b2TensorDampingController.prototype.Step.s_damping = new box2d.b2Vec2();\r\n\r\n/** \r\n * Sets damping independantly along the x and y axes \r\n * @return {void} \r\n * @param {number} xDamping \r\n * @param {number} yDamping \r\n */\r\nbox2d.b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping)\r\n{\r\n\tthis.T.ex.x = (-xDamping);\r\n\tthis.T.ex.y = 0;\r\n\tthis.T.ey.x = 0;\r\n\tthis.T.ey.y = (-yDamping);\r\n\tif (xDamping > 0 || yDamping > 0)\r\n\t{\r\n\t\tthis.maxTimestep = 1 / box2d.b2Max(xDamping, yDamping);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.maxTimestep = 0;\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2DistanceJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Distance joint definition. This requires defining an anchor \r\n * point on both bodies and the non-zero length of the distance \r\n * joint. The definition uses local anchor points so that the \r\n * initial configuration can violate the constraint slightly. \r\n * This helps when saving and loading a game. \r\n * warning Do not use a zero or short length.\r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2DistanceJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_distanceJoint); // base class constructor\r\n\r\n\tthis.localAnchorA = new box2d.b2Vec2();\r\n\tthis.localAnchorB = new box2d.b2Vec2();\r\n}\r\n\r\ngoog.inherits(box2d.b2DistanceJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJointDef.prototype.localAnchorA = null;\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJointDef.prototype.localAnchorB = null;\r\n\r\n/** \r\n * The natural length between the anchor points. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJointDef.prototype.length = 1;\r\n\r\n/** \r\n * The mass-spring-damper frequency in Hertz. A value of 0 \r\n * disables softness. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJointDef.prototype.frequencyHz = 0;\r\n\r\n/** \r\n * The damping ratio. 0 = no damping, 1 = critical damping. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJointDef.prototype.dampingRatio = 0;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} b1 \r\n * @param {box2d.b2Body} b2 \r\n * @param {box2d.b2Vec2} anchor1 \r\n * @param {box2d.b2Vec2} anchor2 \r\n */\r\nbox2d.b2DistanceJointDef.prototype.Initialize = function (b1, b2, anchor1, anchor2)\r\n{\r\n\tthis.bodyA = b1;\r\n\tthis.bodyB = b2;\r\n\tthis.bodyA.GetLocalPoint(anchor1, this.localAnchorA);\r\n\tthis.bodyB.GetLocalPoint(anchor2, this.localAnchorB);\r\n\tthis.length = box2d.b2DistanceVV(anchor1, anchor2);\r\n\tthis.frequencyHz = 0;\r\n\tthis.dampingRatio = 0;\r\n}\r\n\r\n/** \r\n * A distance joint constrains two points on two bodies to \r\n * remain at a fixed distance from each other. You can view this \r\n * as a massless, rigid rod. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2DistanceJointDef} def \r\n */\r\nbox2d.b2DistanceJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_u = new box2d.b2Vec2();\r\n\tthis.m_rA = new box2d.b2Vec2();\r\n\tthis.m_rB = new box2d.b2Vec2();\r\n\tthis.m_localCenterA = new box2d.b2Vec2();\r\n\tthis.m_localCenterB = new box2d.b2Vec2();\r\n\r\n\tthis.m_qA = new box2d.b2Rot();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_lalcA = new box2d.b2Vec2();\r\n\tthis.m_lalcB = new box2d.b2Vec2();\r\n\r\n\tthis.m_frequencyHz = def.frequencyHz;\r\n\tthis.m_dampingRatio = def.dampingRatio;\r\n\r\n\tthis.m_localAnchorA = def.localAnchorA.Clone();\r\n\tthis.m_localAnchorB = def.localAnchorB.Clone();\r\n\tthis.m_length = def.length;\r\n}\r\n\r\ngoog.inherits(box2d.b2DistanceJoint, box2d.b2Joint);\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_frequencyHz = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_dampingRatio = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_bias = 0;\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_localAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_localAnchorB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_gamma = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_impulse = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_length = 0;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_u = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_rB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_invIB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_mass = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_lalcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2DistanceJoint.prototype.m_lalcB = null;\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2DistanceJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2DistanceJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * Get the reaction force given the inverse time step. \r\n * Unit is N.\r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2DistanceJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n\treturn out.SetXY(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);\r\n}\r\n\r\n/** \r\n * Get the reaction torque given the inverse time step. \r\n * Unit is N*m. This is always zero for a distance joint.\r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2DistanceJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2DistanceJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {number} length\r\n */\r\nbox2d.b2DistanceJoint.prototype.SetLength = function (length)\r\n{\r\n\tthis.m_length = length;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.GetLength = function ()\r\n{\r\n\treturn this.m_length;\r\n}\r\n\r\n/** \r\n * Set/get frequency in Hz. \r\n * @export \r\n * @return {void} \r\n * @param {number} hz\r\n */\r\nbox2d.b2DistanceJoint.prototype.SetFrequency = function (hz)\r\n{\r\n\tthis.m_frequencyHz = hz;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.GetFrequency = function ()\r\n{\r\n\treturn this.m_frequencyHz;\r\n}\r\n\r\n/** \r\n * Set/get damping ratio. \r\n * @export \r\n * @return {void} \r\n * @param {number} ratio\r\n */\r\nbox2d.b2DistanceJoint.prototype.SetDampingRatio = function (ratio)\r\n{\r\n\tthis.m_dampingRatio = ratio;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2DistanceJoint.prototype.GetDampingRatio = function ()\r\n{\r\n\treturn this.m_dampingRatio;\r\n}\r\n\r\n/** \r\n * Dump joint to dmLog \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2DistanceJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\t\r\n\t\tbox2d.b2Log(\"  /*box2d.b2DistanceJointDef*/ var jd = new box2d.b2DistanceJointDef();\\n\");\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.localAnchorA.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n\t\tbox2d.b2Log(\"  jd.localAnchorB.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n\t\tbox2d.b2Log(\"  jd.length = %.15f;\\n\", this.m_length);\r\n\t\tbox2d.b2Log(\"  jd.frequencyHz = %.15f;\\n\", this.m_frequencyHz);\r\n\t\tbox2d.b2Log(\"  jd.dampingRatio = %.15f;\\n\", this.m_dampingRatio);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2DistanceJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassA = this.m_bodyA.m_invMass;\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIA = this.m_bodyA.m_invI;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n//\tvar qA = new box2d.b2Rot(aA), qB = new box2d.b2Rot(aB);\r\n\tvar qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n//\tm_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tbox2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tm_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tbox2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n//\tm_u = cB + m_rB - cA - m_rA;\r\n\tthis.m_u.x = cB.x + this.m_rB.x - cA.x - this.m_rA.x;\r\n\tthis.m_u.y = cB.y + this.m_rB.y - cA.y - this.m_rA.y;\r\n\r\n\t// Handle singularity.\r\n\tvar length = this.m_u.GetLength();\r\n\tif (length > box2d.b2_linearSlop)\r\n\t{\r\n\t\tthis.m_u.SelfMul(1 / length);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_u.SetZero();\r\n\t}\r\n\r\n//\tfloat32 crAu = b2Cross(m_rA, m_u);\r\n\tvar crAu = box2d.b2CrossVV(this.m_rA, this.m_u);\r\n//\tfloat32 crBu = b2Cross(m_rB, m_u);\r\n\tvar crBu = box2d.b2CrossVV(this.m_rB, this.m_u);\r\n//\tfloat32 invMass = m_invMassA + m_invIA * crAu * crAu + m_invMassB + m_invIB * crBu * crBu;\r\n\tvar invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;\r\n\r\n\t// Compute the effective mass matrix.\r\n\tthis.m_mass = invMass !== 0 ? 1 / invMass : 0;\r\n\r\n\tif (this.m_frequencyHz > 0)\r\n\t{\r\n\t\tvar C = length - this.m_length;\r\n\r\n\t\t// Frequency\r\n\t\tvar omega = 2 * box2d.b2_pi * this.m_frequencyHz;\r\n\r\n\t\t// Damping coefficient\r\n\t\tvar d = 2 * this.m_mass * this.m_dampingRatio * omega;\r\n\r\n\t\t// Spring stiffness\r\n\t\tvar k = this.m_mass * omega * omega;\r\n\r\n\t\t// magic formulas\r\n\t\t/*float32*/ var h = data.step.dt;\r\n\t\tthis.m_gamma = h * (d + h * k);\r\n\t\tthis.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0;\r\n\t\tthis.m_bias = C * h * k * this.m_gamma;\r\n\r\n\t\tinvMass += this.m_gamma;\r\n\t\tthis.m_mass = invMass !== 0 ? 1 / invMass : 0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_gamma = 0;\r\n\t\tthis.m_bias = 0;\r\n\t}\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\t// Scale the impulse to support a variable time step.\r\n\t\tthis.m_impulse *= data.step.dtRatio;\r\n\r\n//\t\tbox2d.b2Vec2 P = m_impulse * m_u;\r\n\t\tvar P = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P);\r\n\r\n//\t\tvA -= m_invMassA * P;\r\n\t\tvA.SelfMulSub(this.m_invMassA, P);\r\n//\t\twA -= m_invIA * b2Cross(m_rA, P);\r\n\t\twA -= this.m_invIA * box2d.b2CrossVV(this.m_rA, P);\r\n//\t\tvB += m_invMassB * P;\r\n\t\tvB.SelfMulAdd(this.m_invMassB, P);\r\n//\t\twB += m_invIB * b2Cross(m_rB, P);\r\n\t\twB += this.m_invIB * box2d.b2CrossVV(this.m_rB, P);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse = 0;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2DistanceJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n//\tbox2d.b2Vec2 vpA = vA + b2Cross(wA, m_rA);\r\n\tvar vpA = box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA);\r\n//\tbox2d.b2Vec2 vpB = vB + b2Cross(wB, m_rB);\r\n\tvar vpB = box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB);\r\n//\tfloat32 Cdot = b2Dot(m_u, vpB - vpA);\r\n\tvar Cdot = box2d.b2DotVV(this.m_u, box2d.b2SubVV(vpB, vpA, box2d.b2Vec2.s_t0));\r\n\r\n\tvar impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));\r\n\tthis.m_impulse += impulse;\r\n\r\n//\tbox2d.b2Vec2 P = impulse * m_u;\r\n\tvar P = box2d.b2MulSV(impulse, this.m_u, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P);\r\n\r\n//\tvA -= m_invMassA * P;\r\n\tvA.SelfMulSub(this.m_invMassA, P);\r\n//\twA -= m_invIA * b2Cross(m_rA, P);\r\n\twA -= this.m_invIA * box2d.b2CrossVV(this.m_rA, P);\r\n//\tvB += m_invMassB * P;\r\n\tvB.SelfMulAdd(this.m_invMassB, P);\r\n//\twB += m_invIB * b2Cross(m_rB, P);\r\n\twB += this.m_invIB * box2d.b2CrossVV(this.m_rB, P);\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2();\r\nbox2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2();\r\nbox2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2DistanceJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\tif (this.m_frequencyHz > 0)\r\n\t{\r\n\t\t// There is no position correction for soft distance constraints.\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\r\n//\tvar qA = new box2d.b2Rot(aA), qB = new box2d.b2Rot(aB);\r\n\tvar qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n//\tbox2d.b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tvar rA = box2d.b2MulRV(this.m_qA, this.m_lalcA, this.m_rA); // use m_rA\r\n//\tbox2d.b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tvar rB = box2d.b2MulRV(this.m_qB, this.m_lalcB, this.m_rB); // use m_rB\r\n//\tbox2d.b2Vec2 u = cB + rB - cA - rA;\r\n\tvar u = this.m_u; // use m_u\r\n\tu.x = cB.x + rB.x - cA.x - rA.x;\r\n\tu.y = cB.y + rB.y - cA.y - rA.y;\r\n\r\n//\tfloat32 length = u.Normalize();\r\n\tvar length = this.m_u.Normalize();\r\n//\tfloat32 C = length - m_length;\r\n\tvar C = length - this.m_length;\r\n\tC = box2d.b2Clamp(C, (-box2d.b2_maxLinearCorrection), box2d.b2_maxLinearCorrection);\r\n\r\n\tvar impulse = (-this.m_mass * C);\r\n//\tbox2d.b2Vec2 P = impulse * u;\r\n\tvar P = box2d.b2MulSV(impulse, u, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P);\r\n\r\n//\tcA -= m_invMassA * P;\r\n\tcA.SelfMulSub(this.m_invMassA, P);\r\n//\taA -= m_invIA * b2Cross(rA, P);\r\n\taA -= this.m_invIA * box2d.b2CrossVV(rA, P);\r\n//\tcB += m_invMassB * P;\r\n\tcB.SelfMulAdd(this.m_invMassB, P);\r\n//\taB += m_invIB * b2Cross(rB, P);\r\n\taB += this.m_invIB * box2d.b2CrossVV(rB, P);\r\n\r\n//\tdata.positions[this.m_indexA].c = cA;\r\n\tdata.positions[this.m_indexA].a = aA;\r\n//\tdata.positions[this.m_indexB].c = cB;\r\n\tdata.positions[this.m_indexB].a = aB;\r\n\r\n\treturn box2d.b2Abs(C) < box2d.b2_linearSlop;\r\n}\r\nbox2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2FrictionJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Friction joint definition. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2FrictionJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_frictionJoint); // base class constructor\r\n\r\n\tthis.localAnchorA = new box2d.b2Vec2();\r\n\tthis.localAnchorB = new box2d.b2Vec2();\r\n}\r\n\r\ngoog.inherits(box2d.b2FrictionJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJointDef.prototype.localAnchorA = null;\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJointDef.prototype.localAnchorB = null;\r\n\r\n/** \r\n * The maximum friction force in N. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJointDef.prototype.maxForce = 0;\r\n\r\n/** \r\n * The maximum friction torque in N-m. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJointDef.prototype.maxTorque = 0;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} bA \r\n * @param {box2d.b2Body} bB \r\n * @param {box2d.b2Vec2} anchor \r\n */\r\nbox2d.b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor)\r\n{\r\n\tthis.bodyA = bA;\r\n\tthis.bodyB = bB;\r\n\tthis.bodyA.GetLocalPoint(anchor, this.localAnchorA);\r\n\tthis.bodyB.GetLocalPoint(anchor, this.localAnchorB);\r\n}\r\n\r\n/** \r\n * Friction joint. This is used for top-down friction. It \r\n * provides 2D translational friction and angular friction. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2FrictionJointDef} def \r\n */\r\nbox2d.b2FrictionJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_localAnchorA = def.localAnchorA.Clone();\r\n\tthis.m_localAnchorB = def.localAnchorB.Clone();\r\n\r\n\tthis.m_linearImpulse = new box2d.b2Vec2().SetZero();\r\n\tthis.m_maxForce = def.maxForce;\r\n\tthis.m_maxTorque = def.maxTorque;\r\n\r\n\tthis.m_rA = new box2d.b2Vec2();\r\n\tthis.m_rB = new box2d.b2Vec2();\r\n\tthis.m_localCenterA = new box2d.b2Vec2();\r\n\tthis.m_localCenterB = new box2d.b2Vec2();\r\n\tthis.m_linearMass = new box2d.b2Mat22().SetZero();\r\n\r\n\tthis.m_qA = new box2d.b2Rot();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_lalcA = new box2d.b2Vec2();\r\n\tthis.m_lalcB = new box2d.b2Vec2();\r\n\tthis.m_K = new box2d.b2Mat22();\r\n}\r\n\r\ngoog.inherits(box2d.b2FrictionJoint, box2d.b2Joint);\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_localAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_localAnchorB = null;\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_linearImpulse = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_angularImpulse = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_maxForce = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_maxTorque = 0;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_rB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_invIB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_linearMass = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_angularMass = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_lalcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_lalcB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2FrictionJoint.prototype.m_K = null;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2FrictionJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassA = this.m_bodyA.m_invMass;\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIA = this.m_bodyA.m_invI;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n//\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n//\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n//\t/*box2d.b2Rot*/ var qA = new box2d.b2Rot(aA), /*box2d.b2Rot*/ qB = new box2d.b2Rot(aB);\r\n\tvar qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n\t// Compute the effective mass matrix.\r\n//\tm_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tm_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n\t// J = [-I -r1_skew I r2_skew]\r\n\t//     [ 0       -1 0       1]\r\n\t// r_skew = [-ry; rx]\r\n\r\n\t// Matlab\r\n\t// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]\r\n\t//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]\r\n\t//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t/*box2d.b2Mat22*/ var K = this.m_K; //new box2d.b2Mat22();\r\n\tK.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\r\n\tK.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\r\n\tK.ey.x = K.ex.y;\r\n\tK.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\r\n\r\n\tK.GetInverse(this.m_linearMass);\r\n\r\n\tthis.m_angularMass = iA + iB;\r\n\tif (this.m_angularMass > 0)\r\n\t{\r\n\t\tthis.m_angularMass = 1 / this.m_angularMass;\r\n\t}\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\t// Scale impulses to support a variable time step.\r\n//\t\tm_linearImpulse *= data.step.dtRatio;\r\n\t\tthis.m_linearImpulse.SelfMul(data.step.dtRatio);\r\n\t\tthis.m_angularImpulse *= data.step.dtRatio;\r\n\r\n//\t\t/*box2d.b2Vec2*/ var P(m_linearImpulse.x, m_linearImpulse.y);\r\n\t\t/*box2d.b2Vec2*/ var P = this.m_linearImpulse;\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n//\t\twA -= iA * (b2Cross(m_rA, P) + m_angularImpulse);\r\n\t\twA -= iA * (box2d.b2CrossVV(this.m_rA, P) + this.m_angularImpulse);\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n//\t\twB += iB * (b2Cross(m_rB, P) + m_angularImpulse);\r\n\t\twB += iB * (box2d.b2CrossVV(this.m_rB, P) + this.m_angularImpulse);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_linearImpulse.SetZero();\r\n\t\tthis.m_angularImpulse = 0;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2FrictionJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t/*float32*/ var h = data.step.dt;\r\n\r\n\t// Solve angular friction\r\n\tif (true)\r\n\t{\r\n\t\t/*float32*/ var Cdot = wB - wA;\r\n\t\t/*float32*/ var impulse = (-this.m_angularMass * Cdot);\r\n\r\n\t\t/*float32*/ var oldImpulse = this.m_angularImpulse;\r\n\t\t/*float32*/ var maxImpulse = h * this.m_maxTorque;\r\n\t\tthis.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);\r\n\t\timpulse = this.m_angularImpulse - oldImpulse;\r\n\r\n\t\twA -= iA * impulse;\r\n\t\twB += iB * impulse;\r\n\t}\r\n\r\n\t// Solve linear friction\r\n\tif (true)\r\n\t{\r\n//\t\tb2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);\r\n\t\tvar Cdot = box2d.b2SubVV(\r\n\t\t\tbox2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2Vec2.s_t0), \r\n\t\t\tbox2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2Vec2.s_t1), \r\n\t\t\tbox2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot);\r\n\r\n//\t\tb2Vec2 impulse = -b2Mul(m_linearMass, Cdot);\r\n\t\tvar impulseV = box2d.b2MulMV(this.m_linearMass, Cdot, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV).SelfNeg();\r\n//\t\tb2Vec2 oldImpulse = m_linearImpulse;\r\n\t\tvar oldImpulseV = box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV.Copy(this.m_linearImpulse);\r\n//\t\tm_linearImpulse += impulse;\r\n\t\tthis.m_linearImpulse.SelfAdd(impulseV);\r\n\r\n\t\t/*float32*/ var maxImpulse = h * this.m_maxForce;\r\n\r\n\t\tif (this.m_linearImpulse.GetLengthSquared() > maxImpulse * maxImpulse)\r\n\t\t{\r\n\t\t\tthis.m_linearImpulse.Normalize();\r\n\t\t\tthis.m_linearImpulse.SelfMul(maxImpulse);\r\n\t\t}\r\n\r\n//\t\timpulse = m_linearImpulse - oldImpulse;\r\n\t\tbox2d.b2SubVV(this.m_linearImpulse, oldImpulseV, impulseV);\r\n\r\n//\t\tvA -= mA * impulse;\r\n\t\tvA.SelfMulSub(mA, impulseV);\r\n//\t\twA -= iA * b2Cross(m_rA, impulse);\r\n\t\twA -= iA * box2d.b2CrossVV(this.m_rA, impulseV);\r\n\r\n//\t\tvB += mB * impulse;\r\n\t\tvB.SelfMulAdd(mB, impulseV);\r\n//\t\twB += iB * b2Cross(m_rB, impulse);\r\n\t\twB += iB * box2d.b2CrossVV(this.m_rB, impulseV);\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2();\r\nbox2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV = new box2d.b2Vec2();\r\nbox2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2FrictionJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\treturn true;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2FrictionJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2FrictionJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2FrictionJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n\treturn out.SetXY(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn inv_dt * this.m_angularImpulse;\r\n}\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2FrictionJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2FrictionJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }\r\n\r\n/** \r\n * Set the maximum friction force in N. \r\n * @export \r\n * @return {void} \r\n * @param {number} force\r\n */\r\nbox2d.b2FrictionJoint.prototype.SetMaxForce = function (force)\r\n{\r\n\tthis.m_maxForce = force;\r\n}\r\n\r\n/** \r\n * Get the maximum friction force in N. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.GetMaxForce = function ()\r\n{\r\n\treturn this.m_maxForce;\r\n}\r\n\r\n/** \r\n * Set the maximum friction torque in N*m. \r\n * @export \r\n * @return {void} \r\n * @param {number} torque\r\n */\r\nbox2d.b2FrictionJoint.prototype.SetMaxTorque = function (torque)\r\n{\r\n\tthis.m_maxTorque = torque;\r\n}\r\n\r\n/** \r\n * Get the maximum friction torque in N*m. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2FrictionJoint.prototype.GetMaxTorque = function ()\r\n{\r\n\treturn this.m_maxTorque;\r\n}\r\n\r\n/** \r\n * Dump joint to dmLog \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2FrictionJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\t\r\n\t\tbox2d.b2Log(\"  /*box2d.b2FrictionJointDef*/ var jd = new box2d.b2FrictionJointDef();\\n\");\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.localAnchorA.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n\t\tbox2d.b2Log(\"  jd.localAnchorB.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n\t\tbox2d.b2Log(\"  jd.maxForce = %.15f;\\n\", this.m_maxForce);\r\n\t\tbox2d.b2Log(\"  jd.maxTorque = %.15f;\\n\", this.m_maxTorque);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2MouseJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Mouse joint definition. This requires a world target point, \r\n * tuning parameters, and the time step. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2MouseJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_mouseJoint); // base class constructor\r\n\r\n\tthis.target = new box2d.b2Vec2();\r\n}\r\n\r\ngoog.inherits(box2d.b2MouseJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The initial world target point. This is assumed to coincide \r\n * with the body anchor initially. \r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2MouseJointDef.prototype.target = null;\r\n\r\n/** \r\n * The maximum constraint force that can be exerted to move the \r\n * candidate body. Usually you will express as some multiple of \r\n * the weight (multiplier * mass * gravity). \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2MouseJointDef.prototype.maxForce = 0;\r\n\r\n/** \r\n * The response speed. \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2MouseJointDef.prototype.frequencyHz = 5;\r\n\r\n/** \r\n * The damping ratio. 0 = no damping, 1 = critical damping. \r\n * @export \r\n * @type {number} \r\n */\r\nbox2d.b2MouseJointDef.prototype.dampingRatio = 0.7;\r\n\r\n/** \r\n * A mouse joint is used to make a point on a body track a \r\n * specified world point. This a soft constraint with a maximum \r\n * force. This allows the constraint to stretch and without \r\n * applying huge forces. \r\n * NOTE: this joint is not documented in the manual because it \r\n * was developed to be used in the testbed. If you want to learn \r\n * how to use the mouse joint, look at the testbed. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2MouseJointDef} def \r\n */\r\nbox2d.b2MouseJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_localAnchorB = new box2d.b2Vec2();\r\n\tthis.m_targetA = new box2d.b2Vec2();\r\n\r\n\tthis.m_impulse = new box2d.b2Vec2();\r\n\r\n\tthis.m_rB = new box2d.b2Vec2();\r\n\tthis.m_localCenterB = new box2d.b2Vec2();\r\n\tthis.m_mass = new box2d.b2Mat22();\r\n\tthis.m_C = new box2d.b2Vec2();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_lalcB = new box2d.b2Vec2();\r\n\tthis.m_K = new box2d.b2Mat22();\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.target.IsValid()); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(def.maxForce) && def.maxForce >= 0); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(def.frequencyHz) && def.frequencyHz >= 0); }\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(def.dampingRatio) && def.dampingRatio >= 0); }\r\n\r\n\tthis.m_targetA.Copy(def.target);\r\n\tbox2d.b2MulTXV(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB);\r\n\r\n\tthis.m_maxForce = def.maxForce;\r\n\tthis.m_impulse.SetZero();\r\n\r\n\tthis.m_frequencyHz = def.frequencyHz;\r\n\tthis.m_dampingRatio = def.dampingRatio;\r\n\r\n\tthis.m_beta = 0;\r\n\tthis.m_gamma = 0;\r\n}\r\n\r\ngoog.inherits(box2d.b2MouseJoint, box2d.b2Joint);\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_localAnchorB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_targetA = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_frequencyHz = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_dampingRatio = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_beta = 0;\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_impulse = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_maxForce = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_gamma = 0;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_rB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_invIB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_mass = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_C = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_lalcB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2MouseJoint.prototype.m_K = null;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} target\r\n */\r\nbox2d.b2MouseJoint.prototype.SetTarget = function (target)\r\n{\r\n\tif (this.m_bodyB.IsAwake() === false)\r\n\t{\r\n\t\tthis.m_bodyB.SetAwake(true);\r\n\t}\r\n\tthis.m_targetA.Copy(target);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2MouseJoint.prototype.GetTarget = function (out)\r\n{\r\n\treturn out.Copy(this.m_targetA);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} maxForce\r\n */\r\nbox2d.b2MouseJoint.prototype.SetMaxForce = function (maxForce)\r\n{\r\n\tthis.m_maxForce = maxForce;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.GetMaxForce = function ()\r\n{\r\n\treturn this.m_maxForce;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} hz\r\n */\r\nbox2d.b2MouseJoint.prototype.SetFrequency = function (hz)\r\n{\r\n\tthis.m_frequencyHz = hz;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.GetFrequency = function ()\r\n{\r\n\treturn this.m_frequencyHz;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} ratio\r\n */\r\nbox2d.b2MouseJoint.prototype.SetDampingRatio = function (ratio)\r\n{\r\n\tthis.m_dampingRatio = ratio;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2MouseJoint.prototype.GetDampingRatio = function ()\r\n{\r\n\treturn this.m_dampingRatio;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2MouseJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\tvar qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n\t/*float32*/ var mass = this.m_bodyB.GetMass();\r\n\r\n\t// Frequency\r\n\t/*float32*/ var omega = 2 * box2d.b2_pi * this.m_frequencyHz;\r\n\r\n\t// Damping coefficient\r\n\t/*float32*/ var d = 2 * mass * this.m_dampingRatio * omega;\r\n\r\n\t// Spring stiffness\r\n\t/*float32*/ var k = mass * (omega * omega);\r\n\r\n\t// magic formulas\r\n\t// gamma has units of inverse mass.\r\n\t// beta has units of inverse time.\r\n\t/*float32*/ var h = data.step.dt;\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(d + h * k > box2d.b2_epsilon); }\r\n\tthis.m_gamma = h * (d + h * k);\r\n\tif (this.m_gamma !== 0)\r\n\t{\r\n\t\tthis.m_gamma = 1 / this.m_gamma;\r\n\t}\r\n\tthis.m_beta = h * k * this.m_gamma;\r\n\r\n\t// Compute the effective mass matrix.\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tbox2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n\t// K    = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]\r\n\t//      = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]\r\n\t//        [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]\r\n\tvar K = this.m_K;\r\n\tK.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;\r\n\tK.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\r\n\tK.ey.x = K.ex.y;\r\n\tK.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;\r\n\r\n\tK.GetInverse(this.m_mass);\r\n\r\n//\tm_C = cB + m_rB - m_targetA;\r\n\tthis.m_C.x = cB.x + this.m_rB.x - this.m_targetA.x;\r\n\tthis.m_C.y = cB.y + this.m_rB.y - this.m_targetA.y;\r\n//\tm_C *= m_beta;\r\n\tthis.m_C.SelfMul(this.m_beta);\r\n\r\n\t// Cheat with some damping\r\n\twB *= 0.98;\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\tthis.m_impulse.SelfMul(data.step.dtRatio);\r\n//\t\tvB += m_invMassB * m_impulse;\r\n\t\tvB.x += this.m_invMassB * this.m_impulse.x;\r\n\t\tvB.y += this.m_invMassB * this.m_impulse.y;\r\n\t\twB += this.m_invIB * box2d.b2CrossVV(this.m_rB, this.m_impulse);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse.SetZero();\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2MouseJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t// Cdot = v + cross(w, r)\r\n//\tb2Vec2 Cdot = vB + b2Cross(wB, m_rB);\r\n\tvar Cdot = box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot);\r\n//\tb2Vec2 impulse = b2Mul(m_mass, -(Cdot + m_C + m_gamma * m_impulse));\r\n\tvar impulse = box2d.b2MulMV(\r\n\t\tthis.m_mass, \r\n\t\tbox2d.b2AddVV(\r\n\t\t\tCdot, \r\n\t\t\tbox2d.b2AddVV(this.m_C, \r\n\t\t\t\tbox2d.b2MulSV(this.m_gamma, this.m_impulse, box2d.b2Vec2.s_t0), \r\n\t\t\t\tbox2d.b2Vec2.s_t0),\r\n\t\t\tbox2d.b2Vec2.s_t0).SelfNeg(),\r\n\t\tbox2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse);\r\n\r\n//\tb2Vec2 oldImpulse = m_impulse;\r\n\tvar oldImpulse = box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_impulse);\r\n//\tm_impulse += impulse;\r\n\tthis.m_impulse.SelfAdd(impulse);\r\n\t/*float32*/ var maxImpulse = data.step.dt * this.m_maxForce;\r\n\tif (this.m_impulse.GetLengthSquared() > maxImpulse * maxImpulse)\r\n\t{\r\n\t\tthis.m_impulse.SelfMul(maxImpulse / this.m_impulse.GetLength());\r\n\t}\r\n//\timpulse = m_impulse - oldImpulse;\r\n\tbox2d.b2SubVV(this.m_impulse, oldImpulse, impulse);\r\n\r\n//\tvB += m_invMassB * impulse;\r\n\tvB.SelfMulAdd(this.m_invMassB, impulse);\r\n\twB += this.m_invIB * box2d.b2CrossVV(this.m_rB, impulse);\r\n\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2();\r\nbox2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2();\r\nbox2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2MouseJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\treturn true;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MouseJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn out.Copy(this.m_targetA);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2MouseJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MouseJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n\treturn box2d.b2MulSV(inv_dt, this.m_impulse, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2MouseJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * The mouse joint does not support dumping. \r\n * @export\r\n */\r\nbox2d.b2MouseJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tbox2d.b2Log(\"Mouse joint dumping is not supported.\\n\");\r\n\t}\r\n}\r\n\r\n/** \r\n * Implement b2Joint::ShiftOrigin \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} newOrigin\r\n */\r\nbox2d.b2MouseJoint.prototype.ShiftOrigin = function (newOrigin)\r\n{\r\n\tthis.m_targetA.SelfSub(newOrigin);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2ConstantForceController');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Controller');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Applies a force every frame \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Controller} \r\n */\r\nbox2d.b2ConstantForceController = function ()\r\n{\r\n\tgoog.base(this); // base class constructor\r\n\r\n\tthis.F = new box2d.b2Vec2(0, 0);\r\n};\r\n\r\ngoog.inherits(box2d.b2ConstantForceController, box2d.b2Controller);\r\n\r\n/** \r\n * The force to apply \r\n * @export \r\n * @type {box2d.b2Vec2} \r\n */\r\nbox2d.b2ConstantAccelController.prototype.F = null;\r\n\r\n/** \r\n * @see box2d.b2Controller::Step \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2TimeStep} step \r\n */\r\nbox2d.b2ConstantForceController.prototype.Step = function (step)\r\n{\r\n\tfor (var i = this.m_bodyList; i; i = i.nextBody)\r\n\t{\r\n\t\tvar body = i.body;\r\n\t\tif (!body.IsAwake())\r\n\t\t\tcontinue;\r\n\t\tbody.ApplyForce(this.F, body.GetWorldCenter());\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2PulleyJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Joint');\r\ngoog.require('box2d.b2Math');\r\n\r\n/**\r\n * @export \r\n * @const \r\n * @type {number} \r\n */\r\nbox2d.b2_minPulleyLength = 2;\r\n\r\n/** \r\n * Pulley joint definition. This requires two ground anchors, \r\n * two dynamic body anchor points, and a pulley ratio. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2PulleyJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_pulleyJoint); // base class constructor\r\n\tthis.collideConnected = true;\r\n\r\n\tthis.groundAnchorA = new box2d.b2Vec2(-1, 1);\r\n\tthis.groundAnchorB = new box2d.b2Vec2(1, 1);\r\n\r\n\tthis.localAnchorA = new box2d.b2Vec2(-1, 0);\r\n\tthis.localAnchorB = new box2d.b2Vec2(1, 0);\r\n}\r\n\r\ngoog.inherits(box2d.b2PulleyJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The first ground anchor in world coordinates. This point \r\n * never moves. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJointDef.prototype.groundAnchorA = null;\r\n\r\n/** \r\n * The second ground anchor in world coordinates. This point \r\n * never moves. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJointDef.prototype.groundAnchorB = null;\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJointDef.prototype.localAnchorA = null;\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJointDef.prototype.localAnchorB = null;\r\n\r\n/** \r\n * The a reference length for the segment attached to bodyA. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJointDef.prototype.lengthA = 0;\r\n\r\n/** \r\n * The a reference length for the segment attached to bodyB. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJointDef.prototype.lengthB = 0;\r\n\r\n/** \r\n * The pulley ratio, used to simulate a block-and-tackle. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJointDef.prototype.ratio = 1;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} bA \r\n * @param {box2d.b2Body} bB \r\n * @param {box2d.b2Vec2} groundA \r\n * @param {box2d.b2Vec2} groundB \r\n * @param {box2d.b2Vec2} anchorA\r\n * @param {box2d.b2Vec2} anchorB\r\n * @param {number} r \r\n */\r\nbox2d.b2PulleyJointDef.prototype.Initialize = function (bA, bB, groundA, groundB, anchorA, anchorB, r)\r\n{\r\n\tthis.bodyA = bA;\r\n\tthis.bodyB = bB;\r\n\tthis.groundAnchorA.Copy(groundA);\r\n\tthis.groundAnchorB.Copy(groundB);\r\n\tthis.bodyA.GetLocalPoint(anchorA, this.localAnchorA);\r\n\tthis.bodyB.GetLocalPoint(anchorB, this.localAnchorB);\r\n\tthis.lengthA = box2d.b2DistanceVV(anchorA, groundA);\r\n\tthis.lengthB = box2d.b2DistanceVV(anchorB, groundB);\r\n\tthis.ratio = r;\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(this.ratio > box2d.b2_epsilon); }\r\n}\r\n\r\n/** \r\n * The pulley joint is connected to two bodies and two fixed ground points. \r\n * The pulley supports a ratio such that: \r\n * lengthA + ratio * lengthB <= constant \r\n * Yes, the force transmitted is scaled by the ratio. \r\n * Warning: the pulley joint can get a bit squirrelly by itself.\r\n * They often work better when combined with prismatic joints. \r\n * You should also cover the the anchor points with static \r\n * shapes to prevent one side from going to zero length. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2PulleyJointDef} def \r\n */\r\nbox2d.b2PulleyJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_groundAnchorA = new box2d.b2Vec2();\r\n\tthis.m_groundAnchorB = new box2d.b2Vec2();\r\n\tthis.m_localAnchorA = new box2d.b2Vec2();\r\n\tthis.m_localAnchorB = new box2d.b2Vec2();\r\n\r\n\tthis.m_uA = new box2d.b2Vec2();\r\n\tthis.m_uB = new box2d.b2Vec2();\r\n\tthis.m_rA = new box2d.b2Vec2();\r\n\tthis.m_rB = new box2d.b2Vec2();\r\n\tthis.m_localCenterA = new box2d.b2Vec2();\r\n\tthis.m_localCenterB = new box2d.b2Vec2();\r\n\r\n\tthis.m_qA = new box2d.b2Rot();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_lalcA = new box2d.b2Vec2();\r\n\tthis.m_lalcB = new box2d.b2Vec2();\r\n\r\n\tthis.m_groundAnchorA.Copy(def.groundAnchorA);\r\n\tthis.m_groundAnchorB.Copy(def.groundAnchorB);\r\n\tthis.m_localAnchorA.Copy(def.localAnchorA);\r\n\tthis.m_localAnchorB.Copy(def.localAnchorB);\r\n\r\n\tthis.m_lengthA = def.lengthA;\r\n\tthis.m_lengthB = def.lengthB;\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.ratio !== 0); }\r\n\tthis.m_ratio = def.ratio;\r\n\r\n\tthis.m_constant = def.lengthA + this.m_ratio * def.lengthB;\r\n\r\n\tthis.m_impulse = 0;\r\n}\r\n\r\ngoog.inherits(box2d.b2PulleyJoint, box2d.b2Joint);\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_groundAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_groundAnchorB = null;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_lengthA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_lengthB = 0;\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_localAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_localAnchorB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_constant = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_ratio = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_impulse = 0;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_uA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_uB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_rB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_invIB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_mass = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_lalcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2PulleyJoint.prototype.m_lalcB = null;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2PulleyJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassA = this.m_bodyA.m_invMass;\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIA = this.m_bodyA.m_invI;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n//\tbox2d.b2Rot qA(aA), qB(aB);\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n//\tm_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tbox2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tm_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tbox2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n\t// Get the pulley axes.\r\n//\tm_uA = cA + m_rA - m_groundAnchorA;\r\n\tthis.m_uA.Copy(cA).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA);\r\n//\tm_uB = cB + m_rB - m_groundAnchorB;\r\n\tthis.m_uB.Copy(cB).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);\r\n\r\n\t/*float32*/ var lengthA = this.m_uA.GetLength();\r\n\t/*float32*/ var lengthB = this.m_uB.GetLength();\r\n\r\n\tif (lengthA > 10 * box2d.b2_linearSlop)\r\n\t{\r\n\t\tthis.m_uA.SelfMul(1 / lengthA);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_uA.SetZero();\r\n\t}\r\n\r\n\tif (lengthB > 10 * box2d.b2_linearSlop)\r\n\t{\r\n\t\tthis.m_uB.SelfMul(1 / lengthB);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_uB.SetZero();\r\n\t}\r\n\r\n\t// Compute effective mass.\r\n\t/*float32*/ var ruA = box2d.b2CrossVV(this.m_rA, this.m_uA);\r\n\t/*float32*/ var ruB = box2d.b2CrossVV(this.m_rB, this.m_uB);\r\n\r\n\t/*float32*/ var mA = this.m_invMassA + this.m_invIA * ruA * ruA;\r\n\t/*float32*/ var mB = this.m_invMassB + this.m_invIB * ruB * ruB;\r\n\r\n\tthis.m_mass = mA + this.m_ratio * this.m_ratio * mB;\r\n\r\n\tif (this.m_mass > 0)\r\n\t{\r\n\t\tthis.m_mass = 1 / this.m_mass;\r\n\t}\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\t// Scale impulses to support variable time steps.\r\n\t\tthis.m_impulse *= data.step.dtRatio;\r\n\r\n\t\t// Warm starting.\r\n//\t\tbox2d.b2Vec2 PA = -(m_impulse) * m_uA;\r\n\t\tvar PA = box2d.b2MulSV(-(this.m_impulse), this.m_uA, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA);\r\n//\t\tbox2d.b2Vec2 PB = (-m_ratio * m_impulse) * m_uB;\r\n\t\tvar PB = box2d.b2MulSV((-this.m_ratio * this.m_impulse), this.m_uB, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB);\r\n\r\n//\t\tvA += m_invMassA * PA;\r\n\t\tvA.SelfMulAdd(this.m_invMassA, PA);\r\n\t\twA += this.m_invIA * box2d.b2CrossVV(this.m_rA, PA);\r\n//\t\tvB += m_invMassB * PB;\r\n\t\tvB.SelfMulAdd(this.m_invMassB, PB);\r\n\t\twB += this.m_invIB * box2d.b2CrossVV(this.m_rB, PB);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse = 0;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA = new box2d.b2Vec2();\r\nbox2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2PulleyJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n//\tb2Vec2 vpA = vA + b2Cross(wA, m_rA);\r\n\tvar vpA = box2d.b2AddVCrossSV(vA, wA, this.m_rA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA);\r\n//\tb2Vec2 vpB = vB + b2Cross(wB, m_rB);\r\n\tvar vpB = box2d.b2AddVCrossSV(vB, wB, this.m_rB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB);\r\n\r\n\t/*float32*/ var Cdot = -box2d.b2DotVV(this.m_uA, vpA) - this.m_ratio * box2d.b2DotVV(this.m_uB, vpB);\r\n\t/*float32*/ var impulse = -this.m_mass * Cdot;\r\n\tthis.m_impulse += impulse;\r\n\r\n//\tb2Vec2 PA = -impulse * m_uA;\r\n\tvar PA = box2d.b2MulSV(-impulse, this.m_uA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA);\r\n//\tb2Vec2 PB = -m_ratio * impulse * m_uB;\r\n\tvar PB = box2d.b2MulSV(-this.m_ratio * impulse, this.m_uB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB);\r\n//\tvA += m_invMassA * PA;\r\n\tvA.SelfMulAdd(this.m_invMassA, PA);\r\n\twA += this.m_invIA * box2d.b2CrossVV(this.m_rA, PA);\r\n//\tvB += m_invMassB * PB;\r\n\tvB.SelfMulAdd(this.m_invMassB, PB);\r\n\twB += this.m_invIB * box2d.b2CrossVV(this.m_rB, PB);\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2();\r\nbox2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2();\r\nbox2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA = new box2d.b2Vec2();\r\nbox2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2PulleyJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\r\n//\tbox2d.b2Rot qA(aA), qB(aB);\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n//\tb2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tb2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n\t// Get the pulley axes.\r\n//\tb2Vec2 uA = cA + rA - m_groundAnchorA;\r\n\tvar uA = this.m_uA.Copy(cA).SelfAdd(rA).SelfSub(this.m_groundAnchorA);\r\n//\tb2Vec2 uB = cB + rB - m_groundAnchorB;\r\n\tvar uB = this.m_uB.Copy(cB).SelfAdd(rB).SelfSub(this.m_groundAnchorB);\r\n\r\n\t/*float32*/ var lengthA = uA.GetLength();\r\n\t/*float32*/ var lengthB = uB.GetLength();\r\n\r\n\tif (lengthA > 10 * box2d.b2_linearSlop)\r\n\t{\r\n\t\tuA.SelfMul(1 / lengthA);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tuA.SetZero();\r\n\t}\r\n\r\n\tif (lengthB > 10 * box2d.b2_linearSlop)\r\n\t{\r\n\t\tuB.SelfMul(1 / lengthB);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tuB.SetZero();\r\n\t}\r\n\r\n\t// Compute effective mass.\r\n\t/*float32*/ var ruA = box2d.b2CrossVV(rA, uA);\r\n\t/*float32*/ var ruB = box2d.b2CrossVV(rB, uB);\r\n\r\n\t/*float32*/ var mA = this.m_invMassA + this.m_invIA * ruA * ruA;\r\n\t/*float32*/ var mB = this.m_invMassB + this.m_invIB * ruB * ruB;\r\n\r\n\t/*float32*/ var mass = mA + this.m_ratio * this.m_ratio * mB;\r\n\r\n\tif (mass > 0)\r\n\t{\r\n\t\tmass = 1 / mass;\r\n\t}\r\n\r\n\t/*float32*/ var C = this.m_constant - lengthA - this.m_ratio * lengthB;\r\n\t/*float32*/ var linearError = box2d.b2Abs(C);\r\n\r\n\t/*float32*/ var impulse = -mass * C;\r\n\r\n//\tb2Vec2 PA = -impulse * uA;\r\n\tvar PA = box2d.b2MulSV(-impulse, uA, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA);\r\n//\tb2Vec2 PB = -m_ratio * impulse * uB;\r\n\tvar PB = box2d.b2MulSV(-this.m_ratio * impulse, uB, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB);\r\n\r\n//\tcA += m_invMassA * PA;\r\n\tcA.SelfMulAdd(this.m_invMassA, PA);\r\n\taA += this.m_invIA * box2d.b2CrossVV(rA, PA);\r\n//\tcB += m_invMassB * PB;\r\n\tcB.SelfMulAdd(this.m_invMassB, PB);\r\n\taB += this.m_invIB * box2d.b2CrossVV(rB, PB);\r\n\r\n//\tdata.positions[this.m_indexA].c = cA;\r\n\tdata.positions[this.m_indexA].a = aA;\r\n//\tdata.positions[this.m_indexB].c = cB;\r\n\tdata.positions[this.m_indexB].a = aB;\r\n\r\n\treturn linearError < box2d.b2_linearSlop;\r\n}\r\nbox2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA = new box2d.b2Vec2();\r\nbox2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PulleyJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PulleyJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2PulleyJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n//\tb2Vec2 P = m_impulse * m_uB;\r\n//\treturn inv_dt * P;\r\n\treturn out.SetXY(inv_dt * this.m_impulse * this.m_uB.x, inv_dt * this.m_impulse * this.m_uB.y);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn 0;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PulleyJoint.prototype.GetGroundAnchorA = function (out)\r\n{\r\n\treturn out.Copy(this.m_groundAnchorA);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2PulleyJoint.prototype.GetGroundAnchorB = function (out)\r\n{\r\n\treturn out.Copy(this.m_groundAnchorB);\r\n}\r\n\r\n/** \r\n * Get the current length of the segment attached to bodyA. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.GetLengthA = function ()\r\n{\r\n\treturn this.m_lengthA;\r\n}\r\n\r\n/** \r\n * Get the current length of the segment attached to bodyB. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.GetLengthB = function ()\r\n{\r\n\treturn this.m_lengthB;\r\n}\r\n\r\n/** \r\n * Get the pulley ratio. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.GetRatio = function ()\r\n{\r\n\treturn this.m_ratio;\r\n}\r\n\r\n/** \r\n * Get the current length of the segment attached to bodyA. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.GetCurrentLengthA = function ()\r\n{\r\n//\tb2Vec2 p = m_bodyA->GetWorldPoint(m_localAnchorA);\r\n//\tb2Vec2 s = m_groundAnchorA;\r\n//\tb2Vec2 d = p - s;\r\n//\treturn d.Length();\r\n\tvar p = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p);\r\n\tvar s = this.m_groundAnchorA;\r\n\treturn box2d.b2DistanceVV(p, s);\r\n}\r\nbox2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p = new box2d.b2Vec2();\r\n\r\n/** \r\n * Get the current length of the segment attached to bodyB. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2PulleyJoint.prototype.GetCurrentLengthB = function ()\r\n{\r\n//\tb2Vec2 p = m_bodyB->GetWorldPoint(m_localAnchorB);\r\n//\tb2Vec2 s = m_groundAnchorB;\r\n//\tb2Vec2 d = p - s;\r\n//\treturn d.Length();\r\n\tvar p = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p);\r\n\tvar s = this.m_groundAnchorB;\r\n\treturn box2d.b2DistanceVV(p, s);\r\n}\r\nbox2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p = new box2d.b2Vec2();\r\n\r\n/** \r\n * Dump joint to dmLog \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2PulleyJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\t\r\n\t\tbox2d.b2Log(\"  /*box2d.b2PulleyJointDef*/ var jd = new box2d.b2PulleyJointDef();\\n\");\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.groundAnchorA.SetXY(%.15f, %.15f);\\n\", this.m_groundAnchorA.x, this.m_groundAnchorA.y);\r\n\t\tbox2d.b2Log(\"  jd.groundAnchorB.SetXY(%.15f, %.15f);\\n\", this.m_groundAnchorB.x, this.m_groundAnchorB.y);\r\n\t\tbox2d.b2Log(\"  jd.localAnchorA.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n\t\tbox2d.b2Log(\"  jd.localAnchorB.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n\t\tbox2d.b2Log(\"  jd.lengthA = %.15f;\\n\", this.m_lengthA);\r\n\t\tbox2d.b2Log(\"  jd.lengthB = %.15f;\\n\", this.m_lengthB);\r\n\t\tbox2d.b2Log(\"  jd.ratio = %.15f;\\n\", this.m_ratio);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/** \r\n * Implement b2Joint::ShiftOrigin \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} newOrigin\r\n */\r\nbox2d.b2PulleyJoint.prototype.ShiftOrigin = function (newOrigin)\r\n{\r\n\tthis.m_groundAnchorA.SelfSub(newOrigin);\r\n\tthis.m_groundAnchorB.SelfSub(newOrigin);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2CircleShape');\r\n\r\ngoog.require('box2d.b2Shape');\r\n\r\n/** \r\n * A circle shape. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Shape} \r\n * @param {number=} radius \r\n */\r\nbox2d.b2CircleShape = function (radius)\r\n{\r\n\tgoog.base(this, box2d.b2ShapeType.e_circleShape, radius || 0); // base class constructor\r\n\r\n\tthis.m_p = new box2d.b2Vec2();\r\n}\r\n\r\ngoog.inherits(box2d.b2CircleShape, box2d.b2Shape);\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2CircleShape.prototype.m_p = null;\r\n\r\n/** \r\n * Implement box2d.b2Shape. \r\n * @export \r\n * @return {box2d.b2Shape}\r\n */\r\nbox2d.b2CircleShape.prototype.Clone = function ()\r\n{\r\n\treturn new box2d.b2CircleShape().Copy(this);\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2Shape} \r\n * @param {box2d.b2Shape} other\r\n */\r\nbox2d.b2CircleShape.prototype.Copy = function (other)\r\n{\r\n\tgoog.base(this, 'Copy', other);\r\n\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(other instanceof box2d.b2CircleShape); }\r\n\r\n\tthis.m_p.Copy(other.m_p);\r\n\treturn this;\r\n}\r\n\r\n/** \r\n * Implement box2d.b2Shape. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2CircleShape.prototype.GetChildCount = function ()\r\n{\r\n\treturn 1;\r\n}\r\n\r\n/** \r\n * Implement box2d.b2Shape. \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2Transform} transform \r\n * @param {box2d.b2Vec2} p \r\n */\r\nbox2d.b2CircleShape.prototype.TestPoint = function (transform, p)\r\n{\r\n\tvar center = box2d.b2MulXV(transform, this.m_p, box2d.b2CircleShape.prototype.TestPoint.s_center);\r\n\tvar d = box2d.b2SubVV(p, center, box2d.b2CircleShape.prototype.TestPoint.s_d);\r\n\treturn box2d.b2DotVV(d, d) <= box2d.b2Sq(this.m_radius);\r\n}\r\nbox2d.b2CircleShape.prototype.TestPoint.s_center = new box2d.b2Vec2();\r\nbox2d.b2CircleShape.prototype.TestPoint.s_d = new box2d.b2Vec2();\r\n\r\n/** \r\n * Implement box2d.b2Shape. \r\n * Collision Detection in Interactive 3D Environments by Gino \r\n * van den Bergen From Section 3.1.2 \r\n * x = s + a * r \r\n * norm(x) = radius \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2RayCastOutput} output \r\n * @param {box2d.b2RayCastInput} input \r\n * @param {box2d.b2Transform} transform \r\n * @param {number} childIndex \r\n */\r\nbox2d.b2CircleShape.prototype.RayCast = function (output, input, transform, childIndex)\r\n{\r\n\tvar position = box2d.b2MulXV(transform, this.m_p, box2d.b2CircleShape.prototype.RayCast.s_position);\r\n\tvar s = box2d.b2SubVV(input.p1, position, box2d.b2CircleShape.prototype.RayCast.s_s);\r\n\tvar b = box2d.b2DotVV(s, s) - box2d.b2Sq(this.m_radius);\r\n\r\n\t// Solve quadratic equation.\r\n\tvar r = box2d.b2SubVV(input.p2, input.p1, box2d.b2CircleShape.prototype.RayCast.s_r);\r\n\tvar c = box2d.b2DotVV(s, r);\r\n\tvar rr = box2d.b2DotVV(r, r);\r\n\tvar sigma = c * c - rr * b;\r\n\r\n\t// Check for negative discriminant and short segment.\r\n\tif (sigma < 0 || rr < box2d.b2_epsilon)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Find the point of intersection of the line with the circle.\r\n\tvar a = (-(c + box2d.b2Sqrt(sigma)));\r\n\r\n\t// Is the intersection point on the segment?\r\n\tif (0 <= a && a <= input.maxFraction * rr)\r\n\t{\r\n\t\ta /= rr;\r\n\t\toutput.fraction = a;\r\n\t\tbox2d.b2AddVMulSV(s, a, r, output.normal).SelfNormalize();\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbox2d.b2CircleShape.prototype.RayCast.s_position = new box2d.b2Vec2();\r\nbox2d.b2CircleShape.prototype.RayCast.s_s = new box2d.b2Vec2();\r\nbox2d.b2CircleShape.prototype.RayCast.s_r = new box2d.b2Vec2();\r\n\r\n/** \r\n * @see box2d.b2Shape::ComputeAABB \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2AABB} aabb \r\n * @param {box2d.b2Transform} transform \r\n * @param {number} childIndex \r\n */\r\nbox2d.b2CircleShape.prototype.ComputeAABB = function (aabb, transform, childIndex)\r\n{\r\n\tvar p = box2d.b2MulXV(transform, this.m_p, box2d.b2CircleShape.prototype.ComputeAABB.s_p);\r\n\taabb.lowerBound.SetXY(p.x - this.m_radius, p.y - this.m_radius);\r\n\taabb.upperBound.SetXY(p.x + this.m_radius, p.y + this.m_radius);\r\n}\r\nbox2d.b2CircleShape.prototype.ComputeAABB.s_p = new box2d.b2Vec2();\r\n\r\n/** \r\n * @see box2d.b2Shape::ComputeMass \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2MassData} massData \r\n * @param {number} density \r\n */\r\nbox2d.b2CircleShape.prototype.ComputeMass = function (massData, density)\r\n{\r\n\tvar radius_sq = box2d.b2Sq(this.m_radius);\r\n\tmassData.mass = density * box2d.b2_pi * radius_sq;\r\n\tmassData.center.Copy(this.m_p);\r\n\r\n\t// inertia about the local origin\r\n\tmassData.I = massData.mass * (0.5 * radius_sq + box2d.b2DotVV(this.m_p, this.m_p));\r\n}\r\n\r\n/**\r\n * @return {void} \r\n * @param {box2d.b2DistanceProxy} proxy \r\n * @param {number} index \r\n */\r\nbox2d.b2CircleShape.prototype.SetupDistanceProxy = function (proxy, index)\r\n{\r\n\tproxy.m_vertices = new Array(1, true);\r\n\tproxy.m_vertices[0] = this.m_p;\r\n\tproxy.m_count = 1;\r\n\tproxy.m_radius = this.m_radius;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n * @param {box2d.b2Vec2} normal\r\n * @param {number} offset\r\n * @param {box2d.b2Transform} xf\r\n * @param {box2d.b2Vec2} c\r\n */\r\nbox2d.b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)\r\n{\r\n\t/** @type {box2d.b2Vec2} */ var p = box2d.b2MulXV(xf, this.m_p, new box2d.b2Vec2());\r\n\t/** @type {number} */ var l = (-(box2d.b2DotVV(normal, p) - offset));\r\n\r\n\tif (l < (-this.m_radius) + box2d.b2_epsilon)\r\n\t{\r\n\t\t//Completely dry\r\n\t\treturn 0;\r\n\t}\r\n\tif (l > this.m_radius)\r\n\t{\r\n\t\t//Completely wet\r\n\t\tc.Copy(p);\r\n\t\treturn box2d.b2_pi * this.m_radius * this.m_radius;\r\n\t}\r\n\r\n\t//Magic\r\n\t/** @type {number} */ var r2 = this.m_radius * this.m_radius;\r\n\t/** @type {number} */ var l2 = l * l;\r\n\t/** @type {number} */ var area = r2 * (box2d.b2Asin(l / this.m_radius) + box2d.b2_pi / 2) + l * box2d.b2Sqrt(r2 - l2);\r\n\t/** @type {number} */ var com = (-2 / 3 * box2d.b2Pow(r2 - l2, 1.5) / area);\r\n\r\n\tc.x = p.x + normal.x * com;\r\n\tc.y = p.y + normal.y * com;\r\n\r\n\treturn area;\r\n}\r\n\r\n/** \r\n * Dump this shape to the log file. \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2CircleShape.prototype.Dump = function ()\r\n{\r\n\tbox2d.b2Log(\"    /*box2d.b2CircleShape*/ var shape = new box2d.b2CircleShape();\\n\");\r\n\tbox2d.b2Log(\"    shape.m_radius = %.15f;\\n\", this.m_radius);\r\n\tbox2d.b2Log(\"    shape.m_p.SetXY(%.15f, %.15f);\\n\", this.m_p.x, this.m_p.y);\r\n}\r\n\r\n/*\r\n* Copyright (c) 2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2Rope');\r\n\r\ngoog.require('box2d.b2Math');\r\ngoog.require('box2d.b2Draw');\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2RopeDef = function ()\r\n{\r\n\tthis.vertices = new Array();\r\n\tthis.masses = new Array();\r\n\tthis.gravity = new box2d.b2Vec2();\r\n};\r\n\r\n/*box2d.b2Vec2[]*/ box2d.b2RopeDef.prototype.vertices = null;\r\n\r\n/*int32*/ box2d.b2RopeDef.prototype.count = 0;\r\n\r\n/*float32[]*/ box2d.b2RopeDef.prototype.masses = null;\r\n\r\n/*box2d.b2Vec2*/ box2d.b2RopeDef.prototype.gravity = null;\r\n\r\n/*float32*/ box2d.b2RopeDef.prototype.damping = 0.1;\r\n\r\n/**\r\n * Stretching stiffness\r\n */\r\n/*float32*/ box2d.b2RopeDef.prototype.k2 = 0.9;\r\n\r\n/**\r\n * Bending stiffness. Values above 0.5 can make the simulation \r\n * blow up. \r\n */\r\n/*float32*/ box2d.b2RopeDef.prototype.k3 = 0.1;\r\n\r\n/**\r\n * @export \r\n * @constructor\r\n */\r\nbox2d.b2Rope = function ()\r\n{\r\n\tthis.m_gravity = new box2d.b2Vec2();\r\n};\r\n\r\n/*int32*/ box2d.b2Rope.prototype.m_count = 0;\r\n/*box2d.b2Vec2[]*/ box2d.b2Rope.prototype.m_ps = null;\r\n/*box2d.b2Vec2[]*/ box2d.b2Rope.prototype.m_p0s = null;\r\n/*box2d.b2Vec2[]*/ box2d.b2Rope.prototype.m_vs = null;\r\n\r\n/*float32[]*/ box2d.b2Rope.prototype.m_ims = null;\r\n\r\n/*float32[]*/ box2d.b2Rope.prototype.m_Ls = null;\r\n/*float32[]*/ box2d.b2Rope.prototype.m_as = null;\r\n\r\n/*box2d.b2Vec2*/ box2d.b2Rope.prototype.m_gravity = null;\r\n/*float32*/ box2d.b2Rope.prototype.m_damping = 0;\r\n\r\n/*float32*/ box2d.b2Rope.prototype.m_k2 = 1;\r\n/*float32*/ box2d.b2Rope.prototype.m_k3 = 0.1;\r\n\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2Rope.prototype.GetVertexCount = function ()\r\n{\r\n\treturn this.m_count;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {Array.<box2d.b2Vec2>}\r\n */\r\nbox2d.b2Rope.prototype.GetVertices = function ()\r\n{\r\n\treturn this.m_ps;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2RopeDef} def\r\n */\r\nbox2d.b2Rope.prototype.Initialize = function (def)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(def.count >= 3); }\r\n\tthis.m_count = def.count;\r\n//\tthis.m_ps = (box2d.b2Vec2*)b2Alloc(this.m_count * sizeof(box2d.b2Vec2));\r\n\tthis.m_ps = box2d.b2Vec2.MakeArray(this.m_count);\r\n//\tthis.m_p0s = (box2d.b2Vec2*)b2Alloc(this.m_count * sizeof(box2d.b2Vec2));\r\n\tthis.m_p0s = box2d.b2Vec2.MakeArray(this.m_count);\r\n//\tthis.m_vs = (box2d.b2Vec2*)b2Alloc(this.m_count * sizeof(box2d.b2Vec2));\r\n\tthis.m_vs = box2d.b2Vec2.MakeArray(this.m_count);\r\n//\tthis.m_ims = (float32*)b2Alloc(this.m_count * sizeof(float32));\r\n\tthis.m_ims = box2d.b2MakeNumberArray(this.m_count);\r\n\r\n\tfor (/*int32*/ var i = 0; i < this.m_count; ++i)\r\n\t{\r\n\t\tthis.m_ps[i].Copy(def.vertices[i]);\r\n\t\tthis.m_p0s[i].Copy(def.vertices[i]);\r\n\t\tthis.m_vs[i].SetZero();\r\n\r\n\t\t/*float32*/ var m = def.masses[i];\r\n\t\tif (m > 0)\r\n\t\t{\r\n\t\t\tthis.m_ims[i] = 1 / m;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_ims[i] = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/*int32*/ var count2 = this.m_count - 1;\r\n\t/*int32*/ var count3 = this.m_count - 2;\r\n//\tthis.m_Ls = (float32*)be2Alloc(count2 * sizeof(float32));\r\n\tthis.m_Ls = box2d.b2MakeNumberArray(count2);\r\n//\tthis.m_as = (float32*)b2Alloc(count3 * sizeof(float32));\r\n\tthis.m_as = box2d.b2MakeNumberArray(count3);\r\n\r\n\tfor (/*int32*/ var i = 0; i < count2; ++i)\r\n\t{\r\n\t\t/*box2d.b2Vec2&*/ var p1 = this.m_ps[i];\r\n\t\t/*box2d.b2Vec2&*/ var p2 = this.m_ps[i+1];\r\n\t\tthis.m_Ls[i] = box2d.b2DistanceVV(p1, p2);\r\n\t}\r\n\r\n\tfor (/*int32*/ var i = 0; i < count3; ++i)\r\n\t{\r\n\t\t/*box2d.b2Vec2&*/ var p1 = this.m_ps[i];\r\n\t\t/*box2d.b2Vec2&*/ var p2 = this.m_ps[i + 1];\r\n\t\t/*box2d.b2Vec2&*/ var p3 = this.m_ps[i + 2];\r\n\r\n\t\t/*box2d.b2Vec2*/ var d1 = box2d.b2SubVV(p2, p1, box2d.b2Vec2.s_t0);\r\n\t\t/*box2d.b2Vec2*/ var d2 = box2d.b2SubVV(p3, p2, box2d.b2Vec2.s_t1);\r\n\r\n\t\t/*float32*/ var a = box2d.b2CrossVV(d1, d2);\r\n\t\t/*float32*/ var b = box2d.b2DotVV(d1, d2);\r\n\r\n\t\tthis.m_as[i] = box2d.b2Atan2(a, b);\r\n\t}\r\n\r\n\tthis.m_gravity.Copy(def.gravity);\r\n\tthis.m_damping = def.damping;\r\n\tthis.m_k2 = def.k2;\r\n\tthis.m_k3 = def.k3;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} h \r\n * @param {number} iterations \r\n */\r\nbox2d.b2Rope.prototype.Step = function (/*float32*/ h, /*int32*/ iterations)\r\n{\r\n\tif (h === 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t/*float32*/ var d = Math.exp(- h * this.m_damping);\r\n\r\n\tfor (/*int32*/ var i = 0; i < this.m_count; ++i)\r\n\t{\r\n\t\tthis.m_p0s[i].Copy(this.m_ps[i]);\r\n\t\tif (this.m_ims[i] > 0)\r\n\t\t{\r\n\t\t\tthis.m_vs[i].SelfMulAdd(h, this.m_gravity);\r\n\t\t}\r\n\t\tthis.m_vs[i].SelfMul(d);\r\n\t\tthis.m_ps[i].SelfMulAdd(h, this.m_vs[i]);\r\n\r\n\t}\r\n\r\n\tfor (/*int32*/ var i = 0; i < iterations; ++i)\r\n\t{\r\n\t\tthis.SolveC2();\r\n\t\tthis.SolveC3();\r\n\t\tthis.SolveC2();\r\n\t}\r\n\r\n\t/*float32*/ var inv_h = 1 / h;\r\n\tfor (/*int32*/ var i = 0; i < this.m_count; ++i)\r\n\t{\r\n\t\tbox2d.b2MulSV(inv_h, box2d.b2SubVV(this.m_ps[i], this.m_p0s[i], box2d.b2Vec2.s_t0), this.m_vs[i]);\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2Rope.prototype.SolveC2 = function ()\r\n{\r\n\t/*int32*/ var count2 = this.m_count - 1;\r\n\r\n\tfor (/*int32*/ var i = 0; i < count2; ++i)\r\n\t{\r\n\t\t/*box2d.b2Vec2&*/ var p1 = this.m_ps[i];\r\n\t\t/*box2d.b2Vec2&*/ var p2 = this.m_ps[i + 1];\r\n\r\n\t\t/*box2d.b2Vec2*/ var d = box2d.b2SubVV(p2, p1, box2d.b2Rope.s_d);\r\n\t\t/*float32*/ var L = d.Normalize();\r\n\r\n\t\t/*float32*/ var im1 = this.m_ims[i];\r\n\t\t/*float32*/ var im2 = this.m_ims[i + 1];\r\n\r\n\t\tif (im1 + im2 === 0)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/*float32*/ var s1 = im1 / (im1 + im2);\r\n\t\t/*float32*/ var s2 = im2 / (im1 + im2);\r\n\r\n\t\tp1.SelfMulSub(this.m_k2 * s1 * (this.m_Ls[i] - L), d);\r\n\t\tp2.SelfMulAdd(this.m_k2 * s2 * (this.m_Ls[i] - L), d);\r\n\r\n//\t\tthis.m_ps[i] = p1;\r\n//\t\tthis.m_ps[i + 1] = p2;\r\n\t}\r\n}\r\nbox2d.b2Rope.s_d = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {void}\r\n * @param {number} angle\r\n */\r\nbox2d.b2Rope.prototype.SetAngleRadians = function (angle)\r\n{\r\n\t/*int32*/ var count3 = this.m_count - 2;\r\n\tfor (/*int32*/ var i = 0; i < count3; ++i)\r\n\t{\r\n\t\tthis.m_as[i] = angle;\r\n\t}\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2Rope.prototype.SolveC3 = function ()\r\n{\r\n\t/*int32*/ var count3 = this.m_count - 2;\r\n\r\n\tfor (/*int32*/ var i = 0; i < count3; ++i)\r\n\t{\r\n\t\t/*box2d.b2Vec2&*/ var p1 = this.m_ps[i];\r\n\t\t/*box2d.b2Vec2&*/ var p2 = this.m_ps[i + 1];\r\n\t\t/*box2d.b2Vec2&*/ var p3 = this.m_ps[i + 2];\r\n\r\n\t\t/*float32*/ var m1 = this.m_ims[i];\r\n\t\t/*float32*/ var m2 = this.m_ims[i + 1];\r\n\t\t/*float32*/ var m3 = this.m_ims[i + 2];\r\n\r\n\t\t/*box2d.b2Vec2*/ var d1 = box2d.b2SubVV(p2, p1, box2d.b2Rope.s_d1);\r\n\t\t/*box2d.b2Vec2*/ var d2 = box2d.b2SubVV(p3, p2, box2d.b2Rope.s_d2);\r\n\r\n\t\t/*float32*/ var L1sqr = d1.GetLengthSquared();\r\n\t\t/*float32*/ var L2sqr = d2.GetLengthSquared();\r\n\r\n\t\tif (L1sqr * L2sqr === 0)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/*float32*/ var a = box2d.b2CrossVV(d1, d2);\r\n\t\t/*float32*/ var b = box2d.b2DotVV(d1, d2);\r\n\r\n\t\t/*float32*/ var angle = box2d.b2Atan2(a, b);\r\n\r\n\t\t/*box2d.b2Vec2*/ var Jd1 = box2d.b2MulSV((-1 / L1sqr), d1.SelfSkew(), box2d.b2Rope.s_Jd1);\r\n\t\t/*box2d.b2Vec2*/ var Jd2 = box2d.b2MulSV(( 1 / L2sqr), d2.SelfSkew(), box2d.b2Rope.s_Jd2);\r\n\r\n\t\t/*box2d.b2Vec2*/ var J1 = box2d.b2NegV(Jd1, box2d.b2Rope.s_J1);\r\n\t\t/*box2d.b2Vec2*/ var J2 = box2d.b2SubVV(Jd1, Jd2, box2d.b2Rope.s_J2);\r\n\t\t/*box2d.b2Vec2*/ var J3 = Jd2;\r\n\r\n\t\t/*float32*/ var mass = m1 * box2d.b2DotVV(J1, J1) + m2 * box2d.b2DotVV(J2, J2) + m3 * box2d.b2DotVV(J3, J3);\r\n\t\tif (mass === 0)\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tmass = 1 / mass;\r\n\r\n\t\t/*float32*/ var C = angle - this.m_as[i];\r\n\r\n\t\twhile (C > box2d.b2_pi)\r\n\t\t{\r\n\t\t\tangle -= 2 * box2d.b2_pi;\r\n\t\t\tC = angle - this.m_as[i];\r\n\t\t}\r\n\r\n\t\twhile (C < -box2d.b2_pi)\r\n\t\t{\r\n\t\t\tangle += 2 * box2d.b2_pi;\r\n\t\t\tC = angle - this.m_as[i];\r\n\t\t}\r\n\r\n\t\t/*float32*/ var impulse = - this.m_k3 * mass * C;\r\n\r\n\t\tp1.SelfMulAdd((m1 * impulse), J1);\r\n\t\tp2.SelfMulAdd((m2 * impulse), J2);\r\n\t\tp3.SelfMulAdd((m3 * impulse), J3);\r\n\r\n//\t\tthis.m_ps[i] = p1;\r\n//\t\tthis.m_ps[i + 1] = p2;\r\n//\t\tthis.m_ps[i + 2] = p3;\r\n\t}\r\n}\r\nbox2d.b2Rope.s_d1 = new box2d.b2Vec2();\r\nbox2d.b2Rope.s_d2 = new box2d.b2Vec2();\r\nbox2d.b2Rope.s_Jd1 = new box2d.b2Vec2();\r\nbox2d.b2Rope.s_Jd2 = new box2d.b2Vec2();\r\nbox2d.b2Rope.s_J1 = new box2d.b2Vec2();\r\nbox2d.b2Rope.s_J2 = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {void}\r\n * @param {box2d.b2Draw} draw\r\n */\r\nbox2d.b2Rope.prototype.Draw = function (draw)\r\n{\r\n\t/*box2d.b2Color*/ var c = new box2d.b2Color(0.4, 0.5, 0.7);\r\n\r\n\tfor (/*int32*/ var i = 0; i < this.m_count - 1; ++i)\r\n\t{\r\n\t\tdraw.DrawSegment(this.m_ps[i], this.m_ps[i+1], c);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2WheelJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Wheel joint definition. This requires defining a line of \r\n * motion using an axis and an anchor point. The definition uses \r\n * local anchor points and a local axis so that the initial \r\n * configuration can violate the constraint slightly. The joint \r\n * translation is zero when the local anchor points coincide in \r\n * world space. Using local anchors and a local axis helps when \r\n * saving and loading a game. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2WheelJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_wheelJoint); // base class constructor\r\n\r\n\tthis.localAnchorA = new box2d.b2Vec2(0, 0);\r\n\tthis.localAnchorB = new box2d.b2Vec2(0, 0);\r\n\tthis.localAxisA = new box2d.b2Vec2(1, 0);\r\n}\r\n\r\ngoog.inherits(box2d.b2WheelJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJointDef.prototype.localAnchorA = null;\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJointDef.prototype.localAnchorB = null;\r\n\r\n/** \r\n * The local translation axis in bodyA. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJointDef.prototype.localAxisA = null;\r\n\r\n/** \r\n * Enable/disable the joint motor. \r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2WheelJointDef.prototype.enableMotor = false;\r\n\r\n/** \r\n * The maximum motor torque, usually in N-m. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJointDef.prototype.maxMotorTorque = 0;\r\n\r\n/** \r\n * The desired motor speed in radians per second. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJointDef.prototype.motorSpeed = 0;\r\n\r\n/** \r\n * Suspension frequency, zero indicates no suspension \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJointDef.prototype.frequencyHz = 2;\r\n\r\n/** \r\n * Suspension damping ratio, one indicates critical damping \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJointDef.prototype.dampingRatio = 0.7;\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} bA \r\n * @param {box2d.b2Body} bB \r\n * @param {box2d.b2Vec2} anchor \r\n * @param {box2d.b2Vec2} axis \r\n */\r\nbox2d.b2WheelJointDef.prototype.Initialize = function (bA, bB, anchor, axis)\r\n{\r\n\tthis.bodyA = bA;\r\n\tthis.bodyB = bB;\r\n\tthis.bodyA.GetLocalPoint(anchor, this.localAnchorA);\r\n\tthis.bodyB.GetLocalPoint(anchor, this.localAnchorB);\r\n\tthis.bodyA.GetLocalVector(axis, this.localAxisA);\r\n}\r\n\r\n/** \r\n * A wheel joint. This joint provides two degrees of freedom: \r\n * translation along an axis fixed in bodyA and rotation in the \r\n * plane. You can use a joint limit to restrict the range of \r\n * motion and a joint motor to drive the rotation or to model \r\n * rotational friction. \r\n * This joint is designed for vehicle suspensions.\r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2WheelJointDef} def \r\n */\r\nbox2d.b2WheelJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_frequencyHz = def.frequencyHz;\r\n\tthis.m_dampingRatio = def.dampingRatio;\r\n\r\n\tthis.m_localAnchorA = def.localAnchorA.Clone();\r\n\tthis.m_localAnchorB = def.localAnchorB.Clone();\r\n\tthis.m_localXAxisA = def.localAxisA.Clone();\r\n\tthis.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2());\r\n\r\n\tthis.m_maxMotorTorque = def.maxMotorTorque;\r\n\tthis.m_motorSpeed = def.motorSpeed;\r\n\tthis.m_enableMotor = def.enableMotor;\r\n\r\n\tthis.m_localCenterA = new box2d.b2Vec2();\r\n\tthis.m_localCenterB = new box2d.b2Vec2();\r\n\r\n\tthis.m_ax = new box2d.b2Vec2(), this.m_ay = new box2d.b2Vec2();\r\n\r\n\tthis.m_qA = new box2d.b2Rot();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_lalcA = new box2d.b2Vec2();\r\n\tthis.m_lalcB = new box2d.b2Vec2();\r\n\tthis.m_rA = new box2d.b2Vec2();\r\n\tthis.m_rB = new box2d.b2Vec2();\r\n\r\n\tthis.m_ax.SetZero();\r\n\tthis.m_ay.SetZero();\r\n}\r\n\r\ngoog.inherits(box2d.b2WheelJoint, box2d.b2Joint);\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_frequencyHz = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_dampingRatio = 0;\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_localAnchorA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_localAnchorB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_localXAxisA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_localYAxisA = null;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_impulse = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_motorImpulse = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_springImpulse = 0;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_maxMotorTorque = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_motorSpeed = 0;\r\n/**\r\n * @export \r\n * @type {boolean}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_enableMotor = false;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_invIB = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_ax = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_ay = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_sAx = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_sBx = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_sAy = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_sBy = 0;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_mass = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_motorMass = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_springMass = 0;\r\n\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_bias = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_gamma = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_lalcA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_lalcB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2WheelJoint.prototype.m_rB = null;\r\n\r\n/** \r\n * Get the motor speed, usually in radians per second. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.GetMotorSpeed = function ()\r\n{\r\n\treturn this.m_motorSpeed;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.GetMaxMotorTorque = function ()\r\n{\r\n\treturn this.m_maxMotorTorque;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} hz\r\n */\r\nbox2d.b2WheelJoint.prototype.SetSpringFrequencyHz = function (hz)\r\n{\r\n\tthis.m_frequencyHz = hz;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.GetSpringFrequencyHz = function ()\r\n{\r\n\treturn this.m_frequencyHz;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {number} ratio\r\n */\r\nbox2d.b2WheelJoint.prototype.SetSpringDampingRatio = function (ratio)\r\n{\r\n\tthis.m_dampingRatio = ratio;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.GetSpringDampingRatio = function ()\r\n{\r\n\treturn this.m_dampingRatio;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2WheelJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassA = this.m_bodyA.m_invMass;\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIA = this.m_bodyA.m_invI;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n\t// Compute the effective masses.\r\n//\tbox2d.b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tbox2d.b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n//\tbox2d.b2Vec2 d = cB + rB - cA - rA;\r\n\tvar d = box2d.b2SubVV(\r\n\t\tbox2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), \r\n\t\tbox2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), \r\n\t\tbox2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d);\r\n\r\n\t// Point to line constraint\r\n\t{\r\n//\t\tm_ay = b2Mul(qA, m_localYAxisA);\r\n\t\tbox2d.b2MulRV(qA, this.m_localYAxisA, this.m_ay);\r\n//\t\tm_sAy = b2Cross(d + rA, m_ay);\r\n\t\tthis.m_sAy = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), this.m_ay);\r\n//\t\tm_sBy = b2Cross(rB, m_ay);\r\n\t\tthis.m_sBy = box2d.b2CrossVV(rB, this.m_ay);\r\n\r\n\t\tthis.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;\r\n\r\n\t\tif (this.m_mass > 0)\r\n\t\t{\r\n\t\t\tthis.m_mass = 1 / this.m_mass;\r\n\t\t}\r\n\t}\r\n\r\n\t// Spring constraint\r\n\tthis.m_springMass = 0;\r\n\tthis.m_bias = 0;\r\n\tthis.m_gamma = 0;\r\n\tif (this.m_frequencyHz > 0)\r\n\t{\r\n//\t\tm_ax = b2Mul(qA, m_localXAxisA);\r\n\t\tbox2d.b2MulRV(qA, this.m_localXAxisA, this.m_ax);\r\n//\t\tm_sAx = b2Cross(d + rA, m_ax);\r\n\t\tthis.m_sAx = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), this.m_ax);\r\n//\t\tm_sBx = b2Cross(rB, m_ax);\r\n\t\tthis.m_sBx = box2d.b2CrossVV(rB, this.m_ax);\r\n\r\n\t\t/*float32*/ var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;\r\n\r\n\t\tif (invMass > 0)\r\n\t\t{\r\n\t\t\tthis.m_springMass = 1 / invMass;\r\n\r\n\t\t\t/*float32*/ var C = box2d.b2DotVV(d, this.m_ax);\r\n\r\n\t\t\t// Frequency\r\n\t\t\t/*float32*/ var omega = 2 * box2d.b2_pi * this.m_frequencyHz;\r\n\r\n\t\t\t// Damping coefficient\r\n\t\t\t/*float32*/ var dc = 2 * this.m_springMass * this.m_dampingRatio * omega;\r\n\r\n\t\t\t// Spring stiffness\r\n\t\t\t/*float32*/ var k = this.m_springMass * omega * omega;\r\n\r\n\t\t\t// magic formulas\r\n\t\t\t/*float32*/ var h = data.step.dt;\r\n\t\t\tthis.m_gamma = h * (dc + h * k);\r\n\t\t\tif (this.m_gamma > 0)\r\n\t\t\t{\r\n\t\t\t\tthis.m_gamma = 1 / this.m_gamma;\r\n\t\t\t}\r\n\r\n\t\t\tthis.m_bias = C * h * k * this.m_gamma;\r\n\r\n\t\t\tthis.m_springMass = invMass + this.m_gamma;\r\n\t\t\tif (this.m_springMass > 0)\r\n\t\t\t{\r\n\t\t\t\tthis.m_springMass = 1 / this.m_springMass;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_springImpulse = 0;\r\n\t}\r\n\r\n\t// Rotational motor\r\n\tif (this.m_enableMotor)\r\n\t{\r\n\t\tthis.m_motorMass = iA + iB;\r\n\t\tif (this.m_motorMass > 0)\r\n\t\t{\r\n\t\t\tthis.m_motorMass = 1 / this.m_motorMass;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_motorMass = 0;\r\n\t\tthis.m_motorImpulse = 0;\r\n\t}\r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\t// Account for variable time step.\r\n\t\tthis.m_impulse *= data.step.dtRatio;\r\n\t\tthis.m_springImpulse *= data.step.dtRatio;\r\n\t\tthis.m_motorImpulse *= data.step.dtRatio;\r\n\r\n//\t\tbox2d.b2Vec2 P = m_impulse * m_ay + m_springImpulse * m_ax;\r\n\t\tvar P = box2d.b2AddVV(\r\n\t\t\tbox2d.b2MulSV(this.m_impulse, this.m_ay, box2d.b2Vec2.s_t0), \r\n\t\t\tbox2d.b2MulSV(this.m_springImpulse, this.m_ax, box2d.b2Vec2.s_t1), \r\n\t\t\tbox2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P);\r\n//\t\tfloat32 LA = m_impulse * m_sAy + m_springImpulse * m_sAx + m_motorImpulse;\r\n\t\t/*float32*/ var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\r\n//\t\tfloat32 LB = m_impulse * m_sBy + m_springImpulse * m_sBx + m_motorImpulse;\r\n\t\t/*float32*/ var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\r\n\r\n//\t\tvA -= m_invMassA * P;\r\n\t\tvA.SelfMulSub(this.m_invMassA, P);\r\n\t\twA -= this.m_invIA * LA;\r\n\r\n//\t\tvB += m_invMassB * P;\r\n\t\tvB.SelfMulAdd(this.m_invMassB, P);\r\n\t\twB += this.m_invIB * LB;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_impulse = 0;\r\n\t\tthis.m_springImpulse = 0;\r\n\t\tthis.m_motorImpulse = 0;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2();\r\nbox2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2WheelJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t// Solve spring constraint\r\n\tif (true)\r\n\t{\r\n\t\t/*float32*/ var Cdot = box2d.b2DotVV(this.m_ax, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_sBx * wB - this.m_sAx * wA;\r\n\t\t/*float32*/ var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);\r\n\t\tthis.m_springImpulse += impulse;\r\n\r\n//\t\tbox2d.b2Vec2 P = impulse * m_ax;\r\n\t\tvar P = box2d.b2MulSV(impulse, this.m_ax, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P);\r\n\t\t/*float32*/ var LA = impulse * this.m_sAx;\r\n\t\t/*float32*/ var LB = impulse * this.m_sBx;\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * LA;\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * LB;\r\n\t}\r\n\r\n\t// Solve rotational motor constraint\r\n\tif (true)\r\n\t{\r\n\t\t/*float32*/ var Cdot = wB - wA - this.m_motorSpeed;\r\n\t\t/*float32*/ var impulse = -this.m_motorMass * Cdot;\r\n\r\n\t\t/*float32*/ var oldImpulse = this.m_motorImpulse;\r\n\t\t/*float32*/ var maxImpulse = data.step.dt * this.m_maxMotorTorque;\r\n\t\tthis.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\r\n\t\timpulse = this.m_motorImpulse - oldImpulse;\r\n\r\n\t\twA -= iA * impulse;\r\n\t\twB += iB * impulse;\r\n\t}\r\n\r\n\t// Solve point to line constraint\r\n\tif (true)\r\n\t{\r\n\t\t/*float32*/ var Cdot = box2d.b2DotVV(this.m_ay, box2d.b2SubVV(vB, vA, box2d.b2Vec2.s_t0)) + this.m_sBy * wB - this.m_sAy * wA;\r\n\t\t/*float32*/ var impulse = -this.m_mass * Cdot;\r\n\t\tthis.m_impulse += impulse;\r\n\r\n//\t\tbox2d.b2Vec2 P = impulse * m_ay;\r\n\t\tvar P = box2d.b2MulSV(impulse, this.m_ay, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P);\r\n\t\t/*float32*/ var LA = impulse * this.m_sAy;\r\n\t\t/*float32*/ var LB = impulse * this.m_sBy;\r\n\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * LA;\r\n\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * LB;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA;\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB;\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2WheelJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n//\tbox2d.b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n\tbox2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n\tvar rA = box2d.b2MulRV(qA, this.m_lalcA, this.m_rA);\r\n//\tbox2d.b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n\tbox2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n\tvar rB = box2d.b2MulRV(qB, this.m_lalcB, this.m_rB);\r\n//\tbox2d.b2Vec2 d = (cB - cA) + rB - rA;\r\n\tvar d = box2d.b2AddVV(\r\n\t\tbox2d.b2SubVV(cB, cA, box2d.b2Vec2.s_t0), \r\n\t\tbox2d.b2SubVV(rB, rA, box2d.b2Vec2.s_t1), \r\n\t\tbox2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d);\r\n\r\n//\tbox2d.b2Vec2 ay = b2Mul(qA, m_localYAxisA);\r\n\tvar ay = box2d.b2MulRV(qA, this.m_localYAxisA, this.m_ay);\r\n\r\n//\tfloat32 sAy = b2Cross(d + rA, ay);\r\n\tvar sAy = box2d.b2CrossVV(box2d.b2AddVV(d, rA, box2d.b2Vec2.s_t0), ay);\r\n//\tfloat32 sBy = b2Cross(rB, ay);\r\n\tvar sBy = box2d.b2CrossVV(rB, ay);\r\n\r\n//\tfloat32 C = b2Dot(d, ay);\r\n\tvar C = box2d.b2DotVV(d, this.m_ay);\r\n\r\n\t/*float32*/ var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;\r\n\r\n\t/*float32*/ var impulse;\r\n\tif (k !== 0)\r\n\t{\r\n\t\timpulse = - C / k;\r\n\t}\r\n\telse\r\n\t{\r\n\t\timpulse = 0;\r\n\t}\r\n\r\n//\tbox2d.b2Vec2 P = impulse * ay;\r\n\tvar P = box2d.b2MulSV(impulse, ay, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P);\r\n\t/*float32*/ var LA = impulse * sAy;\r\n\t/*float32*/ var LB = impulse * sBy;\r\n\r\n//\tcA -= m_invMassA * P;\r\n\tcA.SelfMulSub(this.m_invMassA, P);\r\n\taA -= this.m_invIA * LA;\r\n//\tcB += m_invMassB * P;\r\n\tcB.SelfMulAdd(this.m_invMassB, P);\r\n\taB += this.m_invIB * LB;\r\n\r\n//\tdata.positions[this.m_indexA].c = cA;\r\n\tdata.positions[this.m_indexA].a = aA;\r\n//\tdata.positions[this.m_indexB].c = cB;\r\n\tdata.positions[this.m_indexB].a = aB;\r\n\r\n\treturn box2d.b2Abs(C) <= box2d.b2_linearSlop;\r\n}\r\nbox2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2();\r\nbox2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2();\r\n\r\n/**\r\n * @export \r\n * @return {box2d.b2WheelJointDef} \r\n * @param {box2d.b2WheelJointDef} def \r\n */\r\nbox2d.b2WheelJoint.prototype.GetDefinition = function (def)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(false); } // TODO\r\n\treturn def;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2WheelJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2WheelJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2WheelJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n//\treturn inv_dt * (m_impulse * m_ay + m_springImpulse * m_ax);\r\n\tout.x = inv_dt * (this.m_impulse * this.m_ay.x + this.m_springImpulse * this.m_ax.x);\r\n\tout.y = inv_dt * (this.m_impulse * this.m_ay.y + this.m_springImpulse * this.m_ax.y);\r\n\treturn out;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2WheelJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn inv_dt * this.m_motorImpulse;\r\n}\r\n\r\n/** \r\n * The local anchor point relative to bodyA's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2WheelJoint.prototype.GetLocalAnchorA = function (out) { return out.Copy(this.m_localAnchorA); }\r\n\r\n/** \r\n * The local anchor point relative to bodyB's origin. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2WheelJoint.prototype.GetLocalAnchorB = function (out) { return out.Copy(this.m_localAnchorB); }\r\n\r\n/** \r\n * The local joint axis relative to bodyA. \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2WheelJoint.prototype.GetLocalAxisA = function (out) { return out.Copy(this.m_localXAxisA); }\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.GetJointTranslation = function ()\r\n{\r\n\t/*box2d.b2Body*/ var bA = this.m_bodyA;\r\n\t/*box2d.b2Body*/ var bB = this.m_bodyB;\r\n\r\n\t/*box2d.b2Vec2*/ var pA = bA.GetWorldPoint(this.m_localAnchorA, new box2d.b2Vec2());\r\n\t/*box2d.b2Vec2*/ var pB = bB.GetWorldPoint(this.m_localAnchorB, new box2d.b2Vec2());\r\n\t/*box2d.b2Vec2*/ var d = box2d.b2SubVV(pB, pA, new box2d.b2Vec2());\r\n\t/*box2d.b2Vec2*/ var axis = bA.GetWorldVector(this.m_localXAxisA, new box2d.b2Vec2());\r\n\r\n\t/*float32*/ var translation = box2d.b2DotVV(d, axis);\r\n\treturn translation;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2WheelJoint.prototype.GetJointSpeed = function ()\r\n{\r\n\t/*float32*/ var wA = this.m_bodyA.m_angularVelocity;\r\n\t/*float32*/ var wB = this.m_bodyB.m_angularVelocity;\r\n\treturn wB - wA;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {boolean}\r\n */\r\nbox2d.b2WheelJoint.prototype.IsMotorEnabled = function ()\r\n{\r\n\treturn this.m_enableMotor;\r\n}\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {boolean} flag\r\n */\r\nbox2d.b2WheelJoint.prototype.EnableMotor = function (flag)\r\n{\r\n\tthis.m_bodyA.SetAwake(true);\r\n\tthis.m_bodyB.SetAwake(true);\r\n\tthis.m_enableMotor = flag;\r\n}\r\n\r\n/** \r\n * Set the motor speed, usually in radians per second. \r\n * @export \r\n * @return {void} \r\n * @param {number} speed\r\n */\r\nbox2d.b2WheelJoint.prototype.SetMotorSpeed = function (speed)\r\n{\r\n\tthis.m_bodyA.SetAwake(true);\r\n\tthis.m_bodyB.SetAwake(true);\r\n\tthis.m_motorSpeed = speed;\r\n}\r\n\r\n/** \r\n * Set/Get the maximum motor force, usually in N-m. \r\n * @export \r\n * @return {void} \r\n * @param {number} force\r\n */\r\nbox2d.b2WheelJoint.prototype.SetMaxMotorTorque = function (force)\r\n{\r\n\tthis.m_bodyA.SetAwake(true);\r\n\tthis.m_bodyB.SetAwake(true);\r\n\tthis.m_maxMotorTorque = force;\r\n}\r\n\r\n/** \r\n * Get the current motor torque given the inverse time step, \r\n * usually in N-m. \r\n * @export \r\n * @return {number}\r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2WheelJoint.prototype.GetMotorTorque = function (inv_dt)\r\n{\r\n\treturn inv_dt * this.m_motorImpulse;\r\n}\r\n\r\n/** \r\n * Dump to b2Log \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2WheelJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\t\r\n\t\tbox2d.b2Log(\"  /*box2d.b2WheelJointDef*/ var jd = new box2d.b2WheelJointDef();\\n\");\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.localAnchorA.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n\t\tbox2d.b2Log(\"  jd.localAnchorB.SetXY(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n\t\tbox2d.b2Log(\"  jd.localAxisA.Set(%.15f, %.15f);\\n\", this.m_localXAxisA.x, this.m_localXAxisA.y);\r\n\t\tbox2d.b2Log(\"  jd.enableMotor = %s;\\n\", (this.m_enableMotor)?('true'):('false'));\r\n\t\tbox2d.b2Log(\"  jd.motorSpeed = %.15f;\\n\", this.m_motorSpeed);\r\n\t\tbox2d.b2Log(\"  jd.maxMotorTorque = %.15f;\\n\", this.m_maxMotorTorque);\r\n\t\tbox2d.b2Log(\"  jd.frequencyHz = %.15f;\\n\", this.m_frequencyHz);\r\n\t\tbox2d.b2Log(\"  jd.dampingRatio = %.15f;\\n\", this.m_dampingRatio);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2012 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d.b2MotorJoint');\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Math');\r\n\r\n/** \r\n * Motor joint definition. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2JointDef} \r\n */\r\nbox2d.b2MotorJointDef = function ()\r\n{\r\n\tgoog.base(this, box2d.b2JointType.e_motorJoint); // base class constructor\r\n\r\n\tthis.linearOffset = new box2d.b2Vec2(0, 0);\r\n}\r\n\r\ngoog.inherits(box2d.b2MotorJointDef, box2d.b2JointDef);\r\n\r\n/** \r\n * Position of bodyB minus the position of bodyA, in bodyA's \r\n * frame, in meters. \r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MotorJointDef.prototype.linearOffset = null;\r\n\r\n/** \r\n * The bodyB angle minus bodyA angle in radians. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJointDef.prototype.angularOffset = 0;\r\n\r\n/** \r\n * The maximum motor force in N. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJointDef.prototype.maxForce = 1;\r\n\r\n/** \r\n * The maximum motor torque in N-m. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJointDef.prototype.maxTorque = 1;\r\n\r\n/** \r\n * Position correction factor in the range [0,1]. \r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJointDef.prototype.correctionFactor = 0.3;\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Body} bA \r\n * @param {box2d.b2Body} bB \r\n */\r\nbox2d.b2MotorJointDef.prototype.Initialize = function (bA, bB)\r\n{\r\n\tthis.bodyA = bA;\r\n\tthis.bodyB = bB;\r\n//\tb2Vec2 xB = bodyB->GetPosition();\r\n//\tlinearOffset = bodyA->GetLocalPoint(xB);\r\n\tthis.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);\r\n\r\n\t/** @type {number} */ var angleA = this.bodyA.GetAngleRadians();\r\n\t/** @type {number} */ var angleB = this.bodyB.GetAngleRadians();\r\n\tthis.angularOffset = angleB - angleA;\r\n}\r\n\r\n/** \r\n * A motor joint is used to control the relative motion between \r\n * two bodies. A typical usage is to control the movement of a \r\n * dynamic body with respect to the ground. \r\n * @export \r\n * @constructor \r\n * @extends {box2d.b2Joint} \r\n * @param {box2d.b2MotorJointDef} def \r\n */\r\nbox2d.b2MotorJoint = function (def)\r\n{\r\n\tgoog.base(this, def); // base class constructor\r\n\r\n\tthis.m_linearOffset = def.linearOffset.Clone();\r\n\tthis.m_linearImpulse = new box2d.b2Vec2(0, 0);\r\n\tthis.m_maxForce = def.maxForce;\r\n\tthis.m_maxTorque = def.maxTorque;\r\n\tthis.m_correctionFactor = def.correctionFactor;\r\n\r\n\tthis.m_rA = new box2d.b2Vec2(0, 0);\r\n\tthis.m_rB = new box2d.b2Vec2(0, 0);\r\n\tthis.m_localCenterA = new box2d.b2Vec2(0, 0);\r\n\tthis.m_localCenterB = new box2d.b2Vec2(0, 0);\r\n\tthis.m_linearError = new box2d.b2Vec2(0, 0);\r\n\tthis.m_linearMass = new box2d.b2Mat22();\r\n\r\n\tthis.m_qA = new box2d.b2Rot();\r\n\tthis.m_qB = new box2d.b2Rot();\r\n\tthis.m_K = new box2d.b2Mat22();\r\n}\r\n\r\ngoog.inherits(box2d.b2MotorJoint, box2d.b2Joint);\r\n\r\n// Solver shared\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_linearOffset = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_angularOffset = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_linearImpulse = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_angularImpulse = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_maxForce = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_maxTorque = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_correctionFactor = 0.3;\r\n\r\n// Solver temp\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_indexA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_indexB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_rA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_rB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_localCenterA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_localCenterB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Vec2}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_linearError = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_angularError = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_invMassA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_invMassB = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_invIA = 0;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_invIB = 0;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_linearMass = null;\r\n/**\r\n * @export \r\n * @type {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_angularMass = 0;\r\n\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_qA = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Rot}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_qB = null;\r\n/**\r\n * @export \r\n * @type {box2d.b2Mat22}\r\n */\r\nbox2d.b2MotorJoint.prototype.m_K = null;\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2MotorJoint.prototype.GetAnchorA = function (out)\r\n{\r\n\treturn this.m_bodyA.GetPosition(out);\r\n}\r\n/**\r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2MotorJoint.prototype.GetAnchorB = function (out)\r\n{\r\n\treturn this.m_bodyB.GetPosition(out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2} \r\n * @param {number} inv_dt \r\n * @param {box2d.b2Vec2} out\r\n */\r\nbox2d.b2MotorJoint.prototype.GetReactionForce = function (inv_dt, out)\r\n{\r\n//\treturn inv_dt * m_linearImpulse;\r\n\treturn box2d.b2MulSV(inv_dt, this.m_linearImpulse, out);\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {number} \r\n * @param {number} inv_dt \r\n */\r\nbox2d.b2MotorJoint.prototype.GetReactionTorque = function (inv_dt)\r\n{\r\n\treturn inv_dt * this.m_angularImpulse;\r\n}\r\n\r\n/**\r\n * Set the position correction factor in the range [0,1]. \r\n * @return {void} \r\n * @param {number} factor \r\n */\r\nbox2d.b2MotorJoint.prototype.SetCorrectionFactor = function (factor)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(factor) && 0.0 <= factor && factor <= 1.0) };\r\n\tthis._correctionFactor = factor;\r\n}\r\n\r\n/**\r\n * Get the position correction factor in the range [0,1]. \r\n * @return {number} \r\n */\r\nbox2d.b2MotorJoint.prototype.GetCorrectionFactor = function ()\r\n{\r\n\treturn this.m_correctionFactor;\r\n}\r\n\r\n/** \r\n * Set/get the target linear offset, in frame A, in meters. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} linearOffset\r\n */\r\nbox2d.b2MotorJoint.prototype.SetLinearOffset = function (linearOffset)\r\n{\r\n\tif (!box2d.b2IsEqualToV(linearOffset, this.m_linearOffset))\r\n\t{\r\n\t\tthis.m_bodyA.SetAwake(true);\r\n\t\tthis.m_bodyB.SetAwake(true);\r\n\t\tthis.m_linearOffset.Copy(linearOffset);\r\n\t}\r\n}\r\n/** \r\n * @export \r\n * @return {box2d.b2Vec2}\r\n * @param {box2d.b2Vec2} out \r\n */\r\nbox2d.b2MotorJoint.prototype.GetLinearOffset = function (out)\r\n{\r\n\treturn out.Copy(this.m_linearOffset);\r\n}\r\n\r\n/** \r\n * Set/get the target angular offset, in radians. \r\n * @export \r\n * @return {void} \r\n * @param {number} angularOffset\r\n */\r\nbox2d.b2MotorJoint.prototype.SetAngularOffset = function (angularOffset)\r\n{\r\n\tif (angularOffset !== this.m_angularOffset)\r\n\t{\r\n\t\tthis.m_bodyA.SetAwake(true);\r\n\t\tthis.m_bodyB.SetAwake(true);\r\n\t\tthis.m_angularOffset = angularOffset;\r\n\t}\r\n}\r\n/** \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.GetAngularOffset = function ()\r\n{\r\n\treturn this.m_angularOffset;\r\n}\r\n\r\n/** \r\n * Set the maximum friction force in N. \r\n * @export \r\n * @return {void} \r\n * @param {number} force\r\n */\r\nbox2d.b2MotorJoint.prototype.SetMaxForce = function (force)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(force) && force >= 0); }\r\n\tthis.m_maxForce = force;\r\n}\r\n\r\n/** \r\n * Get the maximum friction force in N. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.GetMaxForce = function ()\r\n{\r\n\treturn this.m_maxForce;\r\n}\r\n\r\n/** \r\n * Set the maximum friction torque in N*m. \r\n * @export \r\n * @return {void} \r\n * @param {number} torque\r\n */\r\nbox2d.b2MotorJoint.prototype.SetMaxTorque = function (torque)\r\n{\r\n\tif (box2d.ENABLE_ASSERTS) { box2d.b2Assert(box2d.b2IsValid(torque) && torque >= 0); }\r\n\tthis.m_maxTorque = torque;\r\n}\r\n\r\n/** \r\n * Get the maximum friction torque in N*m. \r\n * @export \r\n * @return {number}\r\n */\r\nbox2d.b2MotorJoint.prototype.GetMaxTorque = function ()\r\n{\r\n\treturn this.m_maxTorque;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2MotorJoint.prototype.InitVelocityConstraints = function (data)\r\n{\r\n\tthis.m_indexA = this.m_bodyA.m_islandIndex;\r\n\tthis.m_indexB = this.m_bodyB.m_islandIndex;\r\n\tthis.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n\tthis.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n\tthis.m_invMassA = this.m_bodyA.m_invMass;\r\n\tthis.m_invMassB = this.m_bodyB.m_invMass;\r\n\tthis.m_invIA = this.m_bodyA.m_invI;\r\n\tthis.m_invIB = this.m_bodyB.m_invI;\r\n\r\n\t/*box2d.b2Vec2&*/ var cA = data.positions[this.m_indexA].c;\r\n\t/*float32*/ var aA = data.positions[this.m_indexA].a;\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\r\n\t/*box2d.b2Vec2&*/ var cB = data.positions[this.m_indexB].c;\r\n\t/*float32*/ var aB = data.positions[this.m_indexB].a;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*box2d.b2Rot*/ var qA = this.m_qA.SetAngleRadians(aA), qB = this.m_qB.SetAngleRadians(aB);\r\n\r\n\t// Compute the effective mass matrix.\r\n//\tthis.m_rA = b2Mul(qA, -this.m_localCenterA);\r\n\tvar rA = box2d.b2MulRV(qA, box2d.b2NegV(this.m_localCenterA, box2d.b2Vec2.s_t0), this.m_rA);\r\n//\tthis.m_rB = b2Mul(qB, -this.m_localCenterB); \r\n\tvar rB = box2d.b2MulRV(qB, box2d.b2NegV(this.m_localCenterB, box2d.b2Vec2.s_t0), this.m_rB);\r\n\r\n\t// J = [-I -r1_skew I r2_skew]\r\n\t//     [ 0       -1 0       1]\r\n\t// r_skew = [-ry; rx]\r\n\r\n\t// Matlab\r\n\t// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]\r\n\t//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]\r\n\t//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\t \r\n\t/*b2Mat22*/ var K = this.m_K;\r\n\tK.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\r\n\tK.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\r\n\tK.ey.x = K.ex.y;\r\n\tK.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\r\n\r\n//\tthis.m_linearMass = K.GetInverse(); \r\n\tK.GetInverse(this.m_linearMass);\r\n\r\n\tthis.m_angularMass = iA + iB;\r\n\tif (this.m_angularMass > 0)\r\n\t{\r\n\t\tthis.m_angularMass = 1 / this.m_angularMass;\r\n\t}\r\n\r\n//\tthis.m_linearError = cB + rB - cA - rA - b2Mul(qA, this.m_linearOffset);\r\n\tbox2d.b2SubVV(\r\n\t\tbox2d.b2SubVV(\r\n\t\t\tbox2d.b2AddVV(cB, rB, box2d.b2Vec2.s_t0), \r\n\t\t\tbox2d.b2AddVV(cA, rA, box2d.b2Vec2.s_t1), \r\n\t\t\tbox2d.b2Vec2.s_t2),\r\n\t\tbox2d.b2MulRV(qA, this.m_linearOffset, box2d.b2Vec2.s_t3), \r\n\t\tthis.m_linearError);\r\n\tthis.m_angularError = aB - aA - this.m_angularOffset; \r\n\r\n\tif (data.step.warmStarting)\r\n\t{\r\n\t\t// Scale impulses to support a variable time step.\r\n//\t\tthis.m_linearImpulse *= data.step.dtRatio;\r\n\t\tthis.m_linearImpulse.SelfMul(data.step.dtRatio);\r\n\t\tthis.m_angularImpulse *= data.step.dtRatio;\r\n\r\n//\t\tb2Vec2 P(this.m_linearImpulse.x, this.m_linearImpulse.y);\r\n\t\tvar P = this.m_linearImpulse;\r\n//\t\tvA -= mA * P;\r\n\t\tvA.SelfMulSub(mA, P);\r\n\t\twA -= iA * (box2d.b2CrossVV(rA, P) + this.m_angularImpulse);\r\n//\t\tvB += mB * P;\r\n\t\tvB.SelfMulAdd(mB, P);\r\n\t\twB += iB * (box2d.b2CrossVV(rB, P) + this.m_angularImpulse);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.m_linearImpulse.SetZero();\r\n\t\tthis.m_angularImpulse = 0;\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA; // vA is a reference\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB; // vB is a reference\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\n\r\n/** \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2SolverData} data\r\n */\r\nbox2d.b2MotorJoint.prototype.SolveVelocityConstraints = function (data)\r\n{\r\n\t/*box2d.b2Vec2&*/ var vA = data.velocities[this.m_indexA].v;\r\n\t/*float32*/ var wA = data.velocities[this.m_indexA].w;\r\n\t/*box2d.b2Vec2&*/ var vB = data.velocities[this.m_indexB].v;\r\n\t/*float32*/ var wB = data.velocities[this.m_indexB].w;\r\n\r\n\t/*float32*/ var mA = this.m_invMassA, mB = this.m_invMassB;\r\n\t/*float32*/ var iA = this.m_invIA, iB = this.m_invIB;\r\n\r\n\t/*float32*/ var h = data.step.dt;\r\n\t/*float32*/ var inv_h = data.step.inv_dt;\r\n\r\n\t// Solve angular friction\r\n\t{\r\n\t\t/*float32*/ var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\r\n\t\t/*float32*/ var impulse = -this.m_angularMass * Cdot;\r\n\r\n\t\t/*float32*/ var oldImpulse = this.m_angularImpulse;\r\n\t\t/*float32*/ var maxImpulse = h * this.m_maxTorque;\r\n\t\tthis.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\r\n\t\timpulse = this.m_angularImpulse - oldImpulse;\r\n\r\n\t\twA -= iA * impulse;\r\n\t\twB += iB * impulse;\r\n\t}\r\n\r\n\t// Solve linear friction\r\n\t{\r\n\t\tvar rA = this.m_rA;\r\n\t\tvar rB = this.m_rB;\r\n\r\n//\t\tb2Vec2 Cdot = vB + b2CrossSV(wB, rB) - vA - b2CrossSV(wA, rA) + inv_h * this.m_correctionFactor * this.m_linearError;\r\n\t\tvar Cdot = \r\n\t\t\tbox2d.b2AddVV(\r\n\t\t\t\tbox2d.b2SubVV(\r\n\t\t\t\t\tbox2d.b2AddVV(vB, box2d.b2CrossSV(wB, rB, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), \r\n\t\t\t\t\tbox2d.b2AddVV(vA, box2d.b2CrossSV(wA, rA, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), \r\n\t\t\t\tbox2d.b2MulSV(inv_h * this.m_correctionFactor, this.m_linearError, box2d.b2Vec2.s_t3), \r\n\t\t\t\tbox2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot);\r\n\r\n//\t\tb2Vec2 impulse = -b2Mul(this.m_linearMass, Cdot);\r\n\t\tvar impulse = box2d.b2MulMV(this.m_linearMass, Cdot, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();\r\n//\t\tb2Vec2 oldImpulse = this.m_linearImpulse;\r\n\t\tvar oldImpulse = box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_linearImpulse);\r\n//\t\tthis.m_linearImpulse += impulse;\r\n\t\tthis.m_linearImpulse.SelfAdd(impulse);\r\n\r\n\t\t/*float32*/ var maxImpulse = h * this.m_maxForce;\r\n\r\n\t\tif (this.m_linearImpulse.GetLengthSquared() > maxImpulse * maxImpulse)\r\n\t\t{\r\n\t\t\tthis.m_linearImpulse.Normalize();\r\n//\t\t\tthis.m_linearImpulse *= maxImpulse;\r\n\t\t\tthis.m_linearImpulse.SelfMul(maxImpulse);\r\n\t\t}\r\n\r\n//\t\timpulse = this.m_linearImpulse - oldImpulse;\r\n\t\tbox2d.b2SubVV(this.m_linearImpulse, oldImpulse, impulse);\r\n\r\n//\t\tvA -= mA * impulse;\r\n\t\tvA.SelfMulSub(mA, impulse);\r\n//\t\twA -= iA * b2CrossVV(rA, impulse);\r\n\t\twA -= iA * box2d.b2CrossVV(rA, impulse);\r\n\r\n//\t\tvB += mB * impulse;\r\n\t\tvB.SelfMulAdd(mB, impulse);\r\n//\t\twB += iB * b2CrossVV(rB, impulse);\r\n\t\twB += iB * box2d.b2CrossVV(rB, impulse);\r\n\t}\r\n\r\n//\tdata.velocities[this.m_indexA].v = vA; // vA is a reference\r\n\tdata.velocities[this.m_indexA].w = wA;\r\n//\tdata.velocities[this.m_indexB].v = vB; // vB is a reference\r\n\tdata.velocities[this.m_indexB].w = wB;\r\n}\r\nbox2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2();\r\nbox2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2();\r\nbox2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2();\r\n\r\n/** \r\n * @export \r\n * @return {boolean} \r\n * @param {box2d.b2SolverData} data \r\n */\r\nbox2d.b2MotorJoint.prototype.SolvePositionConstraints = function (data)\r\n{\r\n\treturn true;\r\n}\r\n\r\n/** \r\n * Dump to b2Log \r\n * @export \r\n * @return {void}\r\n */\r\nbox2d.b2MotorJoint.prototype.Dump = function ()\r\n{\r\n\tif (box2d.DEBUG)\r\n\t{\r\n\t\tvar indexA = this.m_bodyA.m_islandIndex;\r\n\t\tvar indexB = this.m_bodyB.m_islandIndex;\r\n\r\n\t\tbox2d.b2Log(\"  /*box2d.b2MotorJointDef*/ var jd = new box2d.b2MotorJointDef();\\n\");\r\n\r\n\t\tbox2d.b2Log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n\t\tbox2d.b2Log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n\t\tbox2d.b2Log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected)?('true'):('false'));\r\n\r\n\t\tbox2d.b2Log(\"  jd.linearOffset.SetXY(%.15f, %.15f);\\n\", this.m_linearOffset.x, this.m_linearOffset.y);\r\n\t\tbox2d.b2Log(\"  jd.angularOffset = %.15f;\\n\", this.m_angularOffset);\r\n\t\tbox2d.b2Log(\"  jd.maxForce = %.15f;\\n\", this.m_maxForce);\r\n\t\tbox2d.b2Log(\"  jd.maxTorque = %.15f;\\n\", this.m_maxTorque);\r\n\t\tbox2d.b2Log(\"  jd.correctionFactor = %.15f;\\n\", this.m_correctionFactor);\r\n\t\tbox2d.b2Log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n\t}\r\n}\r\n\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\ngoog.provide('box2d');\r\n\r\n/**\r\n\\mainpage Box2D API Documentation\r\n\r\n\\section intro_sec Getting Started\r\n\r\nFor documentation please see http://box2d.org/documentation.html\r\n\r\nFor discussion please visit http://box2d.org/forum\r\n*/\r\n\r\n// These include files constitute the main Box2D API\r\n\r\ngoog.require('box2d.b2Settings');\r\ngoog.require('box2d.b2Draw');\r\ngoog.require('box2d.b2Timer');\r\n\r\ngoog.require('box2d.b2CircleShape');\r\ngoog.require('box2d.b2EdgeShape');\r\ngoog.require('box2d.b2ChainShape');\r\ngoog.require('box2d.b2PolygonShape');\r\n\r\ngoog.require('box2d.b2BroadPhase');\r\ngoog.require('box2d.b2Distance');\r\ngoog.require('box2d.b2DynamicTree');\r\ngoog.require('box2d.b2TimeOfImpact');\r\n\r\ngoog.require('box2d.b2Body');\r\ngoog.require('box2d.b2Fixture');\r\ngoog.require('box2d.b2WorldCallbacks');\r\ngoog.require('box2d.b2TimeStep');\r\ngoog.require('box2d.b2World');\r\n\r\ngoog.require('box2d.b2Contact');\r\n\r\ngoog.require('box2d.b2AreaJoint');\r\ngoog.require('box2d.b2DistanceJoint');\r\ngoog.require('box2d.b2FrictionJoint');\r\ngoog.require('box2d.b2GearJoint');\r\ngoog.require('box2d.b2MotorJoint');\r\ngoog.require('box2d.b2MouseJoint');\r\ngoog.require('box2d.b2PrismaticJoint');\r\ngoog.require('box2d.b2PulleyJoint');\r\ngoog.require('box2d.b2RevoluteJoint');\r\ngoog.require('box2d.b2RopeJoint');\r\ngoog.require('box2d.b2WeldJoint');\r\ngoog.require('box2d.b2WheelJoint');\r\n\r\ngoog.require('box2d.b2Rope');\r\n\r\ngoog.require('box2d.b2BuoyancyController');\r\ngoog.require('box2d.b2ConstantAccelController');\r\ngoog.require('box2d.b2ConstantForceController');\r\ngoog.require('box2d.b2GravityController');\r\ngoog.require('box2d.b2TensorDampingController');\r\n\r\n\r\n/**\r\n* @author       Chris Campbell <iforce2d@gmail.com>\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2015 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\n/**\r\n* @class Phaser.Physics.Box2D\r\n* @classdesc Physics World Constructor\r\n* @constructor\r\n* @param {Phaser.Game} game - Reference to the current game instance.\r\n*/\r\nPhaser.Physics.Box2D = function (game, config) {\r\n    \r\n    /**\r\n    * @property {Phaser.Game} game - Local reference to game.\r\n    */\r\n    this.game = game;\r\n    \r\n    /**\r\n    * @property {string} version - The version of the Box2D Plugin that is running.\r\n    */\r\n    this.version = '1.0.2';\r\n\r\n    /**\r\n    * @property {number} ptmRatio - Pixels to Meters ratio.\r\n    * @default 50\r\n    */\r\n    this.ptmRatio = 50;\r\n    \r\n    /**\r\n    * @property {box2d.b2World} world - The Box2D world in which the simulation is run.\r\n    * @protected\r\n    */\r\n    this.world = new box2d.b2World(new box2d.b2Vec2(0, 0));\r\n\r\n    /**\r\n    * @property {Phaser.Physics.Box2D.DefaultDebugDraw} - used for rendering debug information\r\n    * @default\r\n    */\r\n    this.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.mpx(1));\r\n    this.world.SetDebugDraw(this.debugDraw);\r\n\r\n    /**\r\n    * @property {Phaser.Physics.Box2D.DefaultContactListener} - used to check if bodies have contact callbacks set\r\n    * @default\r\n    */\r\n    this.contactListener = new Phaser.Physics.Box2D.DefaultContactListener();\r\n    this.world.SetContactListener(this.contactListener);\r\n\r\n    /**\r\n    * @property {number} nextBodyId - The id to give the next created body\r\n    * @protected\r\n    */\r\n    this.nextBodyId = 0;\r\n\r\n    /**\r\n    * @property {number} nextFixtureId - The id to give the next created fixture\r\n    * @protected\r\n    */\r\n    this.nextFixtureId = 0;\r\n\r\n    /**\r\n    * @property {box2d.b2Vec2} gravity - The gravity of the Box2D world.\r\n    * @protected\r\n    */\r\n    this.gravity = new Phaser.Physics.Box2D.PointProxy(this, this.world, this.world.GetGravity, this.world.SetGravity);\r\n\r\n    /**\r\n    * @property {number} friction - The default friction for fixtures created by 'enable', or other functions like setRectangle, setPolygon etc\r\n    * @default\r\n    */\r\n    this.friction = 0.2;\r\n\r\n    /**\r\n    * @property {number} restitution - The default restitution for fixtures created by 'enable', or other functions like setRectangle, setPolygon etc\r\n    * @default\r\n    */\r\n    this.restitution = 0.0;\r\n\r\n    /**\r\n    * @property {number} density - The default density for fixtures created by 'enable', or other functions like setRectangle, setPolygon etc\r\n    * @default\r\n    */\r\n    this.density = 1.0;\r\n\r\n    /**\r\n    * @property {number} frameRate - The frame rate the world will be stepped at. Defaults to 1 / 60, but you can change here. Also see useElapsedTime property.\r\n    * @default\r\n    */\r\n    this.frameRate = 1 / 60;\r\n\r\n    /**\r\n    * @property {number} velocityIterations - The maximum number of iterations allowed to adjust velocities to match constraints. Defaults to 8.\r\n    * @default\r\n    */\r\n    this.velocityIterations = 8;\r\n\r\n    /**\r\n    * @property {number} positionIterations - The maximum number of iterations allowed to adjust positions to match constraints. Defaults to 3.\r\n    * @default\r\n    */\r\n    this.positionIterations = 3;\r\n\r\n    /**\r\n    * @property {boolean} useElapsedTime - If true the frameRate value will be ignored and instead Box2D will step with the value of Game.Time.physicsElapsed, which is a delta time value.\r\n    * @default\r\n    */\r\n    this.useElapsedTime = false;\r\n\r\n    /**\r\n    * @property {boolean} paused - The paused state of the Box2D world.\r\n    * @default\r\n    */\r\n    this.paused = false;\r\n\r\n    /**\r\n    * @property {box2d.b2ParticleSystem} particleSystem - The World Particle System. Enabled with World.createParticleSystem.\r\n    */\r\n    this.particleSystem = null;\r\n\r\n    /**\r\n    * @property {box2d.b2Body} mouseJointBody - A static body with no fixtures, used internally as the 'body A' for mouse joints when dragging dynamic bodies.\r\n    * @default\r\n    */\r\n    var bd = new box2d.b2BodyDef();\r\n    this.mouseJointBody = this.world.CreateBody(bd);\r\n\r\n    /**\r\n    * @property {box2d.b2MouseJoint} mouseJoint - The active mouse joint for dragging dynamic bodies.\r\n    * @default\r\n    */\r\n    this.mouseJoint = null;\r\n\r\n    //  Pixel to meter function overrides. \r\n    if (config.hasOwnProperty('mpx') && config.hasOwnProperty('pxm'))\r\n    {\r\n        this.mpx = config.mpx;\r\n        this.pxm = config.pxm;\r\n    }\r\n\r\n    /**\r\n    * @property {object} walls - An object containing the 4 wall bodies that bound the physics world.\r\n    */\r\n    this.walls = { left: null, right: null, top: null, bottom: null };\r\n\r\n    /**\r\n    * @property {Phaser.Signal} onBodyAdded - Dispatched when a new Body is added to the World.\r\n    */\r\n    this.onBodyAdded = new Phaser.Signal();\r\n\r\n    /**\r\n    * @property {Phaser.Signal} onBodyRemoved - Dispatched when a Body is removed from the World.\r\n    */\r\n    this.onBodyRemoved = new Phaser.Signal();\r\n\r\n    /**\r\n    * @property {array} _toRemove - Internal var used to hold references to bodies to remove from the world on the next step.\r\n    * @private\r\n    */\r\n    this._toRemove = [];\r\n\r\n};\r\n\r\n// By default Box2D uses a 16bit value for collision filter category and mask. Most commonly,\r\n// users will use categories starting from 1, 2, 4, 8 etc. The value 0x8000 sets the highest\r\n// bit of a 16bit value and should cause the least interference with this method.\r\nPhaser.Physics.Box2D.worldBoundsFilterCategory = 0x8000;\r\n\r\nPhaser.Physics.Box2D.prototype = {\r\n\r\n    /**\r\n    * Returns the next id to use to keep body ids unique\r\n    *\r\n    * @method Phaser.Physics.Box2D#getNextBodyId\r\n    * @return {number} The next unique id for a body to be created with.\r\n    */\r\n    getNextBodyId: function () {\r\n\r\n        var id = this.nextBodyId;\r\n        this.nextBodyId += 1;\r\n        return id;\r\n\r\n    },\r\n\r\n    /**\r\n    * Returns the next id to use to keep fixture ids unique\r\n    *\r\n    * @method Phaser.Physics.Box2D#getNextFixtureId\r\n    * @return {number} The next unique id for a fixture to be created with.\r\n    */\r\n    getNextFixtureId: function () {\r\n\r\n        var id = this.nextFixtureId;\r\n        this.nextFixtureId += 1;\r\n        return id;\r\n\r\n    },\r\n\r\n    /**\r\n    * This will add a Box2D physics body into the removal list for the next step.\r\n    *\r\n    * @method Phaser.Physics.Box2D#removeBodyNextStep\r\n    * @param {Phaser.Physics.Box2D.Body} body - The body to remove at the start of the next step.\r\n    */\r\n    removeBodyNextStep: function (body) {\r\n\r\n        this._toRemove.push(body);\r\n\r\n    },\r\n\r\n    /**\r\n    * Called at the start of the core update loop. Purges flagged bodies from the world.\r\n    *\r\n    * @method Phaser.Physics.Box2D#preUpdate\r\n    */\r\n    preUpdate: function () {\r\n\r\n        var i = this._toRemove.length;\r\n\r\n        while (i--)\r\n        {\r\n            this.removeBody(this._toRemove[i]);\r\n        }\r\n\r\n        this._toRemove.length = 0;\r\n\r\n    },\r\n\r\n    /**\r\n    * This will create a Box2D physics body on the given game object or array of game objects.\r\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\r\n    * Note: When the game object is enabled for Box2D physics it has its anchor x/y set to 0.5 so it becomes centered.\r\n    *\r\n    * @method Phaser.Physics.Box2D#enable\r\n    * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.\r\n    * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.\r\n    */\r\n    enable: function (object, children) {\r\n\r\n        if (typeof children === 'undefined') { children = true; }\r\n\r\n        var i = 1;\r\n\r\n        if (Array.isArray(object))\r\n        {\r\n            i = object.length;\r\n\r\n            while (i--)\r\n            {\r\n                if (object[i] instanceof Phaser.Group)\r\n                {\r\n                    //  If it's a Group then we do it on the children regardless\r\n                    this.enable(object[i].children, children);\r\n                }\r\n                else\r\n                {\r\n                    this.enableBody(object[i]);\r\n\r\n                    if (children && object[i].hasOwnProperty('children') && object[i].children.length > 0)\r\n                    {\r\n                        this.enable(object[i], true);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (object instanceof Phaser.Group)\r\n            {\r\n                //  If it's a Group then we do it on the children regardless\r\n                this.enable(object.children, children);\r\n            }\r\n            else\r\n            {\r\n                this.enableBody(object);\r\n\r\n                if (children && object.hasOwnProperty('children') && object.children.length > 0)\r\n                {\r\n                    this.enable(object.children, true);\r\n                }\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Creates a Box2D physics body on the given game object.\r\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.\r\n    *\r\n    * @method Phaser.Physics.Box2D#enableBody\r\n    * @param {object} object - The game object to create the physics body on. A body will only be created if this object has a null `body` property.\r\n    */\r\n    enableBody: function (object) {\r\n\r\n        if (object.hasOwnProperty('body') && object.body === null)\r\n        {\r\n            object.body = new Phaser.Physics.Box2D.Body(this.game, object, object.x, object.y, 2);\r\n            object.anchor.set(0.5);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets the bounds of the Physics world to match the Game.World dimensions.\r\n    * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n    *\r\n    * @method Phaser.Physics#setBoundsToWorld\r\n    * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n    * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n    * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n    * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n    * @param {number} [collisionCategory=1] - The category (bitmask) to use for the walls.\r\n    * @param {number} [collisionMask=0xFFFFFFFF] - The mask (bitmask) to use for the walls.\r\n    */\r\n    setBoundsToWorld: function (left, right, top, bottom, collisionCategory, collisionMask) {\r\n\r\n        if (typeof left === 'undefined') { left = true; }\r\n        if (typeof right === 'undefined') { right = true; }\r\n        if (typeof top === 'undefined') { top = true; }\r\n        if (typeof bottom === 'undefined') { bottom = true; }\r\n        if (typeof collisionCategory === 'undefined') { collisionCategory = 1; }\r\n        if (typeof collisionMask === 'undefined') { collisionCategory = 0xFFFFFFFF; }\r\n        \r\n        this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, left, right, top, bottom, collisionCategory, collisionMask);\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n    * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n    *\r\n    * @method Phaser.Physics.Box2D#setBounds\r\n    * @param {number} x - The x coordinate of the top-left corner of the bounds.\r\n    * @param {number} y - The y coordinate of the top-left corner of the bounds.\r\n    * @param {number} width - The width of the bounds.\r\n    * @param {number} height - The height of the bounds.\r\n    * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n    * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n    * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n    * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n    * @param {number} [collisionCategory=1] - The category (bitmask) to use for the walls.\r\n    * @param {number} [collisionMask=0xFFFFFFFF] - The mask (bitmask) to use for the walls.\r\n    */\r\n    setBounds: function (x, y, width, height, left, right, top, bottom, collisionCategory, collisionMask) {\r\n\r\n        if (typeof left === 'undefined') { left = true; }\r\n        if (typeof right === 'undefined') { right = true; }\r\n        if (typeof top === 'undefined') { top = true; }\r\n        if (typeof bottom === 'undefined') { bottom = true; }\r\n        if (typeof collisionCategory === 'undefined') { collisionCategory = 1; }\r\n        if (typeof collisionMask === 'undefined') { collisionMask = 0xFFFFFFFF; }\r\n\r\n        if (this.walls.left)\r\n        {\r\n            this.removeBody(this.walls.left);\r\n        }\r\n\r\n        if (this.walls.right)\r\n        {\r\n            this.removeBody(this.walls.right);\r\n        }\r\n\r\n        if (this.walls.top)\r\n        {\r\n            this.removeBody(this.walls.top);\r\n        }\r\n\r\n        if (this.walls.bottom)\r\n        {\r\n            this.removeBody(this.walls.bottom);\r\n        }\r\n        \r\n        // Prepare shape and fixture definitions for use below\r\n        var polygonShape = new box2d.b2PolygonShape();\r\n\r\n        var fixtureDef = new box2d.b2FixtureDef();\r\n        fixtureDef.shape = polygonShape;\r\n\r\n        fixtureDef.filter.categoryBits = Phaser.Physics.Box2D.worldBoundsFilterCategory;\r\n        fixtureDef.filter.maskBits = 0xFFFF;\r\n\r\n        // We could also use edge shapes, but polygons will make sure that if anything\r\n        // should somehow get outside the bounds, it will be brought back (provided it\r\n        // didn't get all the way outside the polygon wall as well of course)\r\n        var boundThickness = this.pxm(100);\r\n        \r\n        var bounds = this.game.world.bounds;\r\n\r\n        if (left)\r\n        {\r\n            this.walls.left = this.createBody(0, 0, 0);\r\n            \r\n            polygonShape.SetAsOrientedBox(boundThickness, this.pxm(bounds.height) + boundThickness, new box2d.b2Vec2(boundThickness, 0), 0);\r\n            \r\n            var f = this.walls.left.data.CreateFixture(fixtureDef);\r\n            f.id = this.getNextFixtureId();\r\n        }\r\n\r\n        if (right)\r\n        {\r\n            this.walls.right = this.createBody(0, 0, 0);\r\n            \r\n            polygonShape.SetAsOrientedBox(boundThickness, this.pxm(bounds.height) + boundThickness, new box2d.b2Vec2(this.pxm(-bounds.width) - boundThickness, 0), 0);\r\n            \r\n            var f = this.walls.right.data.CreateFixture(fixtureDef);\r\n            f.id = this.getNextFixtureId();\r\n        }\r\n\r\n        if (top)\r\n        {\r\n            this.walls.top = this.createBody(0, 0, 0);\r\n\r\n            polygonShape.SetAsOrientedBox(this.pxm(bounds.width) + boundThickness, boundThickness, new box2d.b2Vec2(0, boundThickness), 0);\r\n    \r\n            var f = this.walls.top.data.CreateFixture(fixtureDef);\r\n            f.id = this.getNextFixtureId();\r\n        }\r\n\r\n        if (bottom)\r\n        {\r\n            this.walls.bottom = this.createBody(0, 0, 0);\r\n\r\n            polygonShape.SetAsOrientedBox(this.pxm(bounds.width) + boundThickness, boundThickness, new box2d.b2Vec2(0, this.pxm(-bounds.height) - boundThickness), 0);\r\n    \r\n            var f = this.walls.bottom.data.CreateFixture(fixtureDef);\r\n            f.id = this.getNextFixtureId();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Pauses the Box2D world independent of the game pause state.\r\n    *\r\n    * @method Phaser.Physics.Box2D#pause\r\n    */\r\n    pause: function() {\r\n\r\n        this.paused = true;\r\n\r\n    },\r\n    \r\n    /**\r\n    * Resumes a paused Box2D world.\r\n    *\r\n    * @method Phaser.Physics.Box2D#resume\r\n    */\r\n    resume: function() {\r\n\r\n        this.paused = false;\r\n\r\n    },\r\n\r\n    /**\r\n    * Internal Box2D update loop.\r\n    *\r\n    * @method Phaser.Physics.Box2D#update\r\n    */\r\n    update: function () {\r\n\r\n        // Do nothing when the physics engine was paused before\r\n        if (this.paused)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        if (this.useElapsedTime)\r\n        {\r\n            this.world.Step(this.game.time.physicsElapsed, this.velocityIterations, this.positionIterations);\r\n        }\r\n        else\r\n        {\r\n            this.world.Step(this.frameRate, this.velocityIterations, this.positionIterations);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Clears all bodies from the simulation, resets callbacks.\r\n    *\r\n    * @method Phaser.Physics.Box2D#reset\r\n    */\r\n    reset: function () {\r\n\r\n        this.clear();\r\n\r\n    },\r\n\r\n    /**\r\n    * Clears all bodies from the simulation, resets callbacks.\r\n    *\r\n    * @method Phaser.Physics.Box2D#clear\r\n    */\r\n    clear: function () {\r\n\r\n        var gravity = this.world.GetGravity().Clone();\r\n\r\n        this.world = new box2d.b2World(gravity);\r\n        this.world.SetDebugDraw(this.debugDraw);\r\n        this.world.SetContactListener(this.contactListener);\r\n        this._toRemove = [];\r\n\r\n    },\r\n\r\n    /**\r\n    * Clears all bodies from the simulation and unlinks World from Game. Should only be called on game shutdown. Call `clear` on a State change.\r\n    *\r\n    * @method Phaser.Physics.Box2D#destroy\r\n    */\r\n    destroy: function () {\r\n\r\n        this.clear();\r\n\r\n        this.gravity = null;\r\n        this.world = null;\r\n\r\n        this.game = null;\r\n\r\n    },\r\n\r\n    /**\r\n    * Creates a new Body and adds it to the World.\r\n    *\r\n    * @method Phaser.Physics.Box2D#createBody\r\n    * @param {number} [x=0] - The x coordinate of this Body.\r\n    * @param {number} [y=0] - The y coordinate of this Body.\r\n    * @param {number} [density=2] - The default density of this Body (0 = static, 1 = kinematic, 2 = dynamic, 3 = bullet).\r\n    * @return {Phaser.Physics.P2.Body} The body\r\n    */\r\n    createBody: function (x, y, density) {\r\n\r\n        var body = new Phaser.Physics.Box2D.Body(this.game, null, x, y, density, this);\r\n\r\n        return body;\r\n\r\n    },\r\n\r\n    /**\r\n    * Creates a new dynamic Body and adds a Circle fixture to it of the given size.\r\n    *\r\n    * @method Phaser.Physics.Box2D#createCircle\r\n    * @param {number} [x=0] - The x coordinate of this Body.\r\n    * @param {number} [y=0] - The y coordinate of this Body.\r\n    * @param {number} [radius=32] - The radius of this circle in pixels.\r\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\r\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\r\n    * @return {Phaser.Physics.P2.Body} The body\r\n    */\r\n    createCircle: function (x, y, radius, offsetX, offsetY) {\r\n    \r\n        var body = this.createBody(x, y, 2);\r\n\r\n        return body.setCircle(radius, offsetX, offsetY);\r\n\r\n    },\r\n\r\n    /**\r\n    * Creates a new dynamic Body and adds a Rectangle fixture to it of the given dimensions.\r\n    *\r\n    * @method Phaser.Physics.Box2D#createRectangle\r\n    * @param {number} [x=0] - The x coordinate of this Body.\r\n    * @param {number} [y=0] - The y coordinate of this Body.\r\n    * @param {number} [width=16] - The width of the rectangle in pixels.\r\n    * @param {number} [height=16] - The height of the rectangle in pixels.\r\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\r\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\r\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\r\n    * @return {Phaser.Physics.P2.Body} The body\r\n    */\r\n    createRectangle: function (x, y, width, height, offsetX, offsetY, rotation) {\r\n    \r\n        var body = this.createBody(x, y, 2);\r\n\r\n        return body.setRectangle(width, height, offsetX, offsetY, rotation);\r\n\r\n    },\r\n\r\n    /**\r\n    * Creates a new dynamic Body and adds a Polygon fixture to it.\r\n    *\r\n    * @method Phaser.Physics.Box2D#createPolygon\r\n    * @param {number} [x=0] - The x coordinate of this Body.\r\n    * @param {number} [y=0] - The y coordinate of this Body.\r\n    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]\r\n    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.\r\n    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.\r\n    * @return {Phaser.Physics.P2.Body} The body\r\n    */\r\n    createPolygon: function (x, y, vertices, firstIndex, count) {\r\n    \r\n        var body = this.createBody(x, y, 2);\r\n\r\n        return body.setPolygon(vertices, firstIndex, count);\r\n\r\n    },\r\n\r\n    /**\r\n    * Adds an already created Box2D Body to this Box2D world.\r\n    *\r\n    * @method Phaser.Physics.Box2D#addBody\r\n    * @param {Phaser.Physics.Box2D.Body} body - The Body to add to the World. Must already exist and not be part of another Box2D world.\r\n    * @return {boolean} True if the Body was added successfully, otherwise false.\r\n    */\r\n    addBody: function (body) {\r\n\r\n        if (body.data.world)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            body.data = this.world.CreateBody(body.bodyDef);\r\n            body.data.world = this.world;\r\n            body.data.parent = body;\r\n\r\n            this.onBodyAdded.dispatch(body);\r\n\r\n            return true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Removes a body from the world. This will silently fail if the body wasn't part of the world to begin with.\r\n    *\r\n    * @method Phaser.Physics.Box2D#removeBody\r\n    * @param {Phaser.Physics.Box2D.Body} body - The Body to remove from the World.\r\n    * @return {Phaser.Physics.Box2D.Body} The Body that was removed.\r\n    */\r\n    removeBody: function (body) {\r\n\r\n        if (body.data.world == this.world)\r\n        {\r\n            this.world.DestroyBody(body.data);\r\n\r\n            this.onBodyRemoved.dispatch(body);\r\n        }\r\n\r\n        return body;\r\n\r\n    },\r\n\r\n    /**\r\n    * Populates and returns an array with references to of all current Bodies in the world.\r\n    *\r\n    * @method Phaser.Physics.Box2D#getBodies\r\n    * @return {array<Phaser.Physics.Box2D.Body>} An array containing all current Bodies in the world.\r\n    */\r\n    getBodies: function () {\r\n\r\n        var output = [];\r\n        \r\n        for (var b = this.world.GetBodyList(); b; b = b.GetNext())\r\n        {\r\n            output.push(b);\r\n        }\r\n\r\n        return output;\r\n\r\n    },\r\n\r\n    /**\r\n    * Checks the given object to see if it has a Box2D body and if so returns it.\r\n    *\r\n    * @method Phaser.Physics.Box2D#getBody\r\n    * @param {object} object - The object to check for a box2d.b2Body on.\r\n    * @return {box2d.b2Body} The Box2D body, or null if not found.\r\n    */\r\n    getBody: function (object) {\r\n\r\n        if (object instanceof box2d.b2Body)\r\n        {\r\n            //  Native Box2D body\r\n            return object;\r\n        }\r\n        else if (object instanceof Phaser.Physics.Box2D.Body)\r\n        {\r\n            //  Phaser Box2D Body\r\n            return object.data;\r\n        }\r\n        else if (object['body'] && object['body'].type === Phaser.Physics.BOX2D)\r\n        {\r\n            //  Sprite, TileSprite, etc\r\n            return object.body.data;\r\n        }\r\n\r\n        return null;\r\n\r\n    },\r\n\r\n    /**\r\n    * Converts the current world into a JSON object.\r\n    *\r\n    * @method Phaser.Physics.Box2D#toJSON\r\n    * @return {object} A JSON representation of the world.\r\n    */\r\n    toJSON: function () {\r\n\r\n        return this.world.toJSON();\r\n\r\n    },\r\n\r\n    /**\r\n    * Convert Box2D physics value (meters) to pixel scale.\r\n    * By default we use a scale of 50px per meter.\r\n    * If you need to modify this you can over-ride these functions via the Physics Configuration object.\r\n    *\r\n    * @method Phaser.Physics.Box2D#mpx\r\n    * @param {number} v - The value to convert.\r\n    * @return {number} The scaled value.\r\n    */\r\n    mpx: function (v) {\r\n\r\n        return v *= 2;\r\n\r\n    },\r\n\r\n    /**\r\n    * Convert pixel value to Box2D physics scale (meters).\r\n    * By default we use a scale of 50px per meter.\r\n    * If you need to modify this you can over-ride these functions via the Physics Configuration object.\r\n    *\r\n    * @method Phaser.Physics.Box2D#pxm\r\n    * @param {number} v - The value to convert.\r\n    * @return {number} The scaled value.\r\n    */\r\n    pxm: function (v) {\r\n\r\n        return v / 2;\r\n\r\n    },\r\n    \r\n    /**\r\n    * Runs the standard 'debug draw' rendering. What actually gets drawn will depend\r\n    * on the current status of the flags set in the debug draw object held by the b2World.\r\n    * This could perhaps be made modifiable at runtime, but for now it is just rendering\r\n    * shapes (see usage of b2Shapes flag below).\r\n    *\r\n    * @method Phaser.Physics.Box2D#renderDebugDraw\r\n    * @param {object} context - The context to render to.\r\n    */\r\n    renderDebugDraw: function(context) {\r\n        \r\n        if (!this.game.physics.box2d)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        var world = this.game.physics.box2d;\r\n        \r\n        world.debugDraw.start(context);\r\n    \r\n        world.world.DrawDebugData();\r\n        \r\n        world.debugDraw.stop();\r\n\r\n    },\r\n    \r\n    /**\r\n    * Renders information about the body as text. This is intended to be used internally by Phaser.Utils.Debug.\r\n    * To make use of this from your code you would call something like game.debug.bodyInfo(sprite, x, y)\r\n    *\r\n    * @method Phaser.Physics.Box2D#renderBodyInfo\r\n    * @param {Phaser.Utils.Debug} debug - The Debug class to use.\r\n    * @param {Phaser.Physics.Box2D} body - The Body to render the info of.\r\n    */\r\n    renderBodyInfo: function (debug, body) {\r\n    \r\n        debug.line('Position: x: ' + body.x.toFixed(3) + ' y: ' + body.y.toFixed(3));\r\n        debug.line('Rotation: ' + body.rotation.toFixed(3) + ' degrees');\r\n        debug.line('Velocity: x: ' + body.velocity.x.toFixed(3) + ' y: ' + body.velocity.y.toFixed(3));\r\n        debug.line('Angular velocity: ' + body.angularVelocity.toFixed(3) + ' degrees/sec');\r\n    \r\n    },\r\n\r\n    /**\r\n    * Returns all fixtures found under the given point. Set the onlyOne parameter to true if you only\r\n    * care about finding one fixture under the point.\r\n    *\r\n    * @method Phaser.Physics.Box2D#getFixturesAtPoint\r\n    * @param {Phaser.Pointer} x - The x coordinate of the location to test for (pixel coordinates)\r\n    * @param {Phaser.Pointer} y - The y coordinate of the location to test for (pixel coordinates)\r\n    * @param {boolean} [onlyOne=false] - If true, this function will return after finding just one fixture.\r\n    * @param {boolean} [onlyDynamic=false] - If true, only fixtures on dynamic bodies will be returned.\r\n    * @return {Array} All fixtures found at the given point.\r\n    */\r\n    getFixturesAtPoint: function (x, y, onlyOne, onlyDynamic) {\r\n        \r\n        if (typeof onlyOne === 'undefined') { onlyOne = false; }\r\n        if (typeof onlyDynamic === 'undefined') { onlyDynamic = false; }\r\n        \r\n        var worldx = this.pxm(-x);\r\n        var worldy = this.pxm(-y);\r\n        var worldPoint = new box2d.b2Vec2(worldx, worldy);\r\n        \r\n        // Make a small box.\r\n        var aabb = new box2d.b2AABB();\r\n        var d = new box2d.b2Vec2();\r\n\r\n        d.SetXY(0.001, 0.001);\r\n\r\n        box2d.b2SubVV(worldPoint, d, aabb.lowerBound);\r\n        box2d.b2AddVV(worldPoint, d, aabb.upperBound);\r\n\r\n        var hitFixtures = [];\r\n\r\n        // Query the world for overlapping shapes.\r\n        // Here we return true to keep checking, or false to quit.\r\n        var callback = function (fixture)\r\n        {\r\n            if (onlyDynamic && fixture.GetBody().GetType() !== box2d.b2BodyType.b2_dynamicBody)\r\n            {\r\n                return true;\r\n            }\r\n         \r\n            if (fixture.TestPoint(worldPoint))\r\n            {\r\n                hitFixtures.push(fixture);\r\n                return !onlyOne;\r\n            }\r\n         \r\n            return true;\r\n        };\r\n\r\n        this.world.QueryAABB(callback, aabb);\r\n        \r\n        return hitFixtures;\r\n\r\n    },\r\n\r\n    /**\r\n    * Returns all bodies (Phaser.Physics.Box2D.Body) found under the given coordinates. Set the onlyOne\r\n    * parameter to true if you only care about finding one body.\r\n    *\r\n    * @method Phaser.Physics.Box2D#getBodiesAtPoint\r\n    * @param {number} x - The x coordinate of the location to test for (pixel coordinates)\r\n    * @param {number} y - The y coordinate of the location to test for (pixel coordinates)\r\n    * @param {boolean} [onlyOne=false] - If true, this function will return after finding just one body.\r\n    * @param {boolean} [onlyDynamic=false] - If true, only dynamic bodies will be returned.\r\n    * @return {Array} All bodies that have fixtures at the given point.\r\n    */\r\n    getBodiesAtPoint: function (x, y, onlyOne, onlyDynamic) {\r\n        \r\n        if (typeof onlyOne === 'undefined') { onlyOne = false; }\r\n        if (typeof onlyDynamic === 'undefined') { onlyDynamic = false; }\r\n        \r\n        var fixtures = this.getFixturesAtPoint(x, y, onlyOne, onlyDynamic);\r\n        \r\n        if (fixtures.length < 1)\r\n        {\r\n            return fixtures;\r\n        }\r\n        \r\n        var bodies = [];\r\n\r\n        for (var i = 0; i < fixtures.length; i++)\r\n        {\r\n            bodies.push(fixtures[i].GetBody().parent);\r\n        }\r\n        \r\n        // http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array/9229821\r\n        bodies.filter(function(elem, pos) {\r\n            return bodies.indexOf(elem) === pos;\r\n        });\r\n        \r\n        return bodies;\r\n\r\n    },    \r\n    \r\n    /**\r\n    * If there is a dynamic body under the given point, a mouse joint will be created\r\n    * to drag that body around. Use the mouseDragMove and mouseDragEnd functions to\r\n    * continue the drag action. Any mouse drag already in progress will be canceled.\r\n    *\r\n    * @method Phaser.Physics.Box2D#mouseDragStart\r\n    * @param {Phaser.Point} point - The location for the drag start (pixel coordinates)\r\n    */\r\n    mouseDragStart: function (point) {\r\n        \r\n        this.mouseDragEnd();\r\n        \r\n        var fixturesAtPoint = this.getFixturesAtPoint(point.x, point.y, true, true);\r\n        \r\n        if ( fixturesAtPoint.length < 1 ) {\r\n            return;\r\n        }\r\n        \r\n        var worldx = this.pxm(-point.x);\r\n        var worldy = this.pxm(-point.y);\r\n        var worldPoint = new box2d.b2Vec2(worldx, worldy);\r\n        \r\n        var jd = new box2d.b2MouseJointDef();\r\n        jd.bodyA = this.mouseJointBody;\r\n        jd.bodyB = fixturesAtPoint[0].GetBody();\r\n        jd.target.Copy(worldPoint);\r\n        jd.maxForce = 1000 * jd.bodyB.GetMass();\r\n        this.mouseJoint = this.world.CreateJoint(jd);\r\n        jd.bodyB.SetAwake(true);\r\n    },\r\n    \r\n    /**\r\n    * Updates the target location of the active mouse joint, if there is one. If there\r\n    * is no mouse joint active, this does nothing.\r\n    *\r\n    * @method Phaser.Physics.Box2D#mouseDragMove\r\n    * @param {Phaser.Point} point - The location for the drag move (pixel coordinates)\r\n    */\r\n    mouseDragMove: function (point) {\r\n\r\n        if (!this.mouseJoint)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        var worldx = this.pxm(-point.x);\r\n        var worldy = this.pxm(-point.y);\r\n        var worldPoint = new box2d.b2Vec2(worldx, worldy);\r\n    \r\n        this.mouseJoint.SetTarget(worldPoint);\r\n    \r\n    },\r\n    \r\n    /**\r\n    * Ends the active mouse joint if there is one. If there is no mouse joint active, does nothing.\r\n    *\r\n    * @method Phaser.Physics.Box2D#mouseDragEnd\r\n    */\r\n    mouseDragEnd: function () {\r\n\r\n        if (this.mouseJoint)\r\n        {\r\n            this.world.DestroyJoint(this.mouseJoint);\r\n            this.mouseJoint = null;\r\n        }\r\n    \r\n    },\r\n    \r\n    /**\r\n    * Creates a distance joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#distanceJoint\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined\r\n    * @param {number} length - target length of joint. If not given, the current position of the anchor points will be used to calculate the joint length.\r\n    * @param {number} [ax=0] - local x position of the anchor in bodyA\r\n    * @param {number} [ay=0] - local y position of the anchor in bodyA\r\n    * @param {number} [bx=0] - local x position of the anchor in bodyB\r\n    * @param {number} [by=0] - local y position of the anchor in bodyB\r\n    * @param {number} [frequency=0] - frequency of joint\r\n    * @param {number} [damping=0] - damping of joint\r\n    * @return {box2d.b2DistanceJoint} The created joint.\r\n    */\r\n    distanceJoint: function (bodyA, bodyB, length, ax, ay, bx, by, frequency, damping) {\r\n        \r\n        if ( typeof ax === 'undefined' ) { ax = 0; }\r\n        if ( typeof ay === 'undefined' ) { ay = 0; }\r\n        if ( typeof bx === 'undefined' ) { bx = 0; }\r\n        if ( typeof by === 'undefined' ) { by = 0; }        \r\n        if ( typeof frequency === 'undefined' ) { frequency = 0; }\r\n        if ( typeof damping === 'undefined' ) { damping = 0; }\r\n        \r\n        ax = this.pxm(-ax);\r\n        ay = this.pxm(-ay);\r\n        bx = this.pxm(-bx);\r\n        by = this.pxm(-by);        \r\n        \r\n        // Could be a sprite\r\n        if (bodyA['body'])\r\n        {\r\n            bodyA = bodyA['body'];\r\n        }\r\n\r\n        if (bodyB['body'])\r\n        {\r\n            bodyB = bodyB['body'];\r\n        }\r\n        \r\n        var jd = new box2d.b2DistanceJointDef();\r\n\r\n        jd.bodyA = bodyA.data;\r\n        jd.bodyB = bodyB.data;\r\n\r\n        jd.localAnchorA.SetXY( ax, ay );\r\n        jd.localAnchorB.SetXY( bx, by );\r\n        \r\n        if (length === null || typeof length === 'undefined')\r\n        {\r\n            // Set length to current\r\n            var worldAnchorA = new box2d.b2Vec2();\r\n            var worldAnchorB = new box2d.b2Vec2();\r\n\r\n            jd.bodyA.GetWorldPoint(jd.localAnchorA, worldAnchorA);\r\n            jd.bodyB.GetWorldPoint(jd.localAnchorB, worldAnchorB);\r\n\r\n            worldAnchorA.SelfSub(worldAnchorB);\r\n            length = worldAnchorA.Length();\r\n        }\r\n        else\r\n        {\r\n            length = this.pxm(length);\r\n        }\r\n        \r\n        jd.length = length;\r\n        jd.frequencyHz = frequency;\r\n        jd.dampingRatio = damping;\r\n        \r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n    \r\n    /**\r\n    * Creates a rope joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#ropeJoint\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined\r\n    * @param {number} length - target length of joint. If not given, the current position of the anchor points will be used to calculate the joint length.\r\n    * @param {number} [ax=0] - local x position of the anchor in bodyA\r\n    * @param {number} [ay=0] - local y position of the anchor in bodyA\r\n    * @param {number} [bx=0] - local x position of the anchor in bodyB\r\n    * @param {number} [by=0] - local y position of the anchor in bodyB\r\n    * @return {box2d.b2RopeJoint} The created joint.\r\n    */\r\n    ropeJoint: function (bodyA, bodyB, length, ax, ay, bx, by) {\r\n        \r\n        if ( typeof ax === 'undefined' ) { ax = 0; }\r\n        if ( typeof ay === 'undefined' ) { ay = 0; }\r\n        if ( typeof bx === 'undefined' ) { bx = 0; }\r\n        if ( typeof by === 'undefined' ) { by = 0; }\r\n        \r\n        ax = this.pxm(-ax);\r\n        ay = this.pxm(-ay);\r\n        bx = this.pxm(-bx);\r\n        by = this.pxm(-by);        \r\n        \r\n        // Could be a sprite\r\n        if (bodyA['body'])\r\n        {\r\n            bodyA = bodyA['body'];\r\n        }\r\n\r\n        if (bodyB['body'])\r\n        {\r\n            bodyB = bodyB['body'];\r\n        }\r\n        \r\n        var jd = new box2d.b2RopeJointDef();\r\n\r\n        jd.bodyA = bodyA.data;\r\n        jd.bodyB = bodyB.data;\r\n\r\n        jd.localAnchorA.SetXY( ax, ay );\r\n        jd.localAnchorB.SetXY( bx, by );\r\n        \r\n        if (length === null || typeof length === 'undefined')\r\n        {\r\n            // Set length to current\r\n            var worldAnchorA = new box2d.b2Vec2();\r\n            var worldAnchorB = new box2d.b2Vec2();\r\n\r\n            jd.bodyA.GetWorldPoint(jd.localAnchorA, worldAnchorA);\r\n            jd.bodyB.GetWorldPoint(jd.localAnchorB, worldAnchorB);\r\n\r\n            worldAnchorA.SelfSub(worldAnchorB);\r\n            length = worldAnchorA.Length();\r\n        }\r\n        else\r\n        {\r\n            length = this.pxm(length);\r\n        }\r\n        \r\n        jd.maxLength = length;\r\n        \r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n    \r\n    /**\r\n    * Creates a revolute joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#revoluteJoint\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined\r\n    * @param {number} [ax=0] - local x position of the anchor in bodyA\r\n    * @param {number} [ay=0] - local y position of the anchor in bodyA\r\n    * @param {number} [bx=0] - local x position of the anchor in bodyB\r\n    * @param {number} [by=0] - local y position of the anchor in bodyB\r\n    * @param {number} [motorSpeed=0] - target speed (degrees/second), measured as the angle of bodyB relative to bodyA, counter-clockwise being positive\r\n    * @param {number} [motorTorque=0] - maximum torque the joint motor can exert to maintain the target speed\r\n    * @param {boolean} [motorEnabled=false] - Is the motor enabled or not?\r\n    * @param {number} [lowerLimit=0] - the lower limit angle (degrees), measured as the angle of bodyB relative to bodyA\r\n    * @param {number} [upperLimit=0] - the upper limit angle (degrees), measured as the angle of bodyB relative to bodyA\r\n    * @param {boolean} [limitEnabled=false] - Is the limit enabled?\r\n    * @return {box2d.b2RevoluteJoint} The created joint.\r\n    */\r\n    revoluteJoint: function (bodyA, bodyB, ax, ay, bx, by, motorSpeed, motorTorque, motorEnabled, lowerLimit, upperLimit, limitEnabled) {\r\n        \r\n        if ( typeof ax === 'undefined' ) { ax = 0; }\r\n        if ( typeof ay === 'undefined' ) { ay = 0; }\r\n        if ( typeof bx === 'undefined' ) { bx = 0; }\r\n        if ( typeof by === 'undefined' ) { by = 0; }\r\n        if ( typeof motorSpeed === 'undefined' ) { motorSpeed = 0; }\r\n        if ( typeof motorTorque === 'undefined' ) { motorTorque = 0; }\r\n        if ( typeof motorEnabled === 'undefined' ) { motorEnabled = false; }\r\n        if ( typeof lowerLimit === 'undefined' ) { lowerLimit = 0; }\r\n        if ( typeof upperLimit === 'undefined' ) { upperLimit = 0; }\r\n        if ( typeof limitEnabled === 'undefined' ) { limitEnabled = false; }\r\n        \r\n        ax = this.pxm(-ax);\r\n        ay = this.pxm(-ay);\r\n        bx = this.pxm(-bx);\r\n        by = this.pxm(-by);        \r\n        \r\n        // Could be a sprite\r\n        if (bodyA['body'])\r\n        {\r\n            bodyA = bodyA['body'];\r\n        }\r\n\r\n        if (bodyB['body'])\r\n        {\r\n            bodyB = bodyB['body'];\r\n        }\r\n        \r\n        var jd = new box2d.b2RevoluteJointDef();\r\n\r\n        jd.bodyA = bodyA.data;\r\n        jd.bodyB = bodyB.data;\r\n\r\n        jd.localAnchorA.SetXY( ax, ay );\r\n        jd.localAnchorB.SetXY( bx, by );\r\n        \r\n        jd.motorSpeed = Phaser.Math.degToRad(-motorSpeed);\r\n        jd.maxMotorTorque = motorTorque;\r\n        jd.enableMotor = motorEnabled;\r\n        jd.lowerAngle = Phaser.Math.degToRad(lowerLimit);\r\n        jd.upperAngle = Phaser.Math.degToRad(upperLimit);\r\n        jd.enableLimit = limitEnabled;\r\n        \r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n    \r\n    /**\r\n    * Creates a prismatic joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#prismaticJoint\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined\r\n    * @param {number} [axisX=1] - the x component of the joint axis\r\n    * @param {number} [axisY=0] - the y component of the joint axis\r\n    * @param {number} [ax=0] - local x position of the anchor in bodyA\r\n    * @param {number} [ay=0] - local y position of the anchor in bodyA\r\n    * @param {number} [bx=0] - local x position of the anchor in bodyB\r\n    * @param {number} [by=0] - local y position of the anchor in bodyB\r\n    * @param {number} [motorSpeed=0] - target speed (pixels/second), measured along the joint axis\r\n    * @param {number} [motorForce=0] - maximum torque the joint motor can exert to maintain the target speed\r\n    * @param {boolean} [motorEnabled=false] -Is the motor enabled?\r\n    * @param {number} [lowerLimit=0] - the lower limit angle (pixels), measured along the joint axis\r\n    * @param {number} [upperLimit=0] - the upper limit angle (pixels), measured along the joint axis\r\n    * @param {boolean} [limitEnabled=false] - Is the joint limit enabled?\r\n    * @param {number} [offsetAngle=0] - angle (degrees) relative to bodyA, to which bodyB should be rotated, counter-clockwise being positive\r\n    * @return {box2d.b2PrismaticJoint} The created joint.\r\n    */\r\n    prismaticJoint: function (bodyA, bodyB, axisX, axisY, ax, ay, bx, by, motorSpeed, motorForce, motorEnabled, lowerLimit, upperLimit, limitEnabled, offsetAngle) {\r\n        \r\n        if ( typeof axisX === 'undefined' ) { axisX = 1; }\r\n        if ( typeof axisY === 'undefined' ) { axisY = 0; }\r\n        if ( typeof ax === 'undefined' ) { ax = 0; }\r\n        if ( typeof ay === 'undefined' ) { ay = 0; }\r\n        if ( typeof bx === 'undefined' ) { bx = 0; }\r\n        if ( typeof by === 'undefined' ) { by = 0; }\r\n        if ( typeof motorSpeed === 'undefined' ) { motorSpeed = 0; }\r\n        if ( typeof motorForce === 'undefined' ) { motorForce = 0; }\r\n        if ( typeof lowerLimit === 'undefined' ) { lowerLimit = 0; }\r\n        if ( typeof upperLimit === 'undefined' ) { upperLimit = 0; }\r\n        if ( typeof limitEnabled === 'undefined' ) { limitEnabled = false; }\r\n        if ( typeof motorEnabled === 'undefined' ) { motorEnabled = false; }\r\n        if ( typeof offsetAngle === 'undefined' ) { offsetAngle = 0; }\r\n        \r\n        // Axis is only for direction, so don't need pxm conversion\r\n        axisX *= -1;\r\n        axisY *= -1;\r\n        \r\n        ax = this.pxm(-ax);\r\n        ay = this.pxm(-ay);\r\n        bx = this.pxm(-bx);\r\n        by = this.pxm(-by);\r\n        \r\n        // These are relative to axis, which has been converted already, so only do size change\r\n        motorSpeed = this.pxm(motorSpeed);\r\n        lowerLimit = this.pxm(lowerLimit);\r\n        upperLimit = this.pxm(upperLimit);\r\n        \r\n        // Could be a sprite\r\n        if (bodyA['body'])\r\n        {\r\n            bodyA = bodyA['body'];\r\n        }\r\n\r\n        if (bodyB['body'])\r\n        {\r\n            bodyB = bodyB['body'];\r\n        }\r\n        \r\n        var jd = new box2d.b2PrismaticJointDef();\r\n\r\n        jd.bodyA = bodyA.data;\r\n        jd.bodyB = bodyB.data;\r\n\r\n        jd.localAxisA.SetXY( axisX, axisY );\r\n        jd.localAnchorA.SetXY( ax, ay );\r\n        jd.localAnchorB.SetXY( bx, by );\r\n        \r\n        jd.motorSpeed = motorSpeed;\r\n        jd.maxMotorForce = motorForce;\r\n        jd.enableMotor = motorEnabled;\r\n        jd.lowerTranslation = lowerLimit;\r\n        jd.upperTranslation = upperLimit;\r\n        jd.enableLimit = limitEnabled;\r\n        jd.referenceAngle = Phaser.Math.degToRad(-offsetAngle);\r\n        \r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n    \r\n    /**\r\n    * Creates a friction joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#frictionJoint\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined\r\n    * @param {number} [ax=0] - local x position of the anchor in bodyA\r\n    * @param {number} [ay=0] - local y position of the anchor in bodyA\r\n    * @param {number} [bx=0] - local x position of the anchor in bodyB\r\n    * @param {number} [by=0] - local y position of the anchor in bodyB\r\n    * @param {number} [maxForce=0] - maximum force the joint can exert to maintain zero linear velocity between the two bodies\r\n    * @param {number} [maxTorque=0] - maximum torque the joint can exert to maintain zero angular velocity between the two bodies\r\n    * @return {box2d.b2FrictionJoint} The created joint.\r\n    */\r\n    frictionJoint: function (bodyA, bodyB, maxForce, maxTorque, ax, ay, bx, by) {\r\n        \r\n        if ( typeof ax === 'undefined' ) { ax = 0; }\r\n        if ( typeof ay === 'undefined' ) { ay = 0; }\r\n        if ( typeof bx === 'undefined' ) { bx = 0; }\r\n        if ( typeof by === 'undefined' ) { by = 0; }\r\n        if ( typeof maxForce === 'undefined' ) { maxForce = 0; }\r\n        if ( typeof maxTorque === 'undefined' ) { maxTorque = 0; }\r\n        \r\n        ax = this.pxm(-ax);\r\n        ay = this.pxm(-ay);\r\n        bx = this.pxm(-bx);\r\n        by = this.pxm(-by);\r\n        \r\n        // Could be a sprite\r\n        if (bodyA['body'])\r\n        {\r\n            bodyA = bodyA['body'];\r\n        }\r\n\r\n        if (bodyB['body'])\r\n        {\r\n            bodyB = bodyB['body'];\r\n        }\r\n        \r\n        var jd = new box2d.b2FrictionJointDef();\r\n\r\n        jd.bodyA = bodyA.data;\r\n        jd.bodyB = bodyB.data;\r\n\r\n        jd.localAnchorA.SetXY( ax, ay );\r\n        jd.localAnchorB.SetXY( bx, by );\r\n        \r\n        jd.maxForce = maxForce;\r\n        jd.maxTorque = maxTorque;\r\n        \r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n    \r\n    /**\r\n    * Creates a weld joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#weldJoint\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined\r\n    * @param {number} [ax=0] - local x position of the anchor in bodyA\r\n    * @param {number} [ay=0] - local y position of the anchor in bodyA\r\n    * @param {number} [bx=0] - local x position of the anchor in bodyB\r\n    * @param {number} [by=0] - local y position of the anchor in bodyB\r\n    * @param {number} [frequency=0] - frequency of joint\r\n    * @param {number} [damping=0] - damping of joint\r\n    * @return {box2d.b2WeldJoint} The created joint.\r\n    */\r\n    weldJoint: function (bodyA, bodyB, ax, ay, bx, by, frequency, damping) {\r\n        \r\n        if ( typeof ax === 'undefined' ) { ax = 0; }\r\n        if ( typeof ay === 'undefined' ) { ay = 0; }\r\n        if ( typeof bx === 'undefined' ) { bx = 0; }\r\n        if ( typeof by === 'undefined' ) { by = 0; }\r\n        if ( typeof frequency === 'undefined' ) { frequency = 0; }\r\n        if ( typeof damping === 'undefined' ) { damping = 0; }\r\n        \r\n        ax = this.pxm(-ax);\r\n        ay = this.pxm(-ay);\r\n        bx = this.pxm(-bx);\r\n        by = this.pxm(-by);\r\n        \r\n        // Could be a sprite\r\n        if (bodyA['body'])\r\n        {\r\n            bodyA = bodyA['body'];\r\n        }\r\n\r\n        if (bodyB['body'])\r\n        {\r\n            bodyB = bodyB['body'];\r\n        }\r\n        \r\n        var jd = new box2d.b2WeldJointDef();\r\n\r\n        jd.bodyA = bodyA.data;\r\n        jd.bodyB = bodyB.data;\r\n\r\n        jd.localAnchorA.SetXY( ax, ay );\r\n        jd.localAnchorB.SetXY( bx, by );\r\n        \r\n        jd.frequencyHz = frequency;\r\n        jd.dampingRatio = damping;\r\n        \r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n    \r\n    /**\r\n    * Creates a motor joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#motorJoint\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined\r\n    * @param {number} [offsetX=0] - local x position in bodyA to which bodyB should be moved\r\n    * @param {number} [offsetY=0] - local y position in bodyA to which bodyB should be moved\r\n    * @param {number} [offsetAngle=0] - angle (degrees) relative to bodyA, to which bodyB should be rotated\r\n    * @param {number} [maxForce=0] - maximum force the joint can exert to move bodyB to the offset position\r\n    * @param {number} [maxTorque=0] - maximum torque the joint can exert to rotate bodyB to the offset angle\r\n    * @param {number} [correctionFactor=1] - how quickly the joint should attempt to correct the position of bodyB\r\n    * @return {box2d.b2MotorJoint} The created joint.\r\n    */\r\n    motorJoint: function (bodyA, bodyB, maxForce, maxTorque, correctionFactor, offsetX, offsetY, offsetAngle) {\r\n        \r\n        if ( typeof offsetX === 'undefined' ) { offsetX = 0; }\r\n        if ( typeof offsetY === 'undefined' ) { offsetY = 0; }\r\n        if ( typeof offsetAngle === 'undefined' ) { offsetAngle = 0; }\r\n        if ( typeof maxForce === 'undefined' ) { maxForce = 0; }\r\n        if ( typeof maxTorque === 'undefined' ) { maxTorque = 0; }\r\n        if ( typeof correctionFactor === 'undefined' ) { correctionFactor = 1; }\r\n        \r\n        offsetX = this.pxm(-offsetX);\r\n        offsetY = this.pxm(-offsetY);\r\n        \r\n        // Could be a sprite\r\n        if (bodyA['body'])\r\n        {\r\n            bodyA = bodyA['body'];\r\n        }\r\n\r\n        if (bodyB['body'])\r\n        {\r\n            bodyB = bodyB['body'];\r\n        }\r\n        \r\n        var jd = new box2d.b2MotorJointDef();\r\n\r\n        jd.bodyA = bodyA.data;\r\n        jd.bodyB = bodyB.data;\r\n        jd.linearOffset.SetXY( offsetX, offsetY );\r\n        \r\n        jd.maxForce = maxForce;\r\n        jd.maxTorque = maxTorque;\r\n        jd.angularOffset = Phaser.Math.degToRad(-offsetAngle);\r\n        jd.correctionFactor = correctionFactor;\r\n        \r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n    \r\n    /**\r\n    * Creates a wheel joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#wheelJoint\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined\r\n    * @param {number} [ax=0] - local x position of the anchor in bodyA\r\n    * @param {number} [ay=0] - local y position of the anchor in bodyA\r\n    * @param {number} [bx=0] - local x position of the anchor in bodyB\r\n    * @param {number} [by=0] - local y position of the anchor in bodyB\r\n    * @param {number} [axisX=0] - the x component of the joint axis\r\n    * @param {number} [axisY=1] - the y component of the joint axis\r\n    * @param {number} [frequency=0] - frequency of joint\r\n    * @param {number} [damping=0] - damping of joint\r\n    * @param {number} [motorSpeed=0] - target speed (degrees/second), measured as the angle of bodyB relative to bodyA, counter-clockwise being positive.\r\n    * @param {number} [motorTorque=0] - maximum torque the joint motor can exert to maintain the target speed\r\n    * @param {boolean} [motorEnabled=false] - Is the motor enabled?\r\n    * @return {box2d.b2WheelJoint} The created joint.\r\n    */\r\n    wheelJoint: function (bodyA, bodyB, ax, ay, bx, by, axisX, axisY, frequency, damping, motorSpeed, motorTorque, motorEnabled) {\r\n        \r\n        if ( typeof axisX === 'undefined' ) { axisX = 0; }\r\n        if ( typeof axisY === 'undefined' ) { axisY = 1; }\r\n        if ( typeof ax === 'undefined' ) { ax = 0; }\r\n        if ( typeof ay === 'undefined' ) { ay = 0; }\r\n        if ( typeof bx === 'undefined' ) { bx = 0; }\r\n        if ( typeof by === 'undefined' ) { by = 0; }\r\n        if ( typeof motorSpeed === 'undefined' ) { motorSpeed = 0; }\r\n        if ( typeof motorTorque === 'undefined' ) { motorTorque = 0; }\r\n        if ( typeof motorEnabled === 'undefined' ) { motorEnabled = false; }\r\n        if ( typeof frequency === 'undefined' ) { frequency = 0; }\r\n        if ( typeof damping === 'undefined' ) { damping = 0; }\r\n                \r\n        // Axis is only for direction, so don't need pxm conversion\r\n        axisX *= -1;\r\n        axisY *= -1;\r\n        \r\n        ax = this.pxm(-ax);\r\n        ay = this.pxm(-ay);\r\n        bx = this.pxm(-bx);\r\n        by = this.pxm(-by);\r\n\r\n        // Could be a sprite\r\n        if (bodyA['body'])\r\n        {\r\n            bodyA = bodyA['body'];\r\n        }\r\n\r\n        if (bodyB['body'])\r\n        {\r\n            bodyB = bodyB['body'];\r\n        }\r\n        \r\n        var jd = new box2d.b2WheelJointDef();\r\n\r\n        jd.bodyA = bodyA.data;\r\n        jd.bodyB = bodyB.data;\r\n\r\n        jd.localAxisA.SetXY( axisX, axisY );\r\n        jd.localAnchorA.SetXY( ax, ay );\r\n        jd.localAnchorB.SetXY( bx, by );\r\n        \r\n        jd.motorSpeed = Phaser.Math.degToRad(-motorSpeed);\r\n        jd.maxMotorTorque = motorTorque;\r\n        jd.enableMotor = motorEnabled;\r\n        jd.frequencyHz = frequency;\r\n        jd.dampingRatio = damping;\r\n\r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n    \r\n    /**\r\n    * Creates a pulley joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#pulleyJoint\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyA - first body to be joined\r\n    * @param {Phaser.Physics.Box2D.Body|Phaser.Sprite} bodyB - second body to be joined\r\n    * @param {number} [ax=0] - local x position of the anchor in bodyA\r\n    * @param {number} [ay=0] - local y position of the anchor in bodyA\r\n    * @param {number} [bx=0] - local x position of the anchor in bodyB\r\n    * @param {number} [by=0] - local y position of the anchor in bodyB\r\n    * @param {number} [gax=0] - world x position of the ground anchor of bodyA\r\n    * @param {number} [gay=0] - world y position of the ground anchor of bodyA\r\n    * @param {number} [gbx=0] - world x position of the ground anchor of bodyB\r\n    * @param {number} [gby=0] - world y position of the ground anchor of bodyB\r\n    * @param {number} [ratio=1] - the ratio of movement between the two sides of the pulley\r\n    * @param {number} [lengthA=100] - the length of pulley between bodyA and the ground anchor A\r\n    * @param {number} [lengthB=100] - the length of pulley between bodyB and the ground anchor B\r\n    * @return {box2d.b2PulleyJoint} The created joint.\r\n    */\r\n    pulleyJoint: function (bodyA, bodyB, ax, ay, bx, by, gax, gay, gbx, gby, ratio, lengthA, lengthB) {\r\n        \r\n        if ( typeof ax === 'undefined' ) { ax = 0; }\r\n        if ( typeof ay === 'undefined' ) { ay = 0; }\r\n        if ( typeof bx === 'undefined' ) { bx = 0; }\r\n        if ( typeof by === 'undefined' ) { by = 0; }\r\n        if ( typeof gax === 'undefined' ) { gax = 0; }\r\n        if ( typeof gay === 'undefined' ) { gay = 0; }\r\n        if ( typeof gbx === 'undefined' ) { gbx = 0; }\r\n        if ( typeof gby === 'undefined' ) { gby = 0; }\r\n        if ( typeof ratio === 'undefined' ) { ratio = 1; }\r\n        if ( typeof lengthA === 'undefined' ) { lengthA = 100; }\r\n        if ( typeof lengthB === 'undefined' ) { lengthB = 100; }\r\n        \r\n        ax = this.pxm(-ax);\r\n        ay = this.pxm(-ay);\r\n        bx = this.pxm(-bx);\r\n        by = this.pxm(-by);\r\n        gax = this.pxm(-gax);\r\n        gay = this.pxm(-gay);\r\n        gbx = this.pxm(-gbx);\r\n        gby = this.pxm(-gby);\r\n        lengthA = this.pxm(lengthA);\r\n        lengthB = this.pxm(lengthB);\r\n                \r\n        // Could be a sprite\r\n        if (bodyA['body'])\r\n        {\r\n            bodyA = bodyA['body'];\r\n        }\r\n\r\n        if (bodyB['body'])\r\n        {\r\n            bodyB = bodyB['body'];\r\n        }\r\n        \r\n        var jd = new box2d.b2PulleyJointDef();\r\n\r\n        jd.bodyA = bodyA.data;\r\n        jd.bodyB = bodyB.data;\r\n\r\n        jd.localAnchorA.SetXY( ax, ay );\r\n        jd.localAnchorB.SetXY( bx, by );\r\n        jd.groundAnchorA.SetXY( gax, gay );\r\n        jd.groundAnchorB.SetXY( gbx, gby );\r\n        \r\n        jd.lengthA = lengthA;\r\n        jd.lengthB = lengthB;\r\n        jd.ratio = ratio;\r\n        \r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n    \r\n    /**\r\n    * Creates a gear joint.\r\n    *\r\n    * @method Phaser.Physics.Box2D#gearJoint\r\n    * @param {box2d.b2Joint} joint1 - first joint to be gear-joined\r\n    * @param {box2d.b2Joint} joint2 - second joint to be gear-joined\r\n    * @param {number} [ratio=1] - ratio for gearing\r\n    * @return {box2d.b2PulleyJoint} The created joint.\r\n    */\r\n    gearJoint: function (joint1, joint2, ratio) {\r\n        \r\n        if ( typeof ratio === 'undefined' ) { ratio = 1; }\r\n        \r\n        var jd = new box2d.b2GearJointDef();\r\n        jd.joint1 = joint1;\r\n        jd.joint2 = joint2;\r\n        jd.ratio = -ratio;\r\n\r\n        jd.bodyA = joint1.GetBodyA();\r\n        jd.bodyB = joint2.GetBodyB();\r\n        \r\n        return this.world.CreateJoint(jd);\r\n\r\n    },\r\n\r\n    /**\r\n    * Clears all physics bodies from the given TilemapLayer that were created with `World.convertTilemap`.\r\n    *\r\n    * @method Phaser.Physics.Box2D#clearTilemapLayerBodies\r\n    * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\r\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.\r\n    */\r\n    clearTilemapLayerBodies: function (map, layer) {\r\n\r\n        layer = map.getLayer(layer);\r\n\r\n        var i = map.layers[layer].bodies.length;\r\n\r\n        while (i--)\r\n        {\r\n            map.layers[layer].bodies[i].destroy();\r\n        }\r\n\r\n        map.layers[layer].bodies.length = 0;\r\n\r\n    },\r\n\r\n    /**\r\n    * Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics bodies.\r\n    * Only call this *after* you have specified all of the tiles you wish to collide with calls like Tilemap.setCollisionBetween, etc.\r\n    * Every time you call this method it will destroy any previously created bodies and remove them from the world.\r\n    * Therefore understand it's a very expensive operation and not to be done in a core game update loop.\r\n    *\r\n    * @method Phaser.Physics.Box2D#convertTilemap\r\n    * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\r\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.\r\n    * @param {boolean} [addToWorld=true] - If true it will automatically add each body to the world, otherwise it's up to you to do so.\r\n    * @param {boolean} [optimize=true] - If true adjacent colliding tiles will be combined into a single body to save processing. However it means you cannot perform specific Tile to Body collision responses.\r\n    * @return {array} An array of the Phaser.Physics.Box2D.Body objects that were created.\r\n    */\r\n    convertTilemap: function (map, layer, addToWorld, optimize) {\r\n\r\n        layer = map.getLayer(layer);\r\n\r\n        if (typeof addToWorld === 'undefined') { addToWorld = true; }\r\n        if (typeof optimize === 'undefined') { optimize = true; }\r\n\r\n        //  If the bodies array is already populated we need to nuke it\r\n        this.clearTilemapLayerBodies(map, layer);\r\n\r\n        var width = 0;\r\n        var sx = 0;\r\n        var sy = 0;\r\n\r\n        for (var y = 0, h = map.layers[layer].height; y < h; y++)\r\n        {\r\n            width = 0;\r\n\r\n            for (var x = 0, w = map.layers[layer].width; x < w; x++)\r\n            {\r\n                var tile = map.layers[layer].data[y][x];\r\n\r\n                if (tile && tile.index > -1 && tile.collides)\r\n                {\r\n                    if (optimize)\r\n                    {\r\n                        var right = map.getTileRight(layer, x, y);\r\n\r\n                        if (width === 0)\r\n                        {\r\n                            sx = tile.x * tile.width;\r\n                            sy = tile.y * tile.height;\r\n                            width = tile.width;\r\n                        }\r\n\r\n                        if (right && right.collides)\r\n                        {\r\n                            width += tile.width;\r\n                        }\r\n                        else\r\n                        {\r\n                            var body = new Phaser.Physics.Box2D.Body(this.game, null, sx, sy, 0);\r\n\r\n                            body.addRectangle(width, tile.height, width / 2, tile.height / 2, 0);\r\n\r\n                            if (addToWorld)\r\n                            {\r\n                                this.addBody(body);\r\n                            }\r\n\r\n                            map.layers[layer].bodies.push(body);\r\n\r\n                            width = 0;\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        var body = this.createBody(tile.x * tile.width, tile.y * tile.height, 0, false);\r\n\r\n                        body.addRectangle(tile.width, tile.height, tile.width / 2, tile.height / 2, 0);\r\n\r\n                        if (addToWorld)\r\n                        {\r\n                            this.addBody(body);\r\n                        }\r\n\r\n                        map.layers[layer].bodies.push(body);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return map.layers[layer].bodies;\r\n\r\n    },\r\n    \r\n    /**\r\n    * Casts a ray and finds intersecting fixtures in the world.\r\n    *\r\n    * @method Phaser.Physics.Box2D#raycast\r\n    * @param {number} x1 - x location of start point (pixels)\r\n    * @param {number} y1 - y location of start point (pixels)\r\n    * @param {number} x2 - x location of end point (pixels)\r\n    * @param {number} y2 - y location of end point (pixels)\r\n    * @param {boolean} [closestHitOnly=true] - set to true if you want only the closest hit\r\n    * @param {function} [filterFunction=null] - a function to be called for each hit, to decide which should be ignored\r\n    * @return {Array} array of hits, as objects with body, fixture, point and normal properties. Eg. [ {body,fixture,point:{x,y},normal:{x,y}}, {body,fixture,point:{x,y},normal:{x,y}} ]\r\n    */\r\n    raycast: function (x1, y1, x2, y2, closestHitOnly, filterFunction) {\r\n        \r\n        if ( typeof closestHitOnly === 'undefined' ) { closestHitOnly = true; }\r\n        if ( typeof filterFunction === 'undefined' ) { filterFunction = null; }\r\n        \r\n        x1 = this.pxm(-x1);\r\n        y1 = this.pxm(-y1);\r\n        x2 = this.pxm(-x2);\r\n        y2 = this.pxm(-y2);\r\n\r\n        var point1 = new box2d.b2Vec2(x1, y1);\r\n        var point2 = new box2d.b2Vec2(x2, y2);\r\n        \r\n        var output = [];\r\n                \r\n        var callback = new Phaser.Physics.Box2D.RayCastCallback(this, closestHitOnly, filterFunction);\r\n        this.world.RayCast(callback, point1, point2);\r\n        \r\n        // Need to convert coordinates of hit points to pixels before returning\r\n        for (var i = 0; i < callback.hits.length; i++ )\r\n        {\r\n            var hit = callback.hits[i];\r\n            hit.point = { x: this.mpx(-hit.point.x), y: this.mpx(-hit.point.y) };\r\n            hit.normal = { x: -hit.normal.x, y: -hit.normal.y };\r\n            output.push(hit);\r\n        }\r\n        \r\n        return output;\r\n\r\n    },\r\n    \r\n    /**\r\n    * Finds all fixtures with AABBs overlapping the given area. This does NOT mean\r\n    * that the fixtures themselves are actually overlapping the given area.\r\n    *\r\n    * @method Phaser.Physics.Box2D#queryAABB\r\n    * @param {number} x - x location of AABB corner (pixels)\r\n    * @param {number} y - y location of AABB corner (pixels)\r\n    * @param {number} width - AABB width (pixels)\r\n    * @param {number} height - AABB width (pixels)\r\n    * @return {Array} array of hits, as objects with body and fixture properties. Eg. [ {body,fixture}, {body,fixture} ]\r\n    */\r\n    queryAABB: function (x, y, width, height) {\r\n                \r\n        x = this.pxm(-x);\r\n        y = this.pxm(-y);\r\n        width = this.pxm(width);\r\n        height = this.pxm(height);\r\n        \r\n        var aabb = new box2d.b2AABB();\r\n        aabb.lowerBound.SetXY( x - width, y - height );\r\n        aabb.upperBound.SetXY( x, y );\r\n        \r\n        var callback = new Phaser.Physics.Box2D.QueryCallback(this);\r\n        this.world.QueryAABB(callback, aabb);\r\n        \r\n        return callback.hits;\r\n\r\n    },\r\n    \r\n    /**\r\n    * Finds all fixtures that overlap the given fixture.\r\n    *\r\n    * @method Phaser.Physics.Box2D#queryFixture\r\n    * @param {box2d.b2Fixture} fixture - the fixture to test overlapping for\r\n    * @return {Array} array of hits, as objects with body and fixture properties. Eg. [ {body,fixture}, {body,fixture} ]\r\n    */\r\n    queryFixture: function (fixture) {\r\n                \r\n        var callback = new Phaser.Physics.Box2D.QueryCallback(this);\r\n        this.world.QueryShape(callback, fixture.GetShape(), fixture.GetBody().GetTransform());\r\n        \r\n        return callback.hits;\r\n\r\n    },\r\n\r\n    /**\r\n     * If the PTM ratio is changed after creating the world, the debug draw scale needs to be updated.\r\n     *\r\n     * @method Phaser.Physics.Box2D#setPTMRatio\r\n     * @param {number} newRatio - The new ratio to be used for the DebugDraw.\r\n     */\r\n    setPTMRatio: function (newRatio) {\r\n        \r\n        this.ptmRatio = newRatio;\r\n        this.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.ptmRatio);\r\n        this.world.SetDebugDraw(this.debugDraw);\r\n        \r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Raycast callback, can return either all hits or just the closest, and use a function to filter hits.\r\n * Intended for internal use by the 'raycast' function\r\n * @constructor\r\n * @extends {box2d.b2RayCastCallback}\r\n * @param {Phaser.Physics.Box2D} world\r\n * @param {boolean} closestHitOnly\r\n * @param {function} filterFunction\r\n */\r\nPhaser.Physics.Box2D.RayCastCallback = function(world, closestHitOnly, filterFunction)\r\n{\r\n    this.world = world;\r\n    this.closestHitOnly = closestHitOnly;\r\n    this.filterFunction = filterFunction;    \r\n    this.hits = [];\r\n};\r\n\r\ngoog.inherits(Phaser.Physics.Box2D.RayCastCallback, box2d.b2RayCastCallback);\r\n\r\n/**\r\n * Internally used callback function for raycasting. Checks each reported fixture as it is discovered,\r\n * to see which should be ignored and which should be used.\r\n * \r\n * @param {box2d.b2Fixture} fixture \r\n * @param {box2d.b2Vec2} point \r\n * @param {box2d.b2Vec2} normal \r\n * @param {number} fraction \r\n * @return {number} \r\n */\r\nPhaser.Physics.Box2D.RayCastCallback.prototype.ReportFixture = function (fixture, point, normal, fraction)\r\n{\r\n    // If a filter function was given, use that to decide if this hit should be ignored\r\n    if (this.filterFunction !== null )\r\n    {\r\n        var pxPoint = { x: this.world.mpx(-point.x), y: this.world.mpx(-point.y) };\r\n        var pxNormal = { x: -normal.x, y: -normal.y };\r\n        var body = fixture.GetBody().parent;\r\n\r\n        if (!this.filterFunction.call(this, body, fixture, pxPoint, pxNormal))\r\n        {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    // If we are looking for the closest hit, we will have returned 'fraction' from any previously\r\n    // reported hits to clip the ray length, so we know this hit is closer than what we already had.\r\n    if (this.closestHitOnly)\r\n    {\r\n        this.hits = [];\r\n    }\r\n    \r\n    var hit = {};\r\n    hit.body = fixture.GetBody().parent;\r\n    hit.fixture = fixture;\r\n    hit.point = { x: point.x, y: point.y };\r\n    hit.normal = { x: normal.x, y: normal.y };\r\n    this.hits.push(hit);\r\n    \r\n    if (this.closestHitOnly)\r\n    {\r\n        return fraction;\r\n    }\r\n    else\r\n    {\r\n        return 1;\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Query callback, can use a function to filter hits.\r\n * Intended for internal use by the 'queryAABB' function\r\n * @constructor\r\n * @param {Phaser.Physics.Box2D} world\r\n * @extends {box2d.b2QueryCallback}\r\n */\r\nPhaser.Physics.Box2D.QueryCallback = function(world)\r\n{\r\n    this.world = world;  \r\n    this.hits = [];\r\n};\r\n\r\ngoog.inherits(Phaser.Physics.Box2D.QueryCallback, box2d.b2QueryCallback);\r\n\r\n/**\r\n * Internally used callback function for raycasting. Checks each reported fixture as it is discovered,\r\n * to see which should be ignored and which should be used.\r\n * \r\n * @param {box2d.b2Fixture} fixture\r\n * @return {number} \r\n */\r\nPhaser.Physics.Box2D.QueryCallback.prototype.ReportFixture = function (fixture)\r\n{    \r\n    var hit = {};\r\n    hit.body = fixture.GetBody().parent;\r\n    hit.fixture = fixture;\r\n    this.hits.push(hit);\r\n    \r\n    return true;\r\n};\r\n\r\n/**\r\n* Renders the fixtures of the given body.\r\n*\r\n* @method Phaser.Physics.Box2D#renderBody\r\n* @param {object} context - The context to render to.\r\n* @param {Phaser.Physics.Box2D.Body} body - The Body to render.\r\n* @param {string} [color='rgb(255,255,255)'] - color of the debug shape to be rendered. (format is css color string).\r\n* @param {boolean} [filled=true] - Render the shape as a filled (default, true) or a stroked (false)\r\n*/\r\nPhaser.Physics.Box2D.renderBody = function(context, body, color, filled) {\r\n\r\n    color = color || 'rgb(255,255,255)';\r\n\r\n    if (typeof filled === 'undefined')\r\n    {\r\n        filled = true;\r\n    }\r\n    \r\n    var b = body.data;\r\n    var xf = b.GetTransform();\r\n    var world = body.world;\r\n    \r\n    xf.p.x += -body.game.camera.x / world.ptmRatio;\r\n    xf.p.y -= -body.game.camera.y / world.ptmRatio;\r\n    \r\n    world.debugDraw.start(context);\r\n    \r\n    world.debugDraw.PushTransform(xf);\r\n    \r\n    var rgbcolor = Phaser.Color.webToColor(color);\r\n        \r\n    var b2color = world.debugDraw.color;\r\n    b2color.r = rgbcolor.r / 255;\r\n    b2color.g = rgbcolor.g / 255;\r\n    b2color.b = rgbcolor.b / 255;\r\n\r\n    for (var f = b.GetFixtureList(); f; f = f.GetNext())\r\n    {\r\n        world.world.DrawShape(f, b2color);\r\n    }\r\n\r\n    world.debugDraw.PopTransform();\r\n    \r\n    world.debugDraw.stop();\r\n\r\n};\r\n\r\n/**\r\n* @author       Chris Campbell <iforce2d@gmail.com>\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2015 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\n/**\r\n* The Physics Body is typically linked to a single Sprite and defines properties that determine how the physics body is simulated.\r\n* These properties affect how the body reacts to forces, what forces it generates on itself (to simulate friction), and how it reacts to collisions in the scene.\r\n* In most cases, the properties are used to simulate physical effects. Each body also has its own property values that determine exactly how it reacts to forces and collisions in the scene.\r\n* By default a single Rectangle shape is added to the Body that matches the dimensions of the parent Sprite. See addShape, removeShape, clearFixtures to add extra shapes around the Body.\r\n* Note: When bound to a Sprite to avoid single-pixel jitters on mobile devices we strongly recommend using Sprite sizes that are even on both axis, i.e. 128x128 not 127x127.\r\n* Note: When a game object is given a Box2D body it has its anchor x/y set to 0.5, so it becomes centered.\r\n*\r\n* @class Phaser.Physics.Box2D.Body\r\n* @classdesc Physics Body Constructor\r\n* @constructor\r\n* @param {Phaser.Game} game - Game reference to the currently running game.\r\n* @param {Phaser.Sprite} [sprite] - The Sprite object this physics body belongs to.\r\n* @param {number} [x=0] - The x coordinate of this Body.\r\n* @param {number} [y=0] - The y coordinate of this Body.\r\n* @param {number} [density=2] - The default density of this Body (0 = static, 1 = kinematic, 2 = dynamic, 3 = bullet).\r\n* @param {Phaser.Physics.Box2D} [world] - Reference to the Box2D World.\r\n*/\r\nPhaser.Physics.Box2D.Body = function (game, sprite, x, y, density, world) {\r\n\r\n    if (typeof sprite === 'undefined') { sprite = null; }\r\n    if (typeof x === 'undefined') { x = 0; }\r\n    if (typeof y === 'undefined') { y = 0; }\r\n    if (typeof density === 'undefined') { density = 2; }\r\n    if (typeof world === 'undefined') { world = game.physics.box2d; }\r\n\r\n    /**\r\n    * @property {Phaser.Game} game - Local reference to game.\r\n    */\r\n    this.game = game;\r\n\r\n    /**\r\n    * @property {Phaser.Physics.Box2D} world - Local reference to the Box2D World.\r\n    */\r\n    this.world = world;\r\n\r\n    /**\r\n    * @property {number} id - a unique id for this body in the world\r\n    */\r\n    this.id = this.world.getNextBodyId();\r\n\r\n    /**\r\n    * @property {Phaser.Sprite} sprite - Reference to the parent Sprite.\r\n    */\r\n    this.sprite = sprite;\r\n\r\n    /**\r\n    * @property {number} type - The type of physics system this body belongs to.\r\n    */\r\n    this.type = Phaser.Physics.BOX2D;\r\n\r\n    /**\r\n    * @property {Phaser.Point} offset - The offset of the Physics Body from the Sprite x/y position.\r\n    */\r\n    this.offset = new Phaser.Point();\r\n\r\n    /**\r\n    * @property {box2d.b2BodyDef} bodyDef - The Box2D body definition\r\n    * @protected\r\n    */\r\n    this.bodyDef = new box2d.b2BodyDef();\r\n\r\n    this.bodyDef.position.SetXY(-this.world.pxm(x), -this.world.pxm(y));\r\n\r\n    if (density === 0)\r\n    {\r\n        this.bodyDef.type = box2d.b2BodyType.b2_staticBody;\r\n    }\r\n    else if (density === 1)\r\n    {\r\n        this.bodyDef.type = box2d.b2BodyType.b2_kinematicBody;\r\n    }\r\n    else if (density === 2)\r\n    {\r\n        this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody;\r\n    }\r\n    else if (density === 3)\r\n    {\r\n        this.bodyDef.type = box2d.b2BodyType.b2_bulletBody;\r\n    }\r\n\r\n    /**\r\n    * @property {box2d.b2Body} data - The Box2D body data.\r\n    * @protected\r\n    */\r\n    this.data = this.world.world.CreateBody(this.bodyDef);\r\n    this.data.world = this.world.world;\r\n    this.data.parent = this;\r\n\r\n    /**\r\n    * @property {Phaser.Physics.Box2D.PointProxy} velocity - The velocity of the body. Set velocity.x to a negative value to move to the left, position to the right. velocity.y negative values move up, positive move down.\r\n    */\r\n    this.velocity = new Phaser.Physics.Box2D.PointProxy(this.world, this.data, this.data.GetLinearVelocity, this.data.SetLinearVelocity);\r\n\r\n    /**\r\n    * @property {boolean} removeNextStep - To avoid deleting this body during a physics step, and causing all kinds of problems, set removeNextStep to true to have it removed in the next preUpdate.\r\n    */\r\n    this.removeNextStep = false;\r\n\r\n    /**\r\n    * @property {object} _fixtureContactCallbacks - Array of contact callbacks, triggered when this body begins or ends contact with a specific fixture.\r\n    * @private\r\n    */\r\n    this._fixtureContactCallbacks = {};\r\n\r\n    /**\r\n    * @property {object} _fixtureContactCallbackContext - Array of fixture contact callback contexts.\r\n    * @private\r\n    */\r\n    this._fixtureContactCallbackContext = {};\r\n\r\n    /**\r\n    * @property {object} _bodyContactCallbacks - Array of contact callbacks, triggered when this body begins or ends contact with a specific body.\r\n    * @private\r\n    */\r\n    this._bodyContactCallbacks = {};\r\n\r\n    /**\r\n    * @property {object} _bodyContactCallbackContext - Array of body contact callback contexts.\r\n    * @private\r\n    */\r\n    this._bodyContactCallbackContext = {};\r\n\r\n    /**\r\n    * @property {object} _categoryContactCallbacks - Array of contact callbacks, triggered when this body begins or ends contact with fixtures matching a specific mask.\r\n    * @private\r\n    */\r\n    this._categoryContactCallbacks = {};\r\n\r\n    /**\r\n    * @property {object} _categoryContactCallbackContext - Array of category contact callback contexts.\r\n    * @private\r\n    */\r\n    this._categoryContactCallbackContext = {};\r\n\r\n    /**\r\n    * @property {object} _fixtureCallbacks - Array of presolve callbacks, triggered while this body continues contact with a specific fixture.\r\n    * @private\r\n    */\r\n    this._fixturePresolveCallbacks = {};\r\n\r\n    /**\r\n    * @property {object} _fixtureCallbackContext - Array of fixture presolve callback contexts.\r\n    * @private\r\n    */\r\n    this._fixturePresolveCallbackContext = {};\r\n\r\n    /**\r\n    * @property {object} _bodyCallbacks - Array of presolve callbacks, triggered while this body continues contact with a specific body.\r\n    * @private\r\n    */\r\n    this._bodyPresolveCallbacks = {};\r\n\r\n    /**\r\n    * @property {object} _bodyCallbackContext - Array of body presolve callback contexts.\r\n    * @private\r\n    */\r\n    this._bodyPresolveCallbackContext = {};\r\n\r\n    /**\r\n    * @property {object} _categoryCallbacks - Array of presolve callbacks, triggered while this body continues contact with fixtures matching a specific mask.\r\n    * @private\r\n    */\r\n    this._categoryPresolveCallbacks = {};\r\n\r\n    /**\r\n    * @property {object} _categoryCallbackContext - Array of category presolve callback contexts.\r\n    * @private\r\n    */\r\n    this._categoryPresolveCallbackContext = {};\r\n\r\n    /**\r\n    * @property {object} _fixturePostsolveCallbacks - Array of postsolve callbacks, triggered while this body continues contact with a specific fixture.\r\n    * @private\r\n    */\r\n    this._fixturePostsolveCallbacks = {};\r\n\r\n    /**\r\n    * @property {object} _fixturePostsolveCallbackContext - Array of fixture postsolve callback contexts.\r\n    * @private\r\n    */\r\n    this._fixturePostsolveCallbackContext = {};\r\n\r\n    /**\r\n    * @property {object} _bodyPostsolveCallbacks - Array of postsolve callbacks, triggered while this body continues contact with a specific body.\r\n    * @private\r\n    */\r\n    this._bodyPostsolveCallbacks = {};\r\n\r\n    /**\r\n    * @property {object} _bodyPostsolveCallbackContext - Array of body postsolve callback contexts.\r\n    * @private\r\n    */\r\n    this._bodyPostsolveCallbackContext = {};\r\n\r\n    /**\r\n    * @property {object} _categoryPostsolveCallbacks - Array of postsolve callbacks, triggered while this body continues contact with a specific fixture.\r\n    * @private\r\n    */\r\n    this._categoryPostsolveCallbacks = {};\r\n\r\n    /**\r\n    * @property {object} _categoryPostsolveCallbackContext - Array of category postsolve callback contexts.\r\n    * @private\r\n    */\r\n    this._categoryPostsolveCallbackContext = {};\r\n    \r\n    //  Set-up the default shape\r\n    if (sprite)\r\n    {\r\n        this.setRectangleFromSprite(sprite);\r\n    }\r\n\r\n};\r\n\r\nPhaser.Physics.Box2D.Body.prototype = {\r\n\r\n    /**\r\n    * Sets a callback to be fired any time a fixture in this Body begins or ends contact with a fixture in the given Body. \r\n    * The callback will be sent 6 parameters:\r\n    *     this body\r\n    *     the body that was contacted\r\n    *     the fixture in this body (box2d.b2Fixture)\r\n    *     the fixture in the other body that was contacted (box2d.b2Fixture)\r\n    *     a boolean to say whether it was a begin or end event\r\n    *     the contact object itself (box2d.b2Contact)\r\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setBodyContactCallback\r\n    * @param {Phaser.Sprite|Phaser.Physics.Box2D.Body} object - The object to do callbacks for.\r\n    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.\r\n    * @param {object} callbackContext - The context under which the callback will fire.\r\n    */\r\n    setBodyContactCallback: function (object, callback, callbackContext) {\r\n\r\n        var id = -1;\r\n\r\n        if (object['id'])\r\n        {\r\n            id = object.id;\r\n        }\r\n        else if (object['body'])\r\n        {\r\n            id = object.body.id;\r\n        }\r\n\r\n        if (id > -1)\r\n        {\r\n            if (callback === null)\r\n            {\r\n                delete (this._bodyContactCallbacks[id]);\r\n                delete (this._bodyContactCallbackContext[id]);\r\n            }\r\n            else\r\n            {\r\n                this._bodyContactCallbacks[id] = callback;\r\n                this._bodyContactCallbackContext[id] = callbackContext;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets a callback to be fired any time the given fixture begins or ends contact something\r\n    * The callback will be sent 6 parameters:\r\n    *     this body\r\n    *     the body that was contacted\r\n    *     the fixture in this body (box2d.b2Fixture)\r\n    *     the fixture in the other body that was contacted (box2d.b2Fixture)\r\n    *     a boolean to say whether it was a begin or end event\r\n    *     the contact object itself (box2d.b2Contact)\r\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setFixtureContactCallback\r\n    * @param {box2d.b2Fixture} fixture - The fixture to do callbacks for.\r\n    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.\r\n    * @param {object} callbackContext - The context under which the callback will fire.\r\n    */\r\n    setFixtureContactCallback: function (fixture, callback, callbackContext) {\r\n\r\n        var id = fixture.id;\r\n\r\n        if (id > -1)\r\n        {\r\n            if (callback === null)\r\n            {\r\n                delete (this._fixtureContactCallbacks[id]);\r\n                delete (this._fixtureContactCallbackContext[id]);\r\n            }\r\n            else\r\n            {\r\n                this._fixtureContactCallbacks[id] = callback;\r\n                this._fixtureContactCallbackContext[id] = callbackContext;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets a callback to be fired any time a fixture in this body begins contact with a fixture in another body that matches given category set.\r\n    * The callback will be sent 6 parameters:\r\n    *     this body\r\n    *     the body that was contacted\r\n    *     the fixture in this body (box2d.b2Fixture)\r\n    *     the fixture in the other body that was contacted (box2d.b2Fixture)\r\n    *     a boolean to say whether it was a begin or end event\r\n    *     the contact object itself (box2d.b2Contact)\r\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setCategoryContactCallback\r\n    * @param {number} category - A bitmask specifying the category(s) to trigger for.\r\n    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.\r\n    * @param {object} callbackContext - The context under which the callback will fire.\r\n    */\r\n    setCategoryContactCallback: function (category, callback, callbackContext) {\r\n\r\n        if (callback === null)\r\n        {\r\n            delete (this._categoryContactCallbacks[category]);\r\n            delete (this._categoryContactCallbacksContext[category]);\r\n        }\r\n        else\r\n        {\r\n            this._categoryContactCallbacks[category] = callback;\r\n            this._categoryContactCallbackContext[category] = callbackContext;\r\n        }\r\n\r\n    },\r\n    \r\n    /**\r\n    * Sets a callback to be fired when PreSolve is done for contacts between a fixture in this body and a fixture in the given Body.\r\n    * The callback will be sent 6 parameters:\r\n    *     this body\r\n    *     the body that was contacted\r\n    *     the fixture in this body (box2d.b2Fixture)\r\n    *     the fixture in the other body that was contacted (box2d.b2Fixture)\r\n    *     a boolean to say whether it was a begin or end event\r\n    *     the contact object itself (box2d.b2Contact)\r\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setBodyPresolveCallback\r\n    * @param {Phaser.Sprite|Phaser.Physics.Box2D.Body} object - The object to do callbacks for.\r\n    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.\r\n    * @param {object} callbackContext - The context under which the callback will fire.\r\n    */\r\n    setBodyPresolveCallback: function (object, callback, callbackContext) {\r\n\r\n        var id = -1;\r\n\r\n        if (object['id'])\r\n        {\r\n            id = object.id;\r\n        }\r\n        else if (object['body'])\r\n        {\r\n            id = object.body.id;\r\n        }\r\n\r\n        if (id > -1)\r\n        {\r\n            if (callback === null)\r\n            {\r\n                delete (this._bodyPresolveCallbacks[id]);\r\n                delete (this._bodyPresolveCallbackContext[id]);\r\n            }\r\n            else\r\n            {\r\n                this._bodyPresolveCallbacks[id] = callback;\r\n                this._bodyPresolveCallbackContext[id] = callbackContext;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets a callback to be fired when PreSolve is done for contacts between a fixture in this body the given fixture.\r\n    * The callback will be sent 6 parameters:\r\n    *     this body\r\n    *     the body that was contacted\r\n    *     the fixture in this body (box2d.b2Fixture)\r\n    *     the fixture in the other body that was contacted (box2d.b2Fixture)\r\n    *     a boolean to say whether it was a begin or end event\r\n    *     the contact object itself (box2d.b2Contact)\r\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setFixturePresolveCallback\r\n    * @param {box2d.b2Fixture} fixture - The fixture to do callbacks for.\r\n    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.\r\n    * @param {object} callbackContext - The context under which the callback will fire.\r\n    */\r\n    setFixturePresolveCallback: function (fixture, callback, callbackContext) {\r\n\r\n        var id = fixture.id;\r\n\r\n        if (id > -1)\r\n        {\r\n            if (callback === null)\r\n            {\r\n                delete (this._fixturePresolveCallbacks[id]);\r\n                delete (this._fixturePresolveCallbackContext[id]);\r\n            }\r\n            else\r\n            {\r\n                this._fixturePresolveCallbacks[id] = callback;\r\n                this._fixturePresolveCallbackContext[id] = callbackContext;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets a callback to be fired when PreSolve is done for contacts between a fixture in this body and a fixture in another body that matches given category set.\r\n    * The callback will be sent 6 parameters:\r\n    *     this body\r\n    *     the body that was contacted\r\n    *     the fixture in this body (box2d.b2Fixture)\r\n    *     the fixture in the other body that was contacted (box2d.b2Fixture)\r\n    *     a boolean to say whether it was a begin or end event\r\n    *     the contact object itself (box2d.b2Contact)\r\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setCategoryPresolveCallback\r\n    * @param {number} category - A bitmask specifying the category(s) to trigger for.\r\n    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.\r\n    * @param {object} callbackContext - The context under which the callback will fire.\r\n    */\r\n    setCategoryPresolveCallback: function (category, callback, callbackContext) {\r\n\r\n        if (callback === null)\r\n        {\r\n            delete (this._categoryPresolveCallbacks[category]);\r\n            delete (this._categoryPresolveCallbacksContext[category]);\r\n        }\r\n        else\r\n        {\r\n            this._categoryPresolveCallbacks[category] = callback;\r\n            this._categoryPresolveCallbackContext[category] = callbackContext;\r\n        }\r\n\r\n    },\r\n    \r\n    /**\r\n    * Sets a callback to be fired when PostSolve is done for contacts between a fixture in this body and a fixture in the given Body.\r\n    * The callback will be sent 6 parameters:\r\n    *     this body\r\n    *     the body that was contacted\r\n    *     the fixture in this body (box2d.b2Fixture)\r\n    *     the fixture in the other body that was contacted (box2d.b2Fixture)\r\n    *     a boolean to say whether it was a begin or end event\r\n    *     the contact object itself (box2d.b2Contact)\r\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setBodyPostsolveCallback\r\n    * @param {Phaser.Sprite|Phaser.Physics.Box2D.Body} object - The object to do callbacks for.\r\n    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.\r\n    * @param {object} callbackContext - The context under which the callback will fire.\r\n    */\r\n    setBodyPostsolveCallback: function (object, callback, callbackContext) {\r\n\r\n        var id = -1;\r\n\r\n        if (object['id'])\r\n        {\r\n            id = object.id;\r\n        }\r\n        else if (object['body'])\r\n        {\r\n            id = object.body.id;\r\n        }\r\n\r\n        if (id > -1)\r\n        {\r\n            if (callback === null)\r\n            {\r\n                delete (this._bodyPostsolveCallbacks[id]);\r\n                delete (this._bodyPostsolveCallbackContext[id]);\r\n            }\r\n            else\r\n            {\r\n                this._bodyPostsolveCallbacks[id] = callback;\r\n                this._bodyPostsolveCallbackContext[id] = callbackContext;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets a callback to be fired when PostSolve is done for contacts between a fixture in this body the given fixture.\r\n    * The callback will be sent 6 parameters:\r\n    *     this body\r\n    *     the body that was contacted\r\n    *     the fixture in this body (box2d.b2Fixture)\r\n    *     the fixture in the other body that was contacted (box2d.b2Fixture)\r\n    *     a boolean to say whether it was a begin or end event\r\n    *     the contact object itself (box2d.b2Contact)\r\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setFixturePostsolveCallback\r\n    * @param {box2d.b2Fixture} fixture - The fixture to do callbacks for.\r\n    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.\r\n    * @param {object} callbackContext - The context under which the callback will fire.\r\n    */\r\n    setFixturePostsolveCallback: function (fixture, callback, callbackContext) {\r\n\r\n        var id = fixture.id;\r\n\r\n        if (id > -1)\r\n        {\r\n            if (callback === null)\r\n            {\r\n                delete (this._fixturePostsolveCallbacks[id]);\r\n                delete (this._fixturePostsolveCallbackContext[id]);\r\n            }\r\n            else\r\n            {\r\n                this._fixturePostsolveCallbacks[id] = callback;\r\n                this._fixturePostsolveCallbackContext[id] = callbackContext;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets a callback to be fired when PostSolve is done for contacts between a fixture in this body and a fixture in another body that matches given category set.\r\n    * The callback will be sent 6 parameters:\r\n    *     this body\r\n    *     the body that was contacted\r\n    *     the fixture in this body (box2d.b2Fixture)\r\n    *     the fixture in the other body that was contacted (box2d.b2Fixture)\r\n    *     a boolean to say whether it was a begin or end event\r\n    *     the contact object itself (box2d.b2Contact)\r\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setCategoryPostsolveCallback\r\n    * @param {number} category - A bitmask specifying the category(s) to trigger for.\r\n    * @param {function} callback - The callback to fire on contact. Set to null to clear a previously set callback.\r\n    * @param {object} callbackContext - The context under which the callback will fire.\r\n    */\r\n    setCategoryPostsolveCallback: function (category, callback, callbackContext) {\r\n\r\n        if (callback === null)\r\n        {\r\n            delete (this._categoryPostsolveCallbacks[category]);\r\n            delete (this._categoryPostsolveCallbacksContext[category]);\r\n        }\r\n        else\r\n        {\r\n            this._categoryPostsolveCallbacks[category] = callback;\r\n            this._categoryPostsolveCallbackContext[category] = callbackContext;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets the given collision category for all fixtures in this Body, unless a specific fixture is given.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setCollisionCategory\r\n    * @param {number} category - A bitmask representing the category(s) to include\r\n    * @param {box2d.b2Fixture} [fixture] - An optional fixture. If not provided the collision category will be added to all fixtures in this body.\r\n    */\r\n    setCollisionCategory: function (category, fixture) {\r\n\r\n        if (typeof fixture === 'undefined')\r\n        {\r\n            for (var f = this.data.GetFixtureList(); f; f = f.GetNext())\r\n            {\r\n                var filter = f.GetFilterData();\r\n                filter.categoryBits = category;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var filter = fixture.GetFilterData();\r\n            filter.categoryBits = category;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets the given collision mask for all fixtures in this Body, unless a specific fixture is given.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setCollisionMask\r\n    * @param {number} mask - A bitmask representing the category(s) to include\r\n    * @param {box2d.b2Fixture} [fixture] - An optional fixture. If not provided the collision mask will be added to all fixtures in this body.\r\n    */\r\n    setCollisionMask: function (mask, fixture) {\r\n\r\n        if (typeof fixture === 'undefined')\r\n        {\r\n            for (var f = this.data.GetFixtureList(); f; f = f.GetNext())\r\n            {\r\n                var filter = f.GetFilterData();\r\n                filter.maskBits = mask;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var filter = fixture.GetFilterData();\r\n            filter.maskBits = mask;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Apply force at the center of mass. This will not cause any rotation.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#applyForce\r\n    * @param {number} x - \r\n    * @param {number} y - \r\n    */\r\n    applyForce: function (x, y) {\r\n\r\n        this.data.ApplyForce(new box2d.b2Vec2(-x,-y), this.data.GetWorldCenter(), true);\r\n\r\n    },\r\n\r\n    /**\r\n    * If this Body is dynamic then this will zero its angular velocity.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setZeroRotation\r\n    */\r\n    setZeroRotation: function () {\r\n\r\n        this.data.SetAngularVelocity(0);\r\n\r\n    },\r\n\r\n    /**\r\n    * If this Body is dynamic then this will zero its velocity on both axis.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setZeroVelocity\r\n    */\r\n    setZeroVelocity: function () {\r\n\r\n        this.data.SetLinearVelocity(box2d.b2Vec2.ZERO);\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets the linear damping and angular damping to zero.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setZeroDamping\r\n    */\r\n    setZeroDamping: function () {\r\n\r\n        this.data.SetLinearDamping(0);\r\n        this.data.SetAngularDamping(0);\r\n\r\n    },\r\n\r\n    /**\r\n    * Transform a world point to local body frame.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#toLocalPoint\r\n    * @param {box2d.b2Vec2} out - The point to store the result in.\r\n    * @param {box2d.b2Vec2} worldPoint - The input world point.\r\n    */\r\n    toLocalPoint: function (out, worldPoint) {\r\n    \r\n        out.x = this.world.pxm(-worldPoint.x);\r\n        out.y = this.world.pxm(-worldPoint.y);\r\n        this.data.GetLocalPoint(out, out);        \r\n        out.x = this.world.mpx(-out.x);\r\n        out.y = this.world.mpx(-out.y);\r\n        \r\n        return out;\r\n\r\n    },\r\n\r\n    /**\r\n    * Transform a local point to world frame.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#toWorldPoint\r\n    * @param {box2d.b2Vec2} out - The point to store the result in.\r\n    * @param {box2d.b2Vec2} localPoint - The input local point.\r\n    */\r\n    toWorldPoint: function (out, localPoint) {\r\n\r\n        out.x = this.world.pxm(-localPoint.x);\r\n        out.y = this.world.pxm(-localPoint.y);\r\n        this.data.GetWorldPoint(out, out);        \r\n        out.x = this.world.mpx(-out.x);\r\n        out.y = this.world.mpx(-out.y);\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n    * Transform a world vector to local body frame.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#toLocalVector\r\n    * @param {box2d.b2Vec2} out - The vector to store the result in.\r\n    * @param {box2d.b2Vec2} worldVector - The input world vector.\r\n    */\r\n    toLocalVector: function (out, worldVector) {\r\n\r\n        out.x = this.world.pxm(-worldVector.x);\r\n        out.y = this.world.pxm(-worldVector.y);\r\n        this.data.GetLocalVector(out, out);        \r\n        out.x = this.world.mpx(-out.x);\r\n        out.y = this.world.mpx(-out.y);\r\n        \r\n        return out;\r\n\r\n    },\r\n\r\n    /**\r\n    * Transform a local vector to world frame.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#toWorldVector\r\n    * @param {box2d.b2Vec2} out - The vector to store the result in.\r\n    * @param {box2d.b2Vec2} localVector - The input local vector.\r\n    */\r\n    toWorldVector: function (out, localVector) {\r\n\r\n        out.x = this.world.pxm(-localVector.x);\r\n        out.y = this.world.pxm(-localVector.y);\r\n        this.data.GetWorldVector(out, out);        \r\n        out.x = this.world.mpx(-out.x);\r\n        out.y = this.world.mpx(-out.y);\r\n\r\n    },\r\n\r\n    /**\r\n    * This will rotate the Body by the given speed to the left (counter-clockwise).\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#rotateLeft\r\n    * @param {number} speed - The speed at which it should rotate.\r\n    */\r\n    rotateLeft: function (speed) {\r\n\r\n        this.data.SetAngularVelocity(this.world.pxm(-speed));\r\n\r\n    },\r\n\r\n    /**\r\n    * This will rotate the Body by the given speed to the left (clockwise).\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#rotateRight\r\n    * @param {number} speed - The speed at which it should rotate.\r\n    */\r\n    rotateRight: function (speed) {\r\n\r\n        this.data.SetAngularVelocity(this.world.pxm(speed));\r\n\r\n    },\r\n\r\n    /**\r\n    * Moves the Body forwards based on its current angle and the given speed.\r\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#moveForward\r\n    * @param {number} speed - The speed at which body should move forwards.\r\n    */\r\n    moveForward: function (speed) {\r\n\r\n        var magnitude = this.world.pxm(speed);\r\n        var direction = new box2d.b2Vec2();\r\n        this.toWorldVector(direction, {x:0,y:magnitude});\r\n        this.data.SetLinearVelocity(direction);\r\n        \r\n    },\r\n\r\n    /**\r\n    * Moves the Body backwards based on its current angle and the given speed.\r\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#moveBackward\r\n    * @param {number} speed - The speed at which body should move backwards.\r\n    */\r\n    moveBackward: function (speed) {\r\n\r\n        var magnitude = this.world.pxm(-speed);\r\n        var direction = new box2d.b2Vec2();\r\n        this.toWorldVector(direction, {x:0,y:magnitude});\r\n        this.data.SetLinearVelocity(direction);\r\n\r\n    },\r\n\r\n    /**\r\n    * Applies a force to the Body that causes it to 'thrust' forwards, based on its current angle and the given speed.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#thrust\r\n    * @param {number} power - The magnitude of the thrust force.\r\n    */\r\n    thrust: function (power) {\r\n    \r\n        // Magnitude should be multiplied by the mass of the body, so that user  \r\n        // will see the same results regardless of the size of the sprite.\r\n        var magnitude = this.world.pxm(power) * this.data.GetMass();\r\n        \r\n        var force = new box2d.b2Vec2();\r\n        this.toWorldVector(force, {x:0,y:magnitude});\r\n        \r\n        this.data.ApplyForce( force, this.data.GetWorldCenter(), true );\r\n\r\n    },\r\n\r\n    /**\r\n    * Applies a force to the Body that causes it to 'thrust' backwards (in reverse), based on its current angle and the given speed.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#reverse\r\n    * @param {number} power - The magnitude of the thrust force.\r\n    */\r\n    reverse: function (power) {\r\n    \r\n        // Magnitude should be multiplied by the mass of the body, so that user  \r\n        // will see the same results regardless of the size of the sprite.\r\n        var magnitude = -this.world.pxm(power) * this.data.GetMass();\r\n        \r\n        var force = new box2d.b2Vec2();\r\n        this.toWorldVector(force, {x:0,y:magnitude});\r\n        \r\n        this.data.ApplyForce( force, this.data.GetWorldCenter(), true );\r\n\r\n    },\r\n\r\n    /**\r\n    * If this Body is dynamic then this will move it to the left by setting its x velocity to the given speed.\r\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#moveLeft\r\n    * @param {number} speed - The speed at which it should move to the left, in pixels per second.\r\n    */\r\n    moveLeft: function (speed) {\r\n\r\n        this.velocity.x = -speed;\r\n\r\n    },\r\n\r\n    /**\r\n    * If this Body is dynamic then this will move it to the right by setting its x velocity to the given speed.\r\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#moveRight\r\n    * @param {number} speed - The speed at which it should move to the right, in pixels per second.\r\n    */\r\n    moveRight: function (speed) {\r\n\r\n        this.velocity.x = speed;\r\n\r\n    },\r\n\r\n    /**\r\n    * If this Body is dynamic then this will move it up by setting its y velocity to the given speed.\r\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#moveUp\r\n    * @param {number} speed - The speed at which it should move up, in pixels per second.\r\n    */\r\n    moveUp: function (speed) {\r\n\r\n        this.velocity.y = -speed;\r\n\r\n    },\r\n\r\n    /**\r\n    * If this Body is dynamic then this will move it down by setting its y velocity to the given speed.\r\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#moveDown\r\n    * @param {number} speed - The speed at which it should move down, in pixels per second.\r\n    */\r\n    moveDown: function (speed) {\r\n\r\n        this.velocity.y = speed;\r\n\r\n    },\r\n\r\n    /**\r\n    * Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#preUpdate\r\n    * @protected\r\n    */\r\n    preUpdate: function () {\r\n\r\n        if (this.removeNextStep)\r\n        {\r\n            this.removeFromWorld();\r\n            this.removeNextStep = false;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#postUpdate\r\n    * @protected\r\n    */\r\n    postUpdate: function () {\r\n\r\n        if (this.sprite)\r\n        {\r\n            this.sprite.x = this.world.mpx(-this.data.GetPosition().x);\r\n            this.sprite.y = this.world.mpx(-this.data.GetPosition().y);\r\n            this.sprite.rotation = this.data.GetAngle();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Sets this body as inactive. It will not participate in collisions or\r\n    * any other aspect of the physics simulation. Intended for use by Phaser.Sprite.kill()\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#kill\r\n    */\r\n    kill: function () {\r\n\r\n        this.data.SetActive(false);\r\n\r\n    },\r\n\r\n    /**\r\n    * Restores the active status of this body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#reset\r\n    * @param {number} x - The new x position of the Body.\r\n    * @param {number} y - The new x position of the Body.\r\n    */\r\n    reset: function (x, y) {\r\n\r\n        this.data.SetPositionXY( this.world.pxm(-x), this.world.pxm(-y) );\r\n        this.data.SetActive(true);\r\n\r\n    },\r\n\r\n    /**\r\n    * Removes this physics body from the world.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#removeFromWorld\r\n    */\r\n    removeFromWorld: function () {\r\n\r\n        if (this.data.world === this.game.physics.box2d.world)\r\n        {\r\n            this.game.physics.box2d.removeBodyNextStep(this);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Destroys this Body and all references it holds to other objects.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#destroy\r\n    */\r\n    destroy: function () {\r\n\r\n        this.removeFromWorld();\r\n\r\n        this._bodyCallbacks = {};\r\n        this._bodyCallbackContext = {};\r\n        this._categoryCallbacks = {};\r\n        this._categoryCallbackContext = {};\r\n\r\n        this.sprite = null;\r\n\r\n    },\r\n\r\n    /**\r\n    * Removes all fixtures from this Body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#clearFixtures\r\n    */\r\n    clearFixtures: function () {\r\n\r\n        var fixtures = [];\r\n        for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {\r\n            fixtures.push(f);\r\n        }\r\n\r\n        var i = fixtures.length;\r\n\r\n        while (i--)\r\n        {\r\n            this.data.DestroyFixture(fixtures[i]);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n    * Adds a Circle fixture to this Body. You can control the offset from the center of the body and the rotation.\r\n    * It will use the World friction, restitution and density by default.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#addCircle\r\n    * @param {number} radius - The radius of this circle (in pixels)\r\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\r\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    addCircle: function (radius, offsetX, offsetY) {\r\n\r\n        var circleShape = new box2d.b2CircleShape(this.world.pxm(radius));\r\n        circleShape.m_p.SetXY(this.world.pxm(-offsetX), this.world.pxm(-offsetY));\r\n\r\n        var fixtureDef = new box2d.b2FixtureDef();\r\n        fixtureDef.shape = circleShape;\r\n        fixtureDef.friction = this.world.friction;\r\n        fixtureDef.restitution = this.world.restitution;\r\n        fixtureDef.density = this.world.density;\r\n\r\n        var f = this.data.CreateFixture(fixtureDef);\r\n        f.id = this.world.getNextFixtureId();\r\n\r\n        return f;\r\n\r\n    },\r\n\r\n    /**\r\n    * Adds a Rectangle fixture to this Body. You can control the offset from the center of the body and the rotation.\r\n    * It will use the World friction, restitution and density by default.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#addRectangle\r\n    * @param {number} [width=16] - The width of the rectangle in pixels.\r\n    * @param {number} [height=16] - The height of the rectangle in pixels.\r\n    * @param {number} [offsetX=0] - Local horizontal offset (pixels) of the shape relative to the body center.\r\n    * @param {number} [offsetY=0] - Local vertical offset (pixels) of the shape relative to the body center.\r\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    addRectangle: function (width, height, offsetX, offsetY, rotation) {\r\n\r\n        if (typeof width === 'undefined') { width = 16; }\r\n        if (typeof height === 'undefined') { height = 16; }\r\n        if (typeof offsetX === 'undefined') { offsetX = 0; }\r\n        if (typeof offsetY === 'undefined') { offsetY = 0; }\r\n        if (typeof rotation === 'undefined') { rotation = 0; }   \r\n    \r\n        width = this.world.pxm(width);\r\n        height = this.world.pxm(height);\r\n\r\n        var polygonShape = new box2d.b2PolygonShape();\r\n        polygonShape.SetAsOrientedBox(0.5 * width, 0.5 * height, new box2d.b2Vec2(this.world.pxm(-offsetX), this.world.pxm(-offsetY)), rotation);\r\n\r\n        var fixtureDef = new box2d.b2FixtureDef();\r\n        fixtureDef.shape = polygonShape;\r\n        fixtureDef.friction = this.world.friction;\r\n        fixtureDef.restitution = this.world.restitution;\r\n        fixtureDef.density = this.world.density;\r\n\r\n        var f = this.data.CreateFixture(fixtureDef);\r\n        f.id = this.world.getNextFixtureId();\r\n\r\n        return f;\r\n\r\n    },\r\n\r\n    /**\r\n    * Creates a new Edge Shape and adds it to this Body.\r\n    * It will use the World friction, restitution and density by default.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#addEdge\r\n    * @param {number} [x1=0] - Local horizontal offset of the first point relative to the body center.\r\n    * @param {number} [y1=0] - Local vertical offset of the first point relative to the body center.\r\n    * @param {number} [x2=0] - Local horizontal offset of the second point relative to the body center.\r\n    * @param {number} [y2=0] - Local vertical offset of the second point relative to the body center.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    addEdge: function (x1, y1, x2, y2) {\r\n\r\n        var edgeShape = new box2d.b2EdgeShape();\r\n        edgeShape.Set( new box2d.b2Vec2(this.world.pxm(-x1), this.world.pxm(-y1)), new box2d.b2Vec2(this.world.pxm(-x2), this.world.pxm(-y2)) );\r\n\r\n        var fixtureDef = new box2d.b2FixtureDef();\r\n        fixtureDef.shape = edgeShape;\r\n        fixtureDef.friction = this.world.friction;\r\n        fixtureDef.restitution = this.world.restitution;\r\n        fixtureDef.density = this.world.density;\r\n\r\n        var f = this.data.CreateFixture(fixtureDef);\r\n        f.id = this.world.getNextFixtureId();\r\n\r\n        return f;\r\n\r\n    },\r\n\r\n    /**\r\n    * Creates a new chain shape and adds it to this Body.\r\n    * It will use the World friction, restitution and density by default.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#addChain\r\n    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]\r\n    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.\r\n    * @param {number} [count] - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.\r\n    * @param {boolean} [loop=false] - Whether the chain should form a closed loop.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    addChain: function (vertices, firstIndex, count, loop) {\r\n    \r\n        if (typeof vertices === 'undefined') { return null; }\r\n        if (vertices.length < 4) { return null; }\r\n    \r\n        if (typeof firstIndex === 'undefined') { firstIndex = 0; }\r\n        if (typeof count === 'undefined') { count = (vertices.length - firstIndex) / 2; }\r\n\r\n        var b2Vertices = [];\r\n        for (var i = firstIndex; i < (firstIndex+count); i++) {\r\n            b2Vertices.push( new box2d.b2Vec2(this.world.pxm(-vertices[2*i]), this.world.pxm(-vertices[2*i+1])) );\r\n        }\r\n\r\n        var chainShape = new box2d.b2ChainShape();\r\n        if (loop) {\r\n            chainShape.CreateLoop( b2Vertices, b2Vertices.length );\r\n        }\r\n        else {\r\n            chainShape.CreateChain( b2Vertices, b2Vertices.length );\r\n        }\r\n\r\n        var fixtureDef = new box2d.b2FixtureDef();\r\n        fixtureDef.shape = chainShape;\r\n        fixtureDef.friction = this.world.friction;\r\n        fixtureDef.restitution = this.world.restitution;\r\n        fixtureDef.density = this.world.density;\r\n\r\n        var f = this.data.CreateFixture(fixtureDef);\r\n        f.id = this.world.getNextFixtureId();\r\n        return f;\r\n\r\n    },\r\n\r\n    /**\r\n    * Creates a new loop shape and adds it to this Body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#addLoop\r\n    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]\r\n    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.\r\n    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    addLoop: function (vertices, firstIndex, count) {\r\n        \r\n        return this.addChain(vertices, firstIndex, count, true);\r\n        \r\n    },\r\n\r\n    /**\r\n    * Creates a new polygon shape and adds it to this Body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#addPolygon\r\n    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]\r\n    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.\r\n    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.\r\n    * @return {box2d.b2Fixture} The last fixture that was added to the Body.\r\n    */\r\n    addPolygon: function (vertices, firstIndex, count) {\r\n    \r\n        if (typeof vertices === 'undefined') { return null; }\r\n        if (vertices.length < 6) { return null; } // need at least three vertices\r\n    \r\n        if (typeof firstIndex === 'undefined') { firstIndex = 0; }\r\n        if (typeof count === 'undefined') { count = (vertices.length - firstIndex) / 2; }\r\n\r\n        var b2Vertices = [];\r\n        for (var i = firstIndex; i < (firstIndex+count); i++) {\r\n            b2Vertices.push( { x: this.world.pxm(-vertices[2*i]), y: this.world.pxm(-vertices[2*i+1]) } );\r\n        }\r\n        \r\n        var poly = new Phaser.Physics.Box2D.Polygon();\r\n        poly.setFromXYObjects(b2Vertices);\r\n        var convexPolygons = poly.decompose(b2Vertices);\r\n        \r\n        var lastFixture = null;\r\n        \r\n        for (var i = 0; i < convexPolygons.length; i++)\r\n        {\r\n            var polygonShape = new box2d.b2PolygonShape();\r\n            polygonShape.Set( convexPolygons[i], convexPolygons[i].length );\r\n    \r\n            var fixtureDef = new box2d.b2FixtureDef();\r\n            fixtureDef.shape = polygonShape;\r\n            fixtureDef.friction = this.world.friction;\r\n            fixtureDef.restitution = this.world.restitution;\r\n            fixtureDef.density = this.world.density;\r\n    \r\n            lastFixture = this.data.CreateFixture(fixtureDef);\r\n            lastFixture.id = this.world.getNextFixtureId();\r\n        }\r\n\r\n        return lastFixture;\r\n    },\r\n\r\n    /**\r\n    * Remove a shape from the body. Will automatically update the mass properties and bounding radius.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#removeFixture\r\n    * @param {box2d.b2Fixture} fixture - The fixture to remove from the body.\r\n    * @return {boolean} True if the fixture was found and removed, else false.\r\n    */\r\n    removeFixture: function (fixture) {\r\n\r\n        if ( fixture.GetBody() != this.data ) {\r\n            return false;\r\n        }\r\n    \r\n        this.data.DestroyFixture(fixture);\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n    * Clears any previously set fixtures. Then creates a new Circle shape and adds it to this Body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setCircle\r\n    * @param {number} [radius=32] - The radius of this circle in pixels.\r\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\r\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    setCircle: function (radius, offsetX, offsetY) {\r\n    \r\n        if (typeof radius === 'undefined') { radius = 32; }\r\n        if (typeof offsetX === 'undefined') { offsetX = 0; }\r\n        if (typeof offsetY === 'undefined') { offsetY = 0; }\r\n    \r\n        this.clearFixtures();\r\n\r\n        return this.addCircle(radius, offsetX, offsetY);\r\n\r\n    },\r\n\r\n    /**\r\n    * Clears any previously set fixtures. The creates a new Rectangle fixture at the given size and offset, and adds it to this Body.\r\n    * If you wish to create a Rectangle to match the size of a Sprite or Image see Body.setRectangleFromSprite.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setRectangle\r\n    * @param {number} [width=16] - The width of the rectangle in pixels.\r\n    * @param {number} [height=16] - The height of the rectangle in pixels.\r\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\r\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\r\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    setRectangle: function (width, height, offsetX, offsetY, rotation) {\r\n\r\n        this.clearFixtures();\r\n\r\n        return this.addRectangle(width, height, offsetX, offsetY, rotation);\r\n\r\n    },\r\n\r\n    /**\r\n    * Clears any previously set fixtures.\r\n    * Then creates a Rectangle shape sized to match the dimensions and orientation of the Sprite given.\r\n    * If no Sprite is given it defaults to using the parent of this Body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setRectangleFromSprite\r\n    * @param {Phaser.Sprite|Phaser.Image} [sprite] - The Sprite on which the Rectangle will get its dimensions.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    setRectangleFromSprite: function (sprite) {\r\n\r\n        if (typeof sprite === 'undefined') { sprite = this.sprite; }\r\n\r\n        this.clearFixtures();\r\n\r\n        return this.addRectangle(sprite.width, sprite.height, 0, 0, sprite.rotation);\r\n\r\n    },\r\n\r\n    /**\r\n    * Clears any previously set fixtures. Then creates a new edge shape and adds it to this Body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setEdge\r\n    * @param {number} [x1=0] - Local horizontal offset of the first point relative to the body center.\r\n    * @param {number} [y1=0] - Local vertical offset of the first point relative to the body center.\r\n    * @param {number} [x2=0] - Local horizontal offset of the second point relative to the body center.\r\n    * @param {number} [y2=0] - Local vertical offset of the second point relative to the body center.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    setEdge: function (x1, y1, x2, y2) {\r\n    \r\n        if (typeof x1 === 'undefined') { x1 = 0; }\r\n        if (typeof y1 === 'undefined') { y1 = 0; }\r\n        if (typeof x2 === 'undefined') { x2 = 0; }\r\n        if (typeof y2 === 'undefined') { y2 = 0; }\r\n    \r\n        this.clearFixtures();        \r\n\r\n        return this.addEdge(x1, y1, x2, y2);\r\n\r\n    },\r\n\r\n    /**\r\n    * Clears any previously set fixtures. Then creates a new chain shape and adds it to this Body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setChain\r\n    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]\r\n    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.\r\n    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.\r\n    * @param {boolean} [loop=false] - Whether the chain should form a closed loop.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    setChain: function (vertices, firstIndex, count, loop) {\r\n    \r\n        if (typeof vertices === 'undefined') { return null; }\r\n        if (vertices.length < 4) { return null; }\r\n    \r\n        if (typeof firstIndex === 'undefined') { firstIndex = 0; }\r\n        if (typeof count === 'undefined') { count = (vertices.length - firstIndex) / 2; }\r\n    \r\n        this.clearFixtures();\r\n\r\n        return this.addChain(vertices, firstIndex, count, loop);\r\n\r\n    },\r\n\r\n    /**\r\n    * An alias for setChain.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setLoop\r\n    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]\r\n    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.\r\n    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    setLoop: function (vertices, firstIndex, count) {\r\n        \r\n        return this.setChain(vertices, firstIndex, count, true);\r\n        \r\n    },\r\n\r\n    /**\r\n    * Clears any previously set fixtures. Then creates a new polygon shape and adds it to this Body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#setPolygon\r\n    * @param {Array} vertices - Local positions of the vertices relative to the body center. Format is [x1, y1, x2, y2, ...]\r\n    * @param {number} [firstIndex=0] - The index of the x-value of the starting vertex.\r\n    * @param {number} count - The number of vertices to use. If this parameter is not passed, all vertices above firstIndex will be used.\r\n    * @return {box2d.b2Fixture} The fixture that was added to the Body.\r\n    */\r\n    setPolygon: function (vertices, firstIndex, count) {\r\n    \r\n        if (typeof vertices === 'undefined') { return null; }\r\n        if (vertices.length < 4) { return null; }\r\n    \r\n        if (typeof firstIndex === 'undefined') { firstIndex = 0; }\r\n        if (typeof count === 'undefined') { count = (vertices.length - firstIndex) / 2; }\r\n    \r\n        this.clearFixtures();\r\n\r\n        return this.addPolygon(vertices, firstIndex, count);\r\n\r\n    },\r\n\r\n    /**\r\n    * Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#loadPolygon\r\n    * @param {string} key - The key of the Physics Data file as stored in Game.Cache.\r\n    * @param {string} object - The key of the object within the Physics data file that you wish to load the shape data from.\r\n    * @return {boolean} True on success, else false.\r\n    */\r\n    loadPolygon: function (key, object, sprite) {\r\n\r\n        if (typeof sprite === 'undefined') { sprite = null; }\r\n    \r\n        var data = this.game.cache.getPhysicsData(key, object);\r\n\r\n        for (var i = 0; i < data.length; i++)\r\n        {\r\n            var vertices = [];\r\n\r\n            for (var s = 0; s < data[i].shape.length; s += 2)\r\n            {\r\n                vertices.push( new box2d.b2Vec2( this.world.pxm(-data[i].shape[s]), this.world.pxm(-data[i].shape[s + 1]) ) );\r\n            }\r\n\r\n            if (sprite) {\r\n                var offsetx = this.world.pxm(-0.5 * sprite.width);\r\n                var offsety = this.world.pxm(-0.5 * sprite.height);\r\n                for (var k = 0; k < vertices.length; k++) {\r\n                    vertices[k].x -= offsetx;\r\n                    vertices[k].y -= offsety;\r\n                }\r\n            }\r\n\r\n            var polygonShape = new box2d.b2PolygonShape();\r\n            polygonShape.Set(vertices, vertices.length);\r\n    \r\n            var fixtureDef = new box2d.b2FixtureDef();\r\n            fixtureDef.shape = polygonShape;\r\n            fixtureDef.friction = data[i].friction;\r\n            fixtureDef.restitution = data[i].bounce;\r\n            fixtureDef.density = data[i].density;\r\n            fixtureDef.filter.categoryBits = data[i].filter.categoryBits;\r\n            fixtureDef.filter.maskBits = data[i].filter.maskBits;\r\n\r\n            var f = this.data.CreateFixture(fixtureDef);\r\n            f.id = this.world.getNextFixtureId();\r\n        }\r\n\r\n        return true;\r\n\r\n    },\r\n\r\n    /**\r\n    * Checks if the given point (pixel coords) is contained by any of the fixtures on this body.\r\n    * Not efficient for checking a large number of bodies to find which is under the mouse. (Use\r\n    * Phaser.Physics.Box2D.getBodiesAtPoint for that.)\r\n    *\r\n    * @method Phaser.Physics.Box2D.Body#containsPoint\r\n    * @param {Phaser.Pointer} point - The location to test for (pixel coordinates)\r\n    * @return {boolean} True on success, else false.\r\n    */\r\n    containsPoint: function (point) {\r\n        \r\n        var worldx = this.world.pxm(-point.x);\r\n        var worldy = this.world.pxm(-point.y);\r\n        var worldPoint = new box2d.b2Vec2(worldx, worldy);\r\n        \r\n        for (var f = this.data.GetFixtureList(); f; f = f.GetNext())\r\n        {\r\n            if (f.TestPoint(worldPoint))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n\r\n    }\r\n\r\n};\r\n\r\nPhaser.Physics.Box2D.Body.prototype.constructor = Phaser.Physics.Box2D.Body;\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#static\r\n* @property {boolean} static - Returns true if the Body is static. Setting Body.static to 'false' will make it dynamic.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"static\", {\r\n\r\n    get: function () {\r\n\r\n        return (this.data.GetType() === box2d.b2BodyType.b2_staticBody);\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        if (value && this.data.GetType() !== box2d.b2BodyType.b2_staticBody)\r\n        {\r\n            this.data.SetType(box2d.b2BodyType.b2_staticBody);\r\n        }\r\n        else if (!value && this.data.GetType() === box2d.b2BodyType.b2_staticBody)\r\n        {\r\n            this.data.SetType(box2d.b2BodyType.b2_dynamicBody);\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#dynamic\r\n* @property {boolean} dynamic - Returns true if the Body is dynamic. Setting Body.dynamic to 'false' will make it static.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"dynamic\", {\r\n\r\n    get: function () {\r\n\r\n        return (this.data.GetType() === box2d.b2BodyType.b2_dynamicBody);\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        if (value && this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody)\r\n        {\r\n            this.data.SetType(box2d.b2BodyType.b2_dynamicBody);\r\n        }\r\n        else if (!value && this.data.GetType() === box2d.b2BodyType.b2_dynamicBody)\r\n        {\r\n            this.data.SetType(box2d.b2BodyType.b2_staticBody);\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#kinematic\r\n* @property {boolean} kinematic - Returns true if the Body is kinematic. Setting Body.kinematic to 'false' will make it static.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"kinematic\", {\r\n\r\n    get: function () {\r\n\r\n        return (this.data.GetType() === box2d.b2BodyType.b2_kinematicBody);\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        if (value && this.data.GetType() !== box2d.b2BodyType.b2_kinematicBody)\r\n        {\r\n            this.data.SetType(box2d.b2BodyType.b2_kinematicBody);\r\n        }\r\n        else if (!value && this.data.GetType() === box2d.b2BodyType.b2_kinematicBody)\r\n        {\r\n            this.data.SetType(box2d.b2BodyType.b2_staticBody);\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n\r\n/**\r\n* The angle of the Body in degrees from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\r\n* Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement Body.angle = 450 is the same as Body.angle = 90.\r\n* If you wish to work in radians instead of degrees use the property Body.rotation instead. Working in radians is faster as it doesn't have to convert values.\r\n*\r\n* @name Phaser.Physics.Box2D.Body#angle\r\n* @property {number} angle - The angle of this Body in degrees.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"angle\", {\r\n\r\n    get: function() {\r\n\r\n        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.GetAngle()));\r\n\r\n    },\r\n\r\n    set: function(value) {\r\n\r\n        this.data.SetAngle( Phaser.Math.degToRad(Phaser.Math.wrapAngle(value)) );\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* Linear damping acts like drag to cause a body to slow down.\r\n* @name Phaser.Physics.Box2D.Body#linearDamping\r\n* @property {number} linearDamping - The linear damping acting acting on the body.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"linearDamping\", {\r\n\r\n    get: function () {\r\n\r\n        return this.data.GetLinearDamping();\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        this.data.SetLinearDamping(value);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* Linear damping acts like drag to cause rotation of a body to slow down.\r\n* @name Phaser.Physics.Box2D.Body#angularDamping\r\n* @property {number} angularDamping - The angular damping acting acting on the body.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"angularDamping\", {\r\n\r\n    get: function () {\r\n\r\n        return this.data.GetAngularDamping();\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        this.data.SetAngularDamping(value);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#angularVelocity\r\n* @property {number} angularVelocity - The angular velocity of the body.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"angularVelocity\", {\r\n\r\n    get: function () {\r\n\r\n        return this.data.GetAngularVelocity();\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        this.data.SetAngularVelocity(value);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#fixedRotation\r\n* @property {boolean} fixedRotation - If true, the body will not rotate.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"fixedRotation\", {\r\n\r\n    get: function () {\r\n\r\n        return this.data.IsFixedRotation();\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        this.data.SetFixedRotation(value);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#gravityScale\r\n* @property {boolean} gravityScale - Set to zero to completely ignore gravity, or negative values to reverse gravity for this body.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"gravityScale\", {\r\n\r\n    get: function () {\r\n\r\n        return this.data.GetGravityScale();\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        this.data.SetGravityScale(value);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#friction\r\n* @property {number} friction - When setting, all fixtures on the body will be set to the given friction. When getting, the friction of the first fixture will be returned, or zero if no fixtures are present.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"friction\", {\r\n\r\n    get: function () {\r\n\r\n        var fixture = this.data.GetFixtureList();\r\n        \r\n        if (fixture) {\r\n            return fixture.GetFriction();\r\n        }\r\n\r\n        return 0;\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {\r\n\r\n            f.SetFriction(value);\r\n            f.Refilter();\r\n\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#restitution\r\n* @property {number} restitution - When setting, all fixtures on the body will be set to the given restitution. When getting, the restitution of the first fixture will be returned, or zero if no fixtures are present.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"restitution\", {\r\n\r\n    get: function () {\r\n\r\n        var fixture = this.data.GetFixtureList();\r\n        \r\n        if (fixture) {\r\n            return fixture.GetRestitution();\r\n        }\r\n\r\n        return 0;\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {\r\n\r\n            f.SetRestitution(value);\r\n            f.Refilter();\r\n\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#sensor\r\n* @property {boolean} sensor - When setting, all fixtures on the body will be set to the given sensor status. When getting, the sensor status of the first fixture will be returned, or false if no fixtures are present.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"sensor\", {\r\n\r\n    get: function () {\r\n\r\n        var fixture = this.data.GetFixtureList();\r\n        \r\n        if (fixture) {\r\n            return fixture.IsSensor();\r\n        }\r\n\r\n        return 0;\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {\r\n\r\n            f.SetSensor(value);\r\n            f.Refilter();\r\n\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#bullet\r\n* @property {boolean} bullet - Set to true to give the body 'bullet' status, and use continous collision detection when moving it.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"bullet\", {\r\n\r\n    get: function () {\r\n\r\n        return this.data.IsBullet();\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        this.data.SetBullet(value);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#mass\r\n* @property {number} mass - the new mass for the body. Setting this to zero will cause the body to become a static body.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"mass\", {\r\n\r\n    get: function () {\r\n\r\n        return this.data.GetMass();\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n        \r\n        if (value === 0) {\r\n            this.data.SetType(box2d.b2BodyType.b2_staticBody);\r\n        }\r\n        else {\r\n            \r\n            // Make sure the body is dynamic, before giving it a non-zero mass.\r\n            if (this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody) {\r\n                \r\n                this.data.SetType(box2d.b2BodyType.b2_dynamicBody);\r\n                \r\n            }\r\n        \r\n            // Mass is determined by (area * density) of attached fixtures.\r\n            // We need to find the current mass and scale the density of all\r\n            // fixtures so that the overall mass matches the desired mass.\r\n            \r\n            var oldMass = this.data.GetMass();\r\n            var scaleby = value / oldMass;\r\n    \r\n            for (var f = this.data.GetFixtureList(); f; f = f.GetNext()) {\r\n                var oldDensity = f.GetDensity();\r\n                f.SetDensity(oldDensity * scaleby);\r\n            }\r\n            \r\n            // Make sure the new fixture densities take effect in the body\r\n            this.data.ResetMassData();\r\n        \r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* The angle of the Body in radians.\r\n* If you wish to work in degrees instead of radians use the Body.angle property instead. Working in radians is faster as it doesn't have to convert values.\r\n*\r\n* @name Phaser.Physics.Box2D.Body#rotation\r\n* @property {number} rotation - The angle of this Body in radians.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"rotation\", {\r\n\r\n    get: function() {\r\n\r\n        return this.data.GetAngle();\r\n\r\n    },\r\n\r\n    set: function(value) {\r\n\r\n        this.data.SetAngle(value);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#x\r\n* @property {number} x - The x coordinate of this Body.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"x\", {\r\n\r\n    get: function () {\r\n\r\n        return this.world.mpx(-this.data.GetPosition().x);\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        this.data.SetPositionXY(this.world.pxm(-value), this.data.GetPosition().y);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.Body#y\r\n* @property {number} y - The y coordinate of this Body.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"y\", {\r\n\r\n    get: function () {\r\n\r\n        return this.world.mpx(-this.data.GetPosition().y);\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        this.data.SetPositionXY(this.data.GetPosition().x, this.world.pxm(-value));\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* A Body can be set to collide against the World bounds automatically if this is set to true. Otherwise it will leave the World.\r\n* Note that this only applies if your World has bounds! When getting this property, the returned value will be true if any of the\r\n* fixtures of this body are set to collide with the world bounds.\r\n*\r\n* @name Phaser.Physics.Box2D.Body#collideWorldBounds\r\n* @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.Body.prototype, \"collideWorldBounds\", {\r\n\r\n    get: function () {\r\n\r\n        for (var f = this.data.GetFixtureList(); f; f = f.GetNext())\r\n        {\r\n            var filter = f.GetFilterData();\r\n\r\n            if (filter.maskBits & Phaser.Physics.Box2D.worldBoundsFilterCategory)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        for (var f = this.data.GetFixtureList(); f; f = f.GetNext())\r\n        {\r\n            var filter = f.GetFilterData();\r\n\r\n            if (value)\r\n            {\r\n                filter.maskBits |=  Phaser.Physics.Box2D.worldBoundsFilterCategory;\r\n            }\r\n            else\r\n            {\r\n                filter.maskBits &= ~Phaser.Physics.Box2D.worldBoundsFilterCategory;\r\n            }\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @author       Chris Campbell <iforce2d@gmail.com>\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2015 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\n/**\r\n* A PointProxy is an internal class that allows for direct getter/setter style property access to box2d.b2Vec2 objects but inverses the values on set.\r\n* The value of the vector is not stored in this class. Instead, it holds a reference to the object that actually stores the value, along with the functions used to get and set from that object.\r\n*\r\n* @xclass Phaser.Physics.Box2D.PointProxy\r\n* @classdesc PointProxy\r\n* @constructor\r\n* @param {Phaser.Physics.Box2D} world - A reference to the Box2D world, used for pixel/meter conversions.\r\n* @param {any} object - The object to bind to, which holds the actual value.\r\n* @param {function} gettor - The function of the bound object which gets the value from it.\r\n* @param {function} settor - The function of the bound object which sets the value in it.\r\n*/\r\nPhaser.Physics.Box2D.PointProxy = function (world, object, gettor, settor) {\r\n\r\n    this.world = world;\r\n    this.object = object;\r\n    this.gettor = gettor;\r\n    this.settor = settor;\r\n\r\n};\r\n\r\nPhaser.Physics.Box2D.PointProxy.prototype.constructor = Phaser.Physics.Box2D.PointProxy;\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.PointProxy#x\r\n* @property {number} x - The x property of this PointProxy.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, \"x\", {\r\n\r\n    get: function () {\r\n\r\n        return this.world.mpx(-this.gettor.call(this.object).x);\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n        \r\n        var v = this.gettor.call(this.object);\r\n        v.x = this.world.pxm(-value);\r\n        this.settor.call(this.object, v);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.PointProxy#y\r\n* @property {number} y - The y property of this PointProxy.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, \"y\", {\r\n\r\n    get: function () {\r\n\r\n        return this.world.mpx(-this.gettor.call(this.object).y);\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        var v = this.gettor.call(this.object);\r\n        v.y = this.world.pxm(-value);\r\n        this.settor.call(this.object, v);\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @author       Chris Campbell <iforce2d@gmail.com>\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2015 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n/** \r\n * This class implements debug drawing callbacks\r\n * @constructor\r\n * @param {number} pixelsPerMeter\r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw = function (pixelsPerMeter)\r\n{\r\n    this.context = null;\r\n    this.pixelsPerMeter = pixelsPerMeter;\r\n    this.flags = box2d.b2DrawFlags.e_shapeBit;\r\n};\r\n\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.color = new box2d.b2Color(1, 1, 1);\r\n\r\n/**\r\n * Sets which aspects of the world to render\r\n *\r\n * @export \r\n * @return {void}\r\n * @param {number} flags - a bitflag made from one or more of the following:\r\n *     box2d.b2DrawFlags = { e_none, e_shapeBit, e_jointBit, e_aabbBit, e_pairBit, e_centerOfMassBit, e_all }\r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.SetFlags = function (flags)\r\n{\r\n    this.flags = flags;\r\n};\r\n\r\n/**\r\n * Gets which aspects of the world are currently set to be rendered\r\n *\r\n * @export \r\n * @return {number} - the flags currently set\r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.GetFlags = function ()\r\n{\r\n    return this.flags;\r\n};\r\n\r\n/**\r\n * Sets the canvas context to use in subsequent rendering and applies overall transform.\r\n *\r\n * @export \r\n * @return {void} \r\n * @param {CanvasRenderingContext2D} context\r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.start = function (context)\r\n{\r\n    this.context = context;\r\n    this.context.save();\r\n    this.context.scale(-1, -1);\r\n    this.context.scale(this.pixelsPerMeter, this.pixelsPerMeter);\r\n};\r\n\r\n/**\r\n * Resets transform state to original\r\n *\r\n * @export \r\n * @return {void} \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.stop = function ()\r\n{\r\n    this.context.restore();\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Transform} xf \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.PushTransform = function (xf)\r\n{\r\n    var ctx = this.context;\r\n    ctx.save();\r\n    ctx.translate(xf.p.x, xf.p.y);\r\n    ctx.rotate(xf.q.GetAngleRadians());\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Transform} xf \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.PopTransform = function ()\r\n{\r\n    var ctx = this.context;\r\n    ctx.restore();\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {Array.<box2d.b2Vec2>} vertices \r\n * @param {number} vertexCount \r\n * @param {box2d.b2Color} color \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color)\r\n{\r\n    if (!vertexCount)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var ctx = this.context;\r\n    \r\n    ctx.lineWidth = 1 / this.pixelsPerMeter;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(vertices[0].x, vertices[0].y);\r\n\r\n    for (var i = 1; i < vertexCount; i++)\r\n    {\r\n        ctx.lineTo(vertices[i].x, vertices[i].y);\r\n    }\r\n\r\n    ctx.closePath();\r\n    ctx.strokeStyle = color.MakeStyleString(1);\r\n    ctx.stroke();\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {Array.<box2d.b2Vec2>} vertices \r\n * @param {number} vertexCount \r\n * @param {box2d.b2Color} color \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color)\r\n{\r\n    if (!vertexCount)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var ctx = this.context;\r\n    \r\n    ctx.lineWidth = 1 / this.pixelsPerMeter;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(vertices[0].x, vertices[0].y);\r\n\r\n    for (var i = 1; i < vertexCount; i++)\r\n    {\r\n        ctx.lineTo(vertices[i].x, vertices[i].y);\r\n    }\r\n\r\n    ctx.closePath();\r\n    ctx.fillStyle = color.MakeStyleString(0.5);\r\n    ctx.fill();\r\n    ctx.strokeStyle = color.MakeStyleString(1);\r\n    ctx.stroke();\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} center \r\n * @param {number} radius \r\n * @param {box2d.b2Color} color \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawCircle = function (center, radius, color)\r\n{\r\n    if (!radius)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var ctx = this.context;\r\n\r\n    ctx.beginPath();\r\n    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2, true);\r\n    ctx.strokeStyle = color.MakeStyleString(1);\r\n    ctx.stroke();\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} center \r\n * @param {number} radius \r\n * @param {box2d.b2Vec2} axis \r\n * @param {box2d.b2Color} color \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color)\r\n{\r\n    if (!radius)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var ctx = this.context;\r\n    \r\n    ctx.lineWidth = 1 / this.pixelsPerMeter;\r\n\r\n    var cx = center.x;\r\n    var cy = center.y;\r\n    ctx.beginPath();\r\n    ctx.arc(cx, cy, radius, 0, Math.PI * 2, true);\r\n    ctx.moveTo(cx, cy);\r\n    ctx.lineTo((cx + axis.x * radius), (cy + axis.y * radius));\r\n    ctx.fillStyle = color.MakeStyleString(0.5);\r\n    ctx.fill();\r\n    ctx.strokeStyle = color.MakeStyleString(1);\r\n    ctx.stroke();\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} p1 \r\n * @param {box2d.b2Vec2} p2 \r\n * @param {box2d.b2Color} color \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSegment = function (p1, p2, color)\r\n{\r\n    var ctx = this.context;\r\n    \r\n    ctx.lineWidth = 1 / this.pixelsPerMeter;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(p1.x, p1.y);\r\n    ctx.lineTo(p2.x, p2.y);\r\n    ctx.strokeStyle = color.MakeStyleString(1);\r\n    ctx.stroke();\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Transform} xf \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawTransform = function (xf)\r\n{\r\n    var ctx = this.context;\r\n    \r\n    ctx.lineWidth = 1 / this.pixelsPerMeter;\r\n\r\n    this.PushTransform(xf);\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, 0);\r\n    ctx.lineTo(1, 0);\r\n    ctx.strokeStyle = box2d.b2Color.RED.MakeStyleString(1);\r\n    ctx.stroke();\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, 0);\r\n    ctx.lineTo(0, 1);\r\n    ctx.strokeStyle = box2d.b2Color.GREEN.MakeStyleString(1);\r\n    ctx.stroke();\r\n\r\n    this.PopTransform(xf);\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Vec2} p \r\n * @param {number} size \r\n * @param {box2d.b2Color} color \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPoint = function (p, size, color)\r\n{\r\n    var ctx = this.context;\r\n\r\n    ctx.fillStyle = color.MakeStyleString();\r\n    //size /= this.m_settings.viewZoom;\r\n    //size /= this.m_settings.canvasScale;\r\n    var hsize = size / 2;\r\n    ctx.fillRect(p.x - hsize, p.y - hsize, size, size);\r\n};\r\n\r\n/**\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2AABB} aabb \r\n * @param {box2d.b2Color} color \r\n */\r\nPhaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawAABB = function (aabb, color)\r\n{\r\n    var ctx = this.context;\r\n\r\n    ctx.strokeStyle = color.MakeStyleString();\r\n    var x = aabb.lowerBound.x;\r\n    var y = aabb.lowerBound.y;\r\n    var w = aabb.upperBound.x - aabb.lowerBound.x;\r\n    var h = aabb.upperBound.y - aabb.lowerBound.y;\r\n    ctx.strokeRect(x, y, w, h);\r\n};\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.DefaultDebugDraw#shapes\r\n* @property {boolean} shapes - Specifies whether the debug draw should render shapes.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, \"shapes\", {\r\n\r\n    get: function () {\r\n\r\n        return this.flags & box2d.b2DrawFlags.e_shapeBit;\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        if (value)\r\n        {\r\n            this.flags |= box2d.b2DrawFlags.e_shapeBit;\r\n        }\r\n        else\r\n        {\r\n            this.flags &= ~box2d.b2DrawFlags.e_shapeBit;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.DefaultDebugDraw#joints\r\n* @property {boolean} joints - Specifies whether the debug draw should render joints.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, \"joints\", {\r\n\r\n    get: function () {\r\n\r\n        return this.flags & box2d.b2DrawFlags.e_jointBit;\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        if (value)\r\n        {\r\n            this.flags |= box2d.b2DrawFlags.e_jointBit;\r\n        }\r\n        else\r\n        {\r\n            this.flags &= ~box2d.b2DrawFlags.e_jointBit;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.DefaultDebugDraw#aabbs\r\n* @property {boolean} aabbs - Specifies whether the debug draw should render fixture AABBs.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, \"aabbs\", {\r\n\r\n    get: function () {\r\n\r\n        return this.flags & box2d.b2DrawFlags.e_aabbBit;\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        if (value)\r\n        {\r\n            this.flags |= box2d.b2DrawFlags.e_aabbBit;\r\n        }\r\n        else\r\n        {\r\n            this.flags &= ~box2d.b2DrawFlags.e_aabbBit;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.DefaultDebugDraw#pairs\r\n* @property {boolean} pairs - Specifies whether the debug draw should render contact pairs.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, \"pairs\", {\r\n\r\n    get: function () {\r\n\r\n        return this.flags & box2d.b2DrawFlags.e_pairBit;\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        if (value)\r\n        {\r\n            this.flags |= box2d.b2DrawFlags.e_pairBit;\r\n        }\r\n        else\r\n        {\r\n            this.flags &= ~box2d.b2DrawFlags.e_pairBit;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @name Phaser.Physics.Box2D.DefaultDebugDraw#centerOfMass\r\n* @property {boolean} centerOfMass - Specifies whether the debug draw should render the center of mass of bodies.\r\n*/\r\nObject.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, \"centerOfMass\", {\r\n\r\n    get: function () {\r\n\r\n        return this.flags & box2d.b2DrawFlags.e_centerOfMassBit;\r\n\r\n    },\r\n\r\n    set: function (value) {\r\n\r\n        if (value)\r\n        {\r\n            this.flags |= box2d.b2DrawFlags.e_centerOfMassBit;\r\n        }\r\n        else\r\n        {\r\n            this.flags &= ~box2d.b2DrawFlags.e_centerOfMassBit;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n* @author       Chris Campbell <iforce2d@gmail.com>\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2015 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\n/** \r\n * This class implements a contact listener. The default behaviour is to check if the two bodies\r\n * that contacted had a callback set up by one of the following:\r\n *     Phaser.Physics.Box2D.Body.createBodyContactCallback\r\n *     Phaser.Physics.Box2D.Body.createCategoryContactCallback\r\n *     Phaser.Physics.Box2D.Body.createFixtureContactCallback\r\n * @constructor\r\n */\r\nPhaser.Physics.Box2D.DefaultContactListener = function ()\r\n{\r\n};\r\n\r\n/** \r\n * Called when two fixtures begin to touch. \r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n */\r\nPhaser.Physics.Box2D.DefaultContactListener.prototype.BeginContact = function (contact)\r\n{\r\n    this.handleContactBeginOrEnd(contact, true);\r\n};\r\n\r\n/** \r\n * Called when two fixtures cease touching.\r\n * @export \r\n * @return {void} \r\n * @param {box2d.b2Contact} contact \r\n */\r\nPhaser.Physics.Box2D.DefaultContactListener.prototype.EndContact = function (contact)\r\n{\r\n    this.handleContactBeginOrEnd(contact, false);\r\n};\r\n\r\n/** \r\n * Common code for begin and end contacts.\r\n * @export \r\n * @param {box2d.b2Contact} contact \r\n * @param {boolean} begin - true for a begin, false for an end \r\n * @return {void} \r\n */\r\nPhaser.Physics.Box2D.DefaultContactListener.prototype.handleContactBeginOrEnd = function (contact, begin)\r\n{\r\n    var fA = contact.GetFixtureA();\r\n    var fB = contact.GetFixtureB();\r\n    var bA = fA.GetBody();\r\n    var bB = fB.GetBody();\r\n    var catA = fA.GetFilterData().categoryBits;\r\n    var catB = fB.GetFilterData().categoryBits;\r\n    var pA = bA.parent;\r\n    var pB = bB.parent;\r\n    \r\n    if ( pA === void 0 || pB === void 0 ) {\r\n        return;\r\n    }\r\n    \r\n    var idA = pA.id;\r\n    var idB = pB.id;\r\n    \r\n    // Check body callbacks\r\n    if (pA._bodyContactCallbacks[idB])\r\n    {\r\n        pA._bodyContactCallbacks[idB].call(pA._bodyContactCallbackContext[idB], pA, pB, fA, fB, begin, contact);\r\n    }\r\n\r\n    if (pB._bodyContactCallbacks[idA])\r\n    {\r\n        pB._bodyContactCallbacks[idA].call(pB._bodyContactCallbackContext[idA], pB, pA, fB, fA, begin, contact);\r\n    }   \r\n        \r\n    // Check fixture callbacks\r\n    if (pA._fixtureContactCallbacks[fB.id])\r\n    {\r\n        pA._fixtureContactCallbacks[fB.id].call(pA._fixtureContactCallbackContext[fB.id], pA, pB, fA, fB, begin, contact);\r\n    }\r\n\r\n    if (pB._fixtureContactCallbacks[fA.id])\r\n    {\r\n        pB._fixtureContactCallbacks[fA.id].call(pB._fixtureContactCallbackContext[fA.id], pB, pA, fB, fA, begin, contact);\r\n    }   \r\n        \r\n    if (pA._fixtureContactCallbacks[fA.id])\r\n    {\r\n        pA._fixtureContactCallbacks[fA.id].call(pA._fixtureContactCallbackContext[fA.id], pA, pB, fA, fB, begin, contact);\r\n    }\r\n\r\n    if (pB._fixtureContactCallbacks[fB.id])\r\n    {\r\n        pB._fixtureContactCallbacks[fB.id].call(pB._fixtureContactCallbackContext[fB.id], pB, pA, fB, fA, begin, contact);\r\n    }\r\n    \r\n    // Check group callbacks\r\n    if (pA._categoryContactCallbacks[catB])\r\n    {\r\n        pA._categoryContactCallbacks[catB].call(pA._categoryContactCallbackContext[catB], pA, pB, fA, fB, begin, contact);\r\n    }\r\n\r\n    if (pB._categoryContactCallbacks[catA])\r\n    {\r\n        pB._categoryContactCallbacks[catA].call(pB._categoryContactCallbackContext[catA], pB, pA, fB, fA, begin, contact);\r\n    }\r\n    \r\n    if (pA._categoryContactCallbacks[catA])\r\n    {\r\n        pA._categoryContactCallbacks[catA].call(pA._categoryContactCallbackContext[catA], pA, pB, fA, fB, begin, contact);\r\n    }\r\n\r\n    if (pB._categoryContactCallbacks[catB])\r\n    {\r\n        pB._categoryContactCallbacks[catB].call(pB._categoryContactCallbackContext[catB], pB, pA, fB, fA, begin, contact);\r\n    }\r\n\r\n};\r\n\r\n/** \r\n * This is called after a contact is updated. This allows you to \r\n * inspect a contact before it goes to the solver. If you are \r\n * careful, you can modify the contact manifold (e.g. disable \r\n * contact). \r\n * @export \r\n * @param {box2d.b2Contact} contact \r\n * @param {box2d.b2Manifold} oldManifold \r\n * @return {void} \r\n */\r\nPhaser.Physics.Box2D.DefaultContactListener.prototype.PreSolve = function (contact, oldManifold)\r\n{\r\n    var fA = contact.GetFixtureA();\r\n    var fB = contact.GetFixtureB();\r\n    var bA = fA.GetBody();\r\n    var bB = fB.GetBody();\r\n    var catA = fA.GetFilterData().categoryBits;\r\n    var catB = fB.GetFilterData().categoryBits;\r\n    var pA = bA.parent;\r\n    var pB = bB.parent;\r\n    \r\n    if ( pA === void 0 || pB === void 0 ) {\r\n        return;\r\n    }\r\n    \r\n    var idA = pA.id;\r\n    var idB = pB.id;\r\n\r\n    // Check body callbacks\r\n    if (pA._bodyPresolveCallbacks[idB])\r\n    {\r\n        pA._bodyPresolveCallbacks[idB].call(pA._bodyPresolveCallbackContext[idB], pA, pB, fA, fB, contact, oldManifold);\r\n    }\r\n\r\n    if (pB._bodyPresolveCallbacks[idA])\r\n    {\r\n        pB._bodyPresolveCallbacks[idA].call(pB._bodyPresolveCallbackContext[idA], pB, pA, fB, fA, contact, oldManifold);\r\n    }   \r\n        \r\n    // Check fixture callbacks\r\n    if (pA._fixturePresolveCallbacks[fB.id])\r\n    {\r\n        pA._fixturePresolveCallbacks[fB.id].call(pA._fixturePresolveCallbackContext[fB.id], pA, pB, fA, fB, contact, oldManifold);\r\n    }\r\n\r\n    if (pB._fixturePresolveCallbacks[fA.id])\r\n    {\r\n        pB._fixturePresolveCallbacks[fA.id].call(pB._fixturePresolveCallbackContext[fA.id], pB, pA, fB, fA, contact, oldManifold);\r\n    }\r\n    \r\n    // Check group callbacks\r\n    if (pA._categoryPresolveCallbacks[catB])\r\n    {\r\n        pA._categoryPresolveCallbacks[catB].call(pA._categoryPresolveCallbackContext[catB], pA, pB, fA, fB, contact, oldManifold);\r\n    }\r\n\r\n    if (pB._categoryPresolveCallbacks[catA])\r\n    {\r\n        pB._categoryPresolveCallbacks[catA].call(pB._categoryPresolveCallbackContext[catA], pB, pA, fB, fA, contact, oldManifold);\r\n    }\r\n\r\n};\r\n\r\n/** \r\n * This lets you inspect a contact after the solver is finished. \r\n * @export \r\n * @param {box2d.b2Contact} contact\r\n * @param {box2d.b2ContactImpulse} impulse\r\n * @return {void} \r\n */\r\nPhaser.Physics.Box2D.DefaultContactListener.prototype.PostSolve = function (contact, impulse)\r\n{\r\n    var fA = contact.GetFixtureA();\r\n    var fB = contact.GetFixtureB();\r\n    var bA = fA.GetBody();\r\n    var bB = fB.GetBody();\r\n    var catA = fA.GetFilterData().categoryBits;\r\n    var catB = fB.GetFilterData().categoryBits;\r\n    var pA = bA.parent;\r\n    var pB = bB.parent;\r\n    \r\n    if ( pA === void 0 || pB === void 0 ) {\r\n        return;\r\n    }\r\n    \r\n    var idA = pA.id;\r\n    var idB = pB.id;\r\n\r\n    // Check body callbacks\r\n    if (pA._bodyPostsolveCallbacks[idB])\r\n    {\r\n        pA._bodyPostsolveCallbacks[idB].call(pA._bodyPostsolveCallbackContext[idB], pA, pB, fA, fB, contact, impulse);\r\n    }\r\n\r\n    if (pB._bodyPostsolveCallbacks[idA])\r\n    {\r\n        pB._bodyPostsolveCallbacks[idA].call(pB._bodyPostsolveCallbackContext[idA], pB, pA, fB, fA, contact, impulse);\r\n    }   \r\n        \r\n    // Check fixture callbacks\r\n    if (pA._fixturePostsolveCallbacks[fB.id])\r\n    {\r\n        pA._fixturePostsolveCallbacks[fB.id].call(pA._fixturePostsolveCallbackContext[fB.id], pA, pB, fA, fB, contact, impulse);\r\n    }\r\n\r\n    if (pB._fixturePostsolveCallbacks[fA.id])\r\n    {\r\n        pB._fixturePostsolveCallbacks[fA.id].call(pB._fixturePostsolveCallbackContext[fA.id], pB, pA, fB, fA, contact, impulse);\r\n    }\r\n    \r\n    // Check group callbacks\r\n    if (pA._categoryPostsolveCallbacks[catB])\r\n    {\r\n        pA._categoryPostsolveCallbacks[catB].call(pA._categoryPostsolveCallbackContext[catB], pA, pB, fA, fB, contact, impulse);\r\n    }\r\n\r\n    if (pB._categoryPostsolveCallbacks[catA])\r\n    {\r\n        pB._categoryPostsolveCallbacks[catA].call(pB._categoryPostsolveCallbackContext[catA], pB, pA, fB, fA, contact, impulse);\r\n    }\r\n\r\n};\r\n\r\n/**\r\n* @author       Chris Campbell <iforce2d@gmail.com>\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2015 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\n/**\r\n* A generic polygon class. Includes functions for decomposing into convex polygons.\r\n* Use one of the 'set' functions to define the vertices.\r\n*\r\n* @class Phaser.Physics.Box2D.Polygon\r\n*/\r\nPhaser.Physics.Box2D.Polygon = function () {\r\n    this.vertices = [];\r\n};\r\n\r\n/**\r\n * Sets the vertices of this polygon from a flat array of xy coords, eg [x, y, x, y, x, y, ...]\r\n * @param {Array} flatXYCoords - a flat array of xy coordinates\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.setFromFlatXYCoords = function(flatXYCoords) {\r\n\r\n    this.vertices = [];\r\n\r\n    for (var i = 0; i < flatXYCoords.length / 2; i++) {\r\n        this.vertices.push( { x: flatXYCoords[2*i], y: flatXYCoords[2*i+1] } );\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Sets the vertices of this polygon from an array of xy objects, eg [ {x, y}, {x, y}, {x, y}, ...]\r\n * @param {Array} xyObjects - \r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.setFromXYObjects = function(xyObjects) {\r\n    this.vertices = xyObjects.concat();\r\n};\r\n\r\n/**\r\n * Appends a vertex to this polygon\r\n * @param {object} vertex - an object containing x and y number properties\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.addVertex = function(vertex) {\r\n    this.vertices.push(vertex);\r\n};\r\n\r\n/**\r\n * Returns the vertex at the given position\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.at = function(i) {\r\n\r\n    var s = this.vertices.length;\r\n    return this.vertices[i < 0 ? i % s + s : i % s];\r\n\r\n};\r\n\r\n/**\r\n * Checks if two indices are adjacent or the same on this polygon\r\n * For example, on a polygon with 5 vertices, indices 4 and 0 are adjacent.\r\n * @param {number} a - first index\r\n * @param {number} b - second index\r\n * @return {boolean} true if the two indices are adjacent or equal\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.indicesAreAdjacent = function (a, b) {\r\n\r\n    a = a % this.vertices.length;\r\n    b = b % this.vertices.length;\r\n    \r\n    if ( a == b ) { return true; }\r\n    var diff = Math.abs(a-b);\r\n    if ( diff < 2 ) { return true; }\r\n    if ( diff == this.vertices.length-1 ) { return true; }\r\n    \r\n    return false;\r\n};\r\n\r\n/**\r\n * Returns the area of the triangle formed by three vertices of this polygon.\r\n * Result will be negative for clockwise windings.\r\n * @param {number} a - index of first vertex\r\n * @param {number} b - index of second vertex\r\n * @param {number} c - index of third vertex\r\n * @return {number} The area of the triangle formed by the three vertices\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.areaInTriangle = function (a, b, c) {\r\n\r\n    a = this.at(a);\r\n    b = this.at(b);\r\n    c = this.at(c);\r\n\r\n    return (((b.x - a.x)*(c.y - a.y))-((c.x - a.x)*(b.y - a.y))) * 0.5;\r\n\r\n};\r\n\r\n/**\r\n * Checks if the polygon outline turns left at the given vertex, when moving around\r\n * the outline in counter-clockwise order. Polygon must be made CCW first!\r\n * @return {boolean} True if outline turns left at the given vertex\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.left = function(a, b, c) {    \r\n\r\n    return this.areaInTriangle(a, b, c) > 0;\r\n\r\n};\r\n\r\n/**\r\n * Checks if the polygon outline turns left or stays straight at the given vertex, when moving around\r\n * the outline in counter-clockwise order. Polygon must be made CCW first!\r\n * @return {boolean} True if outline turns left at the given vertex or stays straight\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.leftOn = function(a, b, c) {\r\n\r\n    return this.areaInTriangle(a, b, c) >= 0;\r\n\r\n};\r\n\r\n/**\r\n * Checks if the polygon outline turns right at the given vertex, when moving around\r\n * the outline in counter-clockwise order. Polygon must be made CCW first!\r\n * @return {boolean} True if outline turns right at the given vertex\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.right = function(a, b, c) {\r\n\r\n    return this.areaInTriangle(a, b, c) < 0;\r\n\r\n};\r\n\r\n/**\r\n * Checks if the polygon outline turns right or stays straight at the given vertex, when moving around\r\n * the outline in counter-clockwise order. Polygon must be made CCW first!\r\n * @return {boolean} True if outline turns right at the given vertex or stays straight\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.rightOn = function(a, b, c) {\r\n\r\n    return this.areaInTriangle(a, b, c) <= 0;\r\n\r\n};\r\n\r\n/**\r\n * Finds the squared distance between two points\r\n * @param {object} a - an object with x and y number properties\r\n * @param {object} b - an object with x and y number properties\r\n * @return {number} The square of the distance between the two points\r\n */\r\nPhaser.Physics.Box2D.Polygon.sqdist = function(a, b) {\r\n\r\n    var dx = b.x - a.x;\r\n    var dy = b.y - a.y;\r\n\r\n    return dx * dx + dy * dy;\r\n\r\n};\r\n\r\n/**\r\n * Ensures this polygon is wound counter-clockwise.\r\n * @return {boolean} true if the polygon winding was reversed\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.makeCCW = function() {\r\n    \r\n    // Find bottom right point\r\n    var br = 0;\r\n\r\n    for (var i = 1, len = this.vertices.length; i < len; i++)\r\n    {\r\n        if (this.at(i).y < this.at(br).y || (this.at(i).y === this.at(br).y && this.at(i).x > this.at(br).x))\r\n        {\r\n            br = i;\r\n        }\r\n    }\r\n\r\n    // Reverse poly if clockwise\r\n    if (!this.left(br - 1, br, br + 1))\r\n    {\r\n        this.vertices.reverse();\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n\r\n};\r\n\r\n/**\r\n * Checks if this polygon is convex.\r\n * @return {boolean} True if the polygon is convex.\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.isConvex = function () {\r\n    \r\n    var havePositive = false;\r\n    var haveNegative = false;\r\n    \r\n    for (var i = 0, len = this.vertices.length; i < len; i++)\r\n    {\r\n        var i0 = i;\r\n        var i1 = (i + 1) % len;\r\n        var i2 = (i + 2) % len;\r\n\r\n        if (this.areaInTriangle(this.vertices[i0], this.vertices[i1], this.vertices[i2]) > 0)\r\n        {\r\n            havePositive = true;\r\n        }\r\n        else\r\n        {\r\n            haveNegative = true;\r\n        }\r\n    }\r\n\r\n    return haveNegative ^ havePositive;\r\n\r\n};\r\n\r\n/**\r\n * Checks if the given vertex is reflex (concave causing). Polygon must be made CCW first!\r\n * @param {object} i - the index of the vertex to check\r\n * @return {number} true if the given vertex is a reflex vertex\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.isReflex = function (i) {\r\n\r\n    return this.right(i - 1, i, i + 1);\r\n\r\n};\r\n\r\n/**\r\n * Check if two vectors are equal.\r\n * @param {object} v0 - an object with x and y properties\r\n * @param {object} v1 - an object with x and y properties\r\n * @return {boolean} true if the two vector are the same\r\n */\r\nPhaser.Physics.Box2D.Polygon.areVecsEqual = function(v0, v1) {\r\n\r\n    return v0.x == v1.x && v0.y == v1.y;\r\n\r\n};\r\n\r\n/**\r\n * Check if two lines intersect each other.\r\n * @param {object} v0 - an object with x and y properties (first point of first line)\r\n * @param {object} v1 - an object with x and y properties (second point of first line)\r\n * @param {object} t0 - an object with x and y properties (first point of second line)\r\n * @param {object} t1 - an object with x and y properties (second point of second line)\r\n * @return {number} The intersection point, or null if the lines do not cross\r\n */\r\nPhaser.Physics.Box2D.Polygon.linesCross = function(v0, v1, t0, t1) {\r\n\r\n    if (Phaser.Physics.Box2D.Polygon.areVecsEqual(v1,t0) || Phaser.Physics.Box2D.Polygon.areVecsEqual(v0,t0) || Phaser.Physics.Box2D.Polygon.areVecsEqual(v1,t1) || Phaser.Physics.Box2D.Polygon.areVecsEqual(v0,t1))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    var vnormal = {};\r\n\r\n    box2d.b2SubVV(v1, v0, vnormal);\r\n    box2d.b2CrossVS(vnormal, 1, vnormal);\r\n\r\n    var v0d = box2d.b2DotVV(vnormal, v0);\r\n    var t0d = box2d.b2DotVV(vnormal, t0);\r\n    var t1d = box2d.b2DotVV(vnormal, t1);\r\n\r\n    if ( t0d > v0d && t1d > v0d )\r\n    {\r\n        return null;\r\n    }\r\n\r\n    if ( t0d < v0d && t1d < v0d )\r\n    {\r\n        return null;\r\n    }\r\n\r\n    var tnormal = {};\r\n    box2d.b2SubVV(t1, t0, tnormal);\r\n    box2d.b2CrossVS(tnormal, 1, tnormal);\r\n\r\n    var t0d = box2d.b2DotVV(tnormal, t0);\r\n    var v0d = box2d.b2DotVV(tnormal, v0);\r\n    var v1d = box2d.b2DotVV(tnormal, v1);\r\n\r\n    if ( v0d > t0d && v1d > t0d )\r\n    {\r\n        return null;\r\n    }\r\n\r\n    if ( v0d < t0d && v1d < t0d )\r\n    {\r\n        return null;\r\n    }\r\n\r\n    var f = (t0d - v0d) / (v1d - v0d);\r\n\r\n    var intersectionPoint = { x: v0.x + f * (v1.x-v0.x), y: v0.y + f * (v1.y-v0.y) };\r\n\r\n    return intersectionPoint;\r\n\r\n};\r\n\r\n/**\r\n * Check if two vertices of a polygon have a clear line of sight to each other. \"Line of sight\" means\r\n * that the line between them is not intersected by any other edges of the polygon.\r\n * @param {Array} vertices - array of vertices representing the polygon\r\n * @param {number} a - index of first vertex\r\n * @param {number} b - index of second vertex\r\n * @return {boolean} true if the two vertices are not adjacent and can 'see' each other.\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.canSee = function (a, b) {\r\n\r\n    if (this.indicesAreAdjacent(a, b) )\r\n    {\r\n        return false;\r\n    }\r\n        \r\n    if (this.leftOn(a + 1, a, b) && this.rightOn(a - 1, a, b))\r\n    {\r\n        return false;\r\n    }\r\n    \r\n    for (var i = 0; i < this.vertices.length; ++i)\r\n    {\r\n        // for each edge\r\n        if ((i + 1) % this.vertices.length == a || i == a)\r\n        {\r\n            // ignore incident edges\r\n            continue;\r\n        } \r\n\r\n        if (this.leftOn(a, b, i + 1) && this.rightOn(a, b, i))\r\n        { \r\n            // if diag intersects an edge\r\n            if (Phaser.Physics.Box2D.Polygon.linesCross(this.at(a), this.at(b), this.at(i), this.at(i + 1)))\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n    \r\n};\r\n\r\n/** Copies a subset of the vertices of this polygon to make a new one. Start and end points will be included.\r\n * @param {number} i - index of the first vertex\r\n * @param {number} j - index of the second vertex\r\n * @return {Array} array representing a sub-polygon\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.subPolygon = function (i, j) {\r\n\r\n    var p = new Phaser.Physics.Box2D.Polygon();\r\n\r\n    if (i < j)\r\n    {\r\n        //p.v.insert(p.v.begin(), v.begin() + i, v.begin() + j + 1);\r\n        for (var n = i; n < j + 1; n++)\r\n        {\r\n            p.addVertex( this.at(n) );\r\n        }\r\n    }\r\n    else\r\n    {\r\n        //p.v.insert(p.v.begin(), v.begin() + i, v.end());\r\n        //p.v.insert(p.v.end(), v.begin(), v.begin() + j + 1);\r\n        for (var n = i; n < this.vertices.length; n++)\r\n        {\r\n            p.addVertex( this.at(n) );\r\n        }\r\n\r\n        for (var n = 0; n < j + 1; n++)\r\n        {\r\n            p.addVertex( this.at(n) );\r\n        }\r\n    }\r\n    \r\n    return p;\r\n\r\n};\r\n\r\n/**\r\n * Returns an array of the individual convex polygons which make up the given concave polygon.\r\n * This will return a near-optimal (lowest number of sub-polygons) decomposition and is\r\n * astoundingly slow for polygons with more than about 8 vertices. You most likely will\r\n * not want to use this at runtime, but it could be useful as a pre-process for something.\r\n * Please try the normal 'decompose' function instead.\r\n * @return {Array} Array of objects containing pairs of indices which should be joined\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.decomposeOptimal = function (level) {\r\n\r\n    if (typeof level === 'undefined') { level = 0; }\r\n    \r\n    if (level > 1)\r\n    {\r\n        return this.vertices;\r\n    }\r\n        \r\n    this.makeCCW();\r\n      \r\n    var min = [];\r\n    var tmp1 = [];\r\n    var tmp2 = [];    \r\n    \r\n    var nDiags = Number.MAX_VALUE;\r\n\r\n    for (var i = 0; i < this.vertices.length; i++)\r\n    {\r\n        if (this.isReflex(i))\r\n        {\r\n            for (var j = 0; j < this.vertices.length; j++)\r\n            {\r\n                if (this.canSee(i, j))\r\n                {\r\n                    tmp1 = this.subPolygon(i, j).decompose(level+1);\r\n                    tmp2 = this.subPolygon(j, i).decompose(level+1);                    \r\n\r\n                    if (tmp1.length + tmp2.length < nDiags)\r\n                    {\r\n                        min = tmp1.concat(tmp2);\r\n                        nDiags = min.length;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    if (min.length === 0)\r\n    {\r\n        min.push(this.vertices);\r\n    }\r\n    \r\n    return min;\r\n\r\n};\r\n\r\n/**\r\n * Returns an array of the individual convex polygons which make up the given concave polygon.\r\n * @return {Array} Array of arrays containing the vertex positions of sub-polygons. Vertex positions are an object like {x,y}\r\n */\r\nPhaser.Physics.Box2D.Polygon.prototype.decompose = function (level) {\r\n\r\n    if (typeof level === 'undefined') { level = 0; }\r\n    \r\n    this.makeCCW();\r\n      \r\n    var min = [];\r\n    \r\n    var bestDivision = Number.MAX_VALUE;\r\n    var bestI;\r\n    var bestJ;\r\n    var foundReflex = false;\r\n    \r\n    for (var i = 0; i < this.vertices.length; i++)\r\n    {\r\n        if (this.isReflex(i))\r\n        {\r\n            foundReflex = true;\r\n            var v0 = this.at(i);\r\n\r\n            for (var j = 0; j < this.vertices.length; j++)\r\n            {\r\n                if (this.canSee(i, j))\r\n                {\r\n                    var v1 = this.at(j);\r\n                    var dx = v1.x - v0.x;\r\n                    var dy = v1.y - v0.y;\r\n                    var distanceSquared = (dx * dx) * (dy * dy);\r\n\r\n                    if (distanceSquared < bestDivision)\r\n                    {\r\n                        bestI = i;\r\n                        bestJ = j;\r\n                        bestDivision = distanceSquared;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Specific to Box2D, force to 8 vertices or less\r\n    if (!foundReflex && this.vertices.length > 8 )\r\n    {\r\n        bestI = 0;\r\n        bestJ = Math.floor(this.vertices.length / 2);\r\n        foundReflex = true;\r\n    }\r\n    \r\n    if (foundReflex)\r\n    {\r\n        var tmp1 = this.subPolygon(bestI, bestJ).decompose(level+1);\r\n        var tmp2 = this.subPolygon(bestJ, bestI).decompose(level+1);        \r\n        min = tmp1.concat(tmp2);\r\n    }\r\n    \r\n    if (min.length === 0)\r\n    {\r\n        min.push(this.vertices);\r\n    }\r\n    \r\n    return min;\r\n\r\n};\r\n\n}.call(window));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/CustomizedDeps/box2d-plugin-full.js\n// module id = 9\n// module chunks = 0","// 拡張メソッド\n// setWidth, setHeightはアスペクト比を保ったままサイズを変更する\n\ndeclare module Phaser {\n    interface Image {\n        setSize(width: number, height: number): void;\n        setWidth(width: number): void;\n        setHeight(height: number): void;\n    }\n}\n\nPhaser.Image.prototype.setSize = function (width: number, height: number) {\n    this.width = width;\n    this.height = height;\n};\n\nPhaser.Image.prototype.setWidth = function (width: number) {\n    this.width = width;\n    this.scale.setTo(this.scale.x);\n};\n\nPhaser.Image.prototype.setHeight = function (height: number) {\n    this.height = height;\n    this.scale.setTo(this.scale.y);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Extension/Image.ts","// 拡張メソッド\n// setWidth, setHeightはアスペクト比を保ったままサイズを変更する\n\ndeclare module Phaser {\n    interface Sprite {\n        setSize(width: number, height: number): void;\n        setWidth(width: number): void;\n        setHeight(height: number): void;\n    }\n}\n\nPhaser.Sprite.prototype.setSize = function (width: number, height: number) {\n    this.width = width;\n    this.height = height;\n};\n\nPhaser.Sprite.prototype.setWidth = function (width: number) {\n    this.width = width;\n    this.scale.setTo(this.scale.x);\n};\n\nPhaser.Sprite.prototype.setHeight = function (height: number) {\n    this.height = height;\n    this.scale.setTo(this.scale.y);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Extension/Sprite.ts","// UIに関する定数定義\n\nexport namespace UISettings {\n    // ブラウザのウインドウイズがこの比率の範囲ならフルスクリーン表示\n    export const minCanvasRatio = 12.0 / 9.0;\n    export const maxCanvasRatio = 16.0 / 9.0;\n\n    // 物理サイズがいかなる場合でもゲーム内の論理座標系の横幅が常に320になるように指定\n    // この値とブラウザの物理サイズによって対応する高さが動的にきまる。高さはCoord.worldHeight()で取得可能。\n    export const expectedWidth = 320;\n\n    // Phaser.Textのスタイルに指定するObjectを簡単に生成するためのUtility\n    type Font = \"ヒラギノ角ゴ Pro W6\";\n    export namespace Font{\n        export const hiraginoGothW6: Font = \"ヒラギノ角ゴ Pro W6\"\n    }\n    export function fontStyle(size: number, color: number, family: Font): any {\n        const font = size.toString() + \"px \" + family;\n        const fill = Phaser.Color.getWebRGB(color);\n        return { font: font, fill: fill };\n    }\n\n    export namespace Colors {\n        export const white = 0xFFFFFF;\n        export const black = 0x000000;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Constants/UISettings.ts","import {CustomState} from \"Core/State/CustomState\";\n\nexport class BootState extends CustomState {\n\n    init() {\n        \n    }\n\n    preload() {\n        // Preloadで使う画像をロード\n    }\n\n    create() {\n        this.game.state.start(\"PreloadState\");\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/State/BootState.ts","// import {Res} from \"Constants/Resources\";\nimport {CustomState} from \"Core/State/CustomState\";\n\nexport class PreloadState extends CustomState {\n\n    constructor() {\n        super();\n    }\n\n    init() {\n        super.init();\n    }\n\n    preload() {\n        // アプリ全体で使う画像を画像をロード\n        // this.game.load.image(Res.logo.key, Res.logo.path);\n    }\n\n    create() {\n        this.game.state.start(\"HomeState\");\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/State/PreloadState.ts","import {CustomState} from \"Core/State/CustomState\";\n\nexport class HomeState extends CustomState {\n\n    init() {\n        super.init();\n    }\n\n    preload() {\n    }\n\n    create() {\n        this.adjust();\n    }\n\n    shutdown() {\n    }\n\n    adjust() {\n    }\n\n    // private\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/State/HomeState.ts"],"sourceRoot":""}